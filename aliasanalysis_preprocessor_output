# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/lib/Analysis/AliasAnalysis.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 143 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/lib/Analysis/AliasAnalysis.cpp" 2
# 27 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/lib/Analysis/AliasAnalysis.cpp"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/AliasAnalysis.h" 1
# 40 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/AliasAnalysis.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMap.h" 1
# 17 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMap.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMapInfo.h" 1
# 17 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMapInfo.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/PointerLikeTypeTraits.h" 1
# 18 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/PointerLikeTypeTraits.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/build/include/llvm/Support/DataTypes.h" 1
# 36 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/build/include/llvm/Support/DataTypes.h"
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cmath" 1 3
# 300 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cmath" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__config" 1 3
# 16 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__config" 3







# 1 "/mnt/home/ec2-user/build/emscripten/system/include/compat/unistd.h" 1 3




extern "C" {


char * getwd(char *__buf );


}



# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/unistd.h" 1 3




extern "C" {



# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/features.h" 1 3
# 9 "/mnt/home/ec2-user/build/emscripten/system/include/libc/unistd.h" 2 3
# 33 "/mnt/home/ec2-user/build/emscripten/system/include/libc/unistd.h" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 1 3
# 111 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 3
typedef unsigned int size_t;
# 126 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 3
typedef int ssize_t;




typedef int intptr_t;
# 213 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 3
typedef int off_t;
# 281 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 3
typedef int pid_t;
# 291 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 3
typedef unsigned uid_t;




typedef unsigned gid_t;
# 306 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 3
typedef unsigned useconds_t;
# 34 "/mnt/home/ec2-user/build/emscripten/system/include/libc/unistd.h" 2 3

int pipe(int [2]);
int pipe2(int [2], int);
int close(int);
int posix_close(int, int);
int dup(int);
int dup2(int, int);
int dup3(int, int, int);
off_t lseek(int, off_t, int);
int fsync(int);
int fdatasync(int);

ssize_t read(int, void *, size_t);
ssize_t write(int, const void *, size_t);
ssize_t pread(int, void *, size_t, off_t);
ssize_t pwrite(int, const void *, size_t, off_t);

int chown(const char *, uid_t, gid_t);
int fchown(int, uid_t, gid_t);
int lchown(const char *, uid_t, gid_t);
int fchownat(int, const char *, uid_t, gid_t, int);

int link(const char *, const char *);
int linkat(int, const char *, int, const char *, int);
int symlink(const char *, const char *);
int symlinkat(const char *, int, const char *);
ssize_t readlink(const char *__restrict, char *__restrict, size_t);
ssize_t readlinkat(int, const char *__restrict, char *__restrict, size_t);
int unlink(const char *);
int unlinkat(int, const char *, int);
int rmdir(const char *);
int truncate(const char *, off_t);
int ftruncate(int, off_t);






int access(const char *, int);
int faccessat(int, const char *, int, int);

int chdir(const char *);
int fchdir(int);
char *getcwd(char *, size_t);

unsigned alarm(unsigned);
unsigned sleep(unsigned);
int pause(void);

pid_t fork(void);
int execve(const char *, char *const [], char *const []);
int execv(const char *, char *const []);
int execle(const char *, const char *, ...);
int execl(const char *, const char *, ...);
int execvp(const char *, char *const []);
int execlp(const char *, const char *, ...);
int fexecve(int, char *const [], char *const []);
__attribute__((__noreturn__)) void _exit(int);

pid_t getpid(void);
pid_t getppid(void);
pid_t getpgrp(void);
pid_t getpgid(pid_t);
int setpgid(pid_t, pid_t);
pid_t setsid(void);
pid_t getsid(pid_t);
char *ttyname(int);
int ttyname_r(int, char *, size_t);
int isatty(int);
pid_t tcgetpgrp(int);
int tcsetpgrp(int, pid_t);

uid_t getuid(void);
uid_t geteuid(void);
gid_t getgid(void);
gid_t getegid(void);
int getgroups(int, gid_t []);
int setuid(uid_t);
int setreuid(uid_t, uid_t);
int seteuid(uid_t);
int setgid(gid_t);
int setregid(gid_t, gid_t);
int setegid(gid_t);

char *getlogin(void);
int getlogin_r(char *, size_t);
int gethostname(char *, size_t);
char *ctermid(char *);

int getopt(int, char * const [], const char *);
extern char *optarg;
extern int optind, opterr, optopt;

long pathconf(const char *, int);
long fpathconf(int, int);
long sysconf(int);
size_t confstr(int, char *, size_t);







int lockf(int, int, off_t);
long gethostid(void);
int nice(int);
void sync(void);



pid_t setpgrp(void);
char *crypt(const char *, const char *);
void encrypt(char *, int);
void swab(const void *__restrict, void *__restrict, ssize_t);




int usleep(unsigned);
unsigned ualarm(unsigned, unsigned);






int brk(void *);
void *sbrk(intptr_t);
pid_t vfork(void);
int vhangup(void);
int chroot(const char *);
int getpagesize(void);
int getdtablesize(void);
int sethostname(const char *, size_t);
int getdomainname(char *, size_t);
int setdomainname(const char *, size_t);
int setgroups(size_t, const gid_t *);
char *getpass(const char *);
int daemon(int, int);
void setusershell(void);
void endusershell(void);
char *getusershell(void);
int acct(const char *);
long syscall(long, ...);



extern char **environ;
int setresuid(uid_t, uid_t, uid_t);
int setresgid(gid_t, gid_t, gid_t);
int getresuid(uid_t *, uid_t *, uid_t *);
int getresgid(gid_t *, gid_t *, gid_t *);
char *get_current_dir_name(void);
void syncfs(int);
int euidaccess(const char *, int);
int eaccess(const char *, int);
# 255 "/mnt/home/ec2-user/build/emscripten/system/include/libc/unistd.h" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/posix.h" 1 3
# 256 "/mnt/home/ec2-user/build/emscripten/system/include/libc/unistd.h" 2 3
# 525 "/mnt/home/ec2-user/build/emscripten/system/include/libc/unistd.h" 3
}
# 15 "/mnt/home/ec2-user/build/emscripten/system/include/compat/unistd.h" 2 3
# 24 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__config" 2 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/errno.h" 1 3




extern "C" {





# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/errno.h" 1 3
# 11 "/mnt/home/ec2-user/build/emscripten/system/include/libc/errno.h" 2 3


__attribute__((const))

int *__errno_location(void);



extern char *program_invocation_short_name, *program_invocation_name;



}
# 25 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__config" 2 3
# 232 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__config" 3
typedef __char16_t char16_t;
typedef __char32_t char32_t;
# 365 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__config" 3
namespace std {
  inline namespace __1 {
  }
}
# 542 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__config" 3
template <bool> struct __static_assert_test;
template <> struct __static_assert_test<true> {};
template <unsigned> struct __static_assert_check {};
# 301 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cmath" 2 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/compat/math.h" 1 3
# 12 "/mnt/home/ec2-user/build/emscripten/system/include/compat/math.h" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/math.h" 1 3




extern "C" {







# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 1 3
# 52 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 3
typedef float float_t;




typedef double double_t;
# 13 "/mnt/home/ec2-user/build/emscripten/system/include/libc/math.h" 2 3
# 39 "/mnt/home/ec2-user/build/emscripten/system/include/libc/math.h" 3
int __fpclassify(double);
int __fpclassifyf(float);
int __fpclassifyl(long double);

static inline unsigned __FLOAT_BITS(float __f)
{
 union {float __f; unsigned __i;} __u;
 __u.__f = __f;
 return __u.__i;
}
static inline unsigned long long __DOUBLE_BITS(double __f)
{
 union {double __f; unsigned long long __i;} __u;
 __u.__f = __f;
 return __u.__i;
}
# 81 "/mnt/home/ec2-user/build/emscripten/system/include/libc/math.h" 3
int __signbit(double);
int __signbitf(float);
int __signbitl(long double);
# 96 "/mnt/home/ec2-user/build/emscripten/system/include/libc/math.h" 3
static inline int __islessf(float_t __x, float_t __y) { return !(( sizeof((__x)) == sizeof(float) ? (__FLOAT_BITS((__x)) & 0x7fffffff) > 0x7f800000 : sizeof((__x)) == sizeof(double) ? (__DOUBLE_BITS((__x)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__x)) == 0) ? ((void)(__y),1) : ( sizeof((__y)) == sizeof(float) ? (__FLOAT_BITS((__y)) & 0x7fffffff) > 0x7f800000 : sizeof((__y)) == sizeof(double) ? (__DOUBLE_BITS((__y)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__y)) == 0)) && __x < __y; }
static inline int __isless(double_t __x, double_t __y) { return !(( sizeof((__x)) == sizeof(float) ? (__FLOAT_BITS((__x)) & 0x7fffffff) > 0x7f800000 : sizeof((__x)) == sizeof(double) ? (__DOUBLE_BITS((__x)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__x)) == 0) ? ((void)(__y),1) : ( sizeof((__y)) == sizeof(float) ? (__FLOAT_BITS((__y)) & 0x7fffffff) > 0x7f800000 : sizeof((__y)) == sizeof(double) ? (__DOUBLE_BITS((__y)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__y)) == 0)) && __x < __y; }
static inline int __islessl(long double __x, long double __y) { return !(( sizeof((__x)) == sizeof(float) ? (__FLOAT_BITS((__x)) & 0x7fffffff) > 0x7f800000 : sizeof((__x)) == sizeof(double) ? (__DOUBLE_BITS((__x)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__x)) == 0) ? ((void)(__y),1) : ( sizeof((__y)) == sizeof(float) ? (__FLOAT_BITS((__y)) & 0x7fffffff) > 0x7f800000 : sizeof((__y)) == sizeof(double) ? (__DOUBLE_BITS((__y)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__y)) == 0)) && __x < __y; }
static inline int __islessequalf(float_t __x, float_t __y) { return !(( sizeof((__x)) == sizeof(float) ? (__FLOAT_BITS((__x)) & 0x7fffffff) > 0x7f800000 : sizeof((__x)) == sizeof(double) ? (__DOUBLE_BITS((__x)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__x)) == 0) ? ((void)(__y),1) : ( sizeof((__y)) == sizeof(float) ? (__FLOAT_BITS((__y)) & 0x7fffffff) > 0x7f800000 : sizeof((__y)) == sizeof(double) ? (__DOUBLE_BITS((__y)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__y)) == 0)) && __x <= __y; }
static inline int __islessequal(double_t __x, double_t __y) { return !(( sizeof((__x)) == sizeof(float) ? (__FLOAT_BITS((__x)) & 0x7fffffff) > 0x7f800000 : sizeof((__x)) == sizeof(double) ? (__DOUBLE_BITS((__x)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__x)) == 0) ? ((void)(__y),1) : ( sizeof((__y)) == sizeof(float) ? (__FLOAT_BITS((__y)) & 0x7fffffff) > 0x7f800000 : sizeof((__y)) == sizeof(double) ? (__DOUBLE_BITS((__y)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__y)) == 0)) && __x <= __y; }
static inline int __islessequall(long double __x, long double __y) { return !(( sizeof((__x)) == sizeof(float) ? (__FLOAT_BITS((__x)) & 0x7fffffff) > 0x7f800000 : sizeof((__x)) == sizeof(double) ? (__DOUBLE_BITS((__x)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__x)) == 0) ? ((void)(__y),1) : ( sizeof((__y)) == sizeof(float) ? (__FLOAT_BITS((__y)) & 0x7fffffff) > 0x7f800000 : sizeof((__y)) == sizeof(double) ? (__DOUBLE_BITS((__y)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__y)) == 0)) && __x <= __y; }
static inline int __islessgreaterf(float_t __x, float_t __y) { return !(( sizeof((__x)) == sizeof(float) ? (__FLOAT_BITS((__x)) & 0x7fffffff) > 0x7f800000 : sizeof((__x)) == sizeof(double) ? (__DOUBLE_BITS((__x)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__x)) == 0) ? ((void)(__y),1) : ( sizeof((__y)) == sizeof(float) ? (__FLOAT_BITS((__y)) & 0x7fffffff) > 0x7f800000 : sizeof((__y)) == sizeof(double) ? (__DOUBLE_BITS((__y)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__y)) == 0)) && __x != __y; }
static inline int __islessgreater(double_t __x, double_t __y) { return !(( sizeof((__x)) == sizeof(float) ? (__FLOAT_BITS((__x)) & 0x7fffffff) > 0x7f800000 : sizeof((__x)) == sizeof(double) ? (__DOUBLE_BITS((__x)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__x)) == 0) ? ((void)(__y),1) : ( sizeof((__y)) == sizeof(float) ? (__FLOAT_BITS((__y)) & 0x7fffffff) > 0x7f800000 : sizeof((__y)) == sizeof(double) ? (__DOUBLE_BITS((__y)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__y)) == 0)) && __x != __y; }
static inline int __islessgreaterl(long double __x, long double __y) { return !(( sizeof((__x)) == sizeof(float) ? (__FLOAT_BITS((__x)) & 0x7fffffff) > 0x7f800000 : sizeof((__x)) == sizeof(double) ? (__DOUBLE_BITS((__x)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__x)) == 0) ? ((void)(__y),1) : ( sizeof((__y)) == sizeof(float) ? (__FLOAT_BITS((__y)) & 0x7fffffff) > 0x7f800000 : sizeof((__y)) == sizeof(double) ? (__DOUBLE_BITS((__y)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__y)) == 0)) && __x != __y; }
static inline int __isgreaterf(float_t __x, float_t __y) { return !(( sizeof((__x)) == sizeof(float) ? (__FLOAT_BITS((__x)) & 0x7fffffff) > 0x7f800000 : sizeof((__x)) == sizeof(double) ? (__DOUBLE_BITS((__x)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__x)) == 0) ? ((void)(__y),1) : ( sizeof((__y)) == sizeof(float) ? (__FLOAT_BITS((__y)) & 0x7fffffff) > 0x7f800000 : sizeof((__y)) == sizeof(double) ? (__DOUBLE_BITS((__y)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__y)) == 0)) && __x > __y; }
static inline int __isgreater(double_t __x, double_t __y) { return !(( sizeof((__x)) == sizeof(float) ? (__FLOAT_BITS((__x)) & 0x7fffffff) > 0x7f800000 : sizeof((__x)) == sizeof(double) ? (__DOUBLE_BITS((__x)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__x)) == 0) ? ((void)(__y),1) : ( sizeof((__y)) == sizeof(float) ? (__FLOAT_BITS((__y)) & 0x7fffffff) > 0x7f800000 : sizeof((__y)) == sizeof(double) ? (__DOUBLE_BITS((__y)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__y)) == 0)) && __x > __y; }
static inline int __isgreaterl(long double __x, long double __y) { return !(( sizeof((__x)) == sizeof(float) ? (__FLOAT_BITS((__x)) & 0x7fffffff) > 0x7f800000 : sizeof((__x)) == sizeof(double) ? (__DOUBLE_BITS((__x)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__x)) == 0) ? ((void)(__y),1) : ( sizeof((__y)) == sizeof(float) ? (__FLOAT_BITS((__y)) & 0x7fffffff) > 0x7f800000 : sizeof((__y)) == sizeof(double) ? (__DOUBLE_BITS((__y)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__y)) == 0)) && __x > __y; }
static inline int __isgreaterequalf(float_t __x, float_t __y) { return !(( sizeof((__x)) == sizeof(float) ? (__FLOAT_BITS((__x)) & 0x7fffffff) > 0x7f800000 : sizeof((__x)) == sizeof(double) ? (__DOUBLE_BITS((__x)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__x)) == 0) ? ((void)(__y),1) : ( sizeof((__y)) == sizeof(float) ? (__FLOAT_BITS((__y)) & 0x7fffffff) > 0x7f800000 : sizeof((__y)) == sizeof(double) ? (__DOUBLE_BITS((__y)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__y)) == 0)) && __x >= __y; }
static inline int __isgreaterequal(double_t __x, double_t __y) { return !(( sizeof((__x)) == sizeof(float) ? (__FLOAT_BITS((__x)) & 0x7fffffff) > 0x7f800000 : sizeof((__x)) == sizeof(double) ? (__DOUBLE_BITS((__x)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__x)) == 0) ? ((void)(__y),1) : ( sizeof((__y)) == sizeof(float) ? (__FLOAT_BITS((__y)) & 0x7fffffff) > 0x7f800000 : sizeof((__y)) == sizeof(double) ? (__DOUBLE_BITS((__y)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__y)) == 0)) && __x >= __y; }
static inline int __isgreaterequall(long double __x, long double __y) { return !(( sizeof((__x)) == sizeof(float) ? (__FLOAT_BITS((__x)) & 0x7fffffff) > 0x7f800000 : sizeof((__x)) == sizeof(double) ? (__DOUBLE_BITS((__x)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__x)) == 0) ? ((void)(__y),1) : ( sizeof((__y)) == sizeof(float) ? (__FLOAT_BITS((__y)) & 0x7fffffff) > 0x7f800000 : sizeof((__y)) == sizeof(double) ? (__DOUBLE_BITS((__y)) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl((__y)) == 0)) && __x >= __y; }
# 123 "/mnt/home/ec2-user/build/emscripten/system/include/libc/math.h" 3
double acos(double);
float acosf(float);
long double acosl(long double);

double acosh(double);
float acoshf(float);
long double acoshl(long double);

double asin(double);
float asinf(float);
long double asinl(long double);

double asinh(double);
float asinhf(float);
long double asinhl(long double);

double atan(double);
float atanf(float);
long double atanl(long double);

double atan2(double, double);
float atan2f(float, float);
long double atan2l(long double, long double);

double atanh(double);
float atanhf(float);
long double atanhl(long double);

double cbrt(double);
float cbrtf(float);
long double cbrtl(long double);

double ceil(double);
float ceilf(float);
long double ceill(long double);

double copysign(double, double);
float copysignf(float, float);
long double copysignl(long double, long double);

double cos(double);
float cosf(float);
long double cosl(long double);

double cosh(double);
float coshf(float);
long double coshl(long double);

double erf(double);
float erff(float);
long double erfl(long double);

double erfc(double);
float erfcf(float);
long double erfcl(long double);

double exp(double);
float expf(float);
long double expl(long double);

double exp2(double);
float exp2f(float);
long double exp2l(long double);

double expm1(double);
float expm1f(float);
long double expm1l(long double);

double fabs(double);
float fabsf(float);
long double fabsl(long double);

double fdim(double, double);
float fdimf(float, float);
long double fdiml(long double, long double);

double floor(double);
float floorf(float);
long double floorl(long double);

double fma(double, double, double);
float fmaf(float, float, float);
long double fmal(long double, long double, long double);

double fmax(double, double);
float fmaxf(float, float);
long double fmaxl(long double, long double);

double fmin(double, double);
float fminf(float, float);
long double fminl(long double, long double);

double fmod(double, double);
float fmodf(float, float);
long double fmodl(long double, long double);

double frexp(double, int *);
float frexpf(float, int *);
long double frexpl(long double, int *);

double hypot(double, double);
float hypotf(float, float);
long double hypotl(long double, long double);

int ilogb(double);
int ilogbf(float);
int ilogbl(long double);

double ldexp(double, int);
float ldexpf(float, int);
long double ldexpl(long double, int);

double lgamma(double);
float lgammaf(float);
long double lgammal(long double);

long long llrint(double);
long long llrintf(float);
long long llrintl(long double);

long long llround(double);
long long llroundf(float);
long long llroundl(long double);

double log(double);
float logf(float);
long double logl(long double);

double log10(double);
float log10f(float);
long double log10l(long double);

double log1p(double);
float log1pf(float);
long double log1pl(long double);

double log2(double);
float log2f(float);
long double log2l(long double);

double logb(double);
float logbf(float);
long double logbl(long double);

long lrint(double);
long lrintf(float);
long lrintl(long double);

long lround(double);
long lroundf(float);
long lroundl(long double);

double modf(double, double *);
float modff(float, float *);
long double modfl(long double, long double *);

double nan(const char *);
float nanf(const char *);
long double nanl(const char *);

double nearbyint(double);
float nearbyintf(float);
long double nearbyintl(long double);

double nextafter(double, double);
float nextafterf(float, float);
long double nextafterl(long double, long double);

double nexttoward(double, long double);
float nexttowardf(float, long double);
long double nexttowardl(long double, long double);

double pow(double, double);
float powf(float, float);
long double powl(long double, long double);

double remainder(double, double);
float remainderf(float, float);
long double remainderl(long double, long double);

double remquo(double, double, int *);
float remquof(float, float, int *);
long double remquol(long double, long double, int *);

double rint(double);
float rintf(float);
long double rintl(long double);

double round(double);
float roundf(float);
long double roundl(long double);

double scalbln(double, long);
float scalblnf(float, long);
long double scalblnl(long double, long);

double scalbn(double, int);
float scalbnf(float, int);
long double scalbnl(long double, int);

double sin(double);
float sinf(float);
long double sinl(long double);

double sinh(double);
float sinhf(float);
long double sinhl(long double);

double sqrt(double);
float sqrtf(float);
long double sqrtl(long double);

double tan(double);
float tanf(float);
long double tanl(long double);

double tanh(double);
float tanhf(float);
long double tanhl(long double);

double tgamma(double);
float tgammaf(float);
long double tgammal(long double);

double trunc(double);
float truncf(float);
long double truncl(long double);
# 372 "/mnt/home/ec2-user/build/emscripten/system/include/libc/math.h" 3
extern int signgam;

double j0(double);
double j1(double);
double jn(int, double);

double y0(double);
double y1(double);
double yn(int, double);





double drem(double, double);
float dremf(float, float);

int finite(double);
int finitef(float);

double scalb(double, double);
float scalbf(float, float);

double significand(double);
float significandf(float);

double lgamma_r(double, int*);
float lgammaf_r(float, int*);

float j0f(float);
float j1f(float);
float jnf(int, float);

float y0f(float);
float y1f(float);
float ynf(int, float);



long double lgammal_r(long double, int*);

void sincos(double, double*, double*);
void sincosf(float, float*, float*);
void sincosl(long double, long double*, long double*);

double exp10(double);
float exp10f(float);
long double exp10l(long double);

double pow10(double);
float pow10f(float);
long double pow10l(long double);



}
# 13 "/mnt/home/ec2-user/build/emscripten/system/include/compat/math.h" 2 3
# 302 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cmath" 2 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 1 3
# 204 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cstddef" 1 3
# 38 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cstddef" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/stddef.h" 1 3
# 14 "/mnt/home/ec2-user/build/emscripten/system/include/libc/stddef.h" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 1 3
# 121 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 3
typedef int ptrdiff_t;
# 15 "/mnt/home/ec2-user/build/emscripten/system/include/libc/stddef.h" 2 3
# 39 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cstddef" 2 3
# 42 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cstddef" 3


namespace std {inline namespace __1 {

using ::ptrdiff_t;
using ::size_t;





typedef long double max_align_t;




struct __attribute__ ((__type_visibility__("default"))) nullptr_t
{
    void* __lx;

    struct __nat {int __for_bool_;};

    __attribute__ ((__visibility__("hidden"), __always_inline__)) nullptr_t() : __lx(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) nullptr_t(int __nat::*) : __lx(0) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator int __nat::*() const {return 0;}

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        operator _Tp* () const {return 0;}

    template <class _Tp, class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        operator _Tp _Up::* () const {return 0;}

    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator==(nullptr_t, nullptr_t) {return true;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator!=(nullptr_t, nullptr_t) {return false;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator<(nullptr_t, nullptr_t) {return false;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator<=(nullptr_t, nullptr_t) {return true;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator>(nullptr_t, nullptr_t) {return false;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator>=(nullptr_t, nullptr_t) {return true;}
};

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) nullptr_t __get_nullptr_t() {return nullptr_t(0);}





} }
# 205 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 2 3
# 208 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3


namespace std {inline namespace __1 {

template <bool _Bp, class _If, class _Then>
    struct __attribute__ ((__type_visibility__("default"))) conditional {typedef _If type;};
template <class _If, class _Then>
    struct __attribute__ ((__type_visibility__("default"))) conditional<false, _If, _Then> {typedef _Then type;};





template <bool, class _Tp = void> struct __attribute__ ((__type_visibility__("default"))) enable_if {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) enable_if<true, _Tp> {typedef _Tp type;};






struct __two {char __lx[2];};



template <class _Tp, _Tp __v>
struct __attribute__ ((__type_visibility__("default"))) integral_constant
{
    static const _Tp value = __v;
    typedef _Tp value_type;
    typedef integral_constant type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
                          operator value_type() const throw() {return value;}




};

template <class _Tp, _Tp __v>
                  const _Tp integral_constant<_Tp, __v>::value;

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_const : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_const<_Tp const> : public true_type {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_volatile : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_volatile<_Tp volatile> : public true_type {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_const {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_const<const _Tp> {typedef _Tp type;};






template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_volatile {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_volatile<volatile _Tp> {typedef _Tp type;};






template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_cv
{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};






template <class _Tp> struct __libcpp_is_void : public false_type {};
template <> struct __libcpp_is_void<void> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_void
    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __is_nullptr_t_impl : public false_type {};
template <> struct __is_nullptr_t_impl<nullptr_t> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) __is_nullptr_t
    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};
# 310 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class _Tp> struct __libcpp_is_integral : public false_type {};
template <> struct __libcpp_is_integral<bool> : public true_type {};
template <> struct __libcpp_is_integral<char> : public true_type {};
template <> struct __libcpp_is_integral<signed char> : public true_type {};
template <> struct __libcpp_is_integral<unsigned char> : public true_type {};
template <> struct __libcpp_is_integral<wchar_t> : public true_type {};

template <> struct __libcpp_is_integral<char16_t> : public true_type {};
template <> struct __libcpp_is_integral<char32_t> : public true_type {};

template <> struct __libcpp_is_integral<short> : public true_type {};
template <> struct __libcpp_is_integral<unsigned short> : public true_type {};
template <> struct __libcpp_is_integral<int> : public true_type {};
template <> struct __libcpp_is_integral<unsigned int> : public true_type {};
template <> struct __libcpp_is_integral<long> : public true_type {};
template <> struct __libcpp_is_integral<unsigned long> : public true_type {};
template <> struct __libcpp_is_integral<long long> : public true_type {};
template <> struct __libcpp_is_integral<unsigned long long> : public true_type {};





template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_integral
    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __libcpp_is_floating_point : public false_type {};
template <> struct __libcpp_is_floating_point<float> : public true_type {};
template <> struct __libcpp_is_floating_point<double> : public true_type {};
template <> struct __libcpp_is_floating_point<long double> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_floating_point
    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_array
    : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_array<_Tp[]>
    : public true_type {};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) is_array<_Tp[_Np]>
    : public true_type {};



template <class _Tp> struct __libcpp_is_pointer : public false_type {};
template <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_pointer
    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_lvalue_reference : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_lvalue_reference<_Tp&> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_rvalue_reference : public false_type {};




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_reference : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_reference<_Tp&> : public true_type {};
# 383 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_union
    : public integral_constant<bool, __is_union(_Tp)> {};
# 398 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_class
    : public integral_constant<bool, __is_class(_Tp)> {};
# 416 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class _Tp, class _Up> struct __attribute__ ((__type_visibility__("default"))) is_same : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_same<_Tp, _Tp> : public true_type {};



namespace __libcpp_is_function_imp
{
template <class _Tp> char __test(_Tp*);
template <class _Tp> __two __test(...);
template <class _Tp> _Tp& __source();
}

template <class _Tp, bool = is_class<_Tp>::value ||
                            is_union<_Tp>::value ||
                            is_void<_Tp>::value ||
                            is_reference<_Tp>::value ||
                            __is_nullptr_t<_Tp>::value >
struct __libcpp_is_function
    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>())) == 1>
    {};
template <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_function
    : public __libcpp_is_function<_Tp> {};







template <class _MP, bool _IsMemberFuctionPtr, bool _IsMemberObjectPtr>
struct __member_pointer_traits_imp
{
};


namespace __libcpp_is_member_function_pointer_imp {
    template <typename _Tp>
    char __test(typename std::__member_pointer_traits_imp<_Tp, true, false>::_FnType *);

    template <typename>
    std::__two __test(...);
};

template <class _Tp> struct __libcpp_is_member_function_pointer
    : public integral_constant<bool, sizeof(__libcpp_is_member_function_pointer_imp::__test<_Tp>(std::__1::__get_nullptr_t())) == 1> {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_member_function_pointer
    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __libcpp_is_member_pointer : public false_type {};
template <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_member_pointer
    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_member_object_pointer
    : public integral_constant<bool, is_member_pointer<_Tp>::value &&
                                    !is_member_function_pointer<_Tp>::value> {};





template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_enum
    : public integral_constant<bool, __is_enum(_Tp)> {};
# 506 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_arithmetic
    : public integral_constant<bool, is_integral<_Tp>::value ||
                                     is_floating_point<_Tp>::value> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_fundamental
    : public integral_constant<bool, is_void<_Tp>::value ||
                                     __is_nullptr_t<_Tp>::value ||
                                     is_arithmetic<_Tp>::value> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_scalar
    : public integral_constant<bool, is_arithmetic<_Tp>::value ||
                                     is_member_pointer<_Tp>::value ||
                                     is_pointer<_Tp>::value ||
                                     __is_nullptr_t<_Tp>::value ||
                                     is_enum<_Tp>::value > {};

template <> struct __attribute__ ((__type_visibility__("default"))) is_scalar<nullptr_t> : public true_type {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_object
    : public integral_constant<bool, is_scalar<_Tp>::value ||
                                     is_array<_Tp>::value ||
                                     is_union<_Tp>::value ||
                                     is_class<_Tp>::value > {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};



template <class _Tp, bool = is_reference<_Tp>::value ||
                            is_function<_Tp>::value ||
                            is_const<_Tp>::value >
struct __add_const {typedef _Tp type;};

template <class _Tp>
struct __add_const<_Tp, false> {typedef const _Tp type;};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_const
    {typedef typename __add_const<_Tp>::type type;};







template <class _Tp, bool = is_reference<_Tp>::value ||
                            is_function<_Tp>::value ||
                            is_volatile<_Tp>::value >
struct __add_volatile {typedef _Tp type;};

template <class _Tp>
struct __add_volatile<_Tp, false> {typedef volatile _Tp type;};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_volatile
    {typedef typename __add_volatile<_Tp>::type type;};







template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_cv
    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};







template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference<_Tp&> {typedef _Tp type;};
# 598 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference {typedef _Tp& type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference<_Tp&> {typedef _Tp& type;};
template <> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference<void> {typedef void type;};
template <> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference<const void> {typedef const void type;};
template <> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference<volatile void> {typedef volatile void type;};
template <> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference<const volatile void> {typedef const volatile void type;};
# 631 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class _Tp>
typename add_lvalue_reference<_Tp>::type
declval();



struct __any
{
    __any(...);
};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp*> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* const> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* volatile> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* const volatile> {typedef _Tp type;};







template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_pointer
    {typedef typename remove_reference<_Tp>::type* type;};







template <class _Tp, bool = is_integral<_Tp>::value>
struct __libcpp_is_signed_impl : public integral_constant<bool, _Tp(-1) < _Tp(0)> {};

template <class _Tp>
struct __libcpp_is_signed_impl<_Tp, false> : public true_type {};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
struct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};

template <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_signed : public __libcpp_is_signed<_Tp> {};



template <class _Tp, bool = is_integral<_Tp>::value>
struct __libcpp_is_unsigned_impl : public integral_constant<bool, _Tp(0) < _Tp(-1)> {};

template <class _Tp>
struct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
struct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};

template <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_unsigned : public __libcpp_is_unsigned<_Tp> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) rank
    : public integral_constant<size_t, 0> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) rank<_Tp[]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) rank<_Tp[_Np]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};



template <class _Tp, unsigned _Ip = 0> struct __attribute__ ((__type_visibility__("default"))) extent
    : public integral_constant<size_t, 0> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[], 0>
    : public integral_constant<size_t, 0> {};
template <class _Tp, unsigned _Ip> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[], _Ip>
    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[_Np], 0>
    : public integral_constant<size_t, _Np> {};
template <class _Tp, size_t _Np, unsigned _Ip> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[_Np], _Ip>
    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_extent
    {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_extent<_Tp[]>
    {typedef _Tp type;};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) remove_extent<_Tp[_Np]>
    {typedef _Tp type;};







template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents
    {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents<_Tp[]>
    {typedef typename remove_all_extents<_Tp>::type type;};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents<_Tp[_Np]>
    {typedef typename remove_all_extents<_Tp>::type type;};







template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) decay
{
private:
    typedef typename remove_reference<_Tp>::type _Up;
public:
    typedef typename conditional
                     <
                         is_array<_Up>::value,
                         typename remove_extent<_Up>::type*,
                         typename conditional
                         <
                              is_function<_Up>::value,
                              typename add_pointer<_Up>::type,
                              typename remove_cv<_Up>::type
                         >::type
                     >::type type;
};







namespace __is_abstract_imp
{
template <class _Tp> char __test(_Tp (*)[1]);
template <class _Tp> __two __test(...);
}

template <class _Tp, bool = is_class<_Tp>::value>
struct __libcpp_abstract : public integral_constant<bool, sizeof(__is_abstract_imp::__test<_Tp>(0)) != 1> {};

template <class _Tp> struct __libcpp_abstract<_Tp, false> : public false_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_abstract : public __libcpp_abstract<_Tp> {};
# 792 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class _Bp, class _Dp>
struct __attribute__ ((__type_visibility__("default"))) is_base_of
    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};
# 827 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class _T1, class _T2> struct __attribute__ ((__type_visibility__("default"))) is_convertible
    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&
                                     !is_abstract<_T2>::value> {};
# 946 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_empty
    : public integral_constant<bool, __is_empty(_Tp)> {};
# 977 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)> {};
# 997 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};
# 1009 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) alignment_of
    : public integral_constant<size_t, __alignof__(_Tp)> {};



template <class _Hp, class _Tp>
struct __type_list
{
    typedef _Hp _Head;
    typedef _Tp _Tail;
};

struct __nat
{






};

template <class _Tp>
struct __align_type
{
    static const size_t value = alignment_of<_Tp>::value;
    typedef _Tp type;
};

struct __struct_double {long double __lx;};
struct __struct_double4 {double __lx[4];};

typedef
    __type_list<__align_type<unsigned char>,
    __type_list<__align_type<unsigned short>,
    __type_list<__align_type<unsigned int>,
    __type_list<__align_type<unsigned long>,
    __type_list<__align_type<unsigned long long>,
    __type_list<__align_type<double>,
    __type_list<__align_type<long double>,
    __type_list<__align_type<__struct_double>,
    __type_list<__align_type<__struct_double4>,
    __type_list<__align_type<int*>,
    __nat
    > > > > > > > > > > __all_types;

template <class _TL, size_t _Align> struct __find_pod;

template <class _Hp, size_t _Align>
struct __find_pod<__type_list<_Hp, __nat>, _Align>
{
    typedef typename conditional<
                             _Align == _Hp::value,
                             typename _Hp::type,
                             void
                         >::type type;
};

template <class _Hp, class _Tp, size_t _Align>
struct __find_pod<__type_list<_Hp, _Tp>, _Align>
{
    typedef typename conditional<
                             _Align == _Hp::value,
                             typename _Hp::type,
                             typename __find_pod<_Tp, _Align>::type
                         >::type type;
};

template <class _TL, size_t _Len> struct __find_max_align;

template <class _Hp, size_t _Len>
struct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};

template <size_t _Len, size_t _A1, size_t _A2>
struct __select_align
{
private:
    static const size_t __min = _A2 < _A1 ? _A2 : _A1;
    static const size_t __max = _A1 < _A2 ? _A2 : _A1;
public:
    static const size_t value = _Len < __max ? __min : __max;
};

template <class _Hp, class _Tp, size_t _Len>
struct __find_max_align<__type_list<_Hp, _Tp>, _Len>
    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};

template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
struct __attribute__ ((__type_visibility__("default"))) aligned_storage
{
    typedef typename __find_pod<__all_types, _Align>::type _Aligner;
    typedef __static_assert_check<sizeof(__static_assert_test<(!is_void<_Aligner>::value)>)> __t1100;
    union type
    {
        _Aligner __align;
        unsigned char __data[_Len];
    };
};
# 1123 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x1>{ struct __attribute__((__aligned__(0x1))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x2>{ struct __attribute__((__aligned__(0x2))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x4>{ struct __attribute__((__aligned__(0x4))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x8>{ struct __attribute__((__aligned__(0x8))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x10>{ struct __attribute__((__aligned__(0x10))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x20>{ struct __attribute__((__aligned__(0x20))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x40>{ struct __attribute__((__aligned__(0x40))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x80>{ struct __attribute__((__aligned__(0x80))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x100>{ struct __attribute__((__aligned__(0x100))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x200>{ struct __attribute__((__aligned__(0x200))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x400>{ struct __attribute__((__aligned__(0x400))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x800>{ struct __attribute__((__aligned__(0x800))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x1000>{ struct __attribute__((__aligned__(0x1000))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x2000>{ struct __attribute__((__aligned__(0x2000))) type { unsigned char __lx[_Len]; };};


template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x4000>{ struct __attribute__((__aligned__(0x4000))) type { unsigned char __lx[_Len]; };};
# 1180 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class _Tp>
struct __numeric_type
{
   static void __test(...);
   static float __test(float);
   static double __test(char);
   static double __test(int);
   static double __test(unsigned);
   static double __test(long);
   static double __test(unsigned long);
   static double __test(long long);
   static double __test(unsigned long long);
   static double __test(double);
   static long double __test(long double);

   typedef __typeof__(__test(declval<_Tp>())) type;
   static const bool value = !is_same<type, void>::value;
};

template <>
struct __numeric_type<void>
{
   static const bool value = true;
};



template <class _A1, class _A2 = void, class _A3 = void,
          bool = __numeric_type<_A1>::value &&
                 __numeric_type<_A2>::value &&
                 __numeric_type<_A3>::value>
class __promote
{
    static const bool value = false;
};

template <class _A1, class _A2, class _A3>
class __promote<_A1, _A2, _A3, true>
{
private:
    typedef typename __promote<_A1>::type __type1;
    typedef typename __promote<_A2>::type __type2;
    typedef typename __promote<_A3>::type __type3;
public:
    typedef __typeof__(__type1() + __type2() + __type3()) type;
    static const bool value = true;
};

template <class _A1, class _A2>
class __promote<_A1, _A2, void, true>
{
private:
    typedef typename __promote<_A1>::type __type1;
    typedef typename __promote<_A2>::type __type2;
public:
    typedef __typeof__(__type1() + __type2()) type;
    static const bool value = true;
};

template <class _A1>
class __promote<_A1, void, void, true>
{
public:
    typedef typename __numeric_type<_A1>::type type;
    static const bool value = true;
    static const bool __does_not_throw = false;
};
# 1262 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
typedef
    __type_list<signed char,
    __type_list<signed short,
    __type_list<signed int,
    __type_list<signed long,
    __type_list<signed long long,



    __nat



    > > > > > __signed_types;

typedef
    __type_list<unsigned char,
    __type_list<unsigned short,
    __type_list<unsigned int,
    __type_list<unsigned long,
    __type_list<unsigned long long,



    __nat



    > > > > > __unsigned_types;

template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, true>
{
    typedef _Hp type;
};

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, false>
{
    typedef typename __find_first<_Tp, _Size>::type type;
};

template <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,
                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>
struct __apply_cv
{
    typedef _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, false>
{
    typedef const _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, false, true>
{
    typedef volatile _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, true>
{
    typedef const volatile _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, false>
{
    typedef _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, false>
{
    typedef const _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, true>
{
    typedef volatile _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, true>
{
    typedef const volatile _Up& type;
};

template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_signed {};

template <class _Tp>
struct __make_signed<_Tp, true>
{
    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;
};

template <> struct __make_signed<bool, true> {};
template <> struct __make_signed< signed short, true> {typedef short type;};
template <> struct __make_signed<unsigned short, true> {typedef short type;};
template <> struct __make_signed< signed int, true> {typedef int type;};
template <> struct __make_signed<unsigned int, true> {typedef int type;};
template <> struct __make_signed< signed long, true> {typedef long type;};
template <> struct __make_signed<unsigned long, true> {typedef long type;};
template <> struct __make_signed< signed long long, true> {typedef long long type;};
template <> struct __make_signed<unsigned long long, true> {typedef long long type;};





template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) make_signed
{
    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;
};





template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_unsigned {};

template <class _Tp>
struct __make_unsigned<_Tp, true>
{
    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;
};

template <> struct __make_unsigned<bool, true> {};
template <> struct __make_unsigned< signed short, true> {typedef unsigned short type;};
template <> struct __make_unsigned<unsigned short, true> {typedef unsigned short type;};
template <> struct __make_unsigned< signed int, true> {typedef unsigned int type;};
template <> struct __make_unsigned<unsigned int, true> {typedef unsigned int type;};
template <> struct __make_unsigned< signed long, true> {typedef unsigned long type;};
template <> struct __make_unsigned<unsigned long, true> {typedef unsigned long type;};
template <> struct __make_unsigned< signed long long, true> {typedef unsigned long long type;};
template <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};





template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) make_unsigned
{
    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;
};







template <class _Tp, class _Up = void, class V = void>
struct __attribute__ ((__type_visibility__("default"))) common_type
{
public:
    typedef typename common_type<typename common_type<_Tp, _Up>::type, V>::type type;
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) common_type<_Tp, void, void>
{
public:
    typedef typename decay<_Tp>::type type;
};

template <class _Tp, class _Up>
struct __attribute__ ((__type_visibility__("default"))) common_type<_Tp, _Up, void>
{
private:




    static _Tp __t();
    static _Up __u();

public:
    typedef typename remove_reference<__typeof__(true ? __t() : __u())>::type type;
};
# 1487 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };

template <class _Tp, class _Arg>
typename __select_2nd<__typeof__((std::__1::declval<_Tp>() = std::__1::declval<_Arg>())), true_type>::type



__is_assignable_test(_Tp, _Arg&);


template <class _Arg>
false_type



__is_assignable_test(__any, _Arg&);


template <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>
struct __is_assignable_imp
    : public common_type
        <
            __typeof__(__is_assignable_test(declval<_Tp>(), declval<_Arg>()))
        >::type {};

template <class _Tp, class _Arg>
struct __is_assignable_imp<_Tp, _Arg, true>
    : public false_type
{
};

template <class _Tp, class _Arg>
struct is_assignable
    : public __is_assignable_imp<_Tp, _Arg> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_copy_assignable
    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_move_assignable




    : public is_copy_assignable<_Tp> {};
# 1547 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class>
struct __is_destructible_apply { typedef int type; };

template <typename _Tp>
struct __is_destructor_wellformed {
 template <typename _Tp1>
 static char __test (
        typename __is_destructible_apply<__typeof__(std::__1::declval<_Tp1&>().~_Tp1())>::type
    );

 template <typename _Tp1>
 static __two __test (...);

 static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);
};

template <class _Tp, bool>
struct __destructible_imp;

template <class _Tp>
struct __destructible_imp<_Tp, false>
   : public std::__1::integral_constant<bool,
        __is_destructor_wellformed<typename std::__1::remove_all_extents<_Tp>::type>::value> {};

template <class _Tp>
struct __destructible_imp<_Tp, true>
    : public std::__1::true_type {};

template <class _Tp, bool>
struct __destructible_false;

template <class _Tp>
struct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, std::__1::is_reference<_Tp>::value> {};

template <class _Tp>
struct __destructible_false<_Tp, true> : public std::__1::false_type {};

template <class _Tp>
struct is_destructible
    : public __destructible_false<_Tp, std::__1::is_function<_Tp>::value> {};

template <class _Tp>
struct is_destructible<_Tp[]>
    : public std::__1::false_type {};

template <>
struct is_destructible<void>
    : public std::__1::false_type {};
# 1629 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp&
move(_Tp& __t)
{
    return __t;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _Tp&
move(const _Tp& __t)
{
    return __t;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp&
forward(typename std::remove_reference<_Tp>::type& __t) throw()
{
    return __t;
}


template <class _Tp>
class __rv
{
    typedef typename remove_reference<_Tp>::type _Trr;
    _Trr& t_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Trr* operator->() {return &t_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __rv(_Trr& __t) : t_(__t) {}
};
# 1680 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename decay<_Tp>::type
__decay_copy(const _Tp& __t)
{
    return std::__1::forward<_Tp>(__t);
}
# 1890 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) ();
};

template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp (_Class::*)(...), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (...);
};

template <class _Rp, class _Class, class _P0>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0);
};

template <class _Rp, class _Class, class _P0>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0, ...);
};

template <class _Rp, class _Class, class _P0, class _P1>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0, _P1);
};

template <class _Rp, class _Class, class _P0, class _P1>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0, _P1, ...);
};

template <class _Rp, class _Class, class _P0, class _P1, class _P2>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0, _P1, _P2);
};

template <class _Rp, class _Class, class _P0, class _P1, class _P2>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);
};

template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) ();
};

template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp (_Class::*)(...) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (...);
};

template <class _Rp, class _Class, class _P0>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0);
};

template <class _Rp, class _Class, class _P0>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0, ...);
};

template <class _Rp, class _Class, class _P0, class _P1>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0, _P1);
};

template <class _Rp, class _Class, class _P0, class _P1>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0, _P1, ...);
};

template <class _Rp, class _Class, class _P0, class _P1, class _P2>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0, _P1, _P2);
};

template <class _Rp, class _Class, class _P0, class _P1, class _P2>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);
};

template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) ();
};

template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp (_Class::*)(...) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (...);
};

template <class _Rp, class _Class, class _P0>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0);
};

template <class _Rp, class _Class, class _P0>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0, ...);
};

template <class _Rp, class _Class, class _P0, class _P1>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0, _P1);
};

template <class _Rp, class _Class, class _P0, class _P1>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0, _P1, ...);
};

template <class _Rp, class _Class, class _P0, class _P1, class _P2>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0, _P1, _P2);
};

template <class _Rp, class _Class, class _P0, class _P1, class _P2>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);
};

template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) ();
};

template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp (_Class::*)(...) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (...);
};

template <class _Rp, class _Class, class _P0>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0);
};

template <class _Rp, class _Class, class _P0>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0, ...);
};

template <class _Rp, class _Class, class _P0, class _P1>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0, _P1);
};

template <class _Rp, class _Class, class _P0, class _P1>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0, _P1, ...);
};

template <class _Rp, class _Class, class _P0, class _P1, class _P2>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0, _P1, _P2);
};

template <class _Rp, class _Class, class _P0, class _P1, class _P2>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);
};



template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp _Class::*, false, true>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
};

template <class _MP>
struct __member_pointer_traits
    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,
                    is_member_function_pointer<_MP>::value,
                    is_member_object_pointer<_MP>::value>
{



};



template <class _Callable> class result_of;



template <class _Fn, bool, bool>
class __result_of
{
};

template <class _Fn>
class __result_of<_Fn(), true, false>
{
public:
    typedef __typeof__(declval<_Fn>()()) type;
};

template <class _Fn, class _A0>
class __result_of<_Fn(_A0), true, false>
{
public:
    typedef __typeof__(declval<_Fn>()(declval<_A0>())) type;
};

template <class _Fn, class _A0, class _A1>
class __result_of<_Fn(_A0, _A1), true, false>
{
public:
    typedef __typeof__(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;
};

template <class _Fn, class _A0, class _A1, class _A2>
class __result_of<_Fn(_A0, _A1, _A2), true, false>
{
public:
    typedef __typeof__(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;
};

template <class _MP, class _Tp, bool _IsMemberFunctionPtr>
struct __result_of_mp;



template <class _MP, class _Tp>
struct __result_of_mp<_MP, _Tp, true>
    : public common_type<typename __member_pointer_traits<_MP>::_ReturnType>
{
};



template <class _MP, class _Tp, bool>
struct __result_of_mdp;

template <class _Rp, class _Class, class _Tp>
struct __result_of_mdp<_Rp _Class::*, _Tp, false>
{
    typedef typename __apply_cv<__typeof__(*std::__1::declval<_Tp>()), _Rp>::type& type;
};

template <class _Rp, class _Class, class _Tp>
struct __result_of_mdp<_Rp _Class::*, _Tp, true>
{
    typedef typename __apply_cv<_Tp, _Rp>::type& type;
};

template <class _Rp, class _Class, class _Tp>
struct __result_of_mp<_Rp _Class::*, _Tp, false>
    : public __result_of_mdp<_Rp _Class::*, _Tp,
            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>
{
};



template <class _Fn, class _Tp>
class __result_of<_Fn(_Tp), false, true>
    : public __result_of_mp<typename remove_reference<_Fn>::type,
                            _Tp,
                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
{
};

template <class _Fn, class _Tp, class _A0>
class __result_of<_Fn(_Tp, _A0), false, true>
    : public __result_of_mp<typename remove_reference<_Fn>::type,
                            _Tp,
                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
{
};

template <class _Fn, class _Tp, class _A0, class _A1>
class __result_of<_Fn(_Tp, _A0, _A1), false, true>
    : public __result_of_mp<typename remove_reference<_Fn>::type,
                            _Tp,
                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
{
};

template <class _Fn, class _Tp, class _A0, class _A1, class _A2>
class __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>
    : public __result_of_mp<typename remove_reference<_Fn>::type,
                            _Tp,
                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
{
};



template <class _Fn>
class __attribute__ ((__type_visibility__("default"))) result_of<_Fn()>
    : public __result_of<_Fn(),
                         is_class<typename remove_reference<_Fn>::type>::value ||
                         is_function<typename remove_reference<_Fn>::type>::value,
                         is_member_pointer<typename remove_reference<_Fn>::type>::value
                        >
{
};

template <class _Fn, class _A0>
class __attribute__ ((__type_visibility__("default"))) result_of<_Fn(_A0)>
    : public __result_of<_Fn(_A0),
                         is_class<typename remove_reference<_Fn>::type>::value ||
                         is_function<typename remove_reference<_Fn>::type>::value,
                         is_member_pointer<typename remove_reference<_Fn>::type>::value
                        >
{
};

template <class _Fn, class _A0, class _A1>
class __attribute__ ((__type_visibility__("default"))) result_of<_Fn(_A0, _A1)>
    : public __result_of<_Fn(_A0, _A1),
                         is_class<typename remove_reference<_Fn>::type>::value ||
                         is_function<typename remove_reference<_Fn>::type>::value,
                         is_member_pointer<typename remove_reference<_Fn>::type>::value
                        >
{
};

template <class _Fn, class _A0, class _A1, class _A2>
class __attribute__ ((__type_visibility__("default"))) result_of<_Fn(_A0, _A1, _A2)>
    : public __result_of<_Fn(_A0, _A1, _A2),
                         is_class<typename remove_reference<_Fn>::type>::value ||
                         is_function<typename remove_reference<_Fn>::type>::value,
                         is_member_pointer<typename remove_reference<_Fn>::type>::value
                        >
{
};





namespace __is_construct
{
struct __nat {};
}
# 2458 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class _Tp>
__typeof__((_Tp(), true_type()))
__is_constructible0_test(_Tp&);

false_type
__is_constructible0_test(__any);

template <class _Tp, class _A0>
__typeof__((_Tp(std::__1::declval<_A0>()), true_type()))
__is_constructible1_test(_Tp&, _A0&);

template <class _A0>
false_type
__is_constructible1_test(__any, _A0&);

template <class _Tp, class _A0, class _A1>
__typeof__((_Tp(std::__1::declval<_A0>(), std::__1::declval<_A1>()), true_type()))
__is_constructible2_test(_Tp&, _A0&, _A1&);

template <class _A0, class _A1>
false_type
__is_constructible2_test(__any, _A0&, _A1&);

template <bool, class _Tp>
struct __is_constructible0_imp
    : public common_type
             <
                 __typeof__(__is_constructible0_test(declval<_Tp&>()))
             >::type
    {};

template <bool, class _Tp, class _A0>
struct __is_constructible1_imp
    : public common_type
             <
                 __typeof__(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))
             >::type
    {};

template <bool, class _Tp, class _A0, class _A1>
struct __is_constructible2_imp
    : public common_type
             <
                 __typeof__(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))
             >::type
    {};





template <class _Tp>
struct __is_constructible0_imp<true, _Tp>
    : public is_scalar<_Tp>
    {};

template <class _Tp, class _A0>
struct __is_constructible1_imp<true, _Tp, _A0>
    : public is_convertible<_A0, _Tp>
    {};

template <class _Tp, class _A0, class _A1>
struct __is_constructible2_imp<true, _Tp, _A0, _A1>
    : public false_type
    {};



template <bool, class _Tp>
struct __is_constructible0_void_check
    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
                                _Tp>
    {};

template <bool, class _Tp, class _A0>
struct __is_constructible1_void_check
    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
                                _Tp, _A0>
    {};

template <bool, class _Tp, class _A0, class _A1>
struct __is_constructible2_void_check
    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
                                _Tp, _A0, _A1>
    {};



template <class _Tp>
struct __is_constructible0_void_check<true, _Tp>
    : public false_type
    {};

template <class _Tp, class _A0>
struct __is_constructible1_void_check<true, _Tp, _A0>
    : public false_type
    {};

template <class _Tp, class _A0, class _A1>
struct __is_constructible2_void_check<true, _Tp, _A0, _A1>
    : public false_type
    {};



template <class _Tp, class _A0 = __is_construct::__nat,
                     class _A1 = __is_construct::__nat>
struct __attribute__ ((__type_visibility__("default"))) is_constructible
    : public __is_constructible2_void_check<is_void<_Tp>::value
                                        || is_abstract<_Tp>::value
                                        || is_function<_Tp>::value
                                        || is_void<_A0>::value
                                        || is_void<_A1>::value,
                                           _Tp, _A0, _A1>
    {};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>
    : public __is_constructible0_void_check<is_void<_Tp>::value
                                        || is_abstract<_Tp>::value
                                        || is_function<_Tp>::value,
                                           _Tp>
    {};

template <class _Tp, class _A0>
struct __attribute__ ((__type_visibility__("default"))) is_constructible<_Tp, _A0, __is_construct::__nat>
    : public __is_constructible1_void_check<is_void<_Tp>::value
                                        || is_abstract<_Tp>::value
                                        || is_function<_Tp>::value
                                        || is_void<_A0>::value,
                                           _Tp, _A0>
    {};




template <class _Ap, size_t _Np>
struct __is_constructible0_imp<false, _Ap[_Np]>
    : public is_constructible<typename remove_all_extents<_Ap>::type>
    {};

template <class _Ap, size_t _Np, class _A0>
struct __is_constructible1_imp<false, _Ap[_Np], _A0>
    : public false_type
    {};

template <class _Ap, size_t _Np, class _A0, class _A1>
struct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>
    : public false_type
    {};



template <class _Ap>
struct __is_constructible0_imp<false, _Ap[]>
    : public false_type
    {};

template <class _Ap, class _A0>
struct __is_constructible1_imp<false, _Ap[], _A0>
    : public false_type
    {};

template <class _Ap, class _A0, class _A1>
struct __is_constructible2_imp<false, _Ap[], _A0, _A1>
    : public false_type
    {};






template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_default_constructible
    : public is_constructible<_Tp>
    {};



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_copy_constructible
    : public is_constructible<_Tp,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_move_constructible



    : public is_copy_constructible<_Tp>

    {};
# 2710 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class _Tp, class _A0 = __is_construct::__nat,
                     class _A1 = __is_construct::__nat>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible
    : false_type
{
};



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible<_Tp, __is_construct::__nat,
                                                       __is_construct::__nat>
    : integral_constant<bool, __is_trivially_constructible(_Tp)>
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible<_Tp, _Tp,
                                                       __is_construct::__nat>
    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible<_Tp, const _Tp&,
                                                       __is_construct::__nat>
    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible<_Tp, _Tp&,
                                                       __is_construct::__nat>
    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>
{
};
# 2783 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>
    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copy_constructible
    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>
    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_move_constructible



    : public is_trivially_copy_constructible<_Tp>

    {};





template <class _Tp, class _Arg>
struct is_trivially_assignable
    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>
{
};
# 2843 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copy_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_move_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,



                                     typename add_lvalue_reference<_Tp>::type>

    {};





template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_destructible
    : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};
# 2973 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class _Tp, class _A0 = __is_construct::__nat,
                     class _A1 = __is_construct::__nat>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible
    : false_type
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible<_Tp, __is_construct::__nat,
                                                       __is_construct::__nat>

    : integral_constant<bool, __has_nothrow_constructor(_Tp)>



{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible<_Tp, _Tp,
                                                       __is_construct::__nat>

    : integral_constant<bool, __has_nothrow_copy(_Tp)>



{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible<_Tp, const _Tp&,
                                                       __is_construct::__nat>

    : integral_constant<bool, __has_nothrow_copy(_Tp)>



{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible<_Tp, _Tp&,
                                                       __is_construct::__nat>

    : integral_constant<bool, __has_nothrow_copy(_Tp)>



{
};






template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_default_constructible
    : public is_nothrow_constructible<_Tp>
    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_copy_constructible
    : public is_nothrow_constructible<_Tp,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_move_constructible



    : public is_nothrow_copy_constructible<_Tp>

    {};
# 3075 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class _Tp, class _Arg>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_assignable
    : public false_type {};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_assignable<_Tp&, _Tp>

    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};




template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_assignable<_Tp&, _Tp&>

    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};




template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_assignable<_Tp&, const _Tp&>

    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
# 3119 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_copy_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_move_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,



                                     typename add_lvalue_reference<_Tp>::type>

    {};
# 3182 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class _Tp> struct __libcpp_nothrow_destructor
    : public integral_constant<bool, is_scalar<_Tp>::value ||
                                     is_reference<_Tp>::value> {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible
    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};







template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_pod
    : public integral_constant<bool, __is_pod(_Tp)> {};
# 3210 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_literal_type

    : public integral_constant<bool, __is_literal(_Tp)>




    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_standard_layout

    : public integral_constant<bool, __is_standard_layout(_Tp)>



    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copyable

    : public integral_constant<bool, __is_trivially_copyable(_Tp)>



    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivial

    : public integral_constant<bool, __is_trivial(_Tp)>




    {};
# 3519 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))







void

swap(_Tp& __x, _Tp& __y)

{
    _Tp __t(std::__1::move(__x));
    __x = std::__1::move(__y);
    __y = std::__1::move(__t);
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)



{
    swap(*__a, *__b);
}



namespace __detail
{

using std::__1::swap;
__nat swap(__any, __any);

template <class _Tp>
struct __swappable
{
    typedef __typeof__(swap(std::__1::declval<_Tp&>(), std::__1::declval<_Tp&>())) type;
    static const bool value = !is_same<type, __nat>::value;
};

}

template <class _Tp>
struct __is_swappable
    : public integral_constant<bool, __detail::__swappable<_Tp>::value>
{
};
# 3595 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
template <class _Tp>
struct __is_nothrow_swappable
    : public false_type
{
};





template <class _Tp>
struct underlying_type
{
    typedef __underlying_type(_Tp) type;
};
# 3648 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/type_traits" 3
} }
# 303 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cmath" 2 3
# 310 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cmath" 3






template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_signbit(_A1 __lcpp_x) throw()
{
    return ( sizeof(__lcpp_x) == sizeof(float) ? (int)(__FLOAT_BITS(__lcpp_x)>>31) : sizeof(__lcpp_x) == sizeof(double) ? (int)(__DOUBLE_BITS(__lcpp_x)>>63) : __signbitl(__lcpp_x) );
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
signbit(_A1 __lcpp_x) throw()
{
    return __libcpp_signbit((typename std::__promote<_A1>::type)__lcpp_x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
int
__libcpp_fpclassify(_A1 __lcpp_x) throw()
{
    return ( sizeof(__lcpp_x) == sizeof(float) ? __fpclassifyf(__lcpp_x) : sizeof(__lcpp_x) == sizeof(double) ? __fpclassify(__lcpp_x) : __fpclassifyl(__lcpp_x) );
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, int>::type
fpclassify(_A1 __lcpp_x) throw()
{
    return __libcpp_fpclassify((typename std::__promote<_A1>::type)__lcpp_x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isfinite(_A1 __lcpp_x) throw()
{
    return ( sizeof(__lcpp_x) == sizeof(float) ? (__FLOAT_BITS(__lcpp_x) & 0x7fffffff) < 0x7f800000 : sizeof(__lcpp_x) == sizeof(double) ? (__DOUBLE_BITS(__lcpp_x) & -1ULL>>1) < 0x7ffULL<<52 : __fpclassifyl(__lcpp_x) > 1);
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
isfinite(_A1 __lcpp_x) throw()
{
    return __libcpp_isfinite((typename std::__promote<_A1>::type)__lcpp_x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isinf(_A1 __lcpp_x) throw()
{
    return ( sizeof(__lcpp_x) == sizeof(float) ? (__FLOAT_BITS(__lcpp_x) & 0x7fffffff) == 0x7f800000 : sizeof(__lcpp_x) == sizeof(double) ? (__DOUBLE_BITS(__lcpp_x) & -1ULL>>1) == 0x7ffULL<<52 : __fpclassifyl(__lcpp_x) == 1);
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
isinf(_A1 __lcpp_x) throw()
{
    return __libcpp_isinf((typename std::__promote<_A1>::type)__lcpp_x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isnan(_A1 __lcpp_x) throw()
{
    return ( sizeof(__lcpp_x) == sizeof(float) ? (__FLOAT_BITS(__lcpp_x) & 0x7fffffff) > 0x7f800000 : sizeof(__lcpp_x) == sizeof(double) ? (__DOUBLE_BITS(__lcpp_x) & -1ULL>>1) > 0x7ffULL<<52 : __fpclassifyl(__lcpp_x) == 0);
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
isnan(_A1 __lcpp_x) throw()
{
    return __libcpp_isnan((typename std::__promote<_A1>::type)__lcpp_x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isnormal(_A1 __lcpp_x) throw()
{
    return ( sizeof(__lcpp_x) == sizeof(float) ? ((__FLOAT_BITS(__lcpp_x)+0x00800000) & 0x7fffffff) >= 0x01000000 : sizeof(__lcpp_x) == sizeof(double) ? ((__DOUBLE_BITS(__lcpp_x)+(1ULL<<52)) & -1ULL>>1) >= 1ULL<<53 : __fpclassifyl(__lcpp_x) == 4);
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
isnormal(_A1 __lcpp_x) throw()
{
    return __libcpp_isnormal((typename std::__promote<_A1>::type)__lcpp_x);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isgreater(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
    return ( sizeof((__lcpp_x)+(__lcpp_y)) == sizeof(float) ? __isgreaterf(__lcpp_x, __lcpp_y) : sizeof((__lcpp_x)+(__lcpp_y)) == sizeof(double) ? __isgreater(__lcpp_x, __lcpp_y) : __isgreaterl(__lcpp_x, __lcpp_y) );
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isgreater(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isgreater((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
    return ( sizeof((__lcpp_x)+(__lcpp_y)) == sizeof(float) ? __isgreaterequalf(__lcpp_x, __lcpp_y) : sizeof((__lcpp_x)+(__lcpp_y)) == sizeof(double) ? __isgreaterequal(__lcpp_x, __lcpp_y) : __isgreaterequall(__lcpp_x, __lcpp_y) );
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isgreaterequal((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isless(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
    return ( sizeof((__lcpp_x)+(__lcpp_y)) == sizeof(float) ? __islessf(__lcpp_x, __lcpp_y) : sizeof((__lcpp_x)+(__lcpp_y)) == sizeof(double) ? __isless(__lcpp_x, __lcpp_y) : __islessl(__lcpp_x, __lcpp_y) );
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isless(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isless((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_islessequal(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
    return ( sizeof((__lcpp_x)+(__lcpp_y)) == sizeof(float) ? __islessequalf(__lcpp_x, __lcpp_y) : sizeof((__lcpp_x)+(__lcpp_y)) == sizeof(double) ? __islessequal(__lcpp_x, __lcpp_y) : __islessequall(__lcpp_x, __lcpp_y) );
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
islessequal(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_islessequal((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
    return ( sizeof((__lcpp_x)+(__lcpp_y)) == sizeof(float) ? __islessgreaterf(__lcpp_x, __lcpp_y) : sizeof((__lcpp_x)+(__lcpp_y)) == sizeof(double) ? __islessgreater(__lcpp_x, __lcpp_y) : __islessgreaterl(__lcpp_x, __lcpp_y) );
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_islessgreater((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isunordered(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
    return (isnan((__lcpp_x)) ? ((void)(__lcpp_y),1) : isnan((__lcpp_y)));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isunordered(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isunordered((type)__lcpp_x, (type)__lcpp_y);
}



namespace std {inline namespace __1 {

using ::signbit;
using ::fpclassify;
using ::isfinite;
using ::isinf;
using ::isnan;
using ::isnormal;
using ::isgreater;
using ::isgreaterequal;
using ::isless;
using ::islessequal;
using ::islessgreater;
using ::isunordered;
using ::isunordered;

using ::float_t;
using ::double_t;




inline __attribute__ ((__visibility__("hidden"), __always_inline__))
float
abs(float __lcpp_x) throw() {return fabsf(__lcpp_x);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
double
abs(double __lcpp_x) throw() {return fabs(__lcpp_x);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
long double
abs(long double __lcpp_x) throw() {return fabsl(__lcpp_x);}






using ::acos;
using ::acosf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float acos(float __lcpp_x) throw() {return acosf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double acos(long double __lcpp_x) throw() {return acosl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
acos(_A1 __lcpp_x) throw() {return acos((double)__lcpp_x);}



using ::asin;
using ::asinf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float asin(float __lcpp_x) throw() {return asinf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double asin(long double __lcpp_x) throw() {return asinl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
asin(_A1 __lcpp_x) throw() {return asin((double)__lcpp_x);}



using ::atan;
using ::atanf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float atan(float __lcpp_x) throw() {return atanf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double atan(long double __lcpp_x) throw() {return atanl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
atan(_A1 __lcpp_x) throw() {return atan((double)__lcpp_x);}



using ::atan2;
using ::atan2f;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float atan2(float __lcpp_y, float __lcpp_x) throw() {return atan2f(__lcpp_y, __lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double atan2(long double __lcpp_y, long double __lcpp_x) throw() {return atan2l(__lcpp_y, __lcpp_x);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
atan2(_A1 __lcpp_y, _A2 __lcpp_x) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t740;

    return atan2((__result_type)__lcpp_y, (__result_type)__lcpp_x);
}



using ::ceil;
using ::ceilf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float ceil(float __lcpp_x) throw() {return ceilf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double ceil(long double __lcpp_x) throw() {return ceill(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
ceil(_A1 __lcpp_x) throw() {return ceil((double)__lcpp_x);}



using ::cos;
using ::cosf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float cos(float __lcpp_x) throw() {return cosf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double cos(long double __lcpp_x) throw() {return cosl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
cos(_A1 __lcpp_x) throw() {return cos((double)__lcpp_x);}



using ::cosh;
using ::coshf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float cosh(float __lcpp_x) throw() {return coshf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double cosh(long double __lcpp_x) throw() {return coshl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
cosh(_A1 __lcpp_x) throw() {return cosh((double)__lcpp_x);}




using ::exp;
using ::expf;




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float exp(float __lcpp_x) throw() {return expf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double exp(long double __lcpp_x) throw() {return expl(__lcpp_x);}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
exp(_A1 __lcpp_x) throw() {return exp((double)__lcpp_x);}



using ::fabs;
using ::fabsf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fabs(float __lcpp_x) throw() {return fabsf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fabs(long double __lcpp_x) throw() {return fabsl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
fabs(_A1 __lcpp_x) throw() {return fabs((double)__lcpp_x);}



using ::floor;
using ::floorf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float floor(float __lcpp_x) throw() {return floorf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double floor(long double __lcpp_x) throw() {return floorl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
floor(_A1 __lcpp_x) throw() {return floor((double)__lcpp_x);}




using ::fmod;
using ::fmodf;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fmod(float __lcpp_x, float __lcpp_y) throw() {return fmodf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fmod(long double __lcpp_x, long double __lcpp_y) throw() {return fmodl(__lcpp_x, __lcpp_y);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
fmod(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t862;

    return fmod((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}




using ::frexp;
using ::frexpf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float frexp(float __lcpp_x, int* __lcpp_e) throw() {return frexpf(__lcpp_x, __lcpp_e);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double frexp(long double __lcpp_x, int* __lcpp_e) throw() {return frexpl(__lcpp_x, __lcpp_e);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
frexp(_A1 __lcpp_x, int* __lcpp_e) throw() {return frexp((double)__lcpp_x, __lcpp_e);}



using ::ldexp;
using ::ldexpf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float ldexp(float __lcpp_x, int __lcpp_e) throw() {return ldexpf(__lcpp_x, __lcpp_e);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double ldexp(long double __lcpp_x, int __lcpp_e) throw() {return ldexpl(__lcpp_x, __lcpp_e);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
ldexp(_A1 __lcpp_x, int __lcpp_e) throw() {return ldexp((double)__lcpp_x, __lcpp_e);}




using ::log;
using ::logf;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float log(float __lcpp_x) throw() {return logf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double log(long double __lcpp_x) throw() {return logl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
log(_A1 __lcpp_x) throw() {return log((double)__lcpp_x);}




using ::log10;
using ::log10f;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float log10(float __lcpp_x) throw() {return log10f(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double log10(long double __lcpp_x) throw() {return log10l(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
log10(_A1 __lcpp_x) throw() {return log10((double)__lcpp_x);}



using ::modf;
using ::modff;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float modf(float __lcpp_x, float* __lcpp_y) throw() {return modff(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double modf(long double __lcpp_x, long double* __lcpp_y) throw() {return modfl(__lcpp_x, __lcpp_y);}





using ::pow;
using ::powf;




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float pow(float __lcpp_x, float __lcpp_y) throw() {return powf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double pow(long double __lcpp_x, long double __lcpp_y) throw() {return powl(__lcpp_x, __lcpp_y);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
pow(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t965;

    return pow((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



using ::sin;
using ::sinf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float sin(float __lcpp_x) throw() {return sinf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double sin(long double __lcpp_x) throw() {return sinl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
sin(_A1 __lcpp_x) throw() {return sin((double)__lcpp_x);}



using ::sinh;
using ::sinhf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float sinh(float __lcpp_x) throw() {return sinhf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double sinh(long double __lcpp_x) throw() {return sinhl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
sinh(_A1 __lcpp_x) throw() {return sinh((double)__lcpp_x);}




using ::sqrt;
using ::sqrtf;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float sqrt(float __lcpp_x) throw() {return sqrtf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double sqrt(long double __lcpp_x) throw() {return sqrtl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
sqrt(_A1 __lcpp_x) throw() {return sqrt((double)__lcpp_x);}



using ::tan;
using ::tanf;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float tan(float __lcpp_x) throw() {return tanf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double tan(long double __lcpp_x) throw() {return tanl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
tan(_A1 __lcpp_x) throw() {return tan((double)__lcpp_x);}



using ::tanh;
using ::tanhf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float tanh(float __lcpp_x) throw() {return tanhf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double tanh(long double __lcpp_x) throw() {return tanhl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
tanh(_A1 __lcpp_x) throw() {return tanh((double)__lcpp_x);}




using ::acosh;
using ::acoshf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float acosh(float __lcpp_x) throw() {return acoshf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double acosh(long double __lcpp_x) throw() {return acoshl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
acosh(_A1 __lcpp_x) throw() {return acosh((double)__lcpp_x);}





using ::asinh;
using ::asinhf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float asinh(float __lcpp_x) throw() {return asinhf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double asinh(long double __lcpp_x) throw() {return asinhl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
asinh(_A1 __lcpp_x) throw() {return asinh((double)__lcpp_x);}





using ::atanh;
using ::atanhf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float atanh(float __lcpp_x) throw() {return atanhf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double atanh(long double __lcpp_x) throw() {return atanhl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
atanh(_A1 __lcpp_x) throw() {return atanh((double)__lcpp_x);}





using ::cbrt;
using ::cbrtf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float cbrt(float __lcpp_x) throw() {return cbrtf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double cbrt(long double __lcpp_x) throw() {return cbrtl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
cbrt(_A1 __lcpp_x) throw() {return cbrt((double)__lcpp_x);}




using ::copysign;
using ::copysignf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float copysign(float __lcpp_x, float __lcpp_y) throw() {return copysignf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double copysign(long double __lcpp_x, long double __lcpp_y) throw() {return copysignl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
copysign(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1127;

    return copysign((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}





using ::erf;
using ::erff;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float erf(float __lcpp_x) throw() {return erff(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double erf(long double __lcpp_x) throw() {return erfl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
erf(_A1 __lcpp_x) throw() {return erf((double)__lcpp_x);}



using ::erfc;
using ::erfcf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float erfc(float __lcpp_x) throw() {return erfcf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double erfc(long double __lcpp_x) throw() {return erfcl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
erfc(_A1 __lcpp_x) throw() {return erfc((double)__lcpp_x);}



using ::exp2;
using ::exp2f;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float exp2(float __lcpp_x) throw() {return exp2f(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double exp2(long double __lcpp_x) throw() {return exp2l(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
exp2(_A1 __lcpp_x) throw() {return exp2((double)__lcpp_x);}



using ::expm1;
using ::expm1f;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float expm1(float __lcpp_x) throw() {return expm1f(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double expm1(long double __lcpp_x) throw() {return expm1l(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
expm1(_A1 __lcpp_x) throw() {return expm1((double)__lcpp_x);}



using ::fdim;
using ::fdimf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fdim(float __lcpp_x, float __lcpp_y) throw() {return fdimf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fdim(long double __lcpp_x, long double __lcpp_y) throw() {return fdiml(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
fdim(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1205;

    return fdim((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



using ::fmaf;
using ::fma;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fma(float __lcpp_x, float __lcpp_y, float __lcpp_z) throw() {return fmaf(__lcpp_x, __lcpp_y, __lcpp_z);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fma(long double __lcpp_x, long double __lcpp_y, long double __lcpp_z) throw() {return fmal(__lcpp_x, __lcpp_y, __lcpp_z);}

template <class _A1, class _A2, class _A3>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value &&
    is_arithmetic<_A3>::value,
    typename __promote<_A1, _A2, _A3>::type
>::type
fma(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) throw()
{
    typedef typename __promote<_A1, _A2, _A3>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value && is_same<_A3, __result_type>::value)))>)> __t1231;


    return fma((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);
}



using ::fmax;
using ::fmaxf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fmax(float __lcpp_x, float __lcpp_y) throw() {return fmaxf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fmax(long double __lcpp_x, long double __lcpp_y) throw() {return fmaxl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
fmax(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1255;

    return fmax((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



using ::fmin;
using ::fminf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fmin(float __lcpp_x, float __lcpp_y) throw() {return fminf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fmin(long double __lcpp_x, long double __lcpp_y) throw() {return fminl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
fmin(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1279;

    return fmin((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



using ::hypot;
using ::hypotf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float hypot(float __lcpp_x, float __lcpp_y) throw() {return hypotf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double hypot(long double __lcpp_x, long double __lcpp_y) throw() {return hypotl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
hypot(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1303;

    return hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



using ::ilogb;
using ::ilogbf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int ilogb(float __lcpp_x) throw() {return ilogbf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int ilogb(long double __lcpp_x) throw() {return ilogbl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, int>::type
ilogb(_A1 __lcpp_x) throw() {return ilogb((double)__lcpp_x);}



using ::lgamma;
using ::lgammaf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float lgamma(float __lcpp_x) throw() {return lgammaf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double lgamma(long double __lcpp_x) throw() {return lgammal(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
lgamma(_A1 __lcpp_x) throw() {return lgamma((double)__lcpp_x);}




using ::llrint;
using ::llrintf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long llrint(float __lcpp_x) throw() {return llrintf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long llrint(long double __lcpp_x) throw() {return llrintl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, long long>::type
llrint(_A1 __lcpp_x) throw() {return llrint((double)__lcpp_x);}



using ::llround;
using ::llroundf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long llround(float __lcpp_x) throw() {return llroundf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long llround(long double __lcpp_x) throw() {return llroundl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, long long>::type
llround(_A1 __lcpp_x) throw() {return llround((double)__lcpp_x);}



using ::log1p;
using ::log1pf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float log1p(float __lcpp_x) throw() {return log1pf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double log1p(long double __lcpp_x) throw() {return log1pl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
log1p(_A1 __lcpp_x) throw() {return log1p((double)__lcpp_x);}



using ::log2;
using ::log2f;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float log2(float __lcpp_x) throw() {return log2f(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double log2(long double __lcpp_x) throw() {return log2l(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
log2(_A1 __lcpp_x) throw() {return log2((double)__lcpp_x);}



using ::logb;
using ::logbf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float logb(float __lcpp_x) throw() {return logbf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double logb(long double __lcpp_x) throw() {return logbl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
logb(_A1 __lcpp_x) throw() {return logb((double)__lcpp_x);}



using ::lrint;
using ::lrintf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long lrint(float __lcpp_x) throw() {return lrintf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long lrint(long double __lcpp_x) throw() {return lrintl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, long>::type
lrint(_A1 __lcpp_x) throw() {return lrint((double)__lcpp_x);}



using ::lround;
using ::lroundf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long lround(float __lcpp_x) throw() {return lroundf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long lround(long double __lcpp_x) throw() {return lroundl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, long>::type
lround(_A1 __lcpp_x) throw() {return lround((double)__lcpp_x);}







using ::nan;
using ::nanf;







using ::nearbyint;
using ::nearbyintf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float nearbyint(float __lcpp_x) throw() {return nearbyintf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double nearbyint(long double __lcpp_x) throw() {return nearbyintl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
nearbyint(_A1 __lcpp_x) throw() {return nearbyint((double)__lcpp_x);}



using ::nextafter;
using ::nextafterf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float nextafter(float __lcpp_x, float __lcpp_y) throw() {return nextafterf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double nextafter(long double __lcpp_x, long double __lcpp_y) throw() {return nextafterl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
nextafter(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1472;

    return nextafter((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



using ::nexttoward;
using ::nexttowardf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float nexttoward(float __lcpp_x, long double __lcpp_y) throw() {return nexttowardf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double nexttoward(long double __lcpp_x, long double __lcpp_y) throw() {return nexttowardl(__lcpp_x, __lcpp_y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
nexttoward(_A1 __lcpp_x, long double __lcpp_y) throw() {return nexttoward((double)__lcpp_x, __lcpp_y);}



using ::remainder;
using ::remainderf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float remainder(float __lcpp_x, float __lcpp_y) throw() {return remainderf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double remainder(long double __lcpp_x, long double __lcpp_y) throw() {return remainderl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
remainder(_A1 __lcpp_x, _A2 __lcpp_y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1509;

    return remainder((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



using ::remquo;
using ::remquof;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float remquo(float __lcpp_x, float __lcpp_y, int* __lcpp_z) throw() {return remquof(__lcpp_x, __lcpp_y, __lcpp_z);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double remquo(long double __lcpp_x, long double __lcpp_y, int* __lcpp_z) throw() {return remquol(__lcpp_x, __lcpp_y, __lcpp_z);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
remquo(_A1 __lcpp_x, _A2 __lcpp_y, int* __lcpp_z) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1533;

    return remquo((__result_type)__lcpp_x, (__result_type)__lcpp_y, __lcpp_z);
}



using ::rint;
using ::rintf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float rint(float __lcpp_x) throw() {return rintf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double rint(long double __lcpp_x) throw() {return rintl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
rint(_A1 __lcpp_x) throw() {return rint((double)__lcpp_x);}



using ::round;
using ::roundf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float round(float __lcpp_x) throw() {return roundf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double round(long double __lcpp_x) throw() {return roundl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
round(_A1 __lcpp_x) throw() {return round((double)__lcpp_x);}



using ::scalbln;
using ::scalblnf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float scalbln(float __lcpp_x, long __lcpp_y) throw() {return scalblnf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double scalbln(long double __lcpp_x, long __lcpp_y) throw() {return scalblnl(__lcpp_x, __lcpp_y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
scalbln(_A1 __lcpp_x, long __lcpp_y) throw() {return scalbln((double)__lcpp_x, __lcpp_y);}



using ::scalbn;
using ::scalbnf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float scalbn(float __lcpp_x, int __lcpp_y) throw() {return scalbnf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double scalbn(long double __lcpp_x, int __lcpp_y) throw() {return scalbnl(__lcpp_x, __lcpp_y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
scalbn(_A1 __lcpp_x, int __lcpp_y) throw() {return scalbn((double)__lcpp_x, __lcpp_y);}



using ::tgamma;
using ::tgammaf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float tgamma(float __lcpp_x) throw() {return tgammaf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double tgamma(long double __lcpp_x) throw() {return tgammal(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
tgamma(_A1 __lcpp_x) throw() {return tgamma((double)__lcpp_x);}



using ::trunc;
using ::truncf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float trunc(float __lcpp_x) throw() {return truncf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double trunc(long double __lcpp_x) throw() {return truncl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
trunc(_A1 __lcpp_x) throw() {return trunc((double)__lcpp_x);}



using ::acosl;
using ::asinl;
using ::atanl;
using ::atan2l;
using ::ceill;
using ::cosl;
using ::coshl;
using ::expl;
using ::fabsl;
using ::floorl;
using ::fmodl;
using ::frexpl;
using ::ldexpl;
using ::logl;
using ::log10l;
using ::modfl;
using ::powl;
using ::sinl;
using ::sinhl;
using ::sqrtl;
using ::tanl;

using ::tanhl;
using ::acoshl;
using ::asinhl;
using ::atanhl;
using ::cbrtl;

using ::copysignl;

using ::erfl;
using ::erfcl;
using ::exp2l;
using ::expm1l;
using ::fdiml;
using ::fmal;
using ::fmaxl;
using ::fminl;
using ::hypotl;
using ::ilogbl;
using ::lgammal;
using ::llrintl;
using ::llroundl;
using ::log1pl;
using ::log2l;
using ::logbl;
using ::lrintl;
using ::lroundl;
using ::nanl;
using ::nearbyintl;
using ::nextafterl;
using ::nexttowardl;
using ::remainderl;
using ::remquol;
using ::rintl;
using ::roundl;
using ::scalblnl;
using ::scalbnl;
using ::tgammal;
using ::truncl;






} }
# 37 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/build/include/llvm/Support/DataTypes.h" 2
# 57 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/build/include/llvm/Support/DataTypes.h"
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/sys/types.h" 1 3



extern "C" {
# 58 "/mnt/home/ec2-user/build/emscripten/system/include/libc/sys/types.h" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 1 3
# 75 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 3
typedef long time_t;




typedef long suseconds_t;





typedef struct { union { int __i[9]; unsigned __s[9]; } __u; } pthread_attr_t;




typedef struct { union { int __i[6]; void *__p[6]; } __u; } pthread_mutex_t;




typedef struct { union { int __i[12]; void *__p[12]; } __u; } pthread_cond_t;




typedef struct { union { int __i[8]; void *__p[8]; } __u; } pthread_rwlock_t;




typedef struct { union { int __i[5]; void *__p[5]; } __u; } pthread_barrier_t;
# 141 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 3
typedef int register_t;





typedef signed char int8_t;




typedef short int16_t;




typedef int int32_t;




typedef long long int64_t;
# 192 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 3
typedef unsigned long long u_int64_t;
# 203 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 3
typedef unsigned mode_t;




typedef unsigned int nlink_t;
# 218 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 3
typedef unsigned int ino_t;




typedef unsigned int dev_t;




typedef long blksize_t;




typedef int blkcnt_t;




typedef unsigned int fsblkcnt_t;




typedef unsigned int fsfilcnt_t;
# 255 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 3
typedef void * timer_t;




typedef int clockid_t;




typedef long clock_t;
# 286 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 3
typedef unsigned id_t;
# 301 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 3
typedef int key_t;
# 313 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 3
typedef unsigned long pthread_t;
# 325 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 3
typedef int pthread_once_t;




typedef unsigned pthread_key_t;




typedef int pthread_spinlock_t;




typedef struct { unsigned __attr; } pthread_mutexattr_t;




typedef struct { unsigned __attr; } pthread_condattr_t;




typedef struct { unsigned __attr; } pthread_barrierattr_t;




typedef struct { unsigned __attr[2]; } pthread_rwlockattr_t;
# 59 "/mnt/home/ec2-user/build/emscripten/system/include/libc/sys/types.h" 2 3

typedef unsigned char u_int8_t;
typedef unsigned short u_int16_t;
typedef unsigned u_int32_t;


typedef char *caddr_t;
typedef unsigned char u_char;
typedef unsigned short u_short, ushort;
typedef unsigned u_int, uint;
typedef unsigned long u_long, ulong;
typedef long long quad_t;
typedef unsigned long long u_quad_t;

# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/endian.h" 1 3
# 23 "/mnt/home/ec2-user/build/emscripten/system/include/libc/endian.h" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/stdint.h" 1 3
# 20 "/mnt/home/ec2-user/build/emscripten/system/include/libc/stdint.h" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 1 3
# 116 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 3
typedef unsigned int uintptr_t;
# 167 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 3
typedef long long intmax_t;




typedef unsigned char uint8_t;




typedef unsigned short uint16_t;




typedef unsigned int uint32_t;




typedef unsigned long long uint64_t;
# 197 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 3
typedef unsigned long long uintmax_t;
# 21 "/mnt/home/ec2-user/build/emscripten/system/include/libc/stdint.h" 2 3

typedef int8_t int_fast8_t;
typedef int64_t int_fast64_t;

typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;

typedef uint8_t uint_fast8_t;
typedef uint64_t uint_fast64_t;

typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;
# 95 "/mnt/home/ec2-user/build/emscripten/system/include/libc/stdint.h" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/stdint.h" 1 3
typedef int32_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef uint32_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
# 96 "/mnt/home/ec2-user/build/emscripten/system/include/libc/stdint.h" 2 3
# 24 "/mnt/home/ec2-user/build/emscripten/system/include/libc/endian.h" 2 3

static inline uint16_t __bswap16(uint16_t __x)
{
 return __x<<8 | __x>>8;
}

static inline uint32_t __bswap32(uint32_t __x)
{
 return __x>>24 | __x>>8&0xff00 | __x<<8&0xff0000 | __x<<24;
}

static inline uint64_t __bswap64(uint64_t __x)
{
 return __bswap32(__x)+0ULL<<32 | __bswap32(__x>>32);
}
# 73 "/mnt/home/ec2-user/build/emscripten/system/include/libc/sys/types.h" 2 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/sys/select.h" 1 3



extern "C" {
# 16 "/mnt/home/ec2-user/build/emscripten/system/include/libc/sys/select.h" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 1 3
# 270 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 3
struct timeval { time_t tv_sec; suseconds_t tv_usec; };




struct timespec { time_t tv_sec; long tv_nsec; };
# 373 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 3
typedef struct __sigset_t { unsigned long __bits[128/sizeof(long)]; } sigset_t;
# 17 "/mnt/home/ec2-user/build/emscripten/system/include/libc/sys/select.h" 2 3



typedef unsigned long fd_mask;

typedef struct
{
 unsigned long fds_bits[1024 / 8 / sizeof(long)];
} fd_set;






int select (int, fd_set *__restrict, fd_set *__restrict, fd_set *__restrict, struct timeval *__restrict);
int pselect (int, fd_set *__restrict, fd_set *__restrict, fd_set *__restrict, const struct timespec *__restrict, const sigset_t *__restrict);






}
# 74 "/mnt/home/ec2-user/build/emscripten/system/include/libc/sys/types.h" 2 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/sys/sysmacros.h" 1 3
# 75 "/mnt/home/ec2-user/build/emscripten/system/include/libc/sys/types.h" 2 3
# 87 "/mnt/home/ec2-user/build/emscripten/system/include/libc/sys/types.h" 3
}
# 58 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/build/include/llvm/Support/DataTypes.h" 2


# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/inttypes.h" 1 3




extern "C" {







# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 1 3
# 13 "/mnt/home/ec2-user/build/emscripten/system/include/libc/inttypes.h" 2 3

typedef struct { intmax_t quot, rem; } imaxdiv_t;

intmax_t imaxabs(intmax_t);
imaxdiv_t imaxdiv(intmax_t, intmax_t);

intmax_t strtoimax(const char *__restrict, char **__restrict, int);
uintmax_t strtoumax(const char *__restrict, char **__restrict, int);

intmax_t wcstoimax(const wchar_t *__restrict, wchar_t **__restrict, int);
uintmax_t wcstoumax(const wchar_t *__restrict, wchar_t **__restrict, int);
# 225 "/mnt/home/ec2-user/build/emscripten/system/include/libc/inttypes.h" 3
}
# 61 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/build/include/llvm/Support/DataTypes.h" 2
# 19 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/PointerLikeTypeTraits.h" 2

namespace llvm {




template <typename T>
class PointerLikeTypeTraits {



};


template<typename T>
class PointerLikeTypeTraits<T*> {
public:
  static inline void *getAsVoidPointer(T* P) { return P; }
  static inline T *getFromVoidPointer(void *P) {
    return static_cast<T*>(P);
  }







  enum { NumLowBitsAvailable = 2 };
};


template<typename T>
class PointerLikeTypeTraits<const T*> {
  typedef PointerLikeTypeTraits<T*> NonConst;

public:
  static inline const void *getAsVoidPointer(const T* P) {
    return NonConst::getAsVoidPointer(const_cast<T*>(P));
  }
  static inline const T *getFromVoidPointer(const void *P) {
    return NonConst::getFromVoidPointer(const_cast<void*>(P));
  }
  enum { NumLowBitsAvailable = NonConst::NumLowBitsAvailable };
};


template<>
class PointerLikeTypeTraits<uintptr_t> {
public:
  static inline void *getAsVoidPointer(uintptr_t P) {
    return reinterpret_cast<void*>(P);
  }
  static inline uintptr_t getFromVoidPointer(void *P) {
    return reinterpret_cast<uintptr_t>(P);
  }

  enum { NumLowBitsAvailable = 0 };
};

}
# 18 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMapInfo.h" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/type_traits.h" 1
# 22 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/type_traits.h"
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/utility" 1 3
# 157 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/utility" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__tuple" 1 3
# 20 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__tuple" 3




# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__tuple_03" 1 3
# 18 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__tuple_03" 3


namespace std {inline namespace __1 {

template <class _Tp> class __attribute__ ((__type_visibility__("default"))) tuple_size;
template <size_t _Ip, class _Tp> class __attribute__ ((__type_visibility__("default"))) tuple_element;

} }
# 25 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__tuple" 2 3
# 158 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/utility" 2 3
# 162 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/utility" 3


namespace std {inline namespace __1 {

namespace rel_ops
{

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const _Tp& __x, const _Tp& __y)
{
    return !(__x == __y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const _Tp& __x, const _Tp& __y)
{
    return __y < __x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const _Tp& __x, const _Tp& __y)
{
    return !(__y < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const _Tp& __x, const _Tp& __y)
{
    return !(__x < __y);
}

}



template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator2
swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)
{
    for(; __first1 != __last1; ++__first1, ++__first2)
        swap(*__first1, *__first2);
    return __first2;
}

template<class _Tp, size_t _Np>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np])
{
    std::__1::swap_ranges(__a, __a + _Np, __b);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
# 233 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/utility" 3
const _Tp&

move_if_noexcept(_Tp& __x) throw()
{
    return std::__1::move(__x);
}

struct __attribute__ ((__type_visibility__("default"))) piecewise_construct_t { };

extern const piecewise_construct_t piecewise_construct;




template <class _T1, class _T2>
struct __attribute__ ((__type_visibility__("default"))) pair
{
    typedef _T1 first_type;
    typedef _T2 second_type;

    _T1 first;
    _T2 second;




    __attribute__ ((__visibility__("hidden"), __always_inline__)) pair() : first(), second() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair(const _T1& __x, const _T2& __y)
        : first(__x), second(__y) {}

    template<class _U1, class _U2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        pair(const pair<_U1, _U2>& __p




                                      )
            : first(__p.first), second(__p.second) {}
# 289 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/utility" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair& operator=(const pair& __p)


    {
        first = __p.first;
        second = __p.second;
        return *this;
    }
# 381 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/utility" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void
    swap(pair& __p)

    {
        std::__1::iter_swap(&first, &__p.first);
        std::__1::iter_swap(&second, &__p.second);
    }
private:
# 398 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/utility" 3
};

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __x.first == __y.first && __x.second == __y.second;
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__x == __y);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __y < __x;
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__x < __y);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__y < __x);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    __is_swappable<_T1>::value &&
    __is_swappable<_T2>::value,
    void
>::type
swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)


{
    __x.swap(__y);
}
# 496 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/utility" 3
template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_T1,_T2>
make_pair(_T1 __x, _T2 __y)
{
    return pair<_T1, _T2>(__x, __y);
}



template <class _T1, class _T2>
  class __attribute__ ((__type_visibility__("default"))) tuple_size<pair<_T1, _T2> >
    : public integral_constant<size_t, 2> {};

template <class _T1, class _T2>
  class __attribute__ ((__type_visibility__("default"))) tuple_size<const pair<_T1, _T2> >
    : public integral_constant<size_t, 2> {};

template <class _T1, class _T2>
class __attribute__ ((__type_visibility__("default"))) tuple_element<0, pair<_T1, _T2> >
{
public:
    typedef _T1 type;
};

template <class _T1, class _T2>
class __attribute__ ((__type_visibility__("default"))) tuple_element<1, pair<_T1, _T2> >
{
public:
    typedef _T2 type;
};

template <class _T1, class _T2>
class __attribute__ ((__type_visibility__("default"))) tuple_element<0, const pair<_T1, _T2> >
{
public:
    typedef const _T1 type;
};

template <class _T1, class _T2>
class __attribute__ ((__type_visibility__("default"))) tuple_element<1, const pair<_T1, _T2> >
{
public:
    typedef const _T2 type;
};

template <size_t _Ip> struct __get_pair;

template <>
struct __get_pair<0>
{
    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _T1&
    get(pair<_T1, _T2>& __p) throw() {return __p.first;}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const _T1&
    get(const pair<_T1, _T2>& __p) throw() {return __p.first;}
# 568 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/utility" 3
};

template <>
struct __get_pair<1>
{
    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _T2&
    get(pair<_T1, _T2>& __p) throw() {return __p.second;}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const _T2&
    get(const pair<_T1, _T2>& __p) throw() {return __p.second;}
# 594 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/utility" 3
};

template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>& __p) throw()
{
    return __get_pair<_Ip>::get(__p);
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>& __p) throw()
{
    return __get_pair<_Ip>::get(__p);
}
# 766 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/utility" 3
} }
# 23 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/type_traits.h" 2
# 34 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/type_traits.h"
namespace llvm {

namespace dont_use
{
# 47 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/type_traits.h"
    template<typename T> char is_class_helper(void(T::*)());
    template<typename T> double is_class_helper(...);
}

template <typename T>
struct is_class
{



public:
  static const bool value =
      sizeof(char) == sizeof(dont_use::is_class_helper<T>(0));
};




template <typename T>
struct isPodLike {



  static const bool value = __is_trivially_copyable(T);





};


template<typename T, typename U>
struct isPodLike<std::pair<T, U> > {
  static const bool value = isPodLike<T>::value && isPodLike<U>::value;
};


template <class T, T v>
struct integral_constant {
  typedef T value_type;
  static const value_type value = v;
  typedef integral_constant<T,v> type;
  operator value_type() { return value; }
};

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;



template<typename T, typename U> struct is_same : public false_type {};
template<typename T> struct is_same<T, T> : public true_type {};


template <typename T> struct remove_const { typedef T type; };
template <typename T> struct remove_const<const T> { typedef T type; };


template <typename T> struct remove_volatile { typedef T type; };
template <typename T> struct remove_volatile<volatile T> { typedef T type; };



template <typename T> struct remove_cv {
  typedef typename remove_const<typename remove_volatile<T>::type>::type type;
};


template <typename T> struct is_integral_impl : false_type {};
template <> struct is_integral_impl< bool> : true_type {};
template <> struct is_integral_impl< char> : true_type {};
template <> struct is_integral_impl< signed char> : true_type {};
template <> struct is_integral_impl<unsigned char> : true_type {};
template <> struct is_integral_impl< wchar_t> : true_type {};
template <> struct is_integral_impl< short> : true_type {};
template <> struct is_integral_impl<unsigned short> : true_type {};
template <> struct is_integral_impl< int> : true_type {};
template <> struct is_integral_impl<unsigned int> : true_type {};
template <> struct is_integral_impl< long> : true_type {};
template <> struct is_integral_impl<unsigned long> : true_type {};
template <> struct is_integral_impl< long long> : true_type {};
template <> struct is_integral_impl<unsigned long long> : true_type {};



template <typename T>
struct is_integral : is_integral_impl<T> {};


template <typename T> struct remove_reference { typedef T type; };
template <typename T> struct remove_reference<T&> { typedef T type; };



template <typename T> struct is_pointer : false_type {};
template <typename T> struct is_pointer<T*> : true_type {};
template <typename T> struct is_pointer<T* const> : true_type {};
template <typename T> struct is_pointer<T* volatile> : true_type {};
template <typename T> struct is_pointer<T* const volatile> : true_type {};


template <typename T> struct is_reference : false_type {};
template <typename T> struct is_reference<T&> : true_type {};







template <typename T> class is_integral_or_enum {




  static double check_int_convertible(unsigned long long);
  static char check_int_convertible(...);

  typedef typename remove_reference<T>::type UnderlyingT;
  static UnderlyingT &nonce_instance;

public:
  static const bool
    value = (!is_class<UnderlyingT>::value && !is_pointer<UnderlyingT>::value &&
             !is_same<UnderlyingT, float>::value &&
             !is_same<UnderlyingT, double>::value &&
             sizeof(char) != sizeof(check_int_convertible(nonce_instance)));
};


template<bool Cond, typename T = void>
struct enable_if_c {
  typedef T type;
};

template<typename T> struct enable_if_c<false, T> { };


template<typename Cond, typename T = void>
struct enable_if : public enable_if_c<Cond::value, T> { };

namespace dont_use {
  template<typename Base> char base_of_helper(const volatile Base*);
  template<typename Base> double base_of_helper(...);
}



template<typename Base, typename Derived>
struct is_base_of {
  static const bool value
    = is_class<Base>::value && is_class<Derived>::value &&
      sizeof(char) == sizeof(dont_use::base_of_helper<Base>((Derived*)0));
};



template <typename T> struct remove_pointer { typedef T type; };
template <typename T> struct remove_pointer<T*> { typedef T type; };
template <typename T> struct remove_pointer<T*const> { typedef T type; };
template <typename T> struct remove_pointer<T*volatile> { typedef T type; };
template <typename T> struct remove_pointer<T*const volatile> {
    typedef T type; };


template<typename T, typename Enable = void>
struct add_lvalue_reference_if_not_pointer { typedef T &type; };

template<typename T>
struct add_lvalue_reference_if_not_pointer<T,
                                     typename enable_if<is_pointer<T> >::type> {
  typedef T type;
};



template<typename T, typename Enable = void>
struct add_const_past_pointer { typedef const T type; };

template<typename T>
struct add_const_past_pointer<T, typename enable_if<is_pointer<T> >::type> {
  typedef const typename remove_pointer<T>::type *type;
};

template <bool, typename T, typename F>
struct conditional { typedef T type; };

template <typename T, typename F>
struct conditional<false, T, F> { typedef F type; };

}
# 19 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMapInfo.h" 2

namespace llvm {

template<typename T>
struct DenseMapInfo {




};


template<typename T>
struct DenseMapInfo<T*> {
  static inline T* getEmptyKey() {
    uintptr_t Val = static_cast<uintptr_t>(-1);
    Val <<= PointerLikeTypeTraits<T*>::NumLowBitsAvailable;
    return reinterpret_cast<T*>(Val);
  }
  static inline T* getTombstoneKey() {
    uintptr_t Val = static_cast<uintptr_t>(-2);
    Val <<= PointerLikeTypeTraits<T*>::NumLowBitsAvailable;
    return reinterpret_cast<T*>(Val);
  }
  static unsigned getHashValue(const T *PtrVal) {
    return (unsigned((uintptr_t)PtrVal) >> 4) ^
           (unsigned((uintptr_t)PtrVal) >> 9);
  }
  static bool isEqual(const T *LHS, const T *RHS) { return LHS == RHS; }
};


template<> struct DenseMapInfo<char> {
  static inline char getEmptyKey() { return ~0; }
  static inline char getTombstoneKey() { return ~0 - 1; }
  static unsigned getHashValue(const char& Val) { return Val * 37U; }
  static bool isEqual(const char &LHS, const char &RHS) {
    return LHS == RHS;
  }
};


template<> struct DenseMapInfo<unsigned> {
  static inline unsigned getEmptyKey() { return ~0U; }
  static inline unsigned getTombstoneKey() { return ~0U - 1; }
  static unsigned getHashValue(const unsigned& Val) { return Val * 37U; }
  static bool isEqual(const unsigned& LHS, const unsigned& RHS) {
    return LHS == RHS;
  }
};


template<> struct DenseMapInfo<unsigned long> {
  static inline unsigned long getEmptyKey() { return ~0UL; }
  static inline unsigned long getTombstoneKey() { return ~0UL - 1L; }
  static unsigned getHashValue(const unsigned long& Val) {
    return (unsigned)(Val * 37UL);
  }
  static bool isEqual(const unsigned long& LHS, const unsigned long& RHS) {
    return LHS == RHS;
  }
};


template<> struct DenseMapInfo<unsigned long long> {
  static inline unsigned long long getEmptyKey() { return ~0ULL; }
  static inline unsigned long long getTombstoneKey() { return ~0ULL - 1ULL; }
  static unsigned getHashValue(const unsigned long long& Val) {
    return (unsigned)(Val * 37ULL);
  }
  static bool isEqual(const unsigned long long& LHS,
                      const unsigned long long& RHS) {
    return LHS == RHS;
  }
};


template<> struct DenseMapInfo<int> {
  static inline int getEmptyKey() { return 0x7fffffff; }
  static inline int getTombstoneKey() { return -0x7fffffff - 1; }
  static unsigned getHashValue(const int& Val) { return (unsigned)(Val * 37U); }
  static bool isEqual(const int& LHS, const int& RHS) {
    return LHS == RHS;
  }
};


template<> struct DenseMapInfo<long> {
  static inline long getEmptyKey() {
    return (1UL << (sizeof(long) * 8 - 1)) - 1UL;
  }
  static inline long getTombstoneKey() { return getEmptyKey() - 1L; }
  static unsigned getHashValue(const long& Val) {
    return (unsigned)(Val * 37UL);
  }
  static bool isEqual(const long& LHS, const long& RHS) {
    return LHS == RHS;
  }
};


template<> struct DenseMapInfo<long long> {
  static inline long long getEmptyKey() { return 0x7fffffffffffffffLL; }
  static inline long long getTombstoneKey() { return -0x7fffffffffffffffLL-1; }
  static unsigned getHashValue(const long long& Val) {
    return (unsigned)(Val * 37ULL);
  }
  static bool isEqual(const long long& LHS,
                      const long long& RHS) {
    return LHS == RHS;
  }
};


template<typename T, typename U>
struct DenseMapInfo<std::pair<T, U> > {
  typedef std::pair<T, U> Pair;
  typedef DenseMapInfo<T> FirstInfo;
  typedef DenseMapInfo<U> SecondInfo;

  static inline Pair getEmptyKey() {
    return std::make_pair(FirstInfo::getEmptyKey(),
                          SecondInfo::getEmptyKey());
  }
  static inline Pair getTombstoneKey() {
    return std::make_pair(FirstInfo::getTombstoneKey(),
                          SecondInfo::getTombstoneKey());
  }
  static unsigned getHashValue(const Pair& PairVal) {
    uint64_t key = (uint64_t)FirstInfo::getHashValue(PairVal.first) << 32
          | (uint64_t)SecondInfo::getHashValue(PairVal.second);
    key += ~(key << 32);
    key ^= (key >> 22);
    key += ~(key << 13);
    key ^= (key >> 8);
    key += (key << 3);
    key ^= (key >> 15);
    key += ~(key << 27);
    key ^= (key >> 31);
    return (unsigned)key;
  }
  static bool isEqual(const Pair &LHS, const Pair &RHS) {
    return FirstInfo::isEqual(LHS.first, RHS.first) &&
           SecondInfo::isEqual(LHS.second, RHS.second);
  }
};

}
# 18 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMap.h" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/AlignOf.h" 1
# 18 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/AlignOf.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/Compiler.h" 1
# 18 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/Compiler.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/build/include/llvm/Config/llvm-config.h" 1
# 19 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/Compiler.h" 2
# 19 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/AlignOf.h" 2


namespace llvm {
template <typename T>
struct AlignmentCalcImpl {
  char x;
  T t;
private:
  AlignmentCalcImpl() {}
};
# 37 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/AlignOf.h"
template <typename T>
struct AlignOf {
  enum { Alignment =
         static_cast<unsigned int>(sizeof(AlignmentCalcImpl<T>) - sizeof(T)) };

  enum { Alignment_GreaterEqual_2Bytes = Alignment >= 2 ? 1 : 0 };
  enum { Alignment_GreaterEqual_4Bytes = Alignment >= 4 ? 1 : 0 };
  enum { Alignment_GreaterEqual_8Bytes = Alignment >= 8 ? 1 : 0 };
  enum { Alignment_GreaterEqual_16Bytes = Alignment >= 16 ? 1 : 0 };

  enum { Alignment_LessEqual_2Bytes = Alignment <= 2 ? 1 : 0 };
  enum { Alignment_LessEqual_4Bytes = Alignment <= 4 ? 1 : 0 };
  enum { Alignment_LessEqual_8Bytes = Alignment <= 8 ? 1 : 0 };
  enum { Alignment_LessEqual_16Bytes = Alignment <= 16 ? 1 : 0 };
};





template <typename T>
inline unsigned alignOf() { return AlignOf<T>::Alignment; }
# 81 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/AlignOf.h"
template<std::size_t Alignment, std::size_t Size>
struct AlignedCharArray;







template<std::size_t Size> struct AlignedCharArray<1, Size> { __attribute__((aligned(1))) char buffer[Size]; };
template<std::size_t Size> struct AlignedCharArray<2, Size> { __attribute__((aligned(2))) char buffer[Size]; };
template<std::size_t Size> struct AlignedCharArray<4, Size> { __attribute__((aligned(4))) char buffer[Size]; };
template<std::size_t Size> struct AlignedCharArray<8, Size> { __attribute__((aligned(8))) char buffer[Size]; };
template<std::size_t Size> struct AlignedCharArray<16, Size> { __attribute__((aligned(16))) char buffer[Size]; };
template<std::size_t Size> struct AlignedCharArray<32, Size> { __attribute__((aligned(32))) char buffer[Size]; };
template<std::size_t Size> struct AlignedCharArray<64, Size> { __attribute__((aligned(64))) char buffer[Size]; };
template<std::size_t Size> struct AlignedCharArray<128, Size> { __attribute__((aligned(128))) char buffer[Size]; };
# 170 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/AlignOf.h"
namespace detail {
template <typename T1,
          typename T2 = char, typename T3 = char, typename T4 = char,
          typename T5 = char, typename T6 = char, typename T7 = char>
class AlignerImpl {
  T1 t1; T2 t2; T3 t3; T4 t4; T5 t5; T6 t6; T7 t7;

  AlignerImpl();
};

template <typename T1,
          typename T2 = char, typename T3 = char, typename T4 = char,
          typename T5 = char, typename T6 = char, typename T7 = char>
union SizerImpl {
  char arr1[sizeof(T1)], arr2[sizeof(T2)], arr3[sizeof(T3)], arr4[sizeof(T4)],
       arr5[sizeof(T5)], arr6[sizeof(T6)], arr7[sizeof(T7)];
};
}
# 196 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/AlignOf.h"
template <typename T1,
          typename T2 = char, typename T3 = char, typename T4 = char,
          typename T5 = char, typename T6 = char, typename T7 = char>
struct AlignedCharArrayUnion : llvm::AlignedCharArray<
    AlignOf<detail::AlignerImpl<T1, T2, T3, T4, T5, T6, T7> >::Alignment,
    sizeof(detail::SizerImpl<T1, T2, T3, T4, T5, T6, T7>)> {
};
}
# 19 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMap.h" 2

# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/MathExtras.h" 1
# 18 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/MathExtras.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/SwapByteOrder.h" 1
# 20 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/SwapByteOrder.h"
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/limits" 1 3
# 107 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/limits" 3





# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__undef_min_max" 1 3
# 113 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/limits" 2 3
# 122 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/limits" 3
namespace std {inline namespace __1 {

enum float_round_style
{
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
};

enum float_denorm_style
{
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
class __libcpp_numeric_limits
{
protected:
    typedef _Tp type;

    static const bool is_specialized = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return type();}

    static const int digits = 0;
    static const int digits10 = 0;
    static const int max_digits10 = 0;
    static const bool is_signed = false;
    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 0;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return type();}

    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;

    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return type();}

    static const bool is_iec559 = false;
    static const bool is_bounded = false;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
};

template <class _Tp, int digits, bool is_signed>
struct __libcpp_compute_min
{
    static const _Tp value = _Tp(_Tp(1) << digits);
};

template <class _Tp, int digits>
struct __libcpp_compute_min<_Tp, digits, false>
{
    static const _Tp value = _Tp(0);
};

template <class _Tp>
class __libcpp_numeric_limits<_Tp, true>
{
protected:
    typedef _Tp type;

    static const bool is_specialized = true;

    static const bool is_signed = type(-1) < type(0);
    static const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
    static const int digits10 = digits * 3 / 10;
    static const int max_digits10 = 0;
    static const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
    static const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __min;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __max;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return min();}

    static const bool is_integer = true;
    static const bool is_exact = true;
    static const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return type(0);}

    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;

    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return type(0);}

    static const bool is_iec559 = false;
    static const bool is_bounded = true;
    static const bool is_modulo = !std::__1::is_signed<_Tp>::value;




    static const bool traps = false;

    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<bool, true>
{
protected:
    typedef bool type;

    static const bool is_specialized = true;

    static const bool is_signed = false;
    static const int digits = 1;
    static const int digits10 = 0;
    static const int max_digits10 = 0;
    static const type __min = false;
    static const type __max = true;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __min;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __max;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return min();}

    static const bool is_integer = true;
    static const bool is_exact = true;
    static const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return type(0);}

    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;

    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return type(0);}

    static const bool is_iec559 = false;
    static const bool is_bounded = true;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<float, true>
{
protected:
    typedef float type;

    static const bool is_specialized = true;

    static const bool is_signed = true;
    static const int digits = 24;
    static const int digits10 = 6;
    static const int max_digits10 = 2+(digits * 30103)/100000;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return 1.17549435e-38F;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return 3.40282347e+38F;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return -max();}

    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return 1.19209290e-7F;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return 0.5F;}

    static const int min_exponent = (-125);
    static const int min_exponent10 = (-37);
    static const int max_exponent = 128;
    static const int max_exponent10 = 38;

    static const bool has_infinity = true;
    static const bool has_quiet_NaN = true;
    static const bool has_signaling_NaN = true;
    static const float_denorm_style has_denorm = denorm_present;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __builtin_huge_valf();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __builtin_nanf("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __builtin_nansf("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return 1.40129846e-45F;}

    static const bool is_iec559 = true;
    static const bool is_bounded = true;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<double, true>
{
protected:
    typedef double type;

    static const bool is_specialized = true;

    static const bool is_signed = true;
    static const int digits = 53;
    static const int digits10 = 15;
    static const int max_digits10 = 2+(digits * 30103)/100000;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return 2.2250738585072014e-308;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return 1.7976931348623157e+308;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return -max();}

    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return 2.2204460492503131e-16;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return 0.5;}

    static const int min_exponent = (-1021);
    static const int min_exponent10 = (-307);
    static const int max_exponent = 1024;
    static const int max_exponent10 = 308;

    static const bool has_infinity = true;
    static const bool has_quiet_NaN = true;
    static const bool has_signaling_NaN = true;
    static const float_denorm_style has_denorm = denorm_present;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __builtin_huge_val();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __builtin_nan("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __builtin_nans("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return 4.9406564584124654e-324;}

    static const bool is_iec559 = true;
    static const bool is_bounded = true;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<long double, true>
{
protected:
    typedef long double type;

    static const bool is_specialized = true;

    static const bool is_signed = true;
    static const int digits = 53;
    static const int digits10 = 15;
    static const int max_digits10 = 2+(digits * 30103)/100000;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return 2.2250738585072014e-308L;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return 1.7976931348623157e+308L;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return -max();}

    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return 2.2204460492503131e-16L;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return 0.5;}

    static const int min_exponent = (-1021);
    static const int min_exponent10 = (-307);
    static const int max_exponent = 1024;
    static const int max_exponent10 = 308;

    static const bool has_infinity = true;
    static const bool has_quiet_NaN = true;
    static const bool has_signaling_NaN = true;
    static const float_denorm_style has_denorm = denorm_present;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __builtin_huge_vall();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __builtin_nanl("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __builtin_nansl("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return 4.9406564584124654e-324L;}




    static const bool is_iec559 = true;

    static const bool is_bounded = true;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_to_nearest;
};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits
    : private __libcpp_numeric_limits<typename remove_cv<_Tp>::type>
{
    typedef __libcpp_numeric_limits<typename remove_cv<_Tp>::type> __base;
    typedef typename __base::type type;
public:
    static const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return __base::lowest();}

    static const int digits = __base::digits;
    static const int digits10 = __base::digits10;
    static const int max_digits10 = __base::max_digits10;
    static const bool is_signed = __base::is_signed;
    static const bool is_integer = __base::is_integer;
    static const bool is_exact = __base::is_exact;
    static const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return __base::round_error();}

    static const int min_exponent = __base::min_exponent;
    static const int min_exponent10 = __base::min_exponent10;
    static const int max_exponent = __base::max_exponent;
    static const int max_exponent10 = __base::max_exponent10;

    static const bool has_infinity = __base::has_infinity;
    static const bool has_quiet_NaN = __base::has_quiet_NaN;
    static const bool has_signaling_NaN = __base::has_signaling_NaN;
    static const float_denorm_style has_denorm = __base::has_denorm;
    static const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return __base::denorm_min();}

    static const bool is_iec559 = __base::is_iec559;
    static const bool is_bounded = __base::is_bounded;
    static const bool is_modulo = __base::is_modulo;

    static const bool traps = __base::traps;
    static const bool tinyness_before = __base::tinyness_before;
    static const float_round_style round_style = __base::round_style;
};

template <class _Tp>
                      const bool numeric_limits<_Tp>::is_specialized;
template <class _Tp>
                      const int numeric_limits<_Tp>::digits;
template <class _Tp>
                      const int numeric_limits<_Tp>::digits10;
template <class _Tp>
                      const int numeric_limits<_Tp>::max_digits10;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_signed;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_integer;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_exact;
template <class _Tp>
                      const int numeric_limits<_Tp>::radix;
template <class _Tp>
                      const int numeric_limits<_Tp>::min_exponent;
template <class _Tp>
                      const int numeric_limits<_Tp>::min_exponent10;
template <class _Tp>
                      const int numeric_limits<_Tp>::max_exponent;
template <class _Tp>
                      const int numeric_limits<_Tp>::max_exponent10;
template <class _Tp>
                      const bool numeric_limits<_Tp>::has_infinity;
template <class _Tp>
                      const bool numeric_limits<_Tp>::has_quiet_NaN;
template <class _Tp>
                      const bool numeric_limits<_Tp>::has_signaling_NaN;
template <class _Tp>
                      const float_denorm_style numeric_limits<_Tp>::has_denorm;
template <class _Tp>
                      const bool numeric_limits<_Tp>::has_denorm_loss;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_iec559;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_bounded;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_modulo;
template <class _Tp>
                      const bool numeric_limits<_Tp>::traps;
template <class _Tp>
                      const bool numeric_limits<_Tp>::tinyness_before;
template <class _Tp>
                      const float_round_style numeric_limits<_Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<const _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return __base::lowest();}

    static const int digits = __base::digits;
    static const int digits10 = __base::digits10;
    static const int max_digits10 = __base::max_digits10;
    static const bool is_signed = __base::is_signed;
    static const bool is_integer = __base::is_integer;
    static const bool is_exact = __base::is_exact;
    static const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return __base::round_error();}

    static const int min_exponent = __base::min_exponent;
    static const int min_exponent10 = __base::min_exponent10;
    static const int max_exponent = __base::max_exponent;
    static const int max_exponent10 = __base::max_exponent10;

    static const bool has_infinity = __base::has_infinity;
    static const bool has_quiet_NaN = __base::has_quiet_NaN;
    static const bool has_signaling_NaN = __base::has_signaling_NaN;
    static const float_denorm_style has_denorm = __base::has_denorm;
    static const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return __base::denorm_min();}

    static const bool is_iec559 = __base::is_iec559;
    static const bool is_bounded = __base::is_bounded;
    static const bool is_modulo = __base::is_modulo;

    static const bool traps = __base::traps;
    static const bool tinyness_before = __base::tinyness_before;
    static const float_round_style round_style = __base::round_style;
};

template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_specialized;
template <class _Tp>
                      const int numeric_limits<const _Tp>::digits;
template <class _Tp>
                      const int numeric_limits<const _Tp>::digits10;
template <class _Tp>
                      const int numeric_limits<const _Tp>::max_digits10;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_signed;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_integer;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_exact;
template <class _Tp>
                      const int numeric_limits<const _Tp>::radix;
template <class _Tp>
                      const int numeric_limits<const _Tp>::min_exponent;
template <class _Tp>
                      const int numeric_limits<const _Tp>::min_exponent10;
template <class _Tp>
                      const int numeric_limits<const _Tp>::max_exponent;
template <class _Tp>
                      const int numeric_limits<const _Tp>::max_exponent10;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::has_infinity;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::has_quiet_NaN;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::has_signaling_NaN;
template <class _Tp>
                      const float_denorm_style numeric_limits<const _Tp>::has_denorm;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::has_denorm_loss;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_iec559;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_bounded;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_modulo;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::traps;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::tinyness_before;
template <class _Tp>
                      const float_round_style numeric_limits<const _Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return __base::lowest();}

    static const int digits = __base::digits;
    static const int digits10 = __base::digits10;
    static const int max_digits10 = __base::max_digits10;
    static const bool is_signed = __base::is_signed;
    static const bool is_integer = __base::is_integer;
    static const bool is_exact = __base::is_exact;
    static const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return __base::round_error();}

    static const int min_exponent = __base::min_exponent;
    static const int min_exponent10 = __base::min_exponent10;
    static const int max_exponent = __base::max_exponent;
    static const int max_exponent10 = __base::max_exponent10;

    static const bool has_infinity = __base::has_infinity;
    static const bool has_quiet_NaN = __base::has_quiet_NaN;
    static const bool has_signaling_NaN = __base::has_signaling_NaN;
    static const float_denorm_style has_denorm = __base::has_denorm;
    static const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return __base::denorm_min();}

    static const bool is_iec559 = __base::is_iec559;
    static const bool is_bounded = __base::is_bounded;
    static const bool is_modulo = __base::is_modulo;

    static const bool traps = __base::traps;
    static const bool tinyness_before = __base::tinyness_before;
    static const float_round_style round_style = __base::round_style;
};

template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_specialized;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::digits;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::digits10;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::max_digits10;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_signed;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_integer;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_exact;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::radix;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::min_exponent;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::min_exponent10;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::max_exponent;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::max_exponent10;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::has_infinity;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::has_quiet_NaN;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::has_signaling_NaN;
template <class _Tp>
                      const float_denorm_style numeric_limits<volatile _Tp>::has_denorm;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::has_denorm_loss;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_iec559;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_bounded;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_modulo;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::traps;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::tinyness_before;
template <class _Tp>
                      const float_round_style numeric_limits<volatile _Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<const volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return __base::lowest();}

    static const int digits = __base::digits;
    static const int digits10 = __base::digits10;
    static const int max_digits10 = __base::max_digits10;
    static const bool is_signed = __base::is_signed;
    static const bool is_integer = __base::is_integer;
    static const bool is_exact = __base::is_exact;
    static const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return __base::round_error();}

    static const int min_exponent = __base::min_exponent;
    static const int min_exponent10 = __base::min_exponent10;
    static const int max_exponent = __base::max_exponent;
    static const int max_exponent10 = __base::max_exponent10;

    static const bool has_infinity = __base::has_infinity;
    static const bool has_quiet_NaN = __base::has_quiet_NaN;
    static const bool has_signaling_NaN = __base::has_signaling_NaN;
    static const float_denorm_style has_denorm = __base::has_denorm;
    static const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return __base::denorm_min();}

    static const bool is_iec559 = __base::is_iec559;
    static const bool is_bounded = __base::is_bounded;
    static const bool is_modulo = __base::is_modulo;

    static const bool traps = __base::traps;
    static const bool tinyness_before = __base::tinyness_before;
    static const float_round_style round_style = __base::round_style;
};

template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_specialized;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::digits;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::digits10;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::max_digits10;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_signed;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_integer;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_exact;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::radix;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::min_exponent;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::min_exponent10;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::max_exponent;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::max_exponent10;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::has_infinity;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::has_quiet_NaN;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::has_signaling_NaN;
template <class _Tp>
                      const float_denorm_style numeric_limits<const volatile _Tp>::has_denorm;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::has_denorm_loss;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_iec559;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_bounded;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_modulo;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::traps;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::tinyness_before;
template <class _Tp>
                      const float_round_style numeric_limits<const volatile _Tp>::round_style;

} }
# 21 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/SwapByteOrder.h" 2

namespace llvm {
namespace sys {



inline uint16_t SwapByteOrder_16(uint16_t value) {





  uint16_t Hi = value << 8;
  uint16_t Lo = value >> 8;
  return Hi | Lo;

}



inline uint32_t SwapByteOrder_32(uint32_t value) {


  return __builtin_bswap32(value);
# 54 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/SwapByteOrder.h"
}



inline uint64_t SwapByteOrder_64(uint64_t value) {


  return __builtin_bswap64(value);







}

inline unsigned char SwapByteOrder(unsigned char C) { return C; }
inline signed char SwapByteOrder(signed char C) { return C; }
inline char SwapByteOrder(char C) { return C; }

inline unsigned short SwapByteOrder(unsigned short C) { return SwapByteOrder_16(C); }
inline signed short SwapByteOrder( signed short C) { return SwapByteOrder_16(C); }

inline unsigned int SwapByteOrder(unsigned int C) { return SwapByteOrder_32(C); }
inline signed int SwapByteOrder( signed int C) { return SwapByteOrder_32(C); }


inline unsigned long SwapByteOrder(unsigned long C) { return SwapByteOrder_32(C); }
inline signed long SwapByteOrder( signed long C) { return SwapByteOrder_32(C); }







inline unsigned long long SwapByteOrder(unsigned long long C) {
  return SwapByteOrder_64(C);
}
inline signed long long SwapByteOrder(signed long long C) {
  return SwapByteOrder_64(C);
}

}
}
# 19 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/MathExtras.h" 2


# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cstring" 1 3
# 61 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cstring" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/compat/string.h" 1 3




extern "C" {


extern char* strlwr(char *);
extern char* strupr(char *);


}



# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/string.h" 1 3




extern "C" {
# 23 "/mnt/home/ec2-user/build/emscripten/system/include/libc/string.h" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 1 3
# 367 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 3
typedef struct __locale_struct * locale_t;
# 24 "/mnt/home/ec2-user/build/emscripten/system/include/libc/string.h" 2 3

void *memcpy (void *__restrict, const void *__restrict, size_t);
void *memmove (void *, const void *, size_t);
void *memset (void *, int, size_t);
int memcmp (const void *, const void *, size_t);
void *memchr (const void *, int, size_t);

char *strcpy (char *__restrict, const char *__restrict);
char *strncpy (char *__restrict, const char *__restrict, size_t);

char *strcat (char *__restrict, const char *__restrict);
char *strncat (char *__restrict, const char *__restrict, size_t);

int strcmp (const char *, const char *);
int strncmp (const char *, const char *, size_t);

int strcoll (const char *, const char *);
size_t strxfrm (char *__restrict, const char *__restrict, size_t);

char *strchr (const char *, int);
char *strrchr (const char *, int);

size_t strcspn (const char *, const char *);
size_t strspn (const char *, const char *);
char *strpbrk (const char *, const char *);
char *strstr (const char *, const char *);
char *strtok (char *__restrict, const char *__restrict);

size_t strlen (const char *);

char *strerror (int);



# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/strings.h" 1 3




extern "C" {






# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 1 3
# 12 "/mnt/home/ec2-user/build/emscripten/system/include/libc/strings.h" 2 3




int bcmp (const void *, const void *, size_t);
void bcopy (const void *, void *, size_t);
void bzero (void *, size_t);
char *index (const char *, int);
char *rindex (const char *, int);


int ffs (int);

int strcasecmp (const char *, const char *);
int strncasecmp (const char *, const char *, size_t);

int strcasecmp_l (const char *, const char *, locale_t);
int strncasecmp_l (const char *, const char *, size_t, locale_t);


}
# 58 "/mnt/home/ec2-user/build/emscripten/system/include/libc/string.h" 2 3





char *strtok_r (char *__restrict, const char *__restrict, char **__restrict);
int strerror_r (int, char *, size_t);
char *stpcpy(char *__restrict, const char *__restrict);
char *stpncpy(char *__restrict, const char *__restrict, size_t);
size_t strnlen (const char *, size_t);
char *strdup (const char *);
char *strndup (const char *, size_t);
char *strsignal(int);
char *strerror_l (int, locale_t);
int strcoll_l (const char *, const char *, locale_t);
size_t strxfrm_l (char *__restrict, const char *__restrict, size_t, locale_t);




void *memccpy (void *__restrict, const void *__restrict, int, size_t);



char *strsep(char **, const char *);
size_t strlcat (char *, const char *, size_t);
size_t strlcpy (char *, const char *, size_t);




int strverscmp (const char *, const char *);
int strcasecmp_l (const char *, const char *, locale_t);
int strncasecmp_l (const char *, const char *, size_t, locale_t);
char *strchrnul(const char *, int);
char *strcasestr(const char *, const char *);
void *memmem(const void *, size_t, const void *, size_t);
void *memrchr(const void *, int, size_t);
void *mempcpy(void *, const void *, size_t);






}
# 16 "/mnt/home/ec2-user/build/emscripten/system/include/compat/string.h" 2 3
# 62 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cstring" 2 3
# 65 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cstring" 3


namespace std {inline namespace __1 {

using ::size_t;
using ::memcpy;
using ::memmove;
using ::strcpy;
using ::strncpy;
using ::strcat;
using ::strncat;
using ::memcmp;
using ::strcmp;
using ::strncmp;
using ::strcoll;
using ::strxfrm;

using ::memchr;

using ::strchr;

using ::strcspn;

using ::strpbrk;

using ::strrchr;

using ::strspn;

using ::strstr;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) char* strchr( char* __s, int __c) {return ::strchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) char* strpbrk( char* __s1, const char* __s2) {return ::strpbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) char* strrchr( char* __s, int __c) {return ::strrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void* memchr( void* __s, int __c, size_t __n) {return ::memchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) char* strstr( char* __s1, const char* __s2) {return ::strstr(__s1, __s2);}


using ::strtok;
using ::memset;
using ::strerror;
using ::strlen;

} }
# 22 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/MathExtras.h" 2






namespace llvm {

enum ZeroBehavior {

  ZB_Undefined,

  ZB_Max,

  ZB_Width
};
# 46 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/MathExtras.h"
template <typename T>
typename enable_if_c<std::numeric_limits<T>::is_integer &&
                     !std::numeric_limits<T>::is_signed, std::size_t>::type
countTrailingZeros(T Val, ZeroBehavior ZB = ZB_Width) {
  (void)ZB;

  if (!Val)
    return std::numeric_limits<T>::digits;
  if (Val & 0x1)
    return 0;


  std::size_t ZeroBits = 0;
  T Shift = std::numeric_limits<T>::digits >> 1;
  T Mask = std::numeric_limits<T>::max() >> Shift;
  while (Shift) {
    if ((Val & Mask) == 0) {
      Val >>= Shift;
      ZeroBits |= Shift;
    }
    Shift >>= 1;
    Mask >>= Shift;
  }
  return ZeroBits;
}


template <typename T>
typename enable_if_c<std::numeric_limits<T>::is_integer &&
                     std::numeric_limits<T>::is_signed, std::size_t>::type
countTrailingZeros(T Val, ZeroBehavior ZB = ZB_Width) ;


template <>
inline std::size_t countTrailingZeros<uint32_t>(uint32_t Val, ZeroBehavior ZB) {
  if (ZB != ZB_Undefined && Val == 0)
    return 32;


  return __builtin_ctz(Val);





}


template <>
inline std::size_t countTrailingZeros<uint64_t>(uint64_t Val, ZeroBehavior ZB) {
  if (ZB != ZB_Undefined && Val == 0)
    return 64;


  return __builtin_ctzll(Val);





}
# 117 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/MathExtras.h"
template <typename T>
typename enable_if_c<std::numeric_limits<T>::is_integer &&
                     !std::numeric_limits<T>::is_signed, std::size_t>::type
countLeadingZeros(T Val, ZeroBehavior ZB = ZB_Width) {
  (void)ZB;

  if (!Val)
    return std::numeric_limits<T>::digits;


  std::size_t ZeroBits = 0;
  for (T Shift = std::numeric_limits<T>::digits >> 1; Shift; Shift >>= 1) {
    T Tmp = Val >> Shift;
    if (Tmp)
      Val = Tmp;
    else
      ZeroBits |= Shift;
  }
  return ZeroBits;
}


template <typename T>
typename enable_if_c<std::numeric_limits<T>::is_integer &&
                     std::numeric_limits<T>::is_signed, std::size_t>::type
countLeadingZeros(T Val, ZeroBehavior ZB = ZB_Width) ;


template <>
inline std::size_t countLeadingZeros<uint32_t>(uint32_t Val, ZeroBehavior ZB) {
  if (ZB != ZB_Undefined && Val == 0)
    return 32;


  return __builtin_clz(Val);





}


template <>
inline std::size_t countLeadingZeros<uint64_t>(uint64_t Val, ZeroBehavior ZB) {
  if (ZB != ZB_Undefined && Val == 0)
    return 64;


  return __builtin_clzll(Val);





}
# 183 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/MathExtras.h"
template <typename T>
typename enable_if_c<std::numeric_limits<T>::is_integer &&
                     !std::numeric_limits<T>::is_signed, T>::type
findFirstSet(T Val, ZeroBehavior ZB = ZB_Max) {
  if (ZB == ZB_Max && Val == 0)
    return std::numeric_limits<T>::max();

  return countTrailingZeros(Val, ZB_Undefined);
}


template <typename T>
typename enable_if_c<std::numeric_limits<T>::is_integer &&
                     std::numeric_limits<T>::is_signed, T>::type
findFirstSet(T Val, ZeroBehavior ZB = ZB_Max) ;
# 206 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/MathExtras.h"
template <typename T>
typename enable_if_c<std::numeric_limits<T>::is_integer &&
                     !std::numeric_limits<T>::is_signed, T>::type
findLastSet(T Val, ZeroBehavior ZB = ZB_Max) {
  if (ZB == ZB_Max && Val == 0)
    return std::numeric_limits<T>::max();



  return countLeadingZeros(Val, ZB_Undefined) ^
         (std::numeric_limits<T>::digits - 1);
}


template <typename T>
typename enable_if_c<std::numeric_limits<T>::is_integer &&
                     std::numeric_limits<T>::is_signed, T>::type
findLastSet(T Val, ZeroBehavior ZB = ZB_Max) ;




static const unsigned char BitReverseTable256[256] = {



  0, 0 + 2 * 64, 0 + 1 * 64, 0 + 3 * 64, 0 + 2 * 16, 0 + 2 * 16 + 2 * 64, 0 + 2 * 16 + 1 * 64, 0 + 2 * 16 + 3 * 64, 0 + 1 * 16, 0 + 1 * 16 + 2 * 64, 0 + 1 * 16 + 1 * 64, 0 + 1 * 16 + 3 * 64, 0 + 3 * 16, 0 + 3 * 16 + 2 * 64, 0 + 3 * 16 + 1 * 64, 0 + 3 * 16 + 3 * 64, 0 + 2 * 4, 0 + 2 * 4 + 2 * 64, 0 + 2 * 4 + 1 * 64, 0 + 2 * 4 + 3 * 64, 0 + 2 * 4 + 2 * 16, 0 + 2 * 4 + 2 * 16 + 2 * 64, 0 + 2 * 4 + 2 * 16 + 1 * 64, 0 + 2 * 4 + 2 * 16 + 3 * 64, 0 + 2 * 4 + 1 * 16, 0 + 2 * 4 + 1 * 16 + 2 * 64, 0 + 2 * 4 + 1 * 16 + 1 * 64, 0 + 2 * 4 + 1 * 16 + 3 * 64, 0 + 2 * 4 + 3 * 16, 0 + 2 * 4 + 3 * 16 + 2 * 64, 0 + 2 * 4 + 3 * 16 + 1 * 64, 0 + 2 * 4 + 3 * 16 + 3 * 64, 0 + 1 * 4, 0 + 1 * 4 + 2 * 64, 0 + 1 * 4 + 1 * 64, 0 + 1 * 4 + 3 * 64, 0 + 1 * 4 + 2 * 16, 0 + 1 * 4 + 2 * 16 + 2 * 64, 0 + 1 * 4 + 2 * 16 + 1 * 64, 0 + 1 * 4 + 2 * 16 + 3 * 64, 0 + 1 * 4 + 1 * 16, 0 + 1 * 4 + 1 * 16 + 2 * 64, 0 + 1 * 4 + 1 * 16 + 1 * 64, 0 + 1 * 4 + 1 * 16 + 3 * 64, 0 + 1 * 4 + 3 * 16, 0 + 1 * 4 + 3 * 16 + 2 * 64, 0 + 1 * 4 + 3 * 16 + 1 * 64, 0 + 1 * 4 + 3 * 16 + 3 * 64, 0 + 3 * 4, 0 + 3 * 4 + 2 * 64, 0 + 3 * 4 + 1 * 64, 0 + 3 * 4 + 3 * 64, 0 + 3 * 4 + 2 * 16, 0 + 3 * 4 + 2 * 16 + 2 * 64, 0 + 3 * 4 + 2 * 16 + 1 * 64, 0 + 3 * 4 + 2 * 16 + 3 * 64, 0 + 3 * 4 + 1 * 16, 0 + 3 * 4 + 1 * 16 + 2 * 64, 0 + 3 * 4 + 1 * 16 + 1 * 64, 0 + 3 * 4 + 1 * 16 + 3 * 64, 0 + 3 * 4 + 3 * 16, 0 + 3 * 4 + 3 * 16 + 2 * 64, 0 + 3 * 4 + 3 * 16 + 1 * 64, 0 + 3 * 4 + 3 * 16 + 3 * 64, 2, 2 + 2 * 64, 2 + 1 * 64, 2 + 3 * 64, 2 + 2 * 16, 2 + 2 * 16 + 2 * 64, 2 + 2 * 16 + 1 * 64, 2 + 2 * 16 + 3 * 64, 2 + 1 * 16, 2 + 1 * 16 + 2 * 64, 2 + 1 * 16 + 1 * 64, 2 + 1 * 16 + 3 * 64, 2 + 3 * 16, 2 + 3 * 16 + 2 * 64, 2 + 3 * 16 + 1 * 64, 2 + 3 * 16 + 3 * 64, 2 + 2 * 4, 2 + 2 * 4 + 2 * 64, 2 + 2 * 4 + 1 * 64, 2 + 2 * 4 + 3 * 64, 2 + 2 * 4 + 2 * 16, 2 + 2 * 4 + 2 * 16 + 2 * 64, 2 + 2 * 4 + 2 * 16 + 1 * 64, 2 + 2 * 4 + 2 * 16 + 3 * 64, 2 + 2 * 4 + 1 * 16, 2 + 2 * 4 + 1 * 16 + 2 * 64, 2 + 2 * 4 + 1 * 16 + 1 * 64, 2 + 2 * 4 + 1 * 16 + 3 * 64, 2 + 2 * 4 + 3 * 16, 2 + 2 * 4 + 3 * 16 + 2 * 64, 2 + 2 * 4 + 3 * 16 + 1 * 64, 2 + 2 * 4 + 3 * 16 + 3 * 64, 2 + 1 * 4, 2 + 1 * 4 + 2 * 64, 2 + 1 * 4 + 1 * 64, 2 + 1 * 4 + 3 * 64, 2 + 1 * 4 + 2 * 16, 2 + 1 * 4 + 2 * 16 + 2 * 64, 2 + 1 * 4 + 2 * 16 + 1 * 64, 2 + 1 * 4 + 2 * 16 + 3 * 64, 2 + 1 * 4 + 1 * 16, 2 + 1 * 4 + 1 * 16 + 2 * 64, 2 + 1 * 4 + 1 * 16 + 1 * 64, 2 + 1 * 4 + 1 * 16 + 3 * 64, 2 + 1 * 4 + 3 * 16, 2 + 1 * 4 + 3 * 16 + 2 * 64, 2 + 1 * 4 + 3 * 16 + 1 * 64, 2 + 1 * 4 + 3 * 16 + 3 * 64, 2 + 3 * 4, 2 + 3 * 4 + 2 * 64, 2 + 3 * 4 + 1 * 64, 2 + 3 * 4 + 3 * 64, 2 + 3 * 4 + 2 * 16, 2 + 3 * 4 + 2 * 16 + 2 * 64, 2 + 3 * 4 + 2 * 16 + 1 * 64, 2 + 3 * 4 + 2 * 16 + 3 * 64, 2 + 3 * 4 + 1 * 16, 2 + 3 * 4 + 1 * 16 + 2 * 64, 2 + 3 * 4 + 1 * 16 + 1 * 64, 2 + 3 * 4 + 1 * 16 + 3 * 64, 2 + 3 * 4 + 3 * 16, 2 + 3 * 4 + 3 * 16 + 2 * 64, 2 + 3 * 4 + 3 * 16 + 1 * 64, 2 + 3 * 4 + 3 * 16 + 3 * 64, 1, 1 + 2 * 64, 1 + 1 * 64, 1 + 3 * 64, 1 + 2 * 16, 1 + 2 * 16 + 2 * 64, 1 + 2 * 16 + 1 * 64, 1 + 2 * 16 + 3 * 64, 1 + 1 * 16, 1 + 1 * 16 + 2 * 64, 1 + 1 * 16 + 1 * 64, 1 + 1 * 16 + 3 * 64, 1 + 3 * 16, 1 + 3 * 16 + 2 * 64, 1 + 3 * 16 + 1 * 64, 1 + 3 * 16 + 3 * 64, 1 + 2 * 4, 1 + 2 * 4 + 2 * 64, 1 + 2 * 4 + 1 * 64, 1 + 2 * 4 + 3 * 64, 1 + 2 * 4 + 2 * 16, 1 + 2 * 4 + 2 * 16 + 2 * 64, 1 + 2 * 4 + 2 * 16 + 1 * 64, 1 + 2 * 4 + 2 * 16 + 3 * 64, 1 + 2 * 4 + 1 * 16, 1 + 2 * 4 + 1 * 16 + 2 * 64, 1 + 2 * 4 + 1 * 16 + 1 * 64, 1 + 2 * 4 + 1 * 16 + 3 * 64, 1 + 2 * 4 + 3 * 16, 1 + 2 * 4 + 3 * 16 + 2 * 64, 1 + 2 * 4 + 3 * 16 + 1 * 64, 1 + 2 * 4 + 3 * 16 + 3 * 64, 1 + 1 * 4, 1 + 1 * 4 + 2 * 64, 1 + 1 * 4 + 1 * 64, 1 + 1 * 4 + 3 * 64, 1 + 1 * 4 + 2 * 16, 1 + 1 * 4 + 2 * 16 + 2 * 64, 1 + 1 * 4 + 2 * 16 + 1 * 64, 1 + 1 * 4 + 2 * 16 + 3 * 64, 1 + 1 * 4 + 1 * 16, 1 + 1 * 4 + 1 * 16 + 2 * 64, 1 + 1 * 4 + 1 * 16 + 1 * 64, 1 + 1 * 4 + 1 * 16 + 3 * 64, 1 + 1 * 4 + 3 * 16, 1 + 1 * 4 + 3 * 16 + 2 * 64, 1 + 1 * 4 + 3 * 16 + 1 * 64, 1 + 1 * 4 + 3 * 16 + 3 * 64, 1 + 3 * 4, 1 + 3 * 4 + 2 * 64, 1 + 3 * 4 + 1 * 64, 1 + 3 * 4 + 3 * 64, 1 + 3 * 4 + 2 * 16, 1 + 3 * 4 + 2 * 16 + 2 * 64, 1 + 3 * 4 + 2 * 16 + 1 * 64, 1 + 3 * 4 + 2 * 16 + 3 * 64, 1 + 3 * 4 + 1 * 16, 1 + 3 * 4 + 1 * 16 + 2 * 64, 1 + 3 * 4 + 1 * 16 + 1 * 64, 1 + 3 * 4 + 1 * 16 + 3 * 64, 1 + 3 * 4 + 3 * 16, 1 + 3 * 4 + 3 * 16 + 2 * 64, 1 + 3 * 4 + 3 * 16 + 1 * 64, 1 + 3 * 4 + 3 * 16 + 3 * 64, 3, 3 + 2 * 64, 3 + 1 * 64, 3 + 3 * 64, 3 + 2 * 16, 3 + 2 * 16 + 2 * 64, 3 + 2 * 16 + 1 * 64, 3 + 2 * 16 + 3 * 64, 3 + 1 * 16, 3 + 1 * 16 + 2 * 64, 3 + 1 * 16 + 1 * 64, 3 + 1 * 16 + 3 * 64, 3 + 3 * 16, 3 + 3 * 16 + 2 * 64, 3 + 3 * 16 + 1 * 64, 3 + 3 * 16 + 3 * 64, 3 + 2 * 4, 3 + 2 * 4 + 2 * 64, 3 + 2 * 4 + 1 * 64, 3 + 2 * 4 + 3 * 64, 3 + 2 * 4 + 2 * 16, 3 + 2 * 4 + 2 * 16 + 2 * 64, 3 + 2 * 4 + 2 * 16 + 1 * 64, 3 + 2 * 4 + 2 * 16 + 3 * 64, 3 + 2 * 4 + 1 * 16, 3 + 2 * 4 + 1 * 16 + 2 * 64, 3 + 2 * 4 + 1 * 16 + 1 * 64, 3 + 2 * 4 + 1 * 16 + 3 * 64, 3 + 2 * 4 + 3 * 16, 3 + 2 * 4 + 3 * 16 + 2 * 64, 3 + 2 * 4 + 3 * 16 + 1 * 64, 3 + 2 * 4 + 3 * 16 + 3 * 64, 3 + 1 * 4, 3 + 1 * 4 + 2 * 64, 3 + 1 * 4 + 1 * 64, 3 + 1 * 4 + 3 * 64, 3 + 1 * 4 + 2 * 16, 3 + 1 * 4 + 2 * 16 + 2 * 64, 3 + 1 * 4 + 2 * 16 + 1 * 64, 3 + 1 * 4 + 2 * 16 + 3 * 64, 3 + 1 * 4 + 1 * 16, 3 + 1 * 4 + 1 * 16 + 2 * 64, 3 + 1 * 4 + 1 * 16 + 1 * 64, 3 + 1 * 4 + 1 * 16 + 3 * 64, 3 + 1 * 4 + 3 * 16, 3 + 1 * 4 + 3 * 16 + 2 * 64, 3 + 1 * 4 + 3 * 16 + 1 * 64, 3 + 1 * 4 + 3 * 16 + 3 * 64, 3 + 3 * 4, 3 + 3 * 4 + 2 * 64, 3 + 3 * 4 + 1 * 64, 3 + 3 * 4 + 3 * 64, 3 + 3 * 4 + 2 * 16, 3 + 3 * 4 + 2 * 16 + 2 * 64, 3 + 3 * 4 + 2 * 16 + 1 * 64, 3 + 3 * 4 + 2 * 16 + 3 * 64, 3 + 3 * 4 + 1 * 16, 3 + 3 * 4 + 1 * 16 + 2 * 64, 3 + 3 * 4 + 1 * 16 + 1 * 64, 3 + 3 * 4 + 1 * 16 + 3 * 64, 3 + 3 * 4 + 3 * 16, 3 + 3 * 4 + 3 * 16 + 2 * 64, 3 + 3 * 4 + 3 * 16 + 1 * 64, 3 + 3 * 4 + 3 * 16 + 3 * 64
};


template <typename T>
T reverseBits(T Val) {
  unsigned char in[sizeof(Val)];
  unsigned char out[sizeof(Val)];
  std::memcpy(in, &Val, sizeof(Val));
  for (unsigned i = 0; i < sizeof(Val); ++i)
    out[(sizeof(Val) - i) - 1] = BitReverseTable256[in[i]];
  std::memcpy(&Val, out, sizeof(Val));
  return Val;
}






inline uint32_t Hi_32(uint64_t Value) {
  return static_cast<uint32_t>(Value >> 32);
}


inline uint32_t Lo_32(uint64_t Value) {
  return static_cast<uint32_t>(Value);
}


template<unsigned N>
inline bool isInt(int64_t x) {
  return N >= 64 || (-(1LL<<(N-1)) <= x && x < (1LL<<(N-1)));
}

template<>
inline bool isInt<8>(int64_t x) {
  return static_cast<int8_t>(x) == x;
}
template<>
inline bool isInt<16>(int64_t x) {
  return static_cast<int16_t>(x) == x;
}
template<>
inline bool isInt<32>(int64_t x) {
  return static_cast<int32_t>(x) == x;
}



template<unsigned N, unsigned S>
inline bool isShiftedInt(int64_t x) {
  return isInt<N+S>(x) && (x % (1<<S) == 0);
}


template<unsigned N>
inline bool isUInt(uint64_t x) {
  return N >= 64 || x < (1ULL<<(N));
}

template<>
inline bool isUInt<8>(uint64_t x) {
  return static_cast<uint8_t>(x) == x;
}
template<>
inline bool isUInt<16>(uint64_t x) {
  return static_cast<uint16_t>(x) == x;
}
template<>
inline bool isUInt<32>(uint64_t x) {
  return static_cast<uint32_t>(x) == x;
}



template<unsigned N, unsigned S>
inline bool isShiftedUInt(uint64_t x) {
  return isUInt<N+S>(x) && (x % (1<<S) == 0);
}



inline bool isUIntN(unsigned N, uint64_t x) {
  return x == (x & (~0ULL >> (64 - N)));
}



inline bool isIntN(unsigned N, int64_t x) {
  return N >= 64 || (-(1LL<<(N-1)) <= x && x < (1LL<<(N-1)));
}




inline bool isMask_32(uint32_t Value) {
  return Value && ((Value + 1) & Value) == 0;
}




inline bool isMask_64(uint64_t Value) {
  return Value && ((Value + 1) & Value) == 0;
}




inline bool isShiftedMask_32(uint32_t Value) {
  return isMask_32((Value - 1) | Value);
}



inline bool isShiftedMask_64(uint64_t Value) {
  return isMask_64((Value - 1) | Value);
}



inline bool isPowerOf2_32(uint32_t Value) {
  return Value && !(Value & (Value - 1));
}



inline bool isPowerOf2_64(uint64_t Value) {
  return Value && !(Value & (Value - int64_t(1L)));
}



inline uint16_t ByteSwap_16(uint16_t Value) {
  return sys::SwapByteOrder_16(Value);
}



inline uint32_t ByteSwap_32(uint32_t Value) {
  return sys::SwapByteOrder_32(Value);
}



inline uint64_t ByteSwap_64(uint64_t Value) {
  return sys::SwapByteOrder_64(Value);
}





inline unsigned CountLeadingOnes_32(uint32_t Value) {
  return countLeadingZeros(~Value);
}





inline unsigned CountLeadingOnes_64(uint64_t Value) {
  return countLeadingZeros(~Value);
}





inline unsigned CountTrailingOnes_32(uint32_t Value) {
  return countTrailingZeros(~Value);
}





inline unsigned CountTrailingOnes_64(uint64_t Value) {
  return countTrailingZeros(~Value);
}




inline unsigned CountPopulation_32(uint32_t Value) {

  return __builtin_popcount(Value);





}



inline unsigned CountPopulation_64(uint64_t Value) {

  return __builtin_popcountll(Value);






}




inline unsigned Log2_32(uint32_t Value) {
  return 31 - countLeadingZeros(Value);
}



inline unsigned Log2_64(uint64_t Value) {
  return 63 - countLeadingZeros(Value);
}




inline unsigned Log2_32_Ceil(uint32_t Value) {
  return 32 - countLeadingZeros(Value - 1);
}



inline unsigned Log2_64_Ceil(uint64_t Value) {
  return 64 - countLeadingZeros(Value - 1);
}



inline uint64_t GreatestCommonDivisor64(uint64_t A, uint64_t B) {
  while (B) {
    uint64_t T = B;
    B = A % B;
    A = T;
  }
  return A;
}



inline double BitsToDouble(uint64_t Bits) {
  union {
    uint64_t L;
    double D;
  } T;
  T.L = Bits;
  return T.D;
}



inline float BitsToFloat(uint32_t Bits) {
  union {
    uint32_t I;
    float F;
  } T;
  T.I = Bits;
  return T.F;
}





inline uint64_t DoubleToBits(double Double) {
  union {
    uint64_t L;
    double D;
  } T;
  T.D = Double;
  return T.L;
}





inline uint32_t FloatToBits(float Float) {
  union {
    uint32_t I;
    float F;
  } T;
  T.F = Float;
  return T.I;
}


int IsNAN(float f);
int IsNAN(double d);


int IsInf(float f);
int IsInf(double d);



inline uint64_t MinAlign(uint64_t A, uint64_t B) {





  return (A | B) & (1 + ~(A | B));
}



inline uint64_t NextPowerOf2(uint64_t A) {
  A |= (A >> 1);
  A |= (A >> 2);
  A |= (A >> 4);
  A |= (A >> 8);
  A |= (A >> 16);
  A |= (A >> 32);
  return A + 1;
}
# 565 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/MathExtras.h"
inline uint64_t RoundUpToAlignment(uint64_t Value, uint64_t Align) {
  return ((Value + Align - 1) / Align) * Align;
}




inline uint64_t OffsetToAlignment(uint64_t Value, uint64_t Align) {
  return RoundUpToAlignment(Value, Align) - Value;
}




inline int64_t abs64(int64_t x) {
  return (x < 0) ? -x : x;
}



template <unsigned B> inline int32_t SignExtend32(uint32_t x) {
  return int32_t(x << (32 - B)) >> (32 - B);
}



inline int32_t SignExtend32(uint32_t X, unsigned B) {
  return int32_t(X << (32 - B)) >> (32 - B);
}



template <unsigned B> inline int64_t SignExtend64(uint64_t x) {
  return int64_t(x << (64 - B)) >> (64 - B);
}



inline int64_t SignExtend64(uint64_t X, unsigned B) {
  return int64_t(X << (64 - B)) >> (64 - B);
}






  const float huge_valf = __builtin_inff();

}
# 21 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMap.h" 2


# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/algorithm" 1 3
# 624 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/algorithm" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/initializer_list" 1 3
# 51 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/initializer_list" 3


namespace std
{
# 116 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/initializer_list" 3
}
# 625 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/algorithm" 2 3



# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 1 3
# 598 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/typeinfo" 1 3
# 61 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/typeinfo" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/exception" 1 3
# 85 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/exception" 3


namespace std
{

class __attribute__ ((__visibility__("default"))) exception
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) exception() throw() {}
    virtual ~exception() throw();
    virtual const char* what() const throw();
};

class __attribute__ ((__visibility__("default"))) bad_exception
    : public exception
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bad_exception() throw() {}
    virtual ~bad_exception() throw();
    virtual const char* what() const throw();
};

typedef void (*unexpected_handler)();
__attribute__ ((__visibility__("default"))) unexpected_handler set_unexpected(unexpected_handler) throw();
__attribute__ ((__visibility__("default"))) unexpected_handler get_unexpected() throw();
__attribute__ ((noreturn)) __attribute__ ((__visibility__("default"))) void unexpected();

typedef void (*terminate_handler)();
__attribute__ ((__visibility__("default"))) terminate_handler set_terminate(terminate_handler) throw();
__attribute__ ((__visibility__("default"))) terminate_handler get_terminate() throw();
__attribute__ ((noreturn)) __attribute__ ((__visibility__("default"))) void terminate() throw();

__attribute__ ((__visibility__("default"))) bool uncaught_exception() throw();

class __attribute__ ((__type_visibility__("default"))) exception_ptr;

__attribute__ ((__visibility__("default"))) exception_ptr current_exception() throw();
__attribute__ ((noreturn)) __attribute__ ((__visibility__("default"))) void rethrow_exception(exception_ptr);

class __attribute__ ((__type_visibility__("default"))) exception_ptr
{
    void* __ptr_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) exception_ptr() throw() : __ptr_() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) exception_ptr(nullptr_t) throw() : __ptr_() {}
    exception_ptr(const exception_ptr&) throw();
    exception_ptr& operator=(const exception_ptr&) throw();
    ~exception_ptr() throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))

        operator bool() const throw() {return __ptr_ != std::__1::__get_nullptr_t();}

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const exception_ptr& __x, const exception_ptr& __y) throw()
        {return __x.__ptr_ == __y.__ptr_;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const exception_ptr& __x, const exception_ptr& __y) throw()
        {return !(__x == __y);}

    friend __attribute__ ((__visibility__("default"))) exception_ptr current_exception() throw();
    friend __attribute__ ((__visibility__("default"))) void rethrow_exception(exception_ptr);
};

template<class _Ep>
exception_ptr
make_exception_ptr(_Ep __e) throw()
{
# 163 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/exception" 3
}



class __attribute__ ((__visibility__("default"))) nested_exception
{
    exception_ptr __ptr_;
public:
    nested_exception() throw();


    virtual ~nested_exception() throw();


    __attribute__ ((noreturn)) void rethrow_nested() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) exception_ptr nested_ptr() const throw() {return __ptr_;}
};

template <class _Tp>
struct __nested
    : public _Tp,
      public nested_exception
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __nested(const _Tp& __t) : _Tp(__t) {}
};

template <class _Tp>
__attribute__ ((noreturn))
void






throw_with_nested (_Tp& __t, typename enable_if<
                  is_class<_Tp>::value && !is_base_of<nested_exception, _Tp>::value
                                    >::type* = 0)

{



}

template <class _Tp>
__attribute__ ((noreturn))
void






throw_with_nested (_Tp& __t, typename enable_if<
                  !is_class<_Tp>::value || is_base_of<nested_exception, _Tp>::value
                                    >::type* = 0)

{



}

template <class _Ep>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
rethrow_if_nested(const _Ep& __e, typename enable_if<
                                   is_polymorphic<_Ep>::value
                                                   >::type* = 0)
{
    const nested_exception* __nep = dynamic_cast<const nested_exception*>(&__e);
    if (__nep)
        __nep->rethrow_nested();
}

template <class _Ep>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
rethrow_if_nested(const _Ep&, typename enable_if<
                                   !is_polymorphic<_Ep>::value
                                                   >::type* = 0)
{
}

}
# 62 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/typeinfo" 2 3

# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cstdint" 1 3
# 149 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cstdint" 3


namespace std {inline namespace __1 {

using::int8_t;
using::int16_t;
using::int32_t;
using::int64_t;

using::uint8_t;
using::uint16_t;
using::uint32_t;
using::uint64_t;

using::int_least8_t;
using::int_least16_t;
using::int_least32_t;
using::int_least64_t;

using::uint_least8_t;
using::uint_least16_t;
using::uint_least32_t;
using::uint_least64_t;

using::int_fast8_t;
using::int_fast16_t;
using::int_fast32_t;
using::int_fast64_t;

using::uint_fast8_t;
using::uint_fast16_t;
using::uint_fast32_t;
using::uint_fast64_t;

using::intptr_t;
using::uintptr_t;

using::intmax_t;
using::uintmax_t;

} }
# 64 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/typeinfo" 2 3
# 67 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/typeinfo" 3


namespace std
{

class __attribute__ ((__visibility__("default"))) type_info
{
    type_info& operator=(const type_info&);
    type_info(const type_info&);
protected:

    const char* __type_name;





    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit type_info(const char* __n)

        : __type_name(__n) {}




public:
    virtual ~type_info();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char* name() const throw()

        {return __type_name;}




    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool before(const type_info& __arg) const throw()

        {return __type_name < __arg.__type_name;}






    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t hash_code() const throw()

        {return *reinterpret_cast<const size_t*>(&__type_name);}
# 126 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/typeinfo" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const type_info& __arg) const throw()

        {return __type_name == __arg.__type_name;}






    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const type_info& __arg) const throw()
        {return !operator==(__arg);}







};

class __attribute__ ((__visibility__("default"))) bad_cast
    : public exception
{
public:
    bad_cast() throw();
    virtual ~bad_cast() throw();
    virtual const char* what() const throw();
};

class __attribute__ ((__visibility__("default"))) bad_typeid
    : public exception
{
public:
    bad_typeid() throw();
    virtual ~bad_typeid() throw();
    virtual const char* what() const throw();
};

}
# 599 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 2 3


# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/new" 1 3
# 73 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/new" 3


namespace std
{

class __attribute__ ((__visibility__("default"))) bad_alloc
    : public exception
{
public:
    bad_alloc() throw();
    virtual ~bad_alloc() throw();
    virtual const char* what() const throw();
};

class __attribute__ ((__visibility__("default"))) bad_array_new_length
    : public bad_alloc
{
public:
    bad_array_new_length() throw();
    virtual ~bad_array_new_length() throw();
    virtual const char* what() const throw();
};
# 111 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/new" 3
__attribute__ ((__visibility__("default"))) void __throw_bad_alloc();

struct __attribute__ ((__type_visibility__("default"))) nothrow_t {};
extern __attribute__ ((__visibility__("default"))) const nothrow_t nothrow;
typedef void (*new_handler)();
__attribute__ ((__visibility__("default"))) new_handler set_new_handler(new_handler) throw();
__attribute__ ((__visibility__("default"))) new_handler get_new_handler() throw();

}







__attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz)

    throw(std::bad_alloc)

;
__attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz, const std::nothrow_t&) throw() __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete(void* __p) throw();
__attribute__ ((__visibility__("default"))) void operator delete(void* __p, const std::nothrow_t&) throw();

__attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz)

    throw(std::bad_alloc)

;
__attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz, const std::nothrow_t&) throw() __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p) throw();
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p, const std::nothrow_t&) throw();

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void* operator new (std::size_t, void* __p) throw() {return __p;}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void* operator new[](std::size_t, void* __p) throw() {return __p;}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator delete (void*, void*) throw() {}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator delete[](void*, void*) throw() {}

namespace std {inline namespace __1 {

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void *__allocate(size_t __size) {

  return ::operator new(__size);



}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void __deallocate(void *__ptr) {

  ::operator delete(__ptr);



}

} }
# 602 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 2 3


# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/iterator" 1 3
# 332 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/iterator" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__functional_base" 1 3
# 22 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__functional_base" 3


namespace std {inline namespace __1 {

template <class _Arg, class _Result>
struct __attribute__ ((__type_visibility__("default"))) unary_function
{
    typedef _Arg argument_type;
    typedef _Result result_type;
};

template <class _Arg1, class _Arg2, class _Result>
struct __attribute__ ((__type_visibility__("default"))) binary_function
{
    typedef _Arg1 first_argument_type;
    typedef _Arg2 second_argument_type;
    typedef _Result result_type;
};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) hash;

template <class _Tp>
struct __has_result_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::result_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};




template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) less : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x < __y;}
};
# 80 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__functional_base" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
addressof(_Tp& __x) throw()
{
    return (_Tp*)&reinterpret_cast<const volatile char&>(__x);
}
# 130 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__functional_base" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__functional_base_03" 1 3
# 18 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__functional_base_03" 3
template <class _Tp>
struct __derives_from_unary_function
{
private:
    struct __two {char __lx; char __lxx;};
    static __two __test(...);
    template <class _Ap, class _Rp>
        static unary_function<_Ap, _Rp>
        __test(const volatile unary_function<_Ap, _Rp>*);
public:
    static const bool value = !is_same<__typeof__(__test((_Tp*)0)), __two>::value;
    typedef __typeof__(__test((_Tp*)0)) type;
};

template <class _Tp>
struct __derives_from_binary_function
{
private:
    struct __two {char __lx; char __lxx;};
    static __two __test(...);
    template <class _A1, class _A2, class _Rp>
        static binary_function<_A1, _A2, _Rp>
        __test(const volatile binary_function<_A1, _A2, _Rp>*);
public:
    static const bool value = !is_same<__typeof__(__test((_Tp*)0)), __two>::value;
    typedef __typeof__(__test((_Tp*)0)) type;
};

template <class _Tp, bool = __derives_from_unary_function<_Tp>::value>
struct __maybe_derive_from_unary_function
    : public __derives_from_unary_function<_Tp>::type
{
};

template <class _Tp>
struct __maybe_derive_from_unary_function<_Tp, false>
{
};

template <class _Tp, bool = __derives_from_binary_function<_Tp>::value>
struct __maybe_derive_from_binary_function
    : public __derives_from_binary_function<_Tp>::type
{
};

template <class _Tp>
struct __maybe_derive_from_binary_function<_Tp, false>
{
};

template <class _Tp, bool = __has_result_type<_Tp>::value>
struct __weak_result_type_imp
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
    typedef typename _Tp::result_type result_type;
};

template <class _Tp>
struct __weak_result_type_imp<_Tp, false>
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
};

template <class _Tp>
struct __weak_result_type
    : public __weak_result_type_imp<typename remove_reference<_Tp>::type>
{
};



template <class _Rp>
struct __weak_result_type<_Rp ()>
{
    typedef _Rp result_type;
};

template <class _Rp>
struct __weak_result_type<_Rp (&)()>
{
    typedef _Rp result_type;
};

template <class _Rp>
struct __weak_result_type<_Rp (*)()>
{
    typedef _Rp result_type;
};



template <class _Rp, class _A1>
struct __weak_result_type<_Rp (_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (&)(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (*)(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)()>
    : public unary_function<_Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const>
    : public unary_function<const _Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() volatile>
    : public unary_function<volatile _Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const volatile>
    : public unary_function<const volatile _Cp*, _Rp>
{
};



template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (*)(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (&)(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1)>
    : public binary_function<_Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const>
    : public binary_function<const _Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>
    : public binary_function<volatile _Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>
    : public binary_function<const volatile _Cp*, _A1, _Rp>
{
};



template <class _Rp, class _A1, class _A2, class _A3>
struct __weak_result_type<_Rp (_A1, _A2, _A3)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _A1, class _A2, class _A3>
struct __weak_result_type<_Rp (&)(_A1, _A2, _A3)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _A1, class _A2, class _A3>
struct __weak_result_type<_Rp (*)(_A1, _A2, _A3)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2) const>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2) volatile>
{
    typedef _Rp result_type;
};
# 416 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__functional_base_03" 3
template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(), _T1& __t1)
{
    return (__t1.*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0), _T1& __t1, _A0& __a0)
{
    return (__t1.*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
{
    return (__t1.*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return (__t1.*__f)(__a0, __a1, __a2);
}

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)() const, _T1& __t1)
{
    return (__t1.*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0) const, _T1& __t1, _A0& __a0)
{
    return (__t1.*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
{
    return (__t1.*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return (__t1.*__f)(__a0, __a1, __a2);
}

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)() volatile, _T1& __t1)
{
    return (__t1.*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
{
    return (__t1.*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
{
    return (__t1.*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return (__t1.*__f)(__a0, __a1, __a2);
}

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)() const volatile, _T1& __t1)
{
    return (__t1.*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
{
    return (__t1.*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
{
    return (__t1.*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return (__t1.*__f)(__a0, __a1, __a2);
}



template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(), _T1 __t1)
{
    return ((*__t1).*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0), _T1 __t1, _A0& __a0)
{
    return ((*__t1).*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
{
    return ((*__t1).*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return ((*__t1).*__f)(__a0, __a1, __a2);
}

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)() const, _T1 __t1)
{
    return ((*__t1).*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0) const, _T1 __t1, _A0& __a0)
{
    return ((*__t1).*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
{
    return ((*__t1).*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return ((*__t1).*__f)(__a0, __a1, __a2);
}

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)() volatile, _T1 __t1)
{
    return ((*__t1).*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
{
    return ((*__t1).*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
{
    return ((*__t1).*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return ((*__t1).*__f)(__a0, __a1, __a2);
}

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)() const volatile, _T1 __t1)
{
    return ((*__t1).*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
{
    return ((*__t1).*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
{
    return ((*__t1).*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return ((*__t1).*__f)(__a0, __a1, __a2);
}



template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    typename __apply_cv<_T1, _Rp>::type&
>::type
__invoke(_Rp _Tp::* __f, _T1& __t1)
{
    return __t1.*__f;
}

template <class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__invoke(_Rp _Tp::*)
{
}
# 837 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__functional_base_03" 3
template <class _T1, class _Rp, bool>
struct __4th_helper
{
};

template <class _T1, class _Rp>
struct __4th_helper<_T1, _Rp, true>
{
    typedef typename __apply_cv<__typeof__(*std::__1::declval<_T1>()), _Rp>::type type;
};

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __4th_helper<_T1, _Rp,
                      !is_base_of<_Tp,
                                  typename remove_reference<_T1>::type
                                 >::value
                     >::type&
__invoke(_Rp _Tp::* __f, _T1& __t1)
{
    return (*__t1).*__f;
}
# 874 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__functional_base_03" 3
template <class _Fp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__typeof__(declval<_Fp>()())
__invoke(_Fp __f)
{
    return __f();
}

template <class _Fp, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__typeof__(declval<_Fp>()(declval<_A0&>()))
__invoke(_Fp __f, _A0& __a0)
{
    return __f(__a0);
}

template <class _Fp, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__typeof__(declval<_Fp>()(declval<_A0&>(), declval<_A1&>()))
__invoke(_Fp __f, _A0& __a0, _A1& __a1)
{
    return __f(__a0, __a1);
}

template <class _Fp, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__typeof__(declval<_Fp>()(declval<_A0&>(), declval<_A1&>(), declval<_A2&>()))
__invoke(_Fp __f, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return __f(__a0, __a1, __a2);
}
# 942 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__functional_base_03" 3
template <class _Tp>
struct __has_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Fp, bool = __has_result_type<__weak_result_type<_Fp> >::value>
struct __invoke_return
{
    typedef typename __weak_result_type<_Fp>::result_type type;
};

template <class _Fp>
struct __invoke_return<_Fp, false>
{
    typedef __typeof__(__invoke(std::__1::declval<_Fp>())) type;
};

template <class _Tp, class _A0>
struct __invoke_return0
{
    typedef __typeof__(__invoke(std::__1::declval<_Tp>(), std::__1::declval<_A0>())) type;
};

template <class _Rp, class _Tp, class _A0>
struct __invoke_return0<_Rp _Tp::*, _A0>
{
    typedef typename __apply_cv<_A0, _Rp>::type& type;
};

template <class _Rp, class _Tp, class _A0>
struct __invoke_return0<_Rp _Tp::*, _A0*>
{
    typedef typename __apply_cv<_A0, _Rp>::type& type;
};

template <class _Tp, class _A0, class _A1>
struct __invoke_return1
{
    typedef __typeof__(__invoke(std::__1::declval<_Tp>(), std::__1::declval<_A0>(), std::__1::declval<_A1>())) type;

};

template <class _Tp, class _A0, class _A1, class _A2>
struct __invoke_return2
{
    typedef __typeof__(__invoke(std::__1::declval<_Tp>(), std::__1::declval<_A0>(), std::__1::declval<_A1>(), std::__1::declval<_A2>())) type;


};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) reference_wrapper
    : public __weak_result_type<_Tp>
{
public:

    typedef _Tp type;
private:
    type* __f_;

public:

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference_wrapper(type& __f) : __f_(&__f) {}


    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator type& () const {return *__f_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) type& get() const {return *__f_;}



    __attribute__ ((__visibility__("hidden"), __always_inline__))
    typename __invoke_return<type&>::type
       operator() () const
       {
           return __invoke(get());
       }

    template <class _A0>
       __attribute__ ((__visibility__("hidden"), __always_inline__))
       typename __invoke_return0<type&, _A0>::type
          operator() (_A0& __a0) const
          {
              return __invoke<type&, _A0>(get(), __a0);
          }

    template <class _A0, class _A1>
       __attribute__ ((__visibility__("hidden"), __always_inline__))
       typename __invoke_return1<type&, _A0, _A1>::type
          operator() (_A0& __a0, _A1& __a1) const
          {
              return __invoke<type&, _A0, _A1>(get(), __a0, __a1);
          }

    template <class _A0, class _A1, class _A2>
       __attribute__ ((__visibility__("hidden"), __always_inline__))
       typename __invoke_return2<type&, _A0, _A1, _A2>::type
          operator() (_A0& __a0, _A1& __a1, _A2& __a2) const
          {
              return __invoke<type&, _A0, _A1, _A2>(get(), __a0, __a1, __a2);
          }
};

template <class _Tp> struct __is_reference_wrapper_impl : public false_type {};
template <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};
template <class _Tp> struct __is_reference_wrapper
    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reference_wrapper<_Tp>
ref(_Tp& __t)
{
    return reference_wrapper<_Tp>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reference_wrapper<_Tp>
ref(reference_wrapper<_Tp> __t)
{
    return ref(__t.get());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reference_wrapper<const _Tp>
cref(const _Tp& __t)
{
    return reference_wrapper<const _Tp>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reference_wrapper<const _Tp>
cref(reference_wrapper<_Tp> __t)
{
    return cref(__t.get());
}
# 131 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__functional_base" 2 3
# 523 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__functional_base" 3
struct __attribute__ ((__type_visibility__("default"))) allocator_arg_t { };


extern const allocator_arg_t allocator_arg;






template <class _Tp>
struct __has_allocator_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::allocator_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>
struct __uses_allocator
    : public integral_constant<bool,
        is_convertible<_Alloc, typename _Tp::allocator_type>::value>
{
};

template <class _Tp, class _Alloc>
struct __uses_allocator<_Tp, _Alloc, false>
    : public false_type
{
};

template <class _Tp, class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) uses_allocator
    : public __uses_allocator<_Tp, _Alloc>
{
};
# 613 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__functional_base" 3
} }
# 333 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/iterator" 2 3


# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/iosfwd" 1 3
# 90 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/iosfwd" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/compat/wchar.h" 1 3



# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/wchar.h" 1 3




extern "C" {
# 26 "/mnt/home/ec2-user/build/emscripten/system/include/libc/wchar.h" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 1 3






typedef __builtin_va_list va_list;




typedef __builtin_va_list __isoc_va_list;
# 45 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 3
typedef unsigned wint_t;
# 249 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 3
typedef unsigned long wctype_t;
# 361 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 3
typedef struct _IO_FILE FILE;
# 27 "/mnt/home/ec2-user/build/emscripten/system/include/libc/wchar.h" 2 3
# 45 "/mnt/home/ec2-user/build/emscripten/system/include/libc/wchar.h" 3
typedef struct __mbstate_t
{
 unsigned __opaque1, __opaque2;
} mbstate_t;

wchar_t *wcscpy (wchar_t *__restrict, const wchar_t *__restrict);
wchar_t *wcsncpy (wchar_t *__restrict, const wchar_t *__restrict, size_t);

wchar_t *wcscat (wchar_t *__restrict, const wchar_t *__restrict);
wchar_t *wcsncat (wchar_t *__restrict, const wchar_t *__restrict, size_t);

int wcscmp (const wchar_t *, const wchar_t *);
int wcsncmp (const wchar_t *, const wchar_t *, size_t);

int wcscoll(const wchar_t *, const wchar_t *);
size_t wcsxfrm (wchar_t *__restrict, const wchar_t *__restrict, size_t n);

wchar_t *wcschr (const wchar_t *, wchar_t);
wchar_t *wcsrchr (const wchar_t *, wchar_t);

size_t wcscspn (const wchar_t *, const wchar_t *);
size_t wcsspn (const wchar_t *, const wchar_t *);
wchar_t *wcspbrk (const wchar_t *, const wchar_t *);

wchar_t *wcstok (wchar_t *__restrict, const wchar_t *__restrict, wchar_t **__restrict);

size_t wcslen (const wchar_t *);

wchar_t *wcsstr (const wchar_t *__restrict, const wchar_t *__restrict);
wchar_t *wcswcs (const wchar_t *, const wchar_t *);

wchar_t *wmemchr (const wchar_t *, wchar_t, size_t);
int wmemcmp (const wchar_t *, const wchar_t *, size_t);
wchar_t *wmemcpy (wchar_t *__restrict, const wchar_t *__restrict, size_t);
wchar_t *wmemmove (wchar_t *, const wchar_t *, size_t);
wchar_t *wmemset (wchar_t *, wchar_t, size_t);

wint_t btowc (int);
int wctob (wint_t);

int mbsinit (const mbstate_t *);
size_t mbrtowc (wchar_t *__restrict, const char *__restrict, size_t, mbstate_t *__restrict);
size_t wcrtomb (char *__restrict, wchar_t, mbstate_t *__restrict);

size_t mbrlen (const char *__restrict, size_t, mbstate_t *__restrict);

size_t mbsrtowcs (wchar_t *__restrict, const char **__restrict, size_t, mbstate_t *__restrict);
size_t wcsrtombs (char *__restrict, const wchar_t **__restrict, size_t, mbstate_t *__restrict);

float wcstof (const wchar_t *__restrict, wchar_t **__restrict);
double wcstod (const wchar_t *__restrict, wchar_t **__restrict);
long double wcstold (const wchar_t *__restrict, wchar_t **__restrict);

long wcstol (const wchar_t *__restrict, wchar_t **__restrict, int);
unsigned long wcstoul (const wchar_t *__restrict, wchar_t **__restrict, int);

long long wcstoll (const wchar_t *__restrict, wchar_t **__restrict, int);
unsigned long long wcstoull (const wchar_t *__restrict, wchar_t **__restrict, int);



int fwide (FILE *, int);


int wprintf (const wchar_t *__restrict, ...);
int fwprintf (FILE *__restrict, const wchar_t *__restrict, ...);
int swprintf (wchar_t *__restrict, size_t, const wchar_t *__restrict, ...);

int vwprintf (const wchar_t *__restrict, __isoc_va_list);
int vfwprintf (FILE *__restrict, const wchar_t *__restrict, __isoc_va_list);
int vswprintf (wchar_t *__restrict, size_t, const wchar_t *__restrict, __isoc_va_list);

int wscanf (const wchar_t *__restrict, ...);
int fwscanf (FILE *__restrict, const wchar_t *__restrict, ...);
int swscanf (const wchar_t *__restrict, const wchar_t *__restrict, ...);

int vwscanf (const wchar_t *__restrict, __isoc_va_list);
int vfwscanf (FILE *__restrict, const wchar_t *__restrict, __isoc_va_list);
int vswscanf (const wchar_t *__restrict, const wchar_t *__restrict, __isoc_va_list);

wint_t fgetwc (FILE *);
wint_t getwc (FILE *);
wint_t getwchar (void);

wint_t fputwc (wchar_t, FILE *);
wint_t putwc (wchar_t, FILE *);
wint_t putwchar (wchar_t);

wchar_t *fgetws (wchar_t *__restrict, int, FILE *__restrict);
int fputws (const wchar_t *__restrict, FILE *__restrict);

wint_t ungetwc (wint_t, FILE *);

struct tm;
size_t wcsftime (wchar_t *__restrict, size_t, const wchar_t *__restrict, const struct tm *__restrict);





FILE *open_wmemstream(wchar_t **, size_t *);
size_t mbsnrtowcs(wchar_t *__restrict, const char **__restrict, size_t, size_t, mbstate_t *__restrict);
size_t wcsnrtombs(char *__restrict, const wchar_t **__restrict, size_t, size_t, mbstate_t *__restrict);
wchar_t *wcsdup(const wchar_t *);
size_t wcsnlen (const wchar_t *, size_t);
wchar_t *wcpcpy (wchar_t *__restrict, const wchar_t *__restrict);
wchar_t *wcpncpy (wchar_t *__restrict, const wchar_t *__restrict, size_t);
int wcscasecmp(const wchar_t *, const wchar_t *);
int wcscasecmp_l(const wchar_t *, const wchar_t *, locale_t);
int wcsncasecmp(const wchar_t *, const wchar_t *, size_t);
int wcsncasecmp_l(const wchar_t *, const wchar_t *, size_t, locale_t);
int wcscoll_l(const wchar_t *, const wchar_t *, locale_t);
size_t wcsxfrm_l(wchar_t *__restrict, const wchar_t *__restrict, size_t n, locale_t);



int wcwidth (wchar_t);
int wcswidth (const wchar_t *, size_t);
int iswalnum(wint_t);
int iswalpha(wint_t);
int iswblank(wint_t);
int iswcntrl(wint_t);
int iswdigit(wint_t);
int iswgraph(wint_t);
int iswlower(wint_t);
int iswprint(wint_t);
int iswpunct(wint_t);
int iswspace(wint_t);
int iswupper(wint_t);
int iswxdigit(wint_t);
int iswctype(wint_t, wctype_t);
wint_t towlower(wint_t);
wint_t towupper(wint_t);
wctype_t wctype(const char *);





}
# 5 "/mnt/home/ec2-user/build/emscripten/system/include/compat/wchar.h" 2 3
# 91 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/iosfwd" 2 3
# 94 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/iosfwd" 3


namespace std {inline namespace __1 {

class __attribute__ ((__type_visibility__("default"))) ios_base;

template<class _CharT> struct __attribute__ ((__type_visibility__("default"))) char_traits;
template<class _Tp> class __attribute__ ((__type_visibility__("default"))) allocator;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ios;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_streambuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_istream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ostream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_iostream;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_stringbuf;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_istringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ostringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_stringstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_filebuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ifstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ofstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_fstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) istreambuf_iterator;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) ostreambuf_iterator;

typedef basic_ios<char> ios;
typedef basic_ios<wchar_t> wios;

typedef basic_streambuf<char> streambuf;
typedef basic_istream<char> istream;
typedef basic_ostream<char> ostream;
typedef basic_iostream<char> iostream;

typedef basic_stringbuf<char> stringbuf;
typedef basic_istringstream<char> istringstream;
typedef basic_ostringstream<char> ostringstream;
typedef basic_stringstream<char> stringstream;

typedef basic_filebuf<char> filebuf;
typedef basic_ifstream<char> ifstream;
typedef basic_ofstream<char> ofstream;
typedef basic_fstream<char> fstream;

typedef basic_streambuf<wchar_t> wstreambuf;
typedef basic_istream<wchar_t> wistream;
typedef basic_ostream<wchar_t> wostream;
typedef basic_iostream<wchar_t> wiostream;

typedef basic_stringbuf<wchar_t> wstringbuf;
typedef basic_istringstream<wchar_t> wistringstream;
typedef basic_ostringstream<wchar_t> wostringstream;
typedef basic_stringstream<wchar_t> wstringstream;

typedef basic_filebuf<wchar_t> wfilebuf;
typedef basic_ifstream<wchar_t> wifstream;
typedef basic_ofstream<wchar_t> wofstream;
typedef basic_fstream<wchar_t> wfstream;

template <class _State> class __attribute__ ((__type_visibility__("default"))) fpos;
typedef fpos<mbstate_t> streampos;
typedef fpos<mbstate_t> wstreampos;

typedef fpos<mbstate_t> u16streampos;
typedef fpos<mbstate_t> u32streampos;


typedef long long streamoff;

template <class _CharT,
          class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_string;
typedef basic_string<char, char_traits<char>, allocator<char> > string;
typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;

} }
# 336 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/iterator" 2 3





# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__debug" 1 3
# 18 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__debug" 3
# 342 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/iterator" 2 3
# 345 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/iterator" 3


namespace std {inline namespace __1 {

struct __attribute__ ((__type_visibility__("default"))) input_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) output_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) forward_iterator_tag : public input_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) bidirectional_iterator_tag : public forward_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) random_access_iterator_tag : public bidirectional_iterator_tag {};

template <class _Tp>
struct __has_iterator_category
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::iterator_category* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Iter, bool> struct __iterator_traits_impl {};

template <class _Iter>
struct __iterator_traits_impl<_Iter, true>
{
    typedef typename _Iter::difference_type difference_type;
    typedef typename _Iter::value_type value_type;
    typedef typename _Iter::pointer pointer;
    typedef typename _Iter::reference reference;
    typedef typename _Iter::iterator_category iterator_category;
};

template <class _Iter, bool> struct __iterator_traits {};

template <class _Iter>
struct __iterator_traits<_Iter, true>
    : __iterator_traits_impl
      <
        _Iter,
        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||
        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value
      >
{};






template <class _Iter>
struct __attribute__ ((__type_visibility__("default"))) iterator_traits
    : __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> {};

template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) iterator_traits<_Tp*>
{
    typedef ptrdiff_t difference_type;
    typedef typename remove_const<_Tp>::type value_type;
    typedef _Tp* pointer;
    typedef _Tp& reference;
    typedef random_access_iterator_tag iterator_category;
};

template <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>
struct __has_iterator_category_convertible_to
    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>
{};

template <class _Tp, class _Up>
struct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};

template <class _Tp>
struct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};

template <class _Tp>
struct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};

template <class _Tp>
struct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};

template <class _Tp>
struct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};

template<class _Category, class _Tp, class _Distance = ptrdiff_t,
         class _Pointer = _Tp*, class _Reference = _Tp&>
struct __attribute__ ((__type_visibility__("default"))) iterator
{
    typedef _Tp value_type;
    typedef _Distance difference_type;
    typedef _Pointer pointer;
    typedef _Reference reference;
    typedef _Category iterator_category;
};

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __advance(_InputIter& __i,
             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)
{
    for (; __n > 0; --__n)
        ++__i;
}

template <class _BiDirIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __advance(_BiDirIter& __i,
             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)
{
    if (__n >= 0)
        for (; __n > 0; --__n)
            ++__i;
    else
        for (; __n < 0; ++__n)
            --__i;
}

template <class _RandIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __advance(_RandIter& __i,
             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)
{
   __i += __n;
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void advance(_InputIter& __i,
             typename iterator_traits<_InputIter>::difference_type __n)
{
    __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename iterator_traits<_InputIter>::difference_type
__distance(_InputIter __first, _InputIter __last, input_iterator_tag)
{
    typename iterator_traits<_InputIter>::difference_type __r(0);
    for (; __first != __last; ++__first)
        ++__r;
    return __r;
}

template <class _RandIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename iterator_traits<_RandIter>::difference_type
__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)
{
    return __last - __first;
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename iterator_traits<_InputIter>::difference_type
distance(_InputIter __first, _InputIter __last)
{
    return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());
}

template <class _ForwardIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIter
next(_ForwardIter __x,
     typename iterator_traits<_ForwardIter>::difference_type __n = 1,
     typename enable_if<__is_forward_iterator<_ForwardIter>::value>::type* = 0)
{
    std::__1::advance(__x, __n);
    return __x;
}

template <class _BidiretionalIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_BidiretionalIter
prev(_BidiretionalIter __x,
     typename iterator_traits<_BidiretionalIter>::difference_type __n = 1,
     typename enable_if<__is_bidirectional_iterator<_BidiretionalIter>::value>::type* = 0)
{
    std::__1::advance(__x, -__n);
    return __x;
}

template <class _Iter>
class __attribute__ ((__type_visibility__("default"))) reverse_iterator
    : public iterator<typename iterator_traits<_Iter>::iterator_category,
                      typename iterator_traits<_Iter>::value_type,
                      typename iterator_traits<_Iter>::difference_type,
                      typename iterator_traits<_Iter>::pointer,
                      typename iterator_traits<_Iter>::reference>
{
private:
    mutable _Iter __t;
protected:
    _Iter current;
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<_Iter>::difference_type difference_type;
    typedef typename iterator_traits<_Iter>::reference reference;
    typedef typename iterator_traits<_Iter>::pointer pointer;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator() : current() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}
    template <class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator(const reverse_iterator<_Up>& __u)
        : __t(__u.base()), current(__u.base()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Iter base() const {return current;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator*() const {_Iter __tmp = current; return *--__tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer operator->() const {return std::__1::addressof(operator*());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator& operator++() {--current; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator operator++(int)
        {reverse_iterator __tmp(*this); --current; return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator& operator--() {++current; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator operator--(int)
        {reverse_iterator __tmp(*this); ++current; return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator operator+ (difference_type __n) const
        {return reverse_iterator(current - __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator& operator+=(difference_type __n)
        {current -= __n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator operator- (difference_type __n) const
        {return reverse_iterator(current + __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator& operator-=(difference_type __n)
        {current += __n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](difference_type __n) const
        {return current[-__n-1];}
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() <= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() >= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename reverse_iterator<_Iter1>::difference_type
operator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __y.base() - __x.base();
}

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reverse_iterator<_Iter>
operator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)
{
    return reverse_iterator<_Iter>(__x.base() - __n);
}
# 643 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/iterator" 3
template <class _Container>
class __attribute__ ((__type_visibility__("default"))) back_insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      back_insert_iterator<_Container>&>
{
protected:
    _Container* container;
public:
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit back_insert_iterator(_Container& __x) : container(std::__1::addressof(__x)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) back_insert_iterator& operator=(const typename _Container::value_type& __value_)
        {container->push_back(__value_); return *this;}




    __attribute__ ((__visibility__("hidden"), __always_inline__)) back_insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) back_insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) back_insert_iterator operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
back_insert_iterator<_Container>
back_inserter(_Container& __x)
{
    return back_insert_iterator<_Container>(__x);
}

template <class _Container>
class __attribute__ ((__type_visibility__("default"))) front_insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      front_insert_iterator<_Container>&>
{
protected:
    _Container* container;
public:
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit front_insert_iterator(_Container& __x) : container(std::__1::addressof(__x)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) front_insert_iterator& operator=(const typename _Container::value_type& __value_)
        {container->push_front(__value_); return *this;}




    __attribute__ ((__visibility__("hidden"), __always_inline__)) front_insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) front_insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) front_insert_iterator operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
front_insert_iterator<_Container>
front_inserter(_Container& __x)
{
    return front_insert_iterator<_Container>(__x);
}

template <class _Container>
class __attribute__ ((__type_visibility__("default"))) insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      insert_iterator<_Container>&>
{
protected:
    _Container* container;
    typename _Container::iterator iter;
public:
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator(_Container& __x, typename _Container::iterator __i)
        : container(std::__1::addressof(__x)), iter(__i) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator& operator=(const typename _Container::value_type& __value_)
        {iter = container->insert(iter, __value_); ++iter; return *this;}




    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator& operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
insert_iterator<_Container>
inserter(_Container& __x, typename _Container::iterator __i)
{
    return insert_iterator<_Container>(__x, __i);
}

template <class _Tp, class _CharT = char,
          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>
class __attribute__ ((__type_visibility__("default"))) istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_istream<_CharT,_Traits> istream_type;
private:
    istream_type* __in_stream_;
    _Tp __value_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istream_iterator() : __in_stream_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istream_iterator(istream_type& __s) : __in_stream_(&__s)
        {
            if (!(*__in_stream_ >> __value_))
                __in_stream_ = 0;
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) const _Tp& operator*() const {return __value_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const _Tp* operator->() const {return &(operator*());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istream_iterator& operator++()
        {
            if (!(*__in_stream_ >> __value_))
                __in_stream_ = 0;
            return *this;
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istream_iterator operator++(int)
        {istream_iterator __t(*this); ++(*this); return __t;}

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const istream_iterator& __x, const istream_iterator& __y)
        {return __x.__in_stream_ == __y.__in_stream_;}

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const istream_iterator& __x, const istream_iterator& __y)
        {return !(__x == __y);}
};

template <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >
class __attribute__ ((__type_visibility__("default"))) ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_ostream<_CharT,_Traits> ostream_type;
private:
    ostream_type* __out_stream_;
    const char_type* __delim_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator(ostream_type& __s)
        : __out_stream_(&__s), __delim_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator(ostream_type& __s, const _CharT* __delimiter)
        : __out_stream_(&__s), __delim_(__delimiter) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator& operator=(const _Tp& __value_)
        {
            *__out_stream_ << __value_;
            if (__delim_)
                *__out_stream_ << __delim_;
            return *this;
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator& operator++(int) {return *this;}
};

template<class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT,
                      typename _Traits::off_type, _CharT*,
                      _CharT>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename _Traits::int_type int_type;
    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
    typedef basic_istream<_CharT,_Traits> istream_type;
private:
    mutable streambuf_type* __sbuf_;

    class __proxy
    {
        char_type __keep_;
        streambuf_type* __sbuf_;
        __attribute__ ((__visibility__("hidden"), __always_inline__)) __proxy(char_type __c, streambuf_type* __s)
            : __keep_(__c), __sbuf_(__s) {}
        friend class istreambuf_iterator;
    public:
        __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type operator*() const {return __keep_;}
    };

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool __test_for_eof() const
    {
        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))
            __sbuf_ = 0;
        return __sbuf_ == 0;
    }
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istreambuf_iterator() throw() : __sbuf_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istreambuf_iterator(istream_type& __s) throw()
        : __sbuf_(__s.rdbuf()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istreambuf_iterator(streambuf_type* __s) throw()
        : __sbuf_(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istreambuf_iterator(const __proxy& __p) throw()
        : __sbuf_(__p.__sbuf_) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type operator*() const
        {return static_cast<char_type>(__sbuf_->sgetc());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* operator->() const {return std::__1::__get_nullptr_t();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istreambuf_iterator& operator++()
        {
            __sbuf_->sbumpc();
            return *this;
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __proxy operator++(int)
        {
            return __proxy(__sbuf_->sbumpc(), __sbuf_);
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool equal(const istreambuf_iterator& __b) const
        {return __test_for_eof() == __b.__test_for_eof();}
};

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,
                const istreambuf_iterator<_CharT,_Traits>& __b)
                {return __a.equal(__b);}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,
                const istreambuf_iterator<_CharT,_Traits>& __b)
                {return !__a.equal(__b);}

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
    typedef basic_ostream<_CharT,_Traits> ostream_type;
private:
    streambuf_type* __sbuf_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator(ostream_type& __s) throw()
        : __sbuf_(__s.rdbuf()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator(streambuf_type* __s) throw()
        : __sbuf_(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator& operator=(_CharT __c)
        {
            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))
                __sbuf_ = 0;
            return *this;
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator& operator++(int) {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool failed() const throw() {return __sbuf_ == 0;}





    template <class _Ch, class _Tr>
    friend
    __attribute__ ((__visibility__("hidden")))
    ostreambuf_iterator<_Ch, _Tr>
    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,
                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,
                     ios_base& __iob, _Ch __fl);

};

template <class _Iter>
class __attribute__ ((__type_visibility__("default"))) move_iterator
{
private:
    _Iter __i;
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
    typedef typename iterator_traits<iterator_type>::value_type value_type;
    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
    typedef typename iterator_traits<iterator_type>::pointer pointer;



    typedef typename iterator_traits<iterator_type>::reference reference;


    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator() : __i() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit move_iterator(_Iter __x) : __i(__x) {}
    template <class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator(const move_iterator<_Up>& __u)
        : __i(__u.base()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Iter base() const {return __i;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator*() const {
      return static_cast<reference>(*__i);
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer operator->() const {
      typename iterator_traits<iterator_type>::reference __ref = *__i;
      return &__ref;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator& operator++() {++__i; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator operator++(int)
        {move_iterator __tmp(*this); ++__i; return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator& operator--() {--__i; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator operator--(int)
        {move_iterator __tmp(*this); --__i; return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator operator+ (difference_type __n) const
        {return move_iterator(__i + __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator& operator+=(difference_type __n)
        {__i += __n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator operator- (difference_type __n) const
        {return move_iterator(__i - __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator& operator-=(difference_type __n)
        {__i -= __n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](difference_type __n) const
    {
      return static_cast<reference>(__i[__n]);
    }
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() >= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() <= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename move_iterator<_Iter1>::difference_type
operator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() - __y.base();
}

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
move_iterator<_Iter>
operator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)
{
    return move_iterator<_Iter>(__x.base() + __n);
}

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
move_iterator<_Iter>
make_move_iterator(_Iter __i)
{
    return move_iterator<_Iter>(__i);
}



template <class _Iter> class __wrap_iter;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
typename __wrap_iter<_Iter1>::difference_type
operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter>
__attribute__ ((__visibility__("hidden"), __always_inline__))
__wrap_iter<_Iter>
operator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) throw();

template <class _Ip, class _Op> _Op __attribute__ ((__visibility__("hidden"), __always_inline__)) copy(_Ip, _Ip, _Op);
template <class _B1, class _B2> _B2 __attribute__ ((__visibility__("hidden"), __always_inline__)) copy_backward(_B1, _B1, _B2);
template <class _Ip, class _Op> _Op __attribute__ ((__visibility__("hidden"), __always_inline__)) move(_Ip, _Ip, _Op);
template <class _B1, class _B2> _B2 __attribute__ ((__visibility__("hidden"), __always_inline__)) move_backward(_B1, _B1, _B2);

template <class _Tp>
__attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(__wrap_iter<_Tp*>);

template <class _Iter>
class __wrap_iter
{
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
    typedef typename iterator_traits<iterator_type>::value_type value_type;
    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
    typedef typename iterator_traits<iterator_type>::pointer pointer;
    typedef typename iterator_traits<iterator_type>::reference reference;
private:
    iterator_type __i;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter() throw()



    {



    }
    template <class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter(const __wrap_iter<_Up>& __u,
        typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) throw()
        : __i(__u.base())
    {



    }
# 1157 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/iterator" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator*() const throw()
    {




        return *__i;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer operator->() const throw()
    {




        return (pointer)&reinterpret_cast<const volatile char&>(*__i);
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter& operator++() throw()
    {




        ++__i;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter operator++(int) throw()
        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter& operator--() throw()
    {




        --__i;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter operator--(int) throw()
        {__wrap_iter __tmp(*this); --(*this); return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter operator+ (difference_type __n) const throw()
        {__wrap_iter __w(*this); __w += __n; return __w;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter& operator+=(difference_type __n) throw()
    {




        __i += __n;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter operator- (difference_type __n) const throw()
        {return *this + (-__n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter& operator-=(difference_type __n) throw()
        {*this += -__n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](difference_type __n) const throw()
    {




        return __i[__n];
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator_type base() const throw() {return __i;}

private:






    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter(iterator_type __x) throw() : __i(__x) {}


    template <class _Up> friend class __wrap_iter;
    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;
    template <class _Tp, class _Alloc> friend class vector;

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    typename __wrap_iter<_Iter1>::difference_type
    operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1>
    friend
    __wrap_iter<_Iter1>
    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) throw();

    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);
    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);
    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);
    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);

    template <class _Tp>
    friend
    typename enable_if
    <
        is_trivially_copy_assignable<_Tp>::value,
        _Tp*
    >::type
    __unwrap_iter(__wrap_iter<_Tp*>);
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{




    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{
    return !(__x == __y);
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{
    return __y < __x;
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{
    return !(__x < __y);
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{
    return !(__y < __x);
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) throw()
{
    return !(__x == __y);
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) throw()
{
    return __y < __x;
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) throw()
{
    return !(__x < __y);
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) throw()
{
    return !(__y < __x);
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __wrap_iter<_Iter1>::difference_type
operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{




    return __x.base() - __y.base();
}

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__wrap_iter<_Iter>
operator+(typename __wrap_iter<_Iter>::difference_type __n,
          __wrap_iter<_Iter> __x) throw()
{
    __x += __n;
    return __x;
}

template <class _Tp, size_t _Np>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
begin(_Tp (&__array)[_Np])
{
    return __array;
}

template <class _Tp, size_t _Np>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
end(_Tp (&__array)[_Np])
{
    return __array + _Np;
}
# 1537 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/iterator" 3
template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename _Cp::iterator
begin(_Cp& __c)
{
    return __c.begin();
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename _Cp::const_iterator
begin(const _Cp& __c)
{
    return __c.begin();
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename _Cp::iterator
end(_Cp& __c)
{
    return __c.end();
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename _Cp::const_iterator
end(const _Cp& __c)
{
    return __c.end();
}



} }
# 605 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 2 3


# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/tuple" 1 3
# 134 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/tuple" 3


namespace std {inline namespace __1 {
# 1113 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/tuple" 3
} }
# 608 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 2 3


# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 1 3
# 21 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/assert.h" 1 3
# 12 "/mnt/home/ec2-user/build/emscripten/system/include/libc/assert.h" 3
extern "C" {



__attribute__((__noreturn__))

void __assert_fail (const char *, const char *, int, const char *);


}
# 22 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 2 3
# 25 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 3
# 611 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 2 3






# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__undef_min_max" 1 3
# 618 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 2 3
# 621 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3


namespace std {inline namespace __1 {



template <class _Tp> class allocator;

template <>
class __attribute__ ((__type_visibility__("default"))) allocator<void>
{
public:
    typedef void* pointer;
    typedef const void* const_pointer;
    typedef void value_type;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};
};

template <>
class __attribute__ ((__type_visibility__("default"))) allocator<const void>
{
public:
    typedef const void* pointer;
    typedef const void* const_pointer;
    typedef const void value_type;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};
};



template <class _Tp>
struct __has_element_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::element_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Ptr, bool = __has_element_type<_Ptr>::value>
struct __pointer_traits_element_type;

template <class _Ptr>
struct __pointer_traits_element_type<_Ptr, true>
{
    typedef typename _Ptr::element_type type;
};
# 689 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
template <template <class> class _Sp, class _Tp>
struct __pointer_traits_element_type<_Sp<_Tp>, true>
{
    typedef typename _Sp<_Tp>::element_type type;
};

template <template <class> class _Sp, class _Tp>
struct __pointer_traits_element_type<_Sp<_Tp>, false>
{
    typedef _Tp type;
};

template <template <class, class> class _Sp, class _Tp, class _A0>
struct __pointer_traits_element_type<_Sp<_Tp, _A0>, true>
{
    typedef typename _Sp<_Tp, _A0>::element_type type;
};

template <template <class, class> class _Sp, class _Tp, class _A0>
struct __pointer_traits_element_type<_Sp<_Tp, _A0>, false>
{
    typedef _Tp type;
};

template <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>
struct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true>
{
    typedef typename _Sp<_Tp, _A0, _A1>::element_type type;
};

template <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>
struct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false>
{
    typedef _Tp type;
};

template <template <class, class, class, class> class _Sp, class _Tp, class _A0,
                                                           class _A1, class _A2>
struct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true>
{
    typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;
};

template <template <class, class, class, class> class _Sp, class _Tp, class _A0,
                                                           class _A1, class _A2>
struct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false>
{
    typedef _Tp type;
};



template <class _Tp>
struct __has_difference_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::difference_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Ptr, bool = __has_difference_type<_Ptr>::value>
struct __pointer_traits_difference_type
{
    typedef ptrdiff_t type;
};

template <class _Ptr>
struct __pointer_traits_difference_type<_Ptr, true>
{
    typedef typename _Ptr::difference_type type;
};

template <class _Tp, class _Up>
struct __has_rebind
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Xp> static __two __test(...);
    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __pointer_traits_rebind
{



    typedef typename _Tp::template rebind<_Up>::other type;

};
# 805 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
template <template <class> class _Sp, class _Tp, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp>, _Up, true>
{



    typedef typename _Sp<_Tp>::template rebind<_Up>::other type;

};

template <template <class> class _Sp, class _Tp, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp>, _Up, false>
{
    typedef _Sp<_Up> type;
};

template <template <class, class> class _Sp, class _Tp, class _A0, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true>
{



    typedef typename _Sp<_Tp, _A0>::template rebind<_Up>::other type;

};

template <template <class, class> class _Sp, class _Tp, class _A0, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false>
{
    typedef _Sp<_Up, _A0> type;
};

template <template <class, class, class> class _Sp, class _Tp, class _A0,
                                         class _A1, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true>
{



    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up>::other type;

};

template <template <class, class, class> class _Sp, class _Tp, class _A0,
                                         class _A1, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false>
{
    typedef _Sp<_Up, _A0, _A1> type;
};

template <template <class, class, class, class> class _Sp, class _Tp, class _A0,
                                                class _A1, class _A2, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true>
{



    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;

};

template <template <class, class, class, class> class _Sp, class _Tp, class _A0,
                                                class _A1, class _A2, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false>
{
    typedef _Sp<_Up, _A0, _A1, _A2> type;
};



template <class _Ptr>
struct __attribute__ ((__type_visibility__("default"))) pointer_traits
{
    typedef _Ptr pointer;
    typedef typename __pointer_traits_element_type<pointer>::type element_type;
    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;




    template <class _Up> struct rebind
        {typedef typename __pointer_traits_rebind<pointer, _Up>::type other;};


private:
    struct __nat {};
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer pointer_to(typename conditional<is_void<element_type>::value,
                                           __nat, element_type>::type& __r)
        {return pointer::pointer_to(__r);}
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) pointer_traits<_Tp*>
{
    typedef _Tp* pointer;
    typedef _Tp element_type;
    typedef ptrdiff_t difference_type;




    template <class _Up> struct rebind {typedef _Up* other;};


private:
    struct __nat {};
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer pointer_to(typename conditional<is_void<element_type>::value,
                                      __nat, element_type>::type& __r) throw()
        {return std::__1::addressof(__r);}
};



namespace __has_pointer_type_imp
{
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::pointer* = 0);
}

template <class _Tp>
struct __has_pointer_type
    : public integral_constant<bool, sizeof(__has_pointer_type_imp::__test<_Tp>(0)) == 1>
{
};

namespace __pointer_type_imp
{

template <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>
struct __pointer_type
{
    typedef typename _Dp::pointer type;
};

template <class _Tp, class _Dp>
struct __pointer_type<_Tp, _Dp, false>
{
    typedef _Tp* type;
};

}

template <class _Tp, class _Dp>
struct __pointer_type
{
    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;
};

template <class _Tp>
struct __has_const_pointer
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::const_pointer* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>
struct __const_pointer
{
    typedef typename _Alloc::const_pointer type;
};

template <class _Tp, class _Ptr, class _Alloc>
struct __const_pointer<_Tp, _Ptr, _Alloc, false>
{



    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;

};

template <class _Tp>
struct __has_void_pointer
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::void_pointer* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>
struct __void_pointer
{
    typedef typename _Alloc::void_pointer type;
};

template <class _Ptr, class _Alloc>
struct __void_pointer<_Ptr, _Alloc, false>
{



    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;

};

template <class _Tp>
struct __has_const_void_pointer
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::const_void_pointer* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>
struct __const_void_pointer
{
    typedef typename _Alloc::const_void_pointer type;
};

template <class _Ptr, class _Alloc>
struct __const_void_pointer<_Ptr, _Alloc, false>
{



    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;

};

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
__to_raw_pointer(_Tp* __p) throw()
{
    return __p;
}

template <class _Pointer>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename pointer_traits<_Pointer>::element_type*
__to_raw_pointer(_Pointer __p) throw()
{
    return std::__1::__to_raw_pointer(__p.operator->());
}

template <class _Tp>
struct __has_size_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::size_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>
struct __size_type
{
    typedef typename make_unsigned<_DiffType>::type type;
};

template <class _Alloc, class _DiffType>
struct __size_type<_Alloc, _DiffType, true>
{
    typedef typename _Alloc::size_type type;
};

template <class _Tp>
struct __has_propagate_on_container_copy_assignment
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::propagate_on_container_copy_assignment* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>
struct __propagate_on_container_copy_assignment
{
    typedef false_type type;
};

template <class _Alloc>
struct __propagate_on_container_copy_assignment<_Alloc, true>
{
    typedef typename _Alloc::propagate_on_container_copy_assignment type;
};

template <class _Tp>
struct __has_propagate_on_container_move_assignment
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::propagate_on_container_move_assignment* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>
struct __propagate_on_container_move_assignment
{
    typedef false_type type;
};

template <class _Alloc>
struct __propagate_on_container_move_assignment<_Alloc, true>
{
    typedef typename _Alloc::propagate_on_container_move_assignment type;
};

template <class _Tp>
struct __has_propagate_on_container_swap
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::propagate_on_container_swap* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>
struct __propagate_on_container_swap
{
    typedef false_type type;
};

template <class _Alloc>
struct __propagate_on_container_swap<_Alloc, true>
{
    typedef typename _Alloc::propagate_on_container_swap type;
};

template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __has_rebind_other
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Xp> static __two __test(...);
    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Up>
struct __has_rebind_other<_Tp, _Up, false>
{
    static const bool value = false;
};

template <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>
struct __allocator_traits_rebind
{
    typedef typename _Tp::template rebind<_Up>::other type;
};
# 1185 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
template <template <class> class _Alloc, class _Tp, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp>, _Up, true>
{
    typedef typename _Alloc<_Tp>::template rebind<_Up>::other type;
};

template <template <class> class _Alloc, class _Tp, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp>, _Up, false>
{
    typedef _Alloc<_Up> type;
};

template <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, true>
{
    typedef typename _Alloc<_Tp, _A0>::template rebind<_Up>::other type;
};

template <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, false>
{
    typedef _Alloc<_Up, _A0> type;
};

template <template <class, class, class> class _Alloc, class _Tp, class _A0,
                                         class _A1, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, true>
{
    typedef typename _Alloc<_Tp, _A0, _A1>::template rebind<_Up>::other type;
};

template <template <class, class, class> class _Alloc, class _Tp, class _A0,
                                         class _A1, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, false>
{
    typedef _Alloc<_Up, _A0, _A1> type;
};

template <template <class, class, class, class> class _Alloc, class _Tp, class _A0,
                                                class _A1, class _A2, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, true>
{
    typedef typename _Alloc<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;
};

template <template <class, class, class, class> class _Alloc, class _Tp, class _A0,
                                                class _A1, class _A2, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, false>
{
    typedef _Alloc<_Up, _A0, _A1, _A2> type;
};
# 1264 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
template <class _Alloc, class _SizeType, class _ConstVoidPtr>
struct __has_allocate_hint
    : true_type
{
};
# 1365 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
template <class _Alloc, class _Pointer, class _Args>
struct __has_construct
    : false_type
{
};



template <class _Alloc, class _Pointer>
struct __has_destroy
    : false_type
{
};

template <class _Alloc>
struct __has_max_size
    : true_type
{
};

template <class _Alloc>
struct __has_select_on_container_copy_construction
    : false_type
{
};



template <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>
struct __alloc_traits_difference_type
{
    typedef typename pointer_traits<_Ptr>::difference_type type;
};

template <class _Alloc, class _Ptr>
struct __alloc_traits_difference_type<_Alloc, _Ptr, true>
{
    typedef typename _Alloc::difference_type type;
};

template <class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) allocator_traits
{
    typedef _Alloc allocator_type;
    typedef typename allocator_type::value_type value_type;

    typedef typename __pointer_type<value_type, allocator_type>::type pointer;
    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;
    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;
    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;

    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;
    typedef typename __size_type<allocator_type, difference_type>::type size_type;

    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type
                     propagate_on_container_copy_assignment;
    typedef typename __propagate_on_container_move_assignment<allocator_type>::type
                     propagate_on_container_move_assignment;
    typedef typename __propagate_on_container_swap<allocator_type>::type
                     propagate_on_container_swap;






    template <class _Tp> struct rebind_alloc
        {typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;};
    template <class _Tp> struct rebind_traits
        {typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;};


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer allocate(allocator_type& __a, size_type __n)
        {return __a.allocate(__n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
        {return allocate(__a, __n, __hint,
            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void deallocate(allocator_type& __a, pointer __p, size_type __n) throw()
        {__a.deallocate(__p, __n);}
# 1456 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void construct(allocator_type& __a, _Tp* __p)
            {
                ::new ((void*)__p) _Tp();
            }
    template <class _Tp, class _A0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0)
            {
                ::new ((void*)__p) _Tp(__a0);
            }
    template <class _Tp, class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,
                              const _A1& __a1)
            {
                ::new ((void*)__p) _Tp(__a0, __a1);
            }
    template <class _Tp, class _A0, class _A1, class _A2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,
                              const _A1& __a1, const _A2& __a2)
            {
                ::new ((void*)__p) _Tp(__a0, __a1, __a2);
            }


    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void destroy(allocator_type& __a, _Tp* __p)
            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static size_type max_size(const allocator_type& __a) throw()
        {return __max_size(__has_max_size<const allocator_type>(), __a);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static allocator_type
        select_on_container_copy_construction(const allocator_type& __a)
            {return select_on_container_copy_construction(
                __has_select_on_container_copy_construction<const allocator_type>(),
                __a);}

    template <class _Ptr>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static
        void
        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)
        {
            for (; __begin1 != __end1; ++__begin1, ++__begin2)
                construct(__a, std::__1::__to_raw_pointer(__begin2), std::__1::move_if_noexcept(*__begin1));
        }

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static
        typename enable_if
        <
            (is_same<allocator_type, allocator<_Tp> >::value
                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&
             is_trivially_move_constructible<_Tp>::value,
            void
        >::type
        __construct_forward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)
        {
            ptrdiff_t _Np = __end1 - __begin1;
            std::__1::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));
            __begin2 += _Np;
        }

    template <class _Ptr>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static
        void
        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)
        {
            while (__end1 != __begin1)
            {
                construct(__a, std::__1::__to_raw_pointer(__end2-1), std::__1::move_if_noexcept(*--__end1));
                --__end2;
            }
        }

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static
        typename enable_if
        <
            (is_same<allocator_type, allocator<_Tp> >::value
                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&
             is_trivially_move_constructible<_Tp>::value,
            void
        >::type
        __construct_backward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)
        {
            ptrdiff_t _Np = __end1 - __begin1;
            __end2 -= _Np;
            std::__1::memcpy(__end2, __begin1, _Np * sizeof(_Tp));
        }

private:

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer allocate(allocator_type& __a, size_type __n,
        const_void_pointer __hint, true_type)
        {return __a.allocate(__n, __hint);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer allocate(allocator_type& __a, size_type __n,
        const_void_pointer, false_type)
        {return __a.allocate(__n);}
# 1581 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void __destroy(true_type, allocator_type& __a, _Tp* __p)
            {__a.destroy(__p);}
    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void __destroy(false_type, allocator_type&, _Tp* __p)
            {
                __p->~_Tp();
            }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static size_type __max_size(true_type, const allocator_type& __a)
            {return __a.max_size();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static size_type __max_size(false_type, const allocator_type&)
            {return numeric_limits<size_type>::max();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static allocator_type
        select_on_container_copy_construction(true_type, const allocator_type& __a)
            {return __a.select_on_container_copy_construction();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static allocator_type
        select_on_container_copy_construction(false_type, const allocator_type& __a)
            {return __a;}
};



template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) allocator
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp* pointer;
    typedef const _Tp* const_pointer;
    typedef _Tp& reference;
    typedef const _Tp& const_reference;
    typedef _Tp value_type;

    typedef true_type propagate_on_container_move_assignment;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};

    __attribute__ ((__visibility__("hidden"), __always_inline__)) allocator() throw() {}
    template <class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) allocator(const allocator<_Up>&) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer address(reference __x) const throw()
        {return std::__1::addressof(__x);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_pointer address(const_reference __x) const throw()
        {return std::__1::addressof(__x);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer allocate(size_type __n, allocator<void>::const_pointer = 0)
        {return static_cast<pointer>(std::__1::__allocate(__n * sizeof(_Tp)));}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void deallocate(pointer __p, size_type) throw()
        {std::__1::__deallocate((void*)__p);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type max_size() const throw()
        {return size_type(~0) / sizeof(_Tp);}
# 1648 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p)
        {
            ::new((void*)__p) _Tp();
        }


    template <class _A0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, _A0& __a0)
        {
            ::new((void*)__p) _Tp(__a0);
        }
    template <class _A0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, const _A0& __a0)
        {
            ::new((void*)__p) _Tp(__a0);
        }

    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, _A0& __a0, _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }
    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, const _A0& __a0, _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }
    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, _A0& __a0, const _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }
    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, const _A0& __a0, const _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void destroy(pointer __p) {__p->~_Tp();}
};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) allocator<const _Tp>
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef const _Tp* pointer;
    typedef const _Tp* const_pointer;
    typedef const _Tp& reference;
    typedef const _Tp& const_reference;
    typedef const _Tp value_type;

    typedef true_type propagate_on_container_move_assignment;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};

    __attribute__ ((__visibility__("hidden"), __always_inline__)) allocator() throw() {}
    template <class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) allocator(const allocator<_Up>&) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_pointer address(const_reference __x) const throw()
        {return std::__1::addressof(__x);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer allocate(size_type __n, allocator<void>::const_pointer = 0)
        {return static_cast<pointer>(std::__1::__allocate(__n * sizeof(_Tp)));}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void deallocate(pointer __p, size_type) throw()
        {std::__1::__deallocate((void*)__p);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type max_size() const throw()
        {return size_type(~0) / sizeof(_Tp);}
# 1738 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p)
        {
            ::new((void*)__p) _Tp();
        }


    template <class _A0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, _A0& __a0)
        {
            ::new((void*)__p) _Tp(__a0);
        }
    template <class _A0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, const _A0& __a0)
        {
            ::new((void*)__p) _Tp(__a0);
        }

    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, _A0& __a0, _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }
    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, const _A0& __a0, _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }
    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, _A0& __a0, const _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }
    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, const _A0& __a0, const _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void destroy(pointer __p) {__p->~_Tp();}
};

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator==(const allocator<_Tp>&, const allocator<_Up>&) throw() {return true;}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator!=(const allocator<_Tp>&, const allocator<_Up>&) throw() {return false;}

template <class _OutputIterator, class _Tp>
class __attribute__ ((__type_visibility__("default"))) raw_storage_iterator
    : public iterator<output_iterator_tag,
                      _Tp,
                      ptrdiff_t,
                      _Tp*,
                      raw_storage_iterator<_OutputIterator, _Tp>&>
{
private:
    _OutputIterator __x_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) raw_storage_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) raw_storage_iterator& operator=(const _Tp& __element)
        {::new(&*__x_) _Tp(__element); return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) raw_storage_iterator& operator++() {++__x_; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) raw_storage_iterator operator++(int)
        {raw_storage_iterator __t(*this); ++__x_; return __t;}
};

template <class _Tp>
pair<_Tp*, ptrdiff_t>
get_temporary_buffer(ptrdiff_t __n) throw()
{
    pair<_Tp*, ptrdiff_t> __r(0, 0);
    const ptrdiff_t __m = (~ptrdiff_t(0) ^
                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * 8 - 1)))
                           / sizeof(_Tp);
    if (__n > __m)
        __n = __m;
    while (__n > 0)
    {
        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));
        if (__r.first)
        {
            __r.second = __n;
            break;
        }
        __n /= 2;
    }
    return __r;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void return_temporary_buffer(_Tp* __p) throw() {::operator delete(__p);}

template <class _Tp>
struct auto_ptr_ref
{
    _Tp* __ptr_;
};

template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) auto_ptr
{
private:
    _Tp* __ptr_;
public:
    typedef _Tp element_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}
    template<class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr(auto_ptr<_Up>& __p) throw()
        : __ptr_(__p.release()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr& operator=(auto_ptr& __p) throw()
        {reset(__p.release()); return *this;}
    template<class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr& operator=(auto_ptr<_Up>& __p) throw()
        {reset(__p.release()); return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()
        {reset(__p.__ptr_); return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ~auto_ptr() throw() {delete __ptr_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Tp& operator*() const throw()
        {return *__ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Tp* operator->() const throw() {return __ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Tp* get() const throw() {return __ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Tp* release() throw()
    {
        _Tp* __t = __ptr_;
        __ptr_ = 0;
        return __t;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void reset(_Tp* __p = 0) throw()
    {
        if (__ptr_ != __p)
            delete __ptr_;
        __ptr_ = __p;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}
    template<class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) operator auto_ptr_ref<_Up>() throw()
        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}
    template<class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) operator auto_ptr<_Up>() throw()
        {return auto_ptr<_Up>(release());}
};

template <>
class __attribute__ ((__type_visibility__("default"))) auto_ptr<void>
{
public:
    typedef void element_type;
};

template <class _T1, class _T2, bool = is_same<typename remove_cv<_T1>::type,
                                                     typename remove_cv<_T2>::type>::value,
                                bool = is_empty<_T1>::value

                                       && !__is_final(_T1)

                                ,
                                bool = is_empty<_T2>::value

                                       && !__is_final(_T2)

         >
struct __libcpp_compressed_pair_switch;

template <class _T1, class _T2, bool IsSame>
struct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, false> {enum {value = 0};};

template <class _T1, class _T2, bool IsSame>
struct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, true, false> {enum {value = 1};};

template <class _T1, class _T2, bool IsSame>
struct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, true> {enum {value = 2};};

template <class _T1, class _T2>
struct __libcpp_compressed_pair_switch<_T1, _T2, false, true, true> {enum {value = 3};};

template <class _T1, class _T2>
struct __libcpp_compressed_pair_switch<_T1, _T2, true, true, true> {enum {value = 1};};

template <class _T1, class _T2, unsigned = __libcpp_compressed_pair_switch<_T1, _T2>::value>
class __libcpp_compressed_pair_imp;

template <class _T1, class _T2>
class __libcpp_compressed_pair_imp<_T1, _T2, 0>
{
private:
    _T1 __first_;
    _T2 __second_;
public:
    typedef _T1 _T1_param;
    typedef _T2 _T2_param;

    typedef typename remove_reference<_T1>::type& _T1_reference;
    typedef typename remove_reference<_T2>::type& _T2_reference;

    typedef const typename remove_reference<_T1>::type& _T1_const_reference;
    typedef const typename remove_reference<_T2>::type& _T2_const_reference;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T1_param __t1)
        : __first_(std::__1::forward<_T1_param>(__t1)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T2_param __t2)
        : __second_(std::__1::forward<_T2_param>(__t2)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)
        : __first_(std::__1::forward<_T1_param>(__t1)), __second_(std::__1::forward<_T2_param>(__t2)) {}
# 2014 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_reference first() throw() {return __first_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const throw() {return __first_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_reference second() throw() {return __second_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const throw() {return __second_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(__libcpp_compressed_pair_imp& __x)


    {
        using std::__1::swap;
        swap(__first_, __x.__first_);
        swap(__second_, __x.__second_);
    }
};

template <class _T1, class _T2>
class __libcpp_compressed_pair_imp<_T1, _T2, 1>
    : private _T1
{
private:
    _T2 __second_;
public:
    typedef _T1 _T1_param;
    typedef _T2 _T2_param;

    typedef _T1& _T1_reference;
    typedef typename remove_reference<_T2>::type& _T2_reference;

    typedef const _T1& _T1_const_reference;
    typedef const typename remove_reference<_T2>::type& _T2_const_reference;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T1_param __t1)
        : _T1(std::__1::forward<_T1_param>(__t1)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T2_param __t2)
        : __second_(std::__1::forward<_T2_param>(__t2)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)
        : _T1(std::__1::forward<_T1_param>(__t1)), __second_(std::__1::forward<_T2_param>(__t2)) {}
# 2105 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_reference first() throw() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const throw() {return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_reference second() throw() {return __second_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const throw() {return __second_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(__libcpp_compressed_pair_imp& __x)


    {
        using std::__1::swap;
        swap(__second_, __x.__second_);
    }
};

template <class _T1, class _T2>
class __libcpp_compressed_pair_imp<_T1, _T2, 2>
    : private _T2
{
private:
    _T1 __first_;
public:
    typedef _T1 _T1_param;
    typedef _T2 _T2_param;

    typedef typename remove_reference<_T1>::type& _T1_reference;
    typedef _T2& _T2_reference;

    typedef const typename remove_reference<_T1>::type& _T1_const_reference;
    typedef const _T2& _T2_const_reference;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T1_param __t1)
        : __first_(std::__1::forward<_T1_param>(__t1)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T2_param __t2)
        : _T2(std::__1::forward<_T2_param>(__t2)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)


        : _T2(std::__1::forward<_T2_param>(__t2)), __first_(std::__1::forward<_T1_param>(__t1)) {}
# 2198 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_reference first() throw() {return __first_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const throw() {return __first_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_reference second() throw() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const throw() {return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(__libcpp_compressed_pair_imp& __x)


    {
        using std::__1::swap;
        swap(__first_, __x.__first_);
    }
};

template <class _T1, class _T2>
class __libcpp_compressed_pair_imp<_T1, _T2, 3>
    : private _T1,
      private _T2
{
public:
    typedef _T1 _T1_param;
    typedef _T2 _T2_param;

    typedef _T1& _T1_reference;
    typedef _T2& _T2_reference;

    typedef const _T1& _T1_const_reference;
    typedef const _T2& _T2_const_reference;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T1_param __t1)
        : _T1(std::__1::forward<_T1_param>(__t1)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T2_param __t2)
        : _T2(std::__1::forward<_T2_param>(__t2)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)
        : _T1(std::__1::forward<_T1_param>(__t1)), _T2(std::__1::forward<_T2_param>(__t2)) {}
# 2287 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_reference first() throw() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const throw() {return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_reference second() throw() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const throw() {return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(__libcpp_compressed_pair_imp&)


    {
    }
};

template <class _T1, class _T2>
class __compressed_pair
    : private __libcpp_compressed_pair_imp<_T1, _T2>
{
    typedef __libcpp_compressed_pair_imp<_T1, _T2> base;
public:
    typedef typename base::_T1_param _T1_param;
    typedef typename base::_T2_param _T2_param;

    typedef typename base::_T1_reference _T1_reference;
    typedef typename base::_T2_reference _T2_reference;

    typedef typename base::_T1_const_reference _T1_const_reference;
    typedef typename base::_T2_const_reference _T2_const_reference;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __compressed_pair() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __compressed_pair(_T1_param __t1)
        : base(std::__1::forward<_T1_param>(__t1)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __compressed_pair(_T2_param __t2)
        : base(std::__1::forward<_T2_param>(__t2)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __compressed_pair(_T1_param __t1, _T2_param __t2)
        : base(std::__1::forward<_T1_param>(__t1), std::__1::forward<_T2_param>(__t2)) {}
# 2370 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_reference first() throw() {return base::first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const throw() {return base::first();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_reference second() throw() {return base::second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const throw() {return base::second();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(__compressed_pair& __x)


        {base::swap(__x);}
};

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)


    {__x.swap(__y);}



template <class _Ptr1, class _Ptr2,
          bool = is_same<typename remove_cv<typename pointer_traits<_Ptr1>::element_type>::type,
                         typename remove_cv<typename pointer_traits<_Ptr2>::element_type>::type
                        >::value
         >
struct __same_or_less_cv_qualified_imp
    : is_convertible<_Ptr1, _Ptr2> {};

template <class _Ptr1, class _Ptr2>
struct __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2, false>
    : false_type {};

template <class _Ptr1, class _Ptr2, bool = is_pointer<_Ptr1>::value ||
                                           is_same<_Ptr1, _Ptr2>::value ||
                                           __has_element_type<_Ptr1>::value>
struct __same_or_less_cv_qualified
    : __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2> {};

template <class _Ptr1, class _Ptr2>
struct __same_or_less_cv_qualified<_Ptr1, _Ptr2, false>
    : false_type {};



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) default_delete
{



    __attribute__ ((__visibility__("hidden"), __always_inline__)) default_delete() throw() {}

    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__)) default_delete(const default_delete<_Up>&,
             typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* = 0) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator() (_Tp* __ptr) const throw()
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(sizeof(_Tp) > 0)>)> __t2429;
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_void<_Tp>::value)>)> __t2430;
            delete __ptr;
        }
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) default_delete<_Tp[]>
{
public:



    __attribute__ ((__visibility__("hidden"), __always_inline__)) default_delete() throw() {}

    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__)) default_delete(const default_delete<_Up[]>&,
             typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) throw() {}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void operator() (_Up* __ptr,
                         typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) const throw()
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(sizeof(_Tp) > 0)>)> __t2452;
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_void<_Tp>::value)>)> __t2453;
            delete [] __ptr;
        }
};

template <class _Tp, class _Dp = default_delete<_Tp> >
class __attribute__ ((__type_visibility__("default"))) unique_ptr
{
public:
    typedef _Tp element_type;
    typedef _Dp deleter_type;
    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;
private:
    __compressed_pair<pointer, deleter_type> __ptr_;


    unique_ptr(unique_ptr&);
    template <class _Up, class _Ep>
        unique_ptr(unique_ptr<_Up, _Ep>&);
    unique_ptr& operator=(unique_ptr&);
    template <class _Up, class _Ep>
        unique_ptr& operator=(unique_ptr<_Up, _Ep>&);


    struct __nat {int __for_bool_;};

    typedef typename remove_reference<deleter_type>::type& _Dp_reference;
    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr() throw()
        : __ptr_(pointer())
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_pointer<deleter_type>::value)>)> __t2486;

        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(nullptr_t) throw()
        : __ptr_(pointer())
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_pointer<deleter_type>::value)>)> __t2492;

        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit unique_ptr(pointer __p) throw()
        : __ptr_(std::__1::move(__p))
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_pointer<deleter_type>::value)>)> __t2498;

        }
# 2568 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator __rv<unique_ptr>()
    {
        return __rv<unique_ptr>(*this);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(__rv<unique_ptr> __u)
        : __ptr_(__u->release(), std::__1::forward<deleter_type>(__u->get_deleter())) {}

    template <class _Up, class _Ep>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr& operator=(unique_ptr<_Up, _Ep> __u)
    {
        reset(__u.release());
        __ptr_.second() = std::__1::forward<deleter_type>(__u.get_deleter());
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(pointer __p, deleter_type __d)
        : __ptr_(std::__1::move(__p), std::__1::move(__d)) {}

    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
                typename enable_if<
                                      is_convertible<_Up*, _Tp*>::value &&
                                      is_same<_Dp, default_delete<_Tp> >::value,
                                      unique_ptr&
                                  >::type
        operator=(auto_ptr<_Up> __p)
            {reset(__p.release()); return *this;}


    __attribute__ ((__visibility__("hidden"), __always_inline__)) ~unique_ptr() {reset();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr& operator=(nullptr_t) throw()
    {
        reset();
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename add_lvalue_reference<_Tp>::type operator*() const
        {return *__ptr_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer operator->() const throw() {return __ptr_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer get() const throw() {return __ptr_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Dp_reference get_deleter() throw()
        {return __ptr_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Dp_const_reference get_deleter() const throw()
        {return __ptr_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
                         operator bool() const throw()
        {return __ptr_.first() != std::__1::__get_nullptr_t();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer release() throw()
    {
        pointer __t = __ptr_.first();
        __ptr_.first() = pointer();
        return __t;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void reset(pointer __p = pointer()) throw()
    {
        pointer __tmp = __ptr_.first();
        __ptr_.first() = __p;
        if (__tmp)
            __ptr_.second()(__tmp);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(unique_ptr& __u) throw()
        {__ptr_.swap(__u.__ptr_);}
};

template <class _Tp, class _Dp>
class __attribute__ ((__type_visibility__("default"))) unique_ptr<_Tp[], _Dp>
{
public:
    typedef _Tp element_type;
    typedef _Dp deleter_type;
    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;
private:
    __compressed_pair<pointer, deleter_type> __ptr_;


    unique_ptr(unique_ptr&);
    template <class _Up>
        unique_ptr(unique_ptr<_Up>&);
    unique_ptr& operator=(unique_ptr&);
    template <class _Up>
        unique_ptr& operator=(unique_ptr<_Up>&);


    struct __nat {int __for_bool_;};

    typedef typename remove_reference<deleter_type>::type& _Dp_reference;
    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr() throw()
        : __ptr_(pointer())
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_pointer<deleter_type>::value)>)> __t2665;

        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(nullptr_t) throw()
        : __ptr_(pointer())
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_pointer<deleter_type>::value)>)> __t2671;

        }
# 2761 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit unique_ptr(pointer __p)
        : __ptr_(__p)
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_pointer<deleter_type>::value)>)> __t2765;

        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(pointer __p, deleter_type __d)
        : __ptr_(__p, std::__1::forward<deleter_type>(__d)) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(nullptr_t, deleter_type __d)
        : __ptr_(pointer(), std::__1::forward<deleter_type>(__d)) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator __rv<unique_ptr>()
    {
        return __rv<unique_ptr>(*this);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(__rv<unique_ptr> __u)
        : __ptr_(__u->release(), std::__1::forward<deleter_type>(__u->get_deleter())) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr& operator=(__rv<unique_ptr> __u)
    {
        reset(__u->release());
        __ptr_.second() = std::__1::forward<deleter_type>(__u->get_deleter());
        return *this;
    }


    __attribute__ ((__visibility__("hidden"), __always_inline__)) ~unique_ptr() {reset();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr& operator=(nullptr_t) throw()
    {
        reset();
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename add_lvalue_reference<_Tp>::type operator[](size_t __i) const
        {return __ptr_.first()[__i];}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer get() const throw() {return __ptr_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Dp_reference get_deleter() throw()
        {return __ptr_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Dp_const_reference get_deleter() const throw()
        {return __ptr_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
                         operator bool() const throw()
        {return __ptr_.first() != std::__1::__get_nullptr_t();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer release() throw()
    {
        pointer __t = __ptr_.first();
        __ptr_.first() = pointer();
        return __t;
    }
# 2842 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void reset(pointer __p = pointer())
    {
        pointer __tmp = __ptr_.first();
        __ptr_.first() = __p;
        if (__tmp)
            __ptr_.second()(__tmp);
    }


    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(unique_ptr& __u) {__ptr_.swap(__u.__ptr_);}
private:


    template <class _Up>
        explicit unique_ptr(_Up);
    template <class _Up>
        unique_ptr(_Up __u,
                   typename conditional<
                                       is_reference<deleter_type>::value,
                                       deleter_type,
                                       typename add_lvalue_reference<const deleter_type>::type>::type,
                   typename enable_if
                      <
                         is_convertible<_Up, pointer>::value,
                         __nat
                      >::type = __nat());

};

template <class _Tp, class _Dp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) throw() {__x.swap(__y);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    typedef typename unique_ptr<_T2, _D2>::pointer _P2;
    typedef typename common_type<_P1, _P2>::type _V;
    return less<_V>()(__x.get(), __y.get());
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) throw()
{
    return !__x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) throw()
{
    return !__x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) throw()
{
    return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) throw()
{
    return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    return less<_P1>()(__x.get(), std::__1::__get_nullptr_t());
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    return less<_P1>()(std::__1::__get_nullptr_t(), __x.get());
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return std::__1::__get_nullptr_t() < __x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return __x < std::__1::__get_nullptr_t();
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return !(std::__1::__get_nullptr_t() < __x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return !(__x < std::__1::__get_nullptr_t());
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return !(__x < std::__1::__get_nullptr_t());
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return !(std::__1::__get_nullptr_t() < __x);
}



template <class _Tp, class _Dp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unique_ptr<_Tp, _Dp>
move(unique_ptr<_Tp, _Dp>& __t)
{
    return unique_ptr<_Tp, _Dp>(__rv<unique_ptr<_Tp, _Dp> >(__t));
}
# 3065 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
template <class _Tp> struct hash;

template <class _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Size
__loadword(const void* __p)
{
    _Size __r;
    std::memcpy(&__r, __p, sizeof(__r));
    return __r;
}




template <class _Size, size_t = sizeof(_Size)*8>
struct __murmur2_or_cityhash;

template <class _Size>
struct __murmur2_or_cityhash<_Size, 32>
{
    _Size operator()(const void* __key, _Size __len);
};


template <class _Size>
_Size
__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len)
{
    const _Size __m = 0x5bd1e995;
    const _Size __r = 24;
    _Size __h = __len;
    const unsigned char* __data = static_cast<const unsigned char*>(__key);
    for (; __len >= 4; __data += 4, __len -= 4)
    {
        _Size __k = __loadword<_Size>(__data);
        __k *= __m;
        __k ^= __k >> __r;
        __k *= __m;
        __h *= __m;
        __h ^= __k;
    }
    switch (__len)
    {
    case 3:
        __h ^= __data[2] << 16;
    case 2:
        __h ^= __data[1] << 8;
    case 1:
        __h ^= __data[0];
        __h *= __m;
    }
    __h ^= __h >> 13;
    __h *= __m;
    __h ^= __h >> 15;
    return __h;
}

template <class _Size>
struct __murmur2_or_cityhash<_Size, 64>
{
    _Size operator()(const void* __key, _Size __len);

 private:

  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;
  static const _Size __k1 = 0xb492b66fbe98f273ULL;
  static const _Size __k2 = 0x9ae16a3b2f90404fULL;
  static const _Size __k3 = 0xc949d7c7509e6557ULL;

  static _Size __rotate(_Size __val, int __shift) {
    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));
  }

  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {
    return (__val >> __shift) | (__val << (64 - __shift));
  }

  static _Size __shift_mix(_Size __val) {
    return __val ^ (__val >> 47);
  }

  static _Size __hash_len_16(_Size __u, _Size __v) {
    const _Size __mul = 0x9ddfea08eb382d69ULL;
    _Size __a = (__u ^ __v) * __mul;
    __a ^= (__a >> 47);
    _Size __b = (__v ^ __a) * __mul;
    __b ^= (__b >> 47);
    __b *= __mul;
    return __b;
  }

  static _Size __hash_len_0_to_16(const char* __s, _Size __len) {
    if (__len > 8) {
      const _Size __a = __loadword<_Size>(__s);
      const _Size __b = __loadword<_Size>(__s + __len - 8);
      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;
    }
    if (__len >= 4) {
      const uint32_t __a = __loadword<uint32_t>(__s);
      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);
      return __hash_len_16(__len + (__a << 3), __b);
    }
    if (__len > 0) {
      const unsigned char __a = __s[0];
      const unsigned char __b = __s[__len >> 1];
      const unsigned char __c = __s[__len - 1];
      const uint32_t __y = static_cast<uint32_t>(__a) +
                           (static_cast<uint32_t>(__b) << 8);
      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);
      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;
    }
    return __k2;
  }

  static _Size __hash_len_17_to_32(const char *__s, _Size __len) {
    const _Size __a = __loadword<_Size>(__s) * __k1;
    const _Size __b = __loadword<_Size>(__s + 8);
    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;
    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;
    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,
                         __a + __rotate(__b ^ __k3, 20) - __c + __len);
  }



  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b) {
    __a += __w;
    __b = __rotate(__b + __a + __z, 21);
    const _Size __c = __a;
    __a += __x;
    __a += __y;
    __b += __rotate(__a, 44);
    return pair<_Size, _Size>(__a + __z, __b + __c);
  }


  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
      const char* __s, _Size __a, _Size __b) {
    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),
                                         __loadword<_Size>(__s + 8),
                                         __loadword<_Size>(__s + 16),
                                         __loadword<_Size>(__s + 24),
                                         __a,
                                         __b);
  }


  static _Size __hash_len_33_to_64(const char *__s, size_t __len) {
    _Size __z = __loadword<_Size>(__s + 24);
    _Size __a = __loadword<_Size>(__s) +
                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;
    _Size __b = __rotate(__a + __z, 52);
    _Size __c = __rotate(__a, 37);
    __a += __loadword<_Size>(__s + 8);
    __c += __rotate(__a, 7);
    __a += __loadword<_Size>(__s + 16);
    _Size __vf = __a + __z;
    _Size __vs = __b + __rotate(__a, 31) + __c;
    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);
    __z += __loadword<_Size>(__s + __len - 8);
    __b = __rotate(__a + __z, 52);
    __c = __rotate(__a, 37);
    __a += __loadword<_Size>(__s + __len - 24);
    __c += __rotate(__a, 7);
    __a += __loadword<_Size>(__s + __len - 16);
    _Size __wf = __a + __z;
    _Size __ws = __b + __rotate(__a, 31) + __c;
    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);
    return __shift_mix(__r * __k0 + __vs) * __k2;
  }
};


template <class _Size>
_Size
__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len)
{
  const char* __s = static_cast<const char*>(__key);
  if (__len <= 32) {
    if (__len <= 16) {
      return __hash_len_0_to_16(__s, __len);
    } else {
      return __hash_len_17_to_32(__s, __len);
    }
  } else if (__len <= 64) {
    return __hash_len_33_to_64(__s, __len);
  }



  _Size __x = __loadword<_Size>(__s + __len - 40);
  _Size __y = __loadword<_Size>(__s + __len - 16) +
              __loadword<_Size>(__s + __len - 56);
  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,
                          __loadword<_Size>(__s + __len - 24));
  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);
  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);
  __x = __x * __k1 + __loadword<_Size>(__s);


  __len = (__len - 1) & ~static_cast<_Size>(63);
  do {
    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;
    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;
    __x ^= __w.second;
    __y += __v.first + __loadword<_Size>(__s + 40);
    __z = __rotate(__z + __w.first, 33) * __k1;
    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);
    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,
                                        __y + __loadword<_Size>(__s + 16));
    std::swap(__z, __x);
    __s += 64;
    __len -= 64;
  } while (__len != 0);
  return __hash_len_16(
      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,
      __hash_len_16(__v.second, __w.second) + __x);
}

template <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>
struct __scalar_hash;

template <class _Tp>
struct __scalar_hash<_Tp, 0>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            size_t __a;
        } __u;
        __u.__a = 0;
        __u.__t = __v;
        return __u.__a;
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 1>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            size_t __a;
        } __u;
        __u.__t = __v;
        return __u.__a;
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 2>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
            };
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 3>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
            };
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 4>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
                size_t __d;
            };
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) hash<_Tp*>
    : public unary_function<_Tp*, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp* __v) const throw()
    {
        union
        {
            _Tp* __t;
            size_t __a;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template <class _Tp, class _Dp>
struct __attribute__ ((__type_visibility__("default"))) hash<unique_ptr<_Tp, _Dp> >
{
    typedef unique_ptr<_Tp, _Dp> argument_type;
    typedef size_t result_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result_type operator()(const argument_type& __ptr) const throw()
    {
        typedef typename argument_type::pointer pointer;
        return hash<pointer>()(__ptr.get());
    }
};

struct __destruct_n
{
private:
    size_t size;

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __process(_Tp* __p, false_type) throw()
        {for (size_t __i = 0; __i < size; ++__i, ++__p) __p->~_Tp();}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __process(_Tp*, true_type) throw()
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __incr(false_type) throw()
        {++size;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __incr(true_type) throw()
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __set(size_t __s, false_type) throw()
        {size = __s;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __set(size_t, true_type) throw()
        {}
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __destruct_n(size_t __s) throw()
        : size(__s) {}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __incr(_Tp*) throw()
        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __set(size_t __s, _Tp*) throw()
        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator()(_Tp* __p) throw()
        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}
};

template <class _Alloc>
class __allocator_destructor
{
    typedef allocator_traits<_Alloc> __alloc_traits;
public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::size_type size_type;
private:
    _Alloc& __alloc_;
    size_type __s_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __allocator_destructor(_Alloc& __a, size_type __s)
             throw()
        : __alloc_(__a), __s_(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void operator()(pointer __p) throw()
        {__alloc_traits::deallocate(__alloc_, __p, __s_);}
};

template <class _InputIterator, class _ForwardIterator>
_ForwardIterator
uninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;





        for (; __f != __l; ++__f, ++__r)
            ::new(&*__r) value_type(*__f);
# 3499 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
    return __r;
}

template <class _InputIterator, class _Size, class _ForwardIterator>
_ForwardIterator
uninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;





        for (; __n > 0; ++__f, ++__r, --__n)
            ::new(&*__r) value_type(*__f);
# 3523 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
    return __r;
}

template <class _ForwardIterator, class _Tp>
void
uninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;





        for (; __f != __l; ++__f)
            ::new(&*__f) value_type(__x);
# 3547 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
}

template <class _ForwardIterator, class _Size, class _Tp>
_ForwardIterator
uninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;





        for (; __n > 0; ++__f, --__n)
            ::new(&*__f) value_type(__x);
# 3570 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
    return __f;
}

class __attribute__ ((__visibility__("default"))) bad_weak_ptr
    : public std::exception
{
public:
    virtual ~bad_weak_ptr() throw();
    virtual const char* what() const throw();
};

template<class _Tp> class __attribute__ ((__type_visibility__("default"))) weak_ptr;

class __attribute__ ((__type_visibility__("default"))) __shared_count
{
    __shared_count(const __shared_count&);
    __shared_count& operator=(const __shared_count&);

protected:
    long __shared_owners_;
    virtual ~__shared_count();
private:
    virtual void __on_zero_shared() throw() = 0;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __shared_count(long __refs = 0) throw()
        : __shared_owners_(__refs) {}

    void __add_shared() throw();
    bool __release_shared() throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    long use_count() const throw() {return __shared_owners_ + 1;}
};

class __attribute__ ((__type_visibility__("default"))) __shared_weak_count
    : private __shared_count
{
    long __shared_weak_owners_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __shared_weak_count(long __refs = 0) throw()
        : __shared_count(__refs),
          __shared_weak_owners_(__refs) {}
protected:
    virtual ~__shared_weak_count();

public:
    void __add_shared() throw();
    void __add_weak() throw();
    void __release_shared() throw();
    void __release_weak() throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    long use_count() const throw() {return __shared_count::use_count();}
    __shared_weak_count* lock() throw();






    virtual const void* __get_deleter(const type_info&) const throw();

private:
    virtual void __on_zero_shared_weak() throw() = 0;
};

template <class _Tp, class _Dp, class _Alloc>
class __shared_ptr_pointer
    : public __shared_weak_count
{
    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)
        : __data_(__compressed_pair<_Tp, _Dp>(__p, std::__1::move(__d)), std::__1::move(__a)) {}





private:
    virtual void __on_zero_shared() throw();
    virtual void __on_zero_shared_weak() throw();
};
# 3668 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
template <class _Tp, class _Dp, class _Alloc>
void
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() throw()
{
    __data_.first().second()(__data_.first().first());
    __data_.first().second().~_Dp();
}

template <class _Tp, class _Dp, class _Alloc>
void
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() throw()
{
    typename _Alloc::template rebind<__shared_ptr_pointer>::other __a(__data_.second());
    __data_.second().~_Alloc();
    __a.deallocate(this, 1);
}

template <class _Tp, class _Alloc>
class __shared_ptr_emplace
    : public __shared_weak_count
{
    __compressed_pair<_Alloc, _Tp> __data_;
public:
# 3705 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __shared_ptr_emplace(_Alloc __a)
        : __data_(__a) {}

    template <class _A0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __shared_ptr_emplace(_Alloc __a, _A0& __a0)
            : __data_(__a, _Tp(__a0)) {}

    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1)
            : __data_(__a, _Tp(__a0, __a1)) {}

    template <class _A0, class _A1, class _A2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1, _A2& __a2)
            : __data_(__a, _Tp(__a0, __a1, __a2)) {}



private:
    virtual void __on_zero_shared() throw();
    virtual void __on_zero_shared_weak() throw();
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* get() throw() {return &__data_.second();}
};

template <class _Tp, class _Alloc>
void
__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() throw()
{
    __data_.second().~_Tp();
}

template <class _Tp, class _Alloc>
void
__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() throw()
{
    typename _Alloc::template rebind<__shared_ptr_emplace>::other __a(__data_.first());
    __data_.first().~_Alloc();
    __a.deallocate(this, 1);
}

template<class _Tp> class __attribute__ ((__type_visibility__("default"))) enable_shared_from_this;

template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) shared_ptr
{
public:
    typedef _Tp element_type;
private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;

    struct __nat {int __for_bool_;};
public:
                      shared_ptr() throw();
                      shared_ptr(nullptr_t) throw();
    template<class _Yp>
        explicit shared_ptr(_Yp* __p,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
    template<class _Yp, class _Dp>
        shared_ptr(_Yp* __p, _Dp __d,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
    template<class _Yp, class _Dp, class _Alloc>
        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);
    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);
    template<class _Yp> shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) throw();
    shared_ptr(const shared_ptr& __r) throw();
    template<class _Yp>
        shared_ptr(const shared_ptr<_Yp>& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())
                       throw();






    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type= __nat());





    template<class _Yp>
        shared_ptr(auto_ptr<_Yp> __r,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
# 3819 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
    template <class _Yp, class _Dp>
        shared_ptr(unique_ptr<_Yp, _Dp>,
                   typename enable_if
                   <
                       !is_lvalue_reference<_Dp>::value &&
                       !is_array<_Yp>::value &&
                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                       __nat
                   >::type = __nat());
    template <class _Yp, class _Dp>
        shared_ptr(unique_ptr<_Yp, _Dp>,
                   typename enable_if
                   <
                       is_lvalue_reference<_Dp>::value &&
                       !is_array<_Yp>::value &&
                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                       __nat
                   >::type = __nat());


    ~shared_ptr();

    shared_ptr& operator=(const shared_ptr& __r) throw();
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            shared_ptr&
        >::type
        operator=(const shared_ptr<_Yp>& __r) throw();
# 3867 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
    template<class _Yp>
        typename enable_if
        <
            !is_array<_Yp>::value &&
            is_convertible<_Yp*, element_type*>::value,
            shared_ptr&
        >::type
        operator=(auto_ptr<_Yp> __r);

    template <class _Yp, class _Dp>
        typename enable_if
        <
            !is_array<_Yp>::value &&
            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
            shared_ptr&
        >::type



        operator=(unique_ptr<_Yp, _Dp> __r);


    void swap(shared_ptr& __r) throw();
    void reset() throw();
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            void
        >::type
        reset(_Yp* __p);
    template<class _Yp, class _Dp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            void
        >::type
        reset(_Yp* __p, _Dp __d);
    template<class _Yp, class _Dp, class _Alloc>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            void
        >::type
        reset(_Yp* __p, _Dp __d, _Alloc __a);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    element_type* get() const throw() {return __ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    typename add_lvalue_reference<element_type>::type operator*() const throw()
        {return *__ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    element_type* operator->() const throw() {return __ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    long use_count() const throw() {return __cntrl_ ? __cntrl_->use_count() : 0;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool unique() const throw() {return use_count() == 1;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
                     operator bool() const throw() {return get() != 0;}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool owner_before(shared_ptr<_Up> const& __p) const
        {return __cntrl_ < __p.__cntrl_;}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool owner_before(weak_ptr<_Up> const& __p) const
        {return __cntrl_ < __p.__cntrl_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool
    __owner_equivalent(const shared_ptr& __p) const
        {return __cntrl_ == __p.__cntrl_;}
# 3960 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
    static shared_ptr<_Tp> make_shared();

    template<class _A0>
        static shared_ptr<_Tp> make_shared(_A0&);

    template<class _A0, class _A1>
        static shared_ptr<_Tp> make_shared(_A0&, _A1&);

    template<class _A0, class _A1, class _A2>
        static shared_ptr<_Tp> make_shared(_A0&, _A1&, _A2&);

    template<class _Alloc>
        static shared_ptr<_Tp>
        allocate_shared(const _Alloc& __a);

    template<class _Alloc, class _A0>
        static shared_ptr<_Tp>
        allocate_shared(const _Alloc& __a, _A0& __a0);

    template<class _Alloc, class _A0, class _A1>
        static shared_ptr<_Tp>
        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1);

    template<class _Alloc, class _A0, class _A1, class _A2>
        static shared_ptr<_Tp>
        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2);



private:

    template <class _Yp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        __enable_weak_this(const enable_shared_from_this<_Yp>* __e) throw()
        {
            if (__e)
                __e->__weak_this_ = *this;
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __enable_weak_this(const void*) throw() {}

    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) shared_ptr;
    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) weak_ptr;
};

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

shared_ptr<_Tp>::shared_ptr() throw()
    : __ptr_(0),
      __cntrl_(0)
{
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

shared_ptr<_Tp>::shared_ptr(nullptr_t) throw()
    : __ptr_(0),
      __cntrl_(0)
{
}

template<class _Tp>
template<class _Yp>
shared_ptr<_Tp>::shared_ptr(_Yp* __p,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__p)
{
    unique_ptr<_Yp> __hold(__p);
    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), allocator<_Yp>());
    __hold.release();
    __enable_weak_this(__p);
}

template<class _Tp>
template<class _Yp, class _Dp>
shared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__p)
{




        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Yp>());
        __enable_weak_this(__p);
# 4059 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
}

template<class _Tp>
template<class _Dp>
shared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)
    : __ptr_(0)
{




        typedef __shared_ptr_pointer<nullptr_t, _Dp, allocator<_Tp> > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Tp>());
# 4080 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
}

template<class _Tp>
template<class _Yp, class _Dp, class _Alloc>
shared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__p)
{




        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;
        typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;
        typedef __allocator_destructor<_A2> _D2;
        _A2 __a2(__a);
        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
        ::new(__hold2.get()) _CntrlBlk(__p, __d, __a);
        __cntrl_ = __hold2.release();
        __enable_weak_this(__p);
# 4108 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
}

template<class _Tp>
template<class _Dp, class _Alloc>
shared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)
    : __ptr_(0)
{




        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;
        typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;
        typedef __allocator_destructor<_A2> _D2;
        _A2 __a2(__a);
        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
        ::new(__hold2.get()) _CntrlBlk(__p, __d, __a);
        __cntrl_ = __hold2.release();
# 4134 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) throw()
    : __ptr_(__p),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,
                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)
         throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}
# 4197 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
template<class _Tp>
template<class _Yp>



shared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp> __r,

                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__r.get())
{
    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());
    __enable_weak_this(__r.get());
    __r.release();
}

template<class _Tp>
template <class _Yp, class _Dp>



shared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,

                            typename enable_if
                            <
                                !is_lvalue_reference<_Dp>::value &&
                                !is_array<_Yp>::value &&
                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                                __nat
                            >::type)
    : __ptr_(__r.get())
{
    typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), allocator<_Yp>());
    __enable_weak_this(__r.get());
    __r.release();
}

template<class _Tp>
template <class _Yp, class _Dp>



shared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,

                            typename enable_if
                            <
                                is_lvalue_reference<_Dp>::value &&
                                !is_array<_Yp>::value &&
                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                                __nat
                            >::type)
    : __ptr_(__r.get())
{
    typedef __shared_ptr_pointer<_Yp*,
                                 reference_wrapper<typename remove_reference<_Dp>::type>,
                                 allocator<_Yp> > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), allocator<_Yp>());
    __enable_weak_this(__r.get());
    __r.release();
}
# 4299 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
template<class _Tp>
shared_ptr<_Tp>
shared_ptr<_Tp>::make_shared()
{
    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;
    typedef allocator<_CntrlBlk> _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2;
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__alloc2);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _A0>
shared_ptr<_Tp>
shared_ptr<_Tp>::make_shared(_A0& __a0)
{
    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;
    typedef allocator<_CntrlBlk> _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2;
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _A0, class _A1>
shared_ptr<_Tp>
shared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1)
{
    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;
    typedef allocator<_CntrlBlk> _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2;
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _A0, class _A1, class _A2>
shared_ptr<_Tp>
shared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1, _A2& __a2)
{
    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;
    typedef allocator<_CntrlBlk> _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2;
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1, __a2);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _Alloc>
shared_ptr<_Tp>
shared_ptr<_Tp>::allocate_shared(const _Alloc& __a)
{
    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2(__a);
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__a);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _Alloc, class _A0>
shared_ptr<_Tp>
shared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0)
{
    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2(__a);
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__a, __a0);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _Alloc, class _A0, class _A1>
shared_ptr<_Tp>
shared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)
{
    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2(__a);
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__a, __a0, __a1);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _Alloc, class _A0, class _A1, class _A2>
shared_ptr<_Tp>
shared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)
{
    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2(__a);
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__a, __a0, __a1, __a2);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}



template<class _Tp>
shared_ptr<_Tp>::~shared_ptr()
{
    if (__cntrl_)
        __cntrl_->__release_shared();
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>&
shared_ptr<_Tp>::operator=(const shared_ptr& __r) throw()
{
    shared_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) throw()
{
    shared_ptr(__r).swap(*this);
    return *this;
}
# 4531 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_array<_Yp>::value &&
    is_convertible<_Yp*, _Tp*>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(auto_ptr<_Yp> __r)
{
    shared_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
template <class _Yp, class _Dp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_array<_Yp>::value &&
    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> __r)
{
    shared_ptr(std::__1::move(__r)).swap(*this);
    return *this;
}



template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
shared_ptr<_Tp>::swap(shared_ptr& __r) throw()
{
    std::__1::swap(__ptr_, __r.__ptr_);
    std::__1::swap(__cntrl_, __r.__cntrl_);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
shared_ptr<_Tp>::reset() throw()
{
    shared_ptr().swap(*this);
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p)
{
    shared_ptr(__p).swap(*this);
}

template<class _Tp>
template<class _Yp, class _Dp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)
{
    shared_ptr(__p, __d).swap(*this);
}

template<class _Tp>
template<class _Yp, class _Dp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)
{
    shared_ptr(__p, __d, __a).swap(*this);
}
# 4647 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
make_shared()
{
    return shared_ptr<_Tp>::make_shared();
}

template<class _Tp, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
make_shared(_A0& __a0)
{
    return shared_ptr<_Tp>::make_shared(__a0);
}

template<class _Tp, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
make_shared(_A0& __a0, _A1& __a1)
{
    return shared_ptr<_Tp>::make_shared(__a0, __a1);
}

template<class _Tp, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
make_shared(_A0& __a0, _A1& __a1, _A2& __a2)
{
    return shared_ptr<_Tp>::make_shared(__a0, __a1, __a2);
}

template<class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
allocate_shared(const _Alloc& __a)
{
    return shared_ptr<_Tp>::allocate_shared(__a);
}

template<class _Tp, class _Alloc, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
allocate_shared(const _Alloc& __a, _A0& __a0)
{
    return shared_ptr<_Tp>::allocate_shared(__a, __a0);
}

template<class _Tp, class _Alloc, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)
{
    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1);
}

template<class _Tp, class _Alloc, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1, __a2);
}



template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    return __x.get() == __y.get();
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    return !(__x == __y);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    typedef typename common_type<_Tp*, _Up*>::type _V;
    return less<_V>()(__x.get(), __y.get());
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    return __y < __x;
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    return !(__y < __x);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    return !(__x < __y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return !__x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return !__x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return static_cast<bool>(__x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return static_cast<bool>(__x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return less<_Tp*>()(__x.get(), std::__1::__get_nullptr_t());
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return less<_Tp*>()(std::__1::__get_nullptr_t(), __x.get());
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return std::__1::__get_nullptr_t() < __x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return __x < std::__1::__get_nullptr_t();
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return !(std::__1::__get_nullptr_t() < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return !(__x < std::__1::__get_nullptr_t());
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return !(__x < std::__1::__get_nullptr_t());
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return !(std::__1::__get_nullptr_t() < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) throw()
{
    __x.swap(__y);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_array<_Tp>::value && !is_array<_Up>::value,
    shared_ptr<_Tp>
>::type
static_pointer_cast(const shared_ptr<_Up>& __r) throw()
{
    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_array<_Tp>::value && !is_array<_Up>::value,
    shared_ptr<_Tp>
>::type
dynamic_pointer_cast(const shared_ptr<_Up>& __r) throw()
{
    _Tp* __p = dynamic_cast<_Tp*>(__r.get());
    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();
}

template<class _Tp, class _Up>
typename enable_if
<
    is_array<_Tp>::value == is_array<_Up>::value,
    shared_ptr<_Tp>
>::type
const_pointer_cast(const shared_ptr<_Up>& __r) throw()
{
    typedef typename remove_extent<_Tp>::type _RTp;
    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));
}
# 4915 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) weak_ptr
{
public:
    typedef _Tp element_type;
private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;

public:
                      weak_ptr() throw();
    template<class _Yp> weak_ptr(shared_ptr<_Yp> const& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                        throw();
    weak_ptr(weak_ptr const& __r) throw();
    template<class _Yp> weak_ptr(weak_ptr<_Yp> const& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                         throw();







    ~weak_ptr();

    weak_ptr& operator=(weak_ptr const& __r) throw();
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        operator=(weak_ptr<_Yp> const& __r) throw();
# 4964 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        operator=(shared_ptr<_Yp> const& __r) throw();

    void swap(weak_ptr& __r) throw();
    void reset() throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    long use_count() const throw()
        {return __cntrl_ ? __cntrl_->use_count() : 0;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool expired() const throw()
        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}
    shared_ptr<_Tp> lock() const throw();
    template<class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool owner_before(const shared_ptr<_Up>& __r) const
        {return __cntrl_ < __r.__cntrl_;}
    template<class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool owner_before(const weak_ptr<_Up>& __r) const
        {return __cntrl_ < __r.__cntrl_;}

    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) weak_ptr;
    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) shared_ptr;
};

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

weak_ptr<_Tp>::weak_ptr() throw()
    : __ptr_(0),
      __cntrl_(0)
{
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
weak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
weak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
                         throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
weak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
         throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}
# 5067 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
template<class _Tp>
weak_ptr<_Tp>::~weak_ptr()
{
    if (__cntrl_)
        __cntrl_->__release_weak();
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
weak_ptr<_Tp>&
weak_ptr<_Tp>::operator=(weak_ptr const& __r) throw()
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) throw()
{
    weak_ptr(__r).swap(*this);
    return *this;
}
# 5124 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) throw()
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
weak_ptr<_Tp>::swap(weak_ptr& __r) throw()
{
    std::__1::swap(__ptr_, __r.__ptr_);
    std::__1::swap(__cntrl_, __r.__cntrl_);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) throw()
{
    __x.swap(__y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
weak_ptr<_Tp>::reset() throw()
{
    weak_ptr().swap(*this);
}

template<class _Tp>
template<class _Yp>
shared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,
                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)
{
    if (__cntrl_ == 0)



        ((void)((!"bad_weak_ptr") || (__assert_fail("!\"bad_weak_ptr\"", "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory", 5174, __func__),0)));

}

template<class _Tp>
shared_ptr<_Tp>
weak_ptr<_Tp>::lock() const throw()
{
    shared_ptr<_Tp> __r;
    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;
    if (__r.__cntrl_)
        __r.__ptr_ = __ptr_;
    return __r;
}

template <class _Tp> struct owner_less;

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) owner_less<shared_ptr<_Tp> >
    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>
{
    typedef bool result_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) owner_less<weak_ptr<_Tp> >
    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>
{
    typedef bool result_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()( weak_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
};

template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) enable_shared_from_this
{
    mutable weak_ptr<_Tp> __weak_this_;
protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    enable_shared_from_this() throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    enable_shared_from_this(enable_shared_from_this const&) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    enable_shared_from_this& operator=(enable_shared_from_this const&) throw()
        {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~enable_shared_from_this() {}
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    shared_ptr<_Tp> shared_from_this()
        {return shared_ptr<_Tp>(__weak_this_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    shared_ptr<_Tp const> shared_from_this() const
        {return shared_ptr<const _Tp>(__weak_this_);}

    template <class _Up> friend class shared_ptr;
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) hash<shared_ptr<_Tp> >
{
    typedef shared_ptr<_Tp> argument_type;
    typedef size_t result_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result_type operator()(const argument_type& __ptr) const throw()
    {
        return hash<_Tp*>()(__ptr.get());
    }
};

template<class _CharT, class _Traits, class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);
# 5394 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/memory" 3
struct __attribute__ ((__type_visibility__("default"))) pointer_safety
{
    enum __lx
    {
        relaxed,
        preferred,
        strict
    };

    __lx __v_;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pointer_safety(__lx __v) : __v_(__v) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    operator int() const {return __v_;}
};

__attribute__ ((__visibility__("default"))) void declare_reachable(void* __p);
__attribute__ ((__visibility__("default"))) void declare_no_pointers(char* __p, size_t __n);
__attribute__ ((__visibility__("default"))) void undeclare_no_pointers(char* __p, size_t __n);
__attribute__ ((__visibility__("default"))) pointer_safety get_pointer_safety() throw();
__attribute__ ((__visibility__("default"))) void* __undeclare_reachable(void* __p);

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
undeclare_reachable(_Tp* __p)
{
    return static_cast<_Tp*>(__undeclare_reachable(__p));
}

__attribute__ ((__visibility__("default"))) void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);

} }
# 629 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/algorithm" 2 3
# 639 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/algorithm" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__undef_min_max" 1 3
# 640 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/algorithm" 2 3
# 645 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/algorithm" 3


namespace std {inline namespace __1 {




template <class _T1, class _T2 = _T1>
struct __equal_to
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<_T1, _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<const _T1, _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<_T1, const _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1, class _T2 = _T1>
struct __less
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<_T1, _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<const _T1, _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<_T1, const _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _Predicate>
class __negate
{
private:
    _Predicate __p_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __negate() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __negate(_Predicate __p) : __p_(__p) {}

    template <class _T1>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T1& __x) {return !__p_(__x);}

    template <class _T1, class _T2>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T1& __x, const _T2& __y) {return !__p_(__x, __y);}
};
# 759 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/algorithm" 3
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned
__ctz(unsigned __x)
{
    return static_cast<unsigned>(__builtin_ctz(__x));
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long
__ctz(unsigned long __x)
{
    return static_cast<unsigned long>(__builtin_ctzl(__x));
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long
__ctz(unsigned long long __x)
{
    return static_cast<unsigned long long>(__builtin_ctzll(__x));
}


inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned
__clz(unsigned __x)
{
    return static_cast<unsigned>(__builtin_clz(__x));
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long
__clz(unsigned long __x)
{
    return static_cast<unsigned long>(__builtin_clzl (__x));
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long
__clz(unsigned long long __x)
{
    return static_cast<unsigned long long>(__builtin_clzll(__x));
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int __pop_count(unsigned __x) {return __builtin_popcount (__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int __pop_count(unsigned long __x) {return __builtin_popcountl (__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int __pop_count(unsigned long long __x) {return __builtin_popcountll(__x);}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            return false;
    return true;
}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return true;
    return false;
}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return false;
    return true;
}



template <class _InputIterator, class _Function>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Function
for_each(_InputIterator __first, _InputIterator __last, _Function __f)
{
    for (; __first != __last; ++__first)
        __f(*__first);
    return std::__1::move(__f);
}



template <class _InputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_InputIterator
find(_InputIterator __first, _InputIterator __last, const _Tp& __value_)
{
    for (; __first != __last; ++__first)
        if (*__first == __value_)
            break;
    return __first;
}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_InputIterator
find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            break;
    return __first;
}



template<class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_InputIterator
find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            break;
    return __first;
}



template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
_ForwardIterator1
__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,
           forward_iterator_tag, forward_iterator_tag)
{

    _ForwardIterator1 __r = __last1;
    if (__first2 == __last2)
        return __r;
    while (true)
    {
        while (true)
        {
            if (__first1 == __last1)
                return __r;
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }

        _ForwardIterator1 __m1 = __first1;
        _ForwardIterator2 __m2 = __first2;
        while (true)
        {
            if (++__m2 == __last2)
            {
                __r = __first1;
                ++__first1;
                break;
            }
            if (++__m1 == __last1)
                return __r;
            if (!__pred(*__m1, *__m2))
            {
                ++__first1;
                break;
            }
        }
    }
}

template <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2>
_BidirectionalIterator1
__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,
           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred,
           bidirectional_iterator_tag, bidirectional_iterator_tag)
{

    if (__first2 == __last2)
        return __last1;
    _BidirectionalIterator1 __l1 = __last1;
    _BidirectionalIterator2 __l2 = __last2;
    --__l2;
    while (true)
    {

        while (true)
        {
            if (__first1 == __l1)
                return __last1;
            if (__pred(*--__l1, *__l2))
                break;
        }

        _BidirectionalIterator1 __m1 = __l1;
        _BidirectionalIterator2 __m2 = __l2;
        while (true)
        {
            if (__m2 == __first2)
                return __m1;
            if (__m1 == __first1)
                return __last1;
            if (!__pred(*--__m1, *--__m2))
            {
                break;
            }
        }
    }
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
                              _RandomAccessIterator1
__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,
           random_access_iterator_tag, random_access_iterator_tag)
{

    typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;
    if (__len2 == 0)
        return __last1;
    typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;
    if (__len1 < __len2)
        return __last1;
    const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);
    _RandomAccessIterator1 __l1 = __last1;
    _RandomAccessIterator2 __l2 = __last2;
    --__l2;
    while (true)
    {
        while (true)
        {
            if (__s == __l1)
                return __last1;
            if (__pred(*--__l1, *__l2))
                break;
        }
        _RandomAccessIterator1 __m1 = __l1;
        _RandomAccessIterator2 __m2 = __l2;
        while (true)
        {
            if (__m2 == __first2)
                return __m1;

            if (!__pred(*--__m1, *--__m2))
            {
                break;
            }
        }
    }
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    return std::__1::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>
                         (__first1, __last1, __first2, __last2, __pred,
                          typename iterator_traits<_ForwardIterator1>::iterator_category(),
                          typename iterator_traits<_ForwardIterator2>::iterator_category());
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}



template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
                              _ForwardIterator1
__find_first_of_ce(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    for (; __first1 != __last1; ++__first1)
        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
            if (__pred(*__first1, *__j))
                return __first1;
    return __last1;
}


template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    return std::__1::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}



template <class _ForwardIterator, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__first, *__i))
                return __first;
            __first = __i;
        }
    }
    return __last;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
    return std::__1::adjacent_find(__first, __last, __equal_to<__v>());
}



template <class _InputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename iterator_traits<_InputIterator>::difference_type
count(_InputIterator __first, _InputIterator __last, const _Tp& __value_)
{
    typename iterator_traits<_InputIterator>::difference_type __r(0);
    for (; __first != __last; ++__first)
        if (*__first == __value_)
            ++__r;
    return __r;
}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename iterator_traits<_InputIterator>::difference_type
count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    typename iterator_traits<_InputIterator>::difference_type __r(0);
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            ++__r;
    return __r;
}



template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _BinaryPredicate __pred)
{
    for (; __first1 != __last1; ++__first1, (void) ++__first2)
        if (!__pred(*__first1, *__first2))
            break;
    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__1::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}
# 1187 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/algorithm" 3
template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)
{
    for (; __first1 != __last1; ++__first1, ++__first2)
        if (!__pred(*__first1, *__first2))
            return false;
    return true;
}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__1::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}
# 1264 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/algorithm" 3
template<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2, _BinaryPredicate __pred)
{

    for (; __first1 != __last1; ++__first1, ++__first2)
        if (!__pred(*__first1, *__first2))
            goto __not_done;
    return true;
__not_done:

    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;
    _D1 __l1 = std::__1::distance(__first1, __last1);
    if (__l1 == _D1(1))
        return false;
    _ForwardIterator2 __last2 = std::__1::next(__first2, __l1);


    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)
    {

        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)
            if (__pred(*__j, *__i))
                goto __next_iter;
        {

            _D1 __c2 = 0;
            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
                if (__pred(*__i, *__j))
                    ++__c2;
            if (__c2 == 0)
                return false;

            _D1 __c1 = 1;
            for (_ForwardIterator1 __j = std::__1::next(__i); __j != __last1; ++__j)
                if (__pred(*__i, *__j))
                    ++__c1;
            if (__c1 != __c2)
                return false;
        }
__next_iter:;
    }
    return true;
}

template<class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}
# 1417 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/algorithm" 3
template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
_ForwardIterator1
__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,
         forward_iterator_tag, forward_iterator_tag)
{
    if (__first2 == __last2)
        return __first1;
    while (true)
    {

        while (true)
        {
            if (__first1 == __last1)
                return __last1;
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }

        _ForwardIterator1 __m1 = __first1;
        _ForwardIterator2 __m2 = __first2;
        while (true)
        {
            if (++__m2 == __last2)
                return __first1;
            if (++__m1 == __last1)
                return __last1;
            if (!__pred(*__m1, *__m2))
            {
                ++__first1;
                break;
            }
        }
    }
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
                              _RandomAccessIterator1
__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,
           random_access_iterator_tag, random_access_iterator_tag)
{
    typedef typename std::iterator_traits<_RandomAccessIterator1>::difference_type _D1;
    typedef typename std::iterator_traits<_RandomAccessIterator2>::difference_type _D2;

    _D2 __len2 = __last2 - __first2;
    if (__len2 == 0)
        return __first1;
    _D1 __len1 = __last1 - __first1;
    if (__len1 < __len2)
        return __last1;
    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);
    while (true)
    {

        while (true)
        {
            if (__first1 == __s)
                return __last1;
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }
# 1512 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/algorithm" 3
        _RandomAccessIterator1 __m1 = __first1;
        _RandomAccessIterator2 __m2 = __first2;

         while (true)
         {
             if (++__m2 == __last2)
                 return __first1;
             ++__m1;
             if (!__pred(*__m1, *__m2))
             {
                 ++__first1;
                 break;
             }
         }
# 1563 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/algorithm" 3
    }
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    return std::__1::__search<typename add_lvalue_reference<_BinaryPredicate>::type>
                         (__first1, __last1, __first2, __last2, __pred,
                          typename std::iterator_traits<_ForwardIterator1>::iterator_category(),
                          typename std::iterator_traits<_ForwardIterator2>::iterator_category());
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename std::iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename std::iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}



template <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp>
_ForwardIterator
__search_n(_ForwardIterator __first, _ForwardIterator __last,
           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, forward_iterator_tag)
{
    if (__count <= 0)
        return __first;
    while (true)
    {

        while (true)
        {
            if (__first == __last)
                return __last;
            if (__pred(*__first, __value_))
                break;
            ++__first;
        }

        _ForwardIterator __m = __first;
        _Size __c(0);
        while (true)
        {
            if (++__c == __count)
                return __first;
            if (++__m == __last)
                return __last;
            if (!__pred(*__m, __value_))
            {
                __first = __m;
                ++__first;
                break;
            }
        }
    }
}

template <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp>
_RandomAccessIterator
__search_n(_RandomAccessIterator __first, _RandomAccessIterator __last,
           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, random_access_iterator_tag)
{
    if (__count <= 0)
        return __first;
    _Size __len = static_cast<_Size>(__last - __first);
    if (__len < __count)
        return __last;
    const _RandomAccessIterator __s = __last - (__count - 1);
    while (true)
    {

        while (true)
        {
            if (__first >= __s)
                return __last;
            if (__pred(*__first, __value_))
                break;
            ++__first;
        }

        _RandomAccessIterator __m = __first;
        _Size __c(0);
        while (true)
        {
            if (++__c == __count)
                return __first;
             ++__m;
            if (!__pred(*__m, __value_))
            {
                __first = __m;
                ++__first;
                break;
            }
        }
    }
}

template <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
search_n(_ForwardIterator __first, _ForwardIterator __last,
         _Size __count, const _Tp& __value_, _BinaryPredicate __pred)
{
    return std::__1::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>
           (__first, __last, __count, __value_, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
}

template <class _ForwardIterator, class _Size, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
search_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
    return std::__1::search_n(__first, __last, __count, __value_, __equal_to<__v, _Tp>());
}



template <class _Iter>
struct __libcpp_is_trivial_iterator
{
    static const bool value = is_pointer<_Iter>::value;
};

template <class _Iter>
struct __libcpp_is_trivial_iterator<move_iterator<_Iter> >
{
    static const bool value = is_pointer<_Iter>::value;
};

template <class _Iter>
struct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >
{
    static const bool value = is_pointer<_Iter>::value;
};

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Iter
__unwrap_iter(_Iter __i)
{
    return __i;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(move_iterator<_Tp*> __i)
{
    return __i.base();
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(__wrap_iter<_Tp*> __i)
{
    return __i.base();
}



template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__first, ++__result)
        *__result = *__first;
    return __result;
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__copy(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    std::__1::memmove(__result, __first, __n * sizeof(_Up));
    return __result + __n;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    return std::__1::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}



template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
{
    while (__first != __last)
        *--__result = *--__last;
    return __result;
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__copy_backward(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    __result -= __n;
    std::__1::memmove(__result, __first, __n * sizeof(_Up));
    return __result;
}

template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_BidirectionalIterator2
copy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result)
{
    return std::__1::__copy_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}



template<class _InputIterator, class _OutputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
copy_if(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result, _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (__pred(*__first))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}



template<class _InputIterator, class _Size, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    __is_input_iterator<_InputIterator>::value &&
   !__is_random_access_iterator<_InputIterator>::value,
    _OutputIterator
>::type
copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
{
    if (__n > 0)
    {
        *__result = *__first;
        ++__result;
        for (--__n; __n > 0; --__n)
        {
            ++__first;
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}

template<class _InputIterator, class _Size, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    __is_random_access_iterator<_InputIterator>::value,
    _OutputIterator
>::type
copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
{
    return std::__1::copy(__first, __first + __n, __result);
}



template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__first, ++__result)
        *__result = std::__1::move(*__first);
    return __result;
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__move(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    std::__1::memmove(__result, __first, __n * sizeof(_Up));
    return __result + __n;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    return std::__1::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}



template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    while (__first != __last)
        *--__result = std::__1::move(*--__last);
    return __result;
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__move_backward(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    __result -= __n;
    std::__1::memmove(__result, __first, __n * sizeof(_Up));
    return __result;
}

template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_BidirectionalIterator2
move_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result)
{
    return std::__1::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}







template <class _InputIterator, class _OutputIterator, class _UnaryOperation>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
transform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)
{
    for (; __first != __last; ++__first, ++__result)
        *__result = __op(*__first);
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
transform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
          _OutputIterator __result, _BinaryOperation __binary_op)
{
    for (; __first1 != __last1; ++__first1, ++__first2, ++__result)
        *__result = __binary_op(*__first1, *__first2);
    return __result;
}



template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
replace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)
{
    for (; __first != __last; ++__first)
        if (*__first == __old_value)
            *__first = __new_value;
}



template <class _ForwardIterator, class _Predicate, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
replace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            *__first = __new_value;
}



template <class _InputIterator, class _OutputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
replace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
             const _Tp& __old_value, const _Tp& __new_value)
{
    for (; __first != __last; ++__first, ++__result)
        if (*__first == __old_value)
            *__result = __new_value;
        else
            *__result = *__first;
    return __result;
}



template <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
replace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
                _Predicate __pred, const _Tp& __new_value)
{
    for (; __first != __last; ++__first, ++__result)
        if (__pred(*__first))
            *__result = __new_value;
        else
            *__result = *__first;
    return __result;
}



template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)
{
    for (; __n > 0; ++__first, --__n)
        *__first = __value_;
    return __first;
}

template <class _Tp, class _Size, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && sizeof(_Tp) == 1 &&
    !is_same<_Tp, bool>::value &&
    is_integral<_Up>::value && sizeof(_Up) == 1,
    _Tp*
>::type
__fill_n(_Tp* __first, _Size __n,_Up __value_)
{
    if (__n > 0)
        std::__1::memset(__first, (unsigned char)__value_, (size_t)(__n));
    return __first + __n;
}

template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)
{
   return std::__1::__fill_n(__first, __n, __value_);
}



template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, forward_iterator_tag)
{
    for (; __first != __last; ++__first)
        *__first = __value_;
}

template <class _RandomAccessIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value_, random_access_iterator_tag)
{
    std::__1::fill_n(__first, __last - __first, __value_);
}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    std::__1::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _ForwardIterator, class _Generator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
generate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)
{
    for (; __first != __last; ++__first)
        *__first = __gen();
}



template <class _OutputIterator, class _Size, class _Generator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
{
    for (; __n > 0; ++__first, --__n)
        *__first = __gen();
    return __first;
}



template <class _ForwardIterator, class _Tp>
_ForwardIterator
remove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    __first = std::__1::find(__first, __last, __value_);
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (!(*__i == __value_))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
        }
    }
    return __first;
}



template <class _ForwardIterator, class _Predicate>
_ForwardIterator
remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    __first = std::__1::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>
                           (__first, __last, __pred);
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (!__pred(*__i))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
        }
    }
    return __first;
}



template <class _InputIterator, class _OutputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
remove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_)
{
    for (; __first != __last; ++__first)
    {
        if (!(*__first == __value_))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}



template <class _InputIterator, class _OutputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
remove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (!__pred(*__first))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}



template <class _ForwardIterator, class _BinaryPredicate>
_ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)
{
    __first = std::__1::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>
                                 (__first, __last, __pred);
    if (__first != __last)
    {


        _ForwardIterator __i = __first;
        for (++__i; ++__i != __last;)
            if (!__pred(*__first, *__i))
                *++__first = std::__1::move(*__i);
        ++__first;
    }
    return __first;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
    return std::__1::unique(__first, __last, __equal_to<__v>());
}



template <class _BinaryPredicate, class _InputIterator, class _OutputIterator>
_OutputIterator
__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,
              input_iterator_tag, output_iterator_tag)
{
    if (__first != __last)
    {
        typename iterator_traits<_InputIterator>::value_type __t(*__first);
        *__result = __t;
        ++__result;
        while (++__first != __last)
        {
            if (!__pred(__t, *__first))
            {
                __t = *__first;
                *__result = __t;
                ++__result;
            }
        }
    }
    return __result;
}

template <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>
_OutputIterator
__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,
              forward_iterator_tag, output_iterator_tag)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        *__result = *__i;
        ++__result;
        while (++__first != __last)
        {
            if (!__pred(*__i, *__first))
            {
                *__result = *__first;
                ++__result;
                __i = __first;
            }
        }
    }
    return __result;
}

template <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>
_ForwardIterator
__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,
              input_iterator_tag, forward_iterator_tag)
{
    if (__first != __last)
    {
        *__result = *__first;
        while (++__first != __last)
            if (!__pred(*__result, *__first))
                *++__result = *__first;
        ++__result;
    }
    return __result;
}

template <class _InputIterator, class _OutputIterator, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)
{
    return std::__1::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>
                              (__first, __last, __result, __pred,
                               typename iterator_traits<_InputIterator>::iterator_category(),
                               typename iterator_traits<_OutputIterator>::iterator_category());
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    typedef typename iterator_traits<_InputIterator>::value_type __v;
    return std::__1::unique_copy(__first, __last, __result, __equal_to<__v>());
}



template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)
{
    while (__first != __last)
    {
        if (__first == --__last)
            break;
        swap(*__first, *__last);
        ++__first;
    }
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)
{
    if (__first != __last)
        for (; __first < --__last; ++__first)
            swap(*__first, *__last);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    std::__1::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());
}



template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__result)
        *__result = *--__last;
    return __result;
}



template <class _ForwardIterator>
_ForwardIterator
__rotate_left(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    value_type __tmp = std::__1::move(*__first);
    _ForwardIterator __lm1 = std::__1::move(std::__1::next(__first), __last, __first);
    *__lm1 = std::__1::move(__tmp);
    return __lm1;
}

template <class _BidirectionalIterator>
_BidirectionalIterator
__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    _BidirectionalIterator __lm1 = std::__1::prev(__last);
    value_type __tmp = std::__1::move(*__lm1);
    _BidirectionalIterator __fp1 = std::__1::move_backward(__first, __lm1, __last);
    *__first = std::__1::move(__tmp);
    return __fp1;
}

template <class _ForwardIterator>
_ForwardIterator
__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
{
    _ForwardIterator __i = __middle;
    while (true)
    {
        swap(*__first, *__i);
        ++__first;
        if (++__i == __last)
            break;
        if (__first == __middle)
            __middle = __i;
    }
    _ForwardIterator __r = __first;
    if (__first != __middle)
    {
        __i = __middle;
        while (true)
        {
            swap(*__first, *__i);
            ++__first;
            if (++__i == __last)
            {
                if (__first == __middle)
                    break;
                __i = __middle;
            }
            else if (__first == __middle)
                __middle = __i;
        }
    }
    return __r;
}

template<typename _Integral>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Integral
__gcd(_Integral __x, _Integral __y)
{
    do
    {
        _Integral __t = __x % __y;
        __x = __y;
        __y = __t;
    } while (__y);
    return __x;
}

template<typename _RandomAccessIterator>
_RandomAccessIterator
__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;

    const difference_type __m1 = __middle - __first;
    const difference_type __m2 = __last - __middle;
    if (__m1 == __m2)
    {
        std::__1::swap_ranges(__first, __middle, __middle);
        return __middle;
    }
    const difference_type __g = std::__1::__gcd(__m1, __m2);
    for (_RandomAccessIterator __p = __first + __g; __p != __first;)
    {
        value_type __t(std::__1::move(*--__p));
        _RandomAccessIterator __p1 = __p;
        _RandomAccessIterator __p2 = __p1 + __m1;
        do
        {
            *__p1 = std::__1::move(*__p2);
            __p1 = __p2;
            const difference_type __d = __last - __p2;
            if (__m1 < __d)
                __p2 += __m1;
            else
                __p2 = __first + (__m1 - __d);
        } while (__p2 != __p);
        *__p1 = std::__1::move(__t);
    }
    return __first + __m2;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
__rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,
         std::__1::forward_iterator_tag)
{
    typedef typename std::__1::iterator_traits<_ForwardIterator>::value_type value_type;
    if (std::__1::is_trivially_move_assignable<value_type>::value)
    {
        if (std::__1::next(__first) == __middle)
            return std::__1::__rotate_left(__first, __last);
    }
    return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_BidirectionalIterator
__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
         std::__1::bidirectional_iterator_tag)
{
    typedef typename std::__1::iterator_traits<_BidirectionalIterator>::value_type value_type;
    if (std::__1::is_trivially_move_assignable<value_type>::value)
    {
        if (std::__1::next(__first) == __middle)
            return std::__1::__rotate_left(__first, __last);
        if (std::__1::next(__middle) == __last)
            return std::__1::__rotate_right(__first, __last);
    }
    return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_RandomAccessIterator
__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
         std::__1::random_access_iterator_tag)
{
    typedef typename std::__1::iterator_traits<_RandomAccessIterator>::value_type value_type;
    if (std::__1::is_trivially_move_assignable<value_type>::value)
    {
        if (std::__1::next(__first) == __middle)
            return std::__1::__rotate_left(__first, __last);
        if (std::__1::next(__middle) == __last)
            return std::__1::__rotate_right(__first, __last);
        return std::__1::__rotate_gcd(__first, __middle, __last);
    }
    return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
{
    if (__first == __middle)
        return __last;
    if (__middle == __last)
        return __first;
    return std::__1::__rotate(__first, __middle, __last,
                           typename std::__1::iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _ForwardIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
rotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)
{
    return std::__1::copy(__first, __middle, std::__1::copy(__middle, __last, __result));
}



template <class _ForwardIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
__min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
            if (__comp(*__i, *__first))
                __first = __i;
    }
    return __first;
}

template <class _ForwardIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    return __min_element(__first, __last, __comp);
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return __min_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _Tp&
min(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__b, __a) ? __b : __a;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _Tp&
min(const _Tp& __a, const _Tp& __b)
{
    return std::__1::min(__a, __b, __less<_Tp>());
}
# 2608 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/algorithm" 3
template <class _ForwardIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
__max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
            if (__comp(*__first, *__i))
                __first = __i;
    }
    return __first;
}


template <class _ForwardIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    return __max_element(__first, __last, __comp);
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return __max_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _Tp&
max(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__a, __b) ? __b : __a;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _Tp&
max(const _Tp& __a, const _Tp& __b)
{
    return std::__1::max(__a, __b, __less<_Tp>());
}
# 2681 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/algorithm" 3
template <class _ForwardIterator, class _Compare>
std::pair<_ForwardIterator, _ForwardIterator>
minmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
  std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);
  if (__first != __last)
  {
      if (++__first != __last)
      {
          if (__comp(*__first, *__result.first))
              __result.first = __first;
          else
              __result.second = __first;
          while (++__first != __last)
          {
              _ForwardIterator __i = __first;
              if (++__first == __last)
              {
                  if (__comp(*__i, *__result.first))
                      __result.first = __i;
                  else if (!__comp(*__i, *__result.second))
                      __result.second = __i;
                  break;
              }
              else
              {
                  if (__comp(*__first, *__i))
                  {
                      if (__comp(*__first, *__result.first))
                          __result.first = __first;
                      if (!__comp(*__i, *__result.second))
                          __result.second = __i;
                  }
                  else
                  {
                      if (__comp(*__i, *__result.first))
                          __result.first = __i;
                      if (!__comp(*__first, *__result.second))
                          __result.second = __first;
                  }
              }
          }
      }
  }
  return __result;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
std::pair<_ForwardIterator, _ForwardIterator>
minmax_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::minmax_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template<class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<const _Tp&, const _Tp&>
minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :
                              pair<const _Tp&, const _Tp&>(__a, __b);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<const _Tp&, const _Tp&>
minmax(const _Tp& __a, const _Tp& __b)
{
    return std::__1::minmax(__a, __b, __less<_Tp>());
}
# 2809 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/algorithm" 3
template <unsigned long long _Xp, size_t _Rp>
struct __log2_imp
{
    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp
                                           : __log2_imp<_Xp, _Rp - 1>::value;
};

template <unsigned long long _Xp>
struct __log2_imp<_Xp, 0>
{
    static const size_t value = 0;
};

template <size_t _Rp>
struct __log2_imp<0, _Rp>
{
    static const size_t value = _Rp + 1;
};

template <class _UI, _UI _Xp>
struct __log2
{
    static const size_t value = __log2_imp<_Xp,
                                         sizeof(_UI) * 8 - 1>::value;
};

template<class _Engine, class _UIntType>
class __independent_bits_engine
{
public:

    typedef _UIntType result_type;

private:
    typedef typename _Engine::result_type _Engine_result_type;
    typedef typename conditional
        <
            sizeof(_Engine_result_type) <= sizeof(result_type),
                result_type,
                _Engine_result_type
        >::type _Working_result_type;

    _Engine& __e_;
    size_t __w_;
    size_t __w0_;
    size_t __n_;
    size_t __n0_;
    _Working_result_type __y0_;
    _Working_result_type __y1_;
    _Engine_result_type __mask0_;
    _Engine_result_type __mask1_;


    static const _Working_result_type _Rp = _Engine::_Max - _Engine::_Min
                                          + _Working_result_type(1);




    static const size_t __m = __log2<_Working_result_type, _Rp>::value;
    static const size_t _WDt = numeric_limits<_Working_result_type>::digits;
    static const size_t _EDt = numeric_limits<_Engine_result_type>::digits;

public:

    __independent_bits_engine(_Engine& __e, size_t __w);


    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}

private:
    result_type __eval(false_type);
    result_type __eval(true_type);
};

template<class _Engine, class _UIntType>
__independent_bits_engine<_Engine, _UIntType>
    ::__independent_bits_engine(_Engine& __e, size_t __w)
        : __e_(__e),
          __w_(__w)
{
    __n_ = __w_ / __m + (__w_ % __m != 0);
    __w0_ = __w_ / __n_;
    if (_Rp == 0)
        __y0_ = _Rp;
    else if (__w0_ < _WDt)
        __y0_ = (_Rp >> __w0_) << __w0_;
    else
        __y0_ = 0;
    if (_Rp - __y0_ > __y0_ / __n_)
    {
        ++__n_;
        __w0_ = __w_ / __n_;
        if (__w0_ < _WDt)
            __y0_ = (_Rp >> __w0_) << __w0_;
        else
            __y0_ = 0;
    }
    __n0_ = __n_ - __w_ % __n_;
    if (__w0_ < _WDt - 1)
        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);
    else
        __y1_ = 0;
    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :
                          _Engine_result_type(0);
    __mask1_ = __w0_ < _EDt - 1 ?
                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :
                               _Engine_result_type(~0);
}

template<class _Engine, class _UIntType>
inline
_UIntType
__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)
{
    return static_cast<result_type>(__e_() & __mask0_);
}

template<class _Engine, class _UIntType>
_UIntType
__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)
{
    result_type _Sp = 0;
    for (size_t __k = 0; __k < __n0_; ++__k)
    {
        _Engine_result_type __u;
        do
        {
            __u = __e_() - _Engine::min();
        } while (__u >= __y0_);
        if (__w0_ < _WDt)
            _Sp <<= __w0_;
        else
            _Sp = 0;
        _Sp += __u & __mask0_;
    }
    for (size_t __k = __n0_; __k < __n_; ++__k)
    {
        _Engine_result_type __u;
        do
        {
            __u = __e_() - _Engine::min();
        } while (__u >= __y1_);
        if (__w0_ < _WDt - 1)
            _Sp <<= __w0_ + 1;
        else
            _Sp = 0;
        _Sp += __u & __mask1_;
    }
    return _Sp;
}



template<class _IntType = int>
class uniform_int_distribution
{
public:

    typedef _IntType result_type;

    class param_type
    {
        result_type __a_;
        result_type __b_;
    public:
        typedef uniform_int_distribution distribution_type;

        explicit param_type(result_type __a = 0,
                            result_type __b = numeric_limits<result_type>::max())
            : __a_(__a), __b_(__b) {}

        result_type a() const {return __a_;}
        result_type b() const {return __b_;}

        friend bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}
        friend bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}
    };

private:
    param_type __p_;

public:

    explicit uniform_int_distribution(result_type __a = 0,
                                      result_type __b = numeric_limits<result_type>::max())
        : __p_(param_type(__a, __b)) {}
    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}
    void reset() {}


    template<class _URNG> result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);


    result_type a() const {return __p_.a();}
    result_type b() const {return __p_.b();}

    param_type param() const {return __p_;}
    void param(const param_type& __p) {__p_ = __p;}

    result_type min() const {return a();}
    result_type max() const {return b();}

    friend bool operator==(const uniform_int_distribution& __x,
                           const uniform_int_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    friend bool operator!=(const uniform_int_distribution& __x,
                           const uniform_int_distribution& __y)
            {return !(__x == __y);}
};

template<class _IntType>
template<class _URNG>
typename uniform_int_distribution<_IntType>::result_type
uniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)
{
    typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),
                                            uint32_t, uint64_t>::type _UIntType;
    const _UIntType _Rp = __p.b() - __p.a() + _UIntType(1);
    if (_Rp == 1)
        return __p.a();
    const size_t _Dt = numeric_limits<_UIntType>::digits;
    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;
    if (_Rp == 0)
        return static_cast<result_type>(_Eng(__g, _Dt)());
    size_t __w = _Dt - __clz(_Rp) - 1;
    if ((_Rp & (_UIntType(~0) >> (_Dt - __w))) != 0)
        ++__w;
    _Eng __e(__g, __w);
    _UIntType __u;
    do
    {
        __u = __e();
    } while (__u >= _Rp);
    return static_cast<result_type>(__u + __p.a());
}

class __attribute__ ((__type_visibility__("default"))) __rs_default;

__attribute__ ((__visibility__("default"))) __rs_default __rs_get();

class __attribute__ ((__type_visibility__("default"))) __rs_default
{
    static unsigned __c_;

    __rs_default();
public:
    typedef uint_fast32_t result_type;

    static const result_type _Min = 0;
    static const result_type _Max = 0xFFFFFFFF;

    __rs_default(const __rs_default&);
    ~__rs_default();

    result_type operator()();

    static result_type min() {return _Min;}
    static result_type max() {return _Max;}

    friend __attribute__ ((__visibility__("default"))) __rs_default __rs_get();
};

__attribute__ ((__visibility__("default"))) __rs_default __rs_get();

template <class _RandomAccessIterator>
void
random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef uniform_int_distribution<ptrdiff_t> _Dp;
    typedef typename _Dp::param_type _Pp;
    difference_type __d = __last - __first;
    if (__d > 1)
    {
        _Dp __uid;
        __rs_default __g = __rs_get();
        for (--__last, --__d; __first < __last; ++__first, --__d)
        {
            difference_type __i = __uid(__g, _Pp(0, __d));
            if (__i != difference_type(0))
                swap(*__first, *(__first + __i));
        }
    }
}

template <class _RandomAccessIterator, class _RandomNumberGenerator>
void
random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,



               _RandomNumberGenerator& __rand)

{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __d = __last - __first;
    if (__d > 1)
    {
        for (--__last; __first < __last; ++__first, --__d)
        {
            difference_type __i = __rand(__d);
            swap(*__first, *(__first + __i));
        }
    }
}

template<class _RandomAccessIterator, class _UniformRandomNumberGenerator>
    void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,



                 _UniformRandomNumberGenerator& __g)

{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef uniform_int_distribution<ptrdiff_t> _Dp;
    typedef typename _Dp::param_type _Pp;
    difference_type __d = __last - __first;
    if (__d > 1)
    {
        _Dp __uid;
        for (--__last, --__d; __first < __last; ++__first, --__d)
        {
            difference_type __i = __uid(__g, _Pp(0, __d));
            if (__i != difference_type(0))
                swap(*__first, *(__first + __i));
        }
    }
}

template <class _InputIterator, class _Predicate>
bool
is_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            break;
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return false;
    return true;
}



template <class _Predicate, class _ForwardIterator>
_ForwardIterator
__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)
{
    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }
    for (_ForwardIterator __p = __first; ++__p != __last;)
    {
        if (__pred(*__p))
        {
            swap(*__first, *__p);
            ++__first;
        }
    }
    return __first;
}

template <class _Predicate, class _BidirectionalIterator>
_BidirectionalIterator
__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
            bidirectional_iterator_tag)
{
    while (true)
    {
        while (true)
        {
            if (__first == __last)
                return __first;
            if (!__pred(*__first))
                break;
            ++__first;
        }
        do
        {
            if (__first == --__last)
                return __first;
        } while (!__pred(*__last));
        swap(*__first, *__last);
        ++__first;
    }
}

template <class _ForwardIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    return std::__1::__partition<typename add_lvalue_reference<_Predicate>::type>
                            (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _InputIterator, class _OutputIterator1,
          class _OutputIterator2, class _Predicate>
pair<_OutputIterator1, _OutputIterator2>
partition_copy(_InputIterator __first, _InputIterator __last,
               _OutputIterator1 __out_true, _OutputIterator2 __out_false,
               _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (__pred(*__first))
        {
            *__out_true = *__first;
            ++__out_true;
        }
        else
        {
            *__out_false = *__first;
            ++__out_false;
        }
    }
    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
}



template<class _ForwardIterator, class _Predicate>
_ForwardIterator
partition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = __len / 2;
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__pred(*__m))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else
            __len = __l2;
    }
    return __first;
}



template <class _Predicate, class _ForwardIterator, class _Distance, class _Pair>
_ForwardIterator
__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
                   _Distance __len, _Pair __p, forward_iterator_tag __fit)
{


    if (__len == 1)
        return __first;
    if (__len == 2)
    {
        _ForwardIterator __m = __first;
        if (__pred(*++__m))
        {
            swap(*__first, *__m);
            return __m;
        }
        return __first;
    }
    if (__len <= __p.second)
    {
        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);


        value_type* __t = __p.first;
        ::new(__t) value_type(std::__1::move(*__first));
        __d.__incr((value_type*)0);
        ++__t;
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__i))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
            else
            {
                ::new(__t) value_type(std::__1::move(*__i));
                __d.__incr((value_type*)0);
                ++__t;
            }
        }


        __i = __first;
        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)
            *__i = std::__1::move(*__t2);

        return __first;
    }


    _ForwardIterator __m = __first;
    _Distance __len2 = __len / 2;
    std::__1::advance(__m, __len2);



    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
    _ForwardIterator __first_false = __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);



    _ForwardIterator __m1 = __m;
    _ForwardIterator __second_false = __last;
    _Distance __len_half = __len - __len2;
    while (__pred(*__m1))
    {
        if (++__m1 == __last)
            goto __second_half_done;
        --__len_half;
    }


    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);
__second_half_done:


    return std::__1::rotate(__first_false, __m, __second_false);


}

struct __return_temporary_buffer
{
    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator()(_Tp* __p) const {std::__1::return_temporary_buffer(__p);}
};

template <class _Predicate, class _ForwardIterator>
_ForwardIterator
__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
                   forward_iterator_tag)
{
    const unsigned __alloc_limit = 3;

    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }


    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    difference_type __len = std::__1::distance(__first, __last);
    pair<value_type*, ptrdiff_t> __p(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len >= __alloc_limit)
    {
        __p = std::__1::get_temporary_buffer<value_type>(__len);
        __h.reset(__p.first);
    }
    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, __len, __p, forward_iterator_tag());
}

template <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>
_BidirectionalIterator
__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)
{



    if (__len == 2)
    {
        swap(*__first, *__last);
        return __last;
    }
    if (__len == 3)
    {
        _BidirectionalIterator __m = __first;
        if (__pred(*++__m))
        {
            swap(*__first, *__m);
            swap(*__m, *__last);
            return __last;
        }
        swap(*__m, *__last);
        swap(*__first, *__m);
        return __m;
    }
    if (__len <= __p.second)
    {
        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);


        value_type* __t = __p.first;
        ::new(__t) value_type(std::__1::move(*__first));
        __d.__incr((value_type*)0);
        ++__t;
        _BidirectionalIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__i))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
            else
            {
                ::new(__t) value_type(std::__1::move(*__i));
                __d.__incr((value_type*)0);
                ++__t;
            }
        }

        *__first = std::__1::move(*__i);
        __i = ++__first;


        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)
            *__i = std::__1::move(*__t2);

        return __first;
    }


    _BidirectionalIterator __m = __first;
    _Distance __len2 = __len / 2;
    std::__1::advance(__m, __len2);



    _BidirectionalIterator __m1 = __m;
    _BidirectionalIterator __first_false = __first;
    _Distance __len_half = __len2;
    while (!__pred(*--__m1))
    {
        if (__m1 == __first)
            goto __first_half_done;
        --__len_half;
    }


    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
    __first_false = __stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);
__first_half_done:



    __m1 = __m;
    _BidirectionalIterator __second_false = __last;
    ++__second_false;
    __len_half = __len - __len2;
    while (__pred(*__m1))
    {
        if (++__m1 == __last)
            goto __second_half_done;
        --__len_half;
    }


    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);
__second_half_done:


    return std::__1::rotate(__first_false, __m, __second_false);


}

template <class _Predicate, class _BidirectionalIterator>
_BidirectionalIterator
__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
                   bidirectional_iterator_tag)
{
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    const difference_type __alloc_limit = 4;

    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }


    do
    {
        if (__first == --__last)
            return __first;
    } while (!__pred(*__last));




    difference_type __len = std::__1::distance(__first, __last) + 1;
    pair<value_type*, ptrdiff_t> __p(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len >= __alloc_limit)
    {
        __p = std::__1::get_temporary_buffer<value_type>(__len);
        __h.reset(__p.first);
    }
    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());
}

template <class _ForwardIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _ForwardIterator, class _Compare>
_ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__comp(*__i, *__first))
                return __i;
            __first = __i;
        }
    }
    return __last;
}

template<class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _ForwardIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    return std::__1::is_sorted_until(__first, __last, __comp) == __last;
}

template<class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
}





template <class _Compare, class _ForwardIterator>
unsigned
__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)
{
    unsigned __r = 0;
    if (!__c(*__y, *__x))
    {
        if (!__c(*__z, *__y))
            return __r;

        swap(*__y, *__z);
        __r = 1;
        if (__c(*__y, *__x))
        {
            swap(*__x, *__y);
            __r = 2;
        }
        return __r;
    }
    if (__c(*__z, *__y))
    {
        swap(*__x, *__z);
        __r = 1;
        return __r;
    }
    swap(*__x, *__y);
    __r = 1;
    if (__c(*__z, *__y))
    {
        swap(*__y, *__z);
        __r = 2;
    }
    return __r;
}



template <class _Compare, class _ForwardIterator>
unsigned
__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
            _ForwardIterator __x4, _Compare __c)
{
    unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);
    if (__c(*__x4, *__x3))
    {
        swap(*__x3, *__x4);
        ++__r;
        if (__c(*__x3, *__x2))
        {
            swap(*__x2, *__x3);
            ++__r;
            if (__c(*__x2, *__x1))
            {
                swap(*__x1, *__x2);
                ++__r;
            }
        }
    }
    return __r;
}



template <class _Compare, class _ForwardIterator>
unsigned
__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
            _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)
{
    unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);
    if (__c(*__x5, *__x4))
    {
        swap(*__x4, *__x5);
        ++__r;
        if (__c(*__x4, *__x3))
        {
            swap(*__x3, *__x4);
            ++__r;
            if (__c(*__x3, *__x2))
            {
                swap(*__x2, *__x3);
                ++__r;
                if (__c(*__x2, *__x1))
                {
                    swap(*__x1, *__x2);
                    ++__r;
                }
            }
        }
    }
    return __r;
}


template <class _Compare, class _BirdirectionalIterator>
void
__selection_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)
{
    _BirdirectionalIterator __lm1 = __last;
    for (--__lm1; __first != __lm1; ++__first)
    {
        _BirdirectionalIterator __i = std::__1::min_element<_BirdirectionalIterator,
                                                        typename add_lvalue_reference<_Compare>::type>
                                                       (__first, __last, __comp);
        if (__i != __first)
            swap(*__first, *__i);
    }
}

template <class _Compare, class _BirdirectionalIterator>
void
__insertion_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;
    if (__first != __last)
    {
        _BirdirectionalIterator __i = __first;
        for (++__i; __i != __last; ++__i)
        {
            _BirdirectionalIterator __j = __i;
            value_type __t(std::__1::move(*__j));
            for (_BirdirectionalIterator __k = __i; __k != __first && __comp(__t, *--__k); --__j)
                *__j = std::__1::move(*__k);
            *__j = std::__1::move(__t);
        }
    }
}

template <class _Compare, class _RandomAccessIterator>
void
__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    _RandomAccessIterator __j = __first+2;
    __sort3<_Compare>(__first, __first+1, __j, __comp);
    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)
    {
        if (__comp(*__i, *__j))
        {
            value_type __t(std::__1::move(*__i));
            _RandomAccessIterator __k = __j;
            __j = __i;
            do
            {
                *__j = std::__1::move(*__k);
                __j = __k;
            } while (__j != __first && __comp(__t, *--__k));
            *__j = std::__1::move(__t);
        }
        __j = __i;
    }
}

template <class _Compare, class _RandomAccessIterator>
bool
__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    switch (__last - __first)
    {
    case 0:
    case 1:
        return true;
    case 2:
        if (__comp(*--__last, *__first))
            swap(*__first, *__last);
        return true;
    case 3:
        std::__1::__sort3<_Compare>(__first, __first+1, --__last, __comp);
        return true;
    case 4:
        std::__1::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
        return true;
    case 5:
        std::__1::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
        return true;
    }
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    _RandomAccessIterator __j = __first+2;
    __sort3<_Compare>(__first, __first+1, __j, __comp);
    const unsigned __limit = 8;
    unsigned __count = 0;
    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)
    {
        if (__comp(*__i, *__j))
        {
            value_type __t(std::__1::move(*__i));
            _RandomAccessIterator __k = __j;
            __j = __i;
            do
            {
                *__j = std::__1::move(*__k);
                __j = __k;
            } while (__j != __first && __comp(__t, *--__k));
            *__j = std::__1::move(__t);
            if (++__count == __limit)
                return ++__i == __last;
        }
        __j = __i;
    }
    return true;
}

template <class _Compare, class _BirdirectionalIterator>
void
__insertion_sort_move(_BirdirectionalIterator __first1, _BirdirectionalIterator __last1,
                      typename iterator_traits<_BirdirectionalIterator>::value_type* __first2, _Compare __comp)
{
    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;
    if (__first1 != __last1)
    {
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__first2, __d);
        value_type* __last2 = __first2;
        ::new(__last2) value_type(std::__1::move(*__first1));
        __d.__incr((value_type*)0);
        for (++__last2; ++__first1 != __last1; ++__last2)
        {
            value_type* __j2 = __last2;
            value_type* __i2 = __j2;
            if (__comp(*__first1, *--__i2))
            {
                ::new(__j2) value_type(std::__1::move(*__i2));
                __d.__incr((value_type*)0);
                for (--__j2; __i2 != __first2 && __comp(*__first1, *--__i2); --__j2)
                    *__j2 = std::__1::move(*__i2);
                *__j2 = std::__1::move(*__first1);
            }
            else
            {
                ::new(__j2) value_type(std::__1::move(*__first1));
                __d.__incr((value_type*)0);
            }
        }
        __h.release();
    }
}

template <class _Compare, class _RandomAccessIterator>
void
__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{

    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&
                                    is_trivially_copy_assignable<value_type>::value ? 30 : 6;
    while (true)
    {
    __restart:
        difference_type __len = __last - __first;
        switch (__len)
        {
        case 0:
        case 1:
            return;
        case 2:
            if (__comp(*--__last, *__first))
                swap(*__first, *__last);
            return;
        case 3:
            std::__1::__sort3<_Compare>(__first, __first+1, --__last, __comp);
            return;
        case 4:
            std::__1::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
            return;
        case 5:
            std::__1::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
            return;
        }
        if (__len <= __limit)
        {
            std::__1::__insertion_sort_3<_Compare>(__first, __last, __comp);
            return;
        }

        _RandomAccessIterator __m = __first;
        _RandomAccessIterator __lm1 = __last;
        --__lm1;
        unsigned __n_swaps;
        {
        difference_type __delta;
        if (__len >= 1000)
        {
            __delta = __len/2;
            __m += __delta;
            __delta /= 2;
            __n_swaps = std::__1::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);
        }
        else
        {
            __delta = __len/2;
            __m += __delta;
            __n_swaps = std::__1::__sort3<_Compare>(__first, __m, __lm1, __comp);
        }
        }



        _RandomAccessIterator __i = __first;
        _RandomAccessIterator __j = __lm1;



        if (!__comp(*__i, *__m))
        {


            while (true)
            {
                if (__i == --__j)
                {


                    ++__i;
                    __j = __last;
                    if (!__comp(*__first, *--__j))
                    {
                        while (true)
                        {
                            if (__i == __j)
                                return;
                            if (__comp(*__first, *__i))
                            {
                                swap(*__i, *__j);
                                ++__n_swaps;
                                ++__i;
                                break;
                            }
                            ++__i;
                        }
                    }

                    if (__i == __j)
                        return;
                    while (true)
                    {
                        while (!__comp(*__first, *__i))
                            ++__i;
                        while (__comp(*__first, *--__j))
                            ;
                        if (__i >= __j)
                            break;
                        swap(*__i, *__j);
                        ++__n_swaps;
                        ++__i;
                    }



                    __first = __i;
                    goto __restart;
                }
                if (__comp(*__j, *__m))
                {
                    swap(*__i, *__j);
                    ++__n_swaps;
                    break;
                }
            }
        }

        ++__i;


        if (__i < __j)
        {


            while (true)
            {

                while (__comp(*__i, *__m))
                    ++__i;

                while (!__comp(*--__j, *__m))
                    ;
                if (__i > __j)
                    break;
                swap(*__i, *__j);
                ++__n_swaps;


                if (__m == __i)
                    __m = __j;
                ++__i;
            }
        }

        if (__i != __m && __comp(*__m, *__i))
        {
            swap(*__i, *__m);
            ++__n_swaps;
        }


        if (__n_swaps == 0)
        {
            bool __fs = std::__1::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);
            if (std::__1::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))
            {
                if (__fs)
                    return;
                __last = __i;
                continue;
            }
            else
            {
                if (__fs)
                {
                    __first = ++__i;
                    continue;
                }
            }
        }

        if (__i - __first < __last - __i)
        {
            std::__1::__sort<_Compare>(__first, __i, __comp);

            __first = ++__i;
        }
        else
        {
            std::__1::__sort<_Compare>(__i+1, __last, __comp);

            __last = __i;
        }
    }
}


template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __sort<_Comp_ref>(__first, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(_Tp** __first, _Tp** __last)
{
    std::__1::sort((size_t*)__first, (size_t*)__last, __less<size_t>());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last)
{
    std::__1::sort(__first.base(), __last.base());
}

template <class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp)
{
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    std::__1::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);
}





extern template __attribute__ ((__visibility__("default"))) void __sort<__less<char>&, char*>(char*, char*, __less<char>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<short>&, short*>(short*, short*, __less<short>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<int>&, int*>(int*, int*, __less<int>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<long>&, long*>(long*, long*, __less<long>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<float>&, float*>(float*, float*, __less<float>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<double>&, double*>(double*, double*, __less<double>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&);

extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&);

extern template __attribute__ ((__visibility__("default"))) unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&);






template <class _Compare, class _ForwardIterator, class _Tp>
_ForwardIterator
__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = __len / 2;
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__comp(*__m, __value_))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else
            __len = __l2;
    }
    return __first;
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::lower_bound(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}



template <class _Compare, class _ForwardIterator, class _Tp>
_ForwardIterator
__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = __len / 2;
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__comp(__value_, *__m))
            __len = __l2;
        else
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
    }
    return __first;
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::upper_bound(__first, __last, __value_,
                             __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _Compare, class _ForwardIterator, class _Tp>
pair<_ForwardIterator, _ForwardIterator>
__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = __len / 2;
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__comp(*__m, __value_))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else if (__comp(__value_, *__m))
        {
            __last = __m;
            __len = __l2;
        }
        else
        {
            _ForwardIterator __mp1 = __m;
            return pair<_ForwardIterator, _ForwardIterator>
                   (
                      __lower_bound<_Compare>(__first, __m, __value_, __comp),
                      __upper_bound<_Compare>(++__mp1, __last, __value_, __comp)
                   );
        }
    }
    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::equal_range(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}



template <class _Compare, class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);
    return __first != __last && !__comp(__value_, *__first);
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::binary_search(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__merge(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first2, *__first1))
        {
            *__result = *__first2;
            ++__first2;
        }
        else
        {
            *__result = *__first1;
            ++__first1;
        }
    }
    return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
merge(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return std::__1::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
merge(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());
}



template <class _Compare, class _BidirectionalIterator>
void
__buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
                typename iterator_traits<_BidirectionalIterator>::value_type* __buff)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    typedef typename iterator_traits<_BidirectionalIterator>::pointer pointer;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);
    if (__len1 <= __len2)
    {
        value_type* __p = __buff;
        for (_BidirectionalIterator __i = __first; __i != __middle; __d.__incr((value_type*)0), ++__i, ++__p)
            ::new(__p) value_type(std::__1::move(*__i));
        __merge<_Compare>(move_iterator<value_type*>(__buff),
                          move_iterator<value_type*>(__p),
                          move_iterator<_BidirectionalIterator>(__middle),
                          move_iterator<_BidirectionalIterator>(__last),
                          __first, __comp);
    }
    else
    {
        value_type* __p = __buff;
        for (_BidirectionalIterator __i = __middle; __i != __last; __d.__incr((value_type*)0), ++__i, ++__p)
            ::new(__p) value_type(std::__1::move(*__i));
        typedef reverse_iterator<_BidirectionalIterator> _RBi;
        typedef reverse_iterator<value_type*> _Rv;
        __merge(move_iterator<_RBi>(_RBi(__middle)), move_iterator<_RBi>(_RBi(__first)),
                move_iterator<_Rv>(_Rv(__p)), move_iterator<_Rv>(_Rv(__buff)),
                _RBi(__last), __negate<_Compare>(__comp));
    }
}

template <class _Compare, class _BidirectionalIterator>
void
__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
                typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    while (true)
    {

        if (__len2 == 0)
            return;

        for (; true; ++__first, --__len1)
        {
            if (__len1 == 0)
                return;
            if (__comp(*__middle, *__first))
                break;
        }
        if (__len1 <= __buff_size || __len2 <= __buff_size)
        {
            __buffered_inplace_merge<_Compare>(__first, __middle, __last, __comp, __len1, __len2, __buff);
            return;
        }
# 4431 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/algorithm" 3
        _BidirectionalIterator __m1;
        _BidirectionalIterator __m2;
        difference_type __len11;
        difference_type __len21;

        if (__len1 < __len2)
        {
            __len21 = __len2 / 2;
            __m2 = __middle;
            std::__1::advance(__m2, __len21);
            __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);
            __len11 = std::__1::distance(__first, __m1);
        }
        else
        {
            if (__len1 == 1)
            {

                swap(*__first, *__middle);
                return;
            }

            __len11 = __len1 / 2;
            __m1 = __first;
            std::__1::advance(__m1, __len11);
            __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);
            __len21 = std::__1::distance(__middle, __m2);
        }
        difference_type __len12 = __len1 - __len11;
        difference_type __len22 = __len2 - __len21;


        __middle = std::__1::rotate(__m1, __middle, __m2);


        if (__len11 + __len21 < __len12 + __len22)
        {
            __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);

            __first = __middle;
            __middle = __m2;
            __len1 = __len12;
            __len2 = __len22;
        }
        else
        {
            __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);

            __last = __middle;
            __middle = __m1;
            __len1 = __len11;
            __len2 = __len21;
        }
    }
}

template <class _Tp>
struct __inplace_merge_switch
{
    static const unsigned value = is_trivially_copy_assignable<_Tp>::value;
};

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
              _Compare __comp)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    difference_type __len1 = std::__1::distance(__first, __middle);
    difference_type __len2 = std::__1::distance(__middle, __last);
    difference_type __buf_size = std::__1::min(__len1, __len2);
    pair<value_type*, ptrdiff_t> __buf(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__inplace_merge_switch<value_type>::value && __buf_size > 8)
    {
        __buf = std::__1::get_temporary_buffer<value_type>(__buf_size);
        __h.reset(__buf.first);
    }






    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return std::__1::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,
                                            __buf.first, __buf.second);

}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)
{
    std::__1::inplace_merge(__first, __middle, __last,
                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2>
void
__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)
{
    typedef typename iterator_traits<_InputIterator1>::value_type value_type;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h(__result, __d);
    for (; true; ++__result)
    {
        if (__first1 == __last1)
        {
            for (; __first2 != __last2; ++__first2, ++__result, __d.__incr((value_type*)0))
                ::new (__result) value_type(std::__1::move(*__first2));
            __h.release();
            return;
        }
        if (__first2 == __last2)
        {
            for (; __first1 != __last1; ++__first1, ++__result, __d.__incr((value_type*)0))
                ::new (__result) value_type(std::__1::move(*__first1));
            __h.release();
            return;
        }
        if (__comp(*__first2, *__first1))
        {
            ::new (__result) value_type(std::__1::move(*__first2));
            __d.__incr((value_type*)0);
            ++__first2;
        }
        else
        {
            ::new (__result) value_type(std::__1::move(*__first1));
            __d.__incr((value_type*)0);
            ++__first1;
        }
    }
}

template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
void
__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
        {
            for (; __first1 != __last1; ++__first1, ++__result)
                *__result = std::__1::move(*__first1);
            return;
        }
        if (__comp(*__first2, *__first1))
        {
            *__result = std::__1::move(*__first2);
            ++__first2;
        }
        else
        {
            *__result = std::__1::move(*__first1);
            ++__first1;
        }
    }
    for (; __first2 != __last2; ++__first2, ++__result)
        *__result = std::__1::move(*__first2);
}

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
              typename iterator_traits<_RandomAccessIterator>::difference_type __len,
              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,
                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,
                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    switch (__len)
    {
    case 0:
        return;
    case 1:
        ::new(__first2) value_type(std::__1::move(*__first1));
        return;
    case 2:
       __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);
         if (__comp(*--__last1, *__first1))
        {
            ::new(__first2) value_type(std::__1::move(*__last1));
            __d.__incr((value_type*)0);
            ++__first2;
            ::new(__first2) value_type(std::__1::move(*__first1));
        }
        else
        {
            ::new(__first2) value_type(std::__1::move(*__first1));
            __d.__incr((value_type*)0);
            ++__first2;
            ::new(__first2) value_type(std::__1::move(*__last1));
        }
        __h2.release();
        return;
    }
    if (__len <= 8)
    {
        __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);
        return;
    }
    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
    _RandomAccessIterator __m = __first1 + __l2;
    __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);
    __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);
    __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);
}

template <class _Tp>
struct __stable_sort_switch
{
    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;
};

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
              typename iterator_traits<_RandomAccessIterator>::difference_type __len,
              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    switch (__len)
    {
    case 0:
    case 1:
        return;
    case 2:
        if (__comp(*--__last, *__first))
            swap(*__first, *__last);
        return;
    }
    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))
    {
        __insertion_sort<_Compare>(__first, __last, __comp);
        return;
    }
    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
    _RandomAccessIterator __m = __first + __l2;
    if (__len <= __buff_size)
    {
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);
        __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);
        __d.__set(__l2, (value_type*)0);
        __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);
        __d.__set(__len, (value_type*)0);
        __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);





        return;
    }
    __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);
    __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);
    __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __len = __last - __first;
    pair<value_type*, ptrdiff_t> __buf(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))
    {
        __buf = std::__1::get_temporary_buffer<value_type>(__len);
        __h.reset(__buf.first);
    }





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _RandomAccessIterator, class _Compare>
_RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename std::__1::iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __len = __last - __first;
    difference_type __p = 0;
    difference_type __c = 1;
    _RandomAccessIterator __pp = __first;
    while (__c < __len)
    {
        _RandomAccessIterator __cp = __first + __c;
        if (__comp(*__pp, *__cp))
            return __cp;
        ++__c;
        ++__cp;
        if (__c == __len)
            return __last;
        if (__comp(*__pp, *__cp))
            return __cp;
        ++__p;
        ++__pp;
        __c = 2 * __p + 1;
    }
    return __last;
}

template<class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    return std::__1::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    return std::__1::is_heap_until(__first, __last, __comp) == __last;
}

template<class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    return std::__1::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
          typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    if (__len > 1)
    {
        __len = (__len - 2) / 2;
        _RandomAccessIterator __ptr = __first + __len;
        if (__comp(*__ptr, *--__last))
        {
            value_type __t(std::__1::move(*__last));
            do
            {
                *__last = std::__1::move(*__ptr);
                __last = __ptr;
                if (__len == 0)
                    break;
                __len = (__len - 1) / 2;
                __ptr = __first + __len;
            } while (__comp(*__ptr, __t));
            *__last = std::__1::move(__t);
        }
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __sift_up<_Comp_ref>(__first, __last, __comp, __last - __first);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__sift_down(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
            typename iterator_traits<_RandomAccessIterator>::difference_type __len,
            _RandomAccessIterator __start)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;


    difference_type __child = __start - __first;

    if (__len < 2 || (__len - 2) / 2 < __child)
        return;

    __child = 2 * __child + 1;
    _RandomAccessIterator __child_i = __first + __child;

    if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {

        ++__child_i;
        ++__child;
    }


    if (__comp(*__child_i, *__start))

        return;

    value_type __top(std::__1::move(*__start));
    do
    {

        *__start = std::__1::move(*__child_i);
        __start = __child_i;

        if ((__len - 2) / 2 < __child)
            break;


        __child = 2 * __child + 1;
        __child_i = __first + __child;

        if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {

            ++__child_i;
            ++__child;
        }


    } while (!__comp(*__child_i, __top));
    *__start = std::__1::move(__top);
}

template <class _Compare, class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
           typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
    if (__len > 1)
    {
        swap(*__first, *--__last);
        __sift_down<_Compare>(__first, __last, __comp, __len - 1, __first);
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __n = __last - __first;
    if (__n > 1)
    {

        for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start)
        {
            __sift_down<_Compare>(__first, __last, __comp, __n, __first + __start);
        }
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __make_heap<_Comp_ref>(__first, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    for (difference_type __n = __last - __first; __n > 1; --__last, --__n)
        __pop_heap<_Compare>(__first, __last, __comp, __n);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __sort_heap<_Comp_ref>(__first, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
             _Compare __comp)
{
    __make_heap<_Compare>(__first, __middle, __comp);
    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;
    for (_RandomAccessIterator __i = __middle; __i != __last; ++__i)
    {
        if (__comp(*__i, *__first))
        {
            swap(*__i, *__first);
            __sift_down<_Compare>(__first, __middle, __comp, __len, __first);
        }
    }
    __sort_heap<_Compare>(__first, __middle, __comp);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
             _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
{
    std::__1::partial_sort(__first, __middle, __last,
                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _InputIterator, class _RandomAccessIterator>
_RandomAccessIterator
__partial_sort_copy(_InputIterator __first, _InputIterator __last,
                    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
{
    _RandomAccessIterator __r = __result_first;
    if (__r != __result_last)
    {
        for (; __first != __last && __r != __result_last; ++__first, ++__r)
            *__r = *__first;
        __make_heap<_Compare>(__result_first, __r, __comp);
        typename iterator_traits<_RandomAccessIterator>::difference_type __len = __r - __result_first;
        for (; __first != __last; ++__first)
            if (__comp(*__first, *__result_first))
            {
                *__result_first = *__first;
                __sift_down<_Compare>(__result_first, __r, __comp, __len, __result_first);
            }
        __sort_heap<_Compare>(__result_first, __r, __comp);
    }
    return __r;
}

template <class _InputIterator, class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);

}

template <class _InputIterator, class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)
{
    return std::__1::partial_sort_copy(__first, __last, __result_first, __result_last,
                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
{

    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    const difference_type __limit = 7;
    while (true)
    {
    __restart:
        if (__nth == __last)
            return;
        difference_type __len = __last - __first;
        switch (__len)
        {
        case 0:
        case 1:
            return;
        case 2:
            if (__comp(*--__last, *__first))
                swap(*__first, *__last);
            return;
        case 3:
            {
            _RandomAccessIterator __m = __first;
            std::__1::__sort3<_Compare>(__first, ++__m, --__last, __comp);
            return;
            }
        }
        if (__len <= __limit)
        {
            __selection_sort<_Compare>(__first, __last, __comp);
            return;
        }

        _RandomAccessIterator __m = __first + __len/2;
        _RandomAccessIterator __lm1 = __last;
        unsigned __n_swaps = std::__1::__sort3<_Compare>(__first, __m, --__lm1, __comp);



        _RandomAccessIterator __i = __first;
        _RandomAccessIterator __j = __lm1;



        if (!__comp(*__i, *__m))
        {


            while (true)
            {
                if (__i == --__j)
                {


                    ++__i;
                    __j = __last;
                    if (!__comp(*__first, *--__j))
                    {
                        while (true)
                        {
                            if (__i == __j)
                                return;
                            if (__comp(*__first, *__i))
                            {
                                swap(*__i, *__j);
                                ++__n_swaps;
                                ++__i;
                                break;
                            }
                            ++__i;
                        }
                    }

                    if (__i == __j)
                        return;
                    while (true)
                    {
                        while (!__comp(*__first, *__i))
                            ++__i;
                        while (__comp(*__first, *--__j))
                            ;
                        if (__i >= __j)
                            break;
                        swap(*__i, *__j);
                        ++__n_swaps;
                        ++__i;
                    }


                    if (__nth < __i)
                        return;


                    __first = __i;
                    goto __restart;
                }
                if (__comp(*__j, *__m))
                {
                    swap(*__i, *__j);
                    ++__n_swaps;
                    break;
                }
            }
        }
        ++__i;


        if (__i < __j)
        {

            while (true)
            {

                while (__comp(*__i, *__m))
                    ++__i;

                while (!__comp(*--__j, *__m))
                    ;
                if (__i >= __j)
                    break;
                swap(*__i, *__j);
                ++__n_swaps;


                if (__m == __i)
                    __m = __j;
                ++__i;
            }
        }

        if (__i != __m && __comp(*__m, *__i))
        {
            swap(*__i, *__m);
            ++__n_swaps;
        }

        if (__nth == __i)
            return;
        if (__n_swaps == 0)
        {

            if (__nth < __i)
            {

                __j = __m = __first;
                while (++__j != __i)
                {
                    if (__comp(*__j, *__m))

                        goto not_sorted;
                    __m = __j;
                }

                return;
            }
            else
            {

                __j = __m = __i;
                while (++__j != __last)
                {
                    if (__comp(*__j, *__m))

                        goto not_sorted;
                    __m = __j;
                }

                return;
            }
        }
not_sorted:

        if (__nth < __i)
        {

            __last = __i;
        }
        else
        {

            __first = ++__i;
        }
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __nth_element<_Comp_ref>(__first, __nth, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)
{
    std::__1::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2>
bool
__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
           _Compare __comp)
{
    for (; __first2 != __last2; ++__first1)
    {
        if (__first1 == __last1 || __comp(*__first2, *__first1))
            return false;
        if (!__comp(*__first1, *__first2))
            ++__first2;
    }
    return true;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
         _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);

}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)
{
    return std::__1::includes(__first1, __last1, __first2, __last2,
                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                 typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__set_union(_InputIterator1 __first1, _InputIterator1 __last1,
            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first2, *__first1))
        {
            *__result = *__first2;
            ++__first2;
        }
        else
        {
            *__result = *__first1;
            if (!__comp(*__first1, *__first2))
                ++__first2;
            ++__first1;
        }
    }
    return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_union(_InputIterator1 __first1, _InputIterator1 __last1,
          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_union(_InputIterator1 __first1, _InputIterator1 __last1,
          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_union(__first1, __last1, __first2, __last2, __result,
                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                 typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                   _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1 && __first2 != __last2)
    {
        if (__comp(*__first1, *__first2))
            ++__first1;
        else
        {
            if (!__comp(*__first2, *__first1))
            {
                *__result = *__first1;
                ++__result;
                ++__first1;
            }
            ++__first2;
        }
    }
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_intersection(__first1, __last1, __first2, __last2, __result,
                                  __less<typename iterator_traits<_InputIterator1>::value_type,
                                         typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first1, *__first2))
        {
            *__result = *__first1;
            ++__result;
            ++__first1;
        }
        else
        {
            if (!__comp(*__first2, *__first1))
                ++__first1;
            ++__first2;
        }
    }
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_difference(__first1, __last1, __first2, __last2, __result,
                                __less<typename iterator_traits<_InputIterator1>::value_type,
                                       typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first1, *__first2))
        {
            *__result = *__first1;
            ++__result;
            ++__first1;
        }
        else
        {
            if (__comp(*__first2, *__first1))
            {
                *__result = *__first2;
                ++__result;
            }
            else
                ++__first1;
            ++__first2;
        }
    }
    return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,
                                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                                 typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2>
bool
__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
{
    for (; __first2 != __last2; ++__first1, ++__first2)
    {
        if (__first1 == __last1 || __comp(*__first1, *__first2))
            return true;
        if (__comp(*__first2, *__first1))
            return false;
    }
    return false;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);

}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2)
{
    return std::__1::lexicographical_compare(__first1, __last1, __first2, __last2,
                                         __less<typename iterator_traits<_InputIterator1>::value_type,
                                                typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _BidirectionalIterator>
bool
__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    _BidirectionalIterator __i = __last;
    if (__first == __last || __first == --__i)
        return false;
    while (true)
    {
        _BidirectionalIterator __ip1 = __i;
        if (__comp(*--__i, *__ip1))
        {
            _BidirectionalIterator __j = __last;
            while (!__comp(*__i, *--__j))
                ;
            swap(*__i, *__j);
            std::__1::reverse(__ip1, __last);
            return true;
        }
        if (__i == __first)
        {
            std::__1::reverse(__first, __last);
            return false;
        }
    }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __next_permutation<_Comp_ref>(__first, __last, __comp);

}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    return std::__1::next_permutation(__first, __last,
                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}



template <class _Compare, class _BidirectionalIterator>
bool
__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    _BidirectionalIterator __i = __last;
    if (__first == __last || __first == --__i)
        return false;
    while (true)
    {
        _BidirectionalIterator __ip1 = __i;
        if (__comp(*__ip1, *--__i))
        {
            _BidirectionalIterator __j = __last;
            while (!__comp(*--__j, *__i))
                ;
            swap(*__i, *__j);
            std::__1::reverse(__ip1, __last);
            return true;
        }
        if (__i == __first)
        {
            std::__1::reverse(__first, __last);
            return false;
        }
    }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __prev_permutation<_Comp_ref>(__first, __last, __comp);

}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    return std::__1::prev_permutation(__first, __last,
                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value,
    _Tp
>::type
__rotate_left(_Tp __t, _Tp __n = 1)
{
    const unsigned __bits = static_cast<unsigned>(sizeof(_Tp) * 8 - 1);
    __n &= __bits;
    return static_cast<_Tp>((__t << __n) | (static_cast<typename make_unsigned<_Tp>::type>(__t) >> (__bits - __n)));
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value,
    _Tp
>::type
__rotate_right(_Tp __t, _Tp __n = 1)
{
    const unsigned __bits = static_cast<unsigned>(sizeof(_Tp) * 8 - 1);
    __n &= __bits;
    return static_cast<_Tp>((__t << (__bits - __n)) | (static_cast<typename make_unsigned<_Tp>::type>(__t) >> __n));
}

} }
# 24 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMap.h" 2
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 1 3
# 21 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/assert.h" 1 3
# 12 "/mnt/home/ec2-user/build/emscripten/system/include/libc/assert.h" 3
extern "C" {



__attribute__((__noreturn__))

void __assert_fail (const char *, const char *, int, const char *);


}
# 22 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 2 3
# 25 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 3
# 25 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMap.h" 2
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/climits" 1 3
# 42 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/climits" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/limits.h" 1 3







# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/limits.h" 1 3
# 9 "/mnt/home/ec2-user/build/emscripten/system/include/libc/limits.h" 2 3
# 43 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/climits" 2 3
# 46 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/climits" 3
# 26 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMap.h" 2






namespace llvm {

template<typename KeyT, typename ValueT,
         typename KeyInfoT = DenseMapInfo<KeyT>,
         bool IsConst = false>
class DenseMapIterator;

template<typename DerivedT,
         typename KeyT, typename ValueT, typename KeyInfoT>
class DenseMapBase {
protected:
  typedef std::pair<KeyT, ValueT> BucketT;

public:
  typedef KeyT key_type;
  typedef ValueT mapped_type;
  typedef BucketT value_type;

  typedef DenseMapIterator<KeyT, ValueT, KeyInfoT> iterator;
  typedef DenseMapIterator<KeyT, ValueT,
                           KeyInfoT, true> const_iterator;
  inline iterator begin() {

    return empty() ? end() : iterator(getBuckets(), getBucketsEnd());
  }
  inline iterator end() {
    return iterator(getBucketsEnd(), getBucketsEnd(), true);
  }
  inline const_iterator begin() const {
    return empty() ? end() : const_iterator(getBuckets(), getBucketsEnd());
  }
  inline const_iterator end() const {
    return const_iterator(getBucketsEnd(), getBucketsEnd(), true);
  }

  bool __attribute__((__warn_unused_result__)) empty() const {
    return getNumEntries() == 0;
  }
  unsigned size() const { return getNumEntries(); }


  void resize(size_t Size) {
    if (Size > getNumBuckets())
      grow(Size);
  }

  void clear() {
    if (getNumEntries() == 0 && getNumTombstones() == 0) return;



    if (getNumEntries() * 4 < getNumBuckets() && getNumBuckets() > 64) {
      shrink_and_clear();
      return;
    }

    const KeyT EmptyKey = getEmptyKey(), TombstoneKey = getTombstoneKey();
    for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P) {
      if (!KeyInfoT::isEqual(P->first, EmptyKey)) {
        if (!KeyInfoT::isEqual(P->first, TombstoneKey)) {
          P->second.~ValueT();
          decrementNumEntries();
        }
        P->first = EmptyKey;
      }
    }
    ((void)((getNumEntries() == 0 && "Node count imbalance!") || (__assert_fail("getNumEntries() == 0 && \"Node count imbalance!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMap.h", 98, __func__),0)));
    setNumTombstones(0);
  }


  bool count(const KeyT &Val) const {
    const BucketT *TheBucket;
    return LookupBucketFor(Val, TheBucket);
  }

  iterator find(const KeyT &Val) {
    BucketT *TheBucket;
    if (LookupBucketFor(Val, TheBucket))
      return iterator(TheBucket, getBucketsEnd(), true);
    return end();
  }
  const_iterator find(const KeyT &Val) const {
    const BucketT *TheBucket;
    if (LookupBucketFor(Val, TheBucket))
      return const_iterator(TheBucket, getBucketsEnd(), true);
    return end();
  }






  template<class LookupKeyT>
  iterator find_as(const LookupKeyT &Val) {
    BucketT *TheBucket;
    if (LookupBucketFor(Val, TheBucket))
      return iterator(TheBucket, getBucketsEnd(), true);
    return end();
  }
  template<class LookupKeyT>
  const_iterator find_as(const LookupKeyT &Val) const {
    const BucketT *TheBucket;
    if (LookupBucketFor(Val, TheBucket))
      return const_iterator(TheBucket, getBucketsEnd(), true);
    return end();
  }



  ValueT lookup(const KeyT &Val) const {
    const BucketT *TheBucket;
    if (LookupBucketFor(Val, TheBucket))
      return TheBucket->second;
    return ValueT();
  }




  std::pair<iterator, bool> insert(const std::pair<KeyT, ValueT> &KV) {
    BucketT *TheBucket;
    if (LookupBucketFor(KV.first, TheBucket))
      return std::make_pair(iterator(TheBucket, getBucketsEnd(), true),
                            false);


    TheBucket = InsertIntoBucket(KV.first, KV.second, TheBucket);
    return std::make_pair(iterator(TheBucket, getBucketsEnd(), true), true);
  }
# 183 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMap.h"
  template<typename InputIt>
  void insert(InputIt I, InputIt E) {
    for (; I != E; ++I)
      insert(*I);
  }


  bool erase(const KeyT &Val) {
    BucketT *TheBucket;
    if (!LookupBucketFor(Val, TheBucket))
      return false;

    TheBucket->second.~ValueT();
    TheBucket->first = getTombstoneKey();
    decrementNumEntries();
    incrementNumTombstones();
    return true;
  }
  void erase(iterator I) {
    BucketT *TheBucket = &*I;
    TheBucket->second.~ValueT();
    TheBucket->first = getTombstoneKey();
    decrementNumEntries();
    incrementNumTombstones();
  }

  value_type& FindAndConstruct(const KeyT &Key) {
    BucketT *TheBucket;
    if (LookupBucketFor(Key, TheBucket))
      return *TheBucket;

    return *InsertIntoBucket(Key, ValueT(), TheBucket);
  }

  ValueT &operator[](const KeyT &Key) {
    return FindAndConstruct(Key).second;
  }
# 238 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMap.h"
  bool isPointerIntoBucketsArray(const void *Ptr) const {
    return Ptr >= getBuckets() && Ptr < getBucketsEnd();
  }




  const void *getPointerIntoBucketsArray() const { return getBuckets(); }

protected:
  DenseMapBase() {}

  void destroyAll() {
    if (getNumBuckets() == 0)
      return;

    const KeyT EmptyKey = getEmptyKey(), TombstoneKey = getTombstoneKey();
    for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P) {
      if (!KeyInfoT::isEqual(P->first, EmptyKey) &&
          !KeyInfoT::isEqual(P->first, TombstoneKey))
        P->second.~ValueT();
      P->first.~KeyT();
    }


    memset((void*)getBuckets(), 0x5a, sizeof(BucketT)*getNumBuckets());

  }

  void initEmpty() {
    setNumEntries(0);
    setNumTombstones(0);

    ((void)(((getNumBuckets() & (getNumBuckets()-1)) == 0 && "# initial buckets must be a power of two!") || (__assert_fail("(getNumBuckets() & (getNumBuckets()-1)) == 0 && \"# initial buckets must be a power of two!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMap.h", 272, __func__),0)));

    const KeyT EmptyKey = getEmptyKey();
    for (BucketT *B = getBuckets(), *E = getBucketsEnd(); B != E; ++B)
      new (&B->first) KeyT(EmptyKey);
  }

  void moveFromOldBuckets(BucketT *OldBucketsBegin, BucketT *OldBucketsEnd) {
    initEmpty();


    const KeyT EmptyKey = getEmptyKey();
    const KeyT TombstoneKey = getTombstoneKey();
    for (BucketT *B = OldBucketsBegin, *E = OldBucketsEnd; B != E; ++B) {
      if (!KeyInfoT::isEqual(B->first, EmptyKey) &&
          !KeyInfoT::isEqual(B->first, TombstoneKey)) {

        BucketT *DestBucket;
        bool FoundVal = LookupBucketFor(B->first, DestBucket);
        (void)FoundVal;
        ((void)((!FoundVal && "Key already in new map?") || (__assert_fail("!FoundVal && \"Key already in new map?\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMap.h", 291, __func__),0)));
        DestBucket->first = (B->first);
        new (&DestBucket->second) ValueT((B->second));
        incrementNumEntries();


        B->second.~ValueT();
      }
      B->first.~KeyT();
    }


    if (OldBucketsBegin != OldBucketsEnd)
      memset((void*)OldBucketsBegin, 0x5a,
             sizeof(BucketT) * (OldBucketsEnd - OldBucketsBegin));

  }

  template <typename OtherBaseT>
  void copyFrom(const DenseMapBase<OtherBaseT, KeyT, ValueT, KeyInfoT>& other) {
    ((void)((getNumBuckets() == other.getNumBuckets()) || (__assert_fail("getNumBuckets() == other.getNumBuckets()", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMap.h", 311, __func__),0)));

    setNumEntries(other.getNumEntries());
    setNumTombstones(other.getNumTombstones());

    if (isPodLike<KeyT>::value && isPodLike<ValueT>::value)
      memcpy(getBuckets(), other.getBuckets(),
             getNumBuckets() * sizeof(BucketT));
    else
      for (size_t i = 0; i < getNumBuckets(); ++i) {
        new (&getBuckets()[i].first) KeyT(other.getBuckets()[i].first);
        if (!KeyInfoT::isEqual(getBuckets()[i].first, getEmptyKey()) &&
            !KeyInfoT::isEqual(getBuckets()[i].first, getTombstoneKey()))
          new (&getBuckets()[i].second) ValueT(other.getBuckets()[i].second);
      }
  }

  void swap(DenseMapBase& RHS) {
    std::swap(getNumEntries(), RHS.getNumEntries());
    std::swap(getNumTombstones(), RHS.getNumTombstones());
  }

  static unsigned getHashValue(const KeyT &Val) {
    return KeyInfoT::getHashValue(Val);
  }
  template<typename LookupKeyT>
  static unsigned getHashValue(const LookupKeyT &Val) {
    return KeyInfoT::getHashValue(Val);
  }
  static const KeyT getEmptyKey() {
    return KeyInfoT::getEmptyKey();
  }
  static const KeyT getTombstoneKey() {
    return KeyInfoT::getTombstoneKey();
  }

private:
  unsigned getNumEntries() const {
    return static_cast<const DerivedT *>(this)->getNumEntries();
  }
  void setNumEntries(unsigned Num) {
    static_cast<DerivedT *>(this)->setNumEntries(Num);
  }
  void incrementNumEntries() {
    setNumEntries(getNumEntries() + 1);
  }
  void decrementNumEntries() {
    setNumEntries(getNumEntries() - 1);
  }
  unsigned getNumTombstones() const {
    return static_cast<const DerivedT *>(this)->getNumTombstones();
  }
  void setNumTombstones(unsigned Num) {
    static_cast<DerivedT *>(this)->setNumTombstones(Num);
  }
  void incrementNumTombstones() {
    setNumTombstones(getNumTombstones() + 1);
  }
  void decrementNumTombstones() {
    setNumTombstones(getNumTombstones() - 1);
  }
  const BucketT *getBuckets() const {
    return static_cast<const DerivedT *>(this)->getBuckets();
  }
  BucketT *getBuckets() {
    return static_cast<DerivedT *>(this)->getBuckets();
  }
  unsigned getNumBuckets() const {
    return static_cast<const DerivedT *>(this)->getNumBuckets();
  }
  BucketT *getBucketsEnd() {
    return getBuckets() + getNumBuckets();
  }
  const BucketT *getBucketsEnd() const {
    return getBuckets() + getNumBuckets();
  }

  void grow(unsigned AtLeast) {
    static_cast<DerivedT *>(this)->grow(AtLeast);
  }

  void shrink_and_clear() {
    static_cast<DerivedT *>(this)->shrink_and_clear();
  }


  BucketT *InsertIntoBucket(const KeyT &Key, const ValueT &Value,
                            BucketT *TheBucket) {
    TheBucket = InsertIntoBucketImpl(Key, TheBucket);

    TheBucket->first = Key;
    new (&TheBucket->second) ValueT(Value);
    return TheBucket;
  }
# 425 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMap.h"
  BucketT *InsertIntoBucketImpl(const KeyT &Key, BucketT *TheBucket) {
# 435 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMap.h"
    unsigned NewNumEntries = getNumEntries() + 1;
    unsigned NumBuckets = getNumBuckets();
    if (NewNumEntries*4 >= NumBuckets*3) {
      this->grow(NumBuckets * 2);
      LookupBucketFor(Key, TheBucket);
      NumBuckets = getNumBuckets();
    } else if (NumBuckets-(NewNumEntries+getNumTombstones()) <= NumBuckets/8) {
      this->grow(NumBuckets);
      LookupBucketFor(Key, TheBucket);
    }
    ((void)((TheBucket) || (__assert_fail("TheBucket", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMap.h", 445, __func__),0)));



    incrementNumEntries();


    const KeyT EmptyKey = getEmptyKey();
    if (!KeyInfoT::isEqual(TheBucket->first, EmptyKey))
      decrementNumTombstones();

    return TheBucket;
  }





  template<typename LookupKeyT>
  bool LookupBucketFor(const LookupKeyT &Val,
                       const BucketT *&FoundBucket) const {
    const BucketT *BucketsPtr = getBuckets();
    const unsigned NumBuckets = getNumBuckets();

    if (NumBuckets == 0) {
      FoundBucket = 0;
      return false;
    }


    const BucketT *FoundTombstone = 0;
    const KeyT EmptyKey = getEmptyKey();
    const KeyT TombstoneKey = getTombstoneKey();
    ((void)((!KeyInfoT::isEqual(Val, EmptyKey) && !KeyInfoT::isEqual(Val, TombstoneKey) && "Empty/Tombstone value shouldn't be inserted into map!") || (__assert_fail("!KeyInfoT::isEqual(Val, EmptyKey) && !KeyInfoT::isEqual(Val, TombstoneKey) && \"Empty/Tombstone value shouldn't be inserted into map!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMap.h", 480, __func__),0)));



    unsigned BucketNo = getHashValue(Val) & (NumBuckets-1);
    unsigned ProbeAmt = 1;
    while (1) {
      const BucketT *ThisBucket = BucketsPtr + BucketNo;

      if (KeyInfoT::isEqual(Val, ThisBucket->first)) {
        FoundBucket = ThisBucket;
        return true;
      }



      if (KeyInfoT::isEqual(ThisBucket->first, EmptyKey)) {


        FoundBucket = FoundTombstone ? FoundTombstone : ThisBucket;
        return false;
      }



      if (KeyInfoT::isEqual(ThisBucket->first, TombstoneKey) && !FoundTombstone)
        FoundTombstone = ThisBucket;



      BucketNo += ProbeAmt++;
      BucketNo &= (NumBuckets-1);
    }
  }

  template <typename LookupKeyT>
  bool LookupBucketFor(const LookupKeyT &Val, BucketT *&FoundBucket) {
    const BucketT *ConstFoundBucket;
    bool Result = const_cast<const DenseMapBase *>(this)
      ->LookupBucketFor(Val, ConstFoundBucket);
    FoundBucket = const_cast<BucketT *>(ConstFoundBucket);
    return Result;
  }

public:




  size_t getMemorySize() const {
    return getNumBuckets() * sizeof(BucketT);
  }
};

template<typename KeyT, typename ValueT,
         typename KeyInfoT = DenseMapInfo<KeyT> >
class DenseMap
    : public DenseMapBase<DenseMap<KeyT, ValueT, KeyInfoT>,
                          KeyT, ValueT, KeyInfoT> {


  typedef DenseMapBase<DenseMap, KeyT, ValueT, KeyInfoT> BaseT;
  typedef typename BaseT::BucketT BucketT;
  friend class DenseMapBase<DenseMap, KeyT, ValueT, KeyInfoT>;

  BucketT *Buckets;
  unsigned NumEntries;
  unsigned NumTombstones;
  unsigned NumBuckets;

public:
  explicit DenseMap(unsigned NumInitBuckets = 0) {
    init(NumInitBuckets);
  }

  DenseMap(const DenseMap &other) : BaseT() {
    init(0);
    copyFrom(other);
  }
# 565 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMap.h"
  template<typename InputIt>
  DenseMap(const InputIt &I, const InputIt &E) {
    init(NextPowerOf2(std::distance(I, E)));
    this->insert(I, E);
  }

  ~DenseMap() {
    this->destroyAll();
    operator delete(Buckets);
  }

  void swap(DenseMap& RHS) {
    std::swap(Buckets, RHS.Buckets);
    std::swap(NumEntries, RHS.NumEntries);
    std::swap(NumTombstones, RHS.NumTombstones);
    std::swap(NumBuckets, RHS.NumBuckets);
  }

  DenseMap& operator=(const DenseMap& other) {
    copyFrom(other);
    return *this;
  }
# 598 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMap.h"
  void copyFrom(const DenseMap& other) {
    this->destroyAll();
    operator delete(Buckets);
    if (allocateBuckets(other.NumBuckets)) {
      this->BaseT::copyFrom(other);
    } else {
      NumEntries = 0;
      NumTombstones = 0;
    }
  }

  void init(unsigned InitBuckets) {
    if (allocateBuckets(InitBuckets)) {
      this->BaseT::initEmpty();
    } else {
      NumEntries = 0;
      NumTombstones = 0;
    }
  }

  void grow(unsigned AtLeast) {
    unsigned OldNumBuckets = NumBuckets;
    BucketT *OldBuckets = Buckets;

    allocateBuckets(std::max<unsigned>(64, static_cast<unsigned>(NextPowerOf2(AtLeast-1))));
    ((void)((Buckets) || (__assert_fail("Buckets", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMap.h", 623, __func__),0)));
    if (!OldBuckets) {
      this->BaseT::initEmpty();
      return;
    }

    this->moveFromOldBuckets(OldBuckets, OldBuckets+OldNumBuckets);


    operator delete(OldBuckets);
  }

  void shrink_and_clear() {
    unsigned OldNumEntries = NumEntries;
    this->destroyAll();


    unsigned NewNumBuckets = 0;
    if (OldNumEntries)
      NewNumBuckets = std::max(64, 1 << (Log2_32_Ceil(OldNumEntries) + 1));
    if (NewNumBuckets == NumBuckets) {
      this->BaseT::initEmpty();
      return;
    }

    operator delete(Buckets);
    init(NewNumBuckets);
  }

private:
  unsigned getNumEntries() const {
    return NumEntries;
  }
  void setNumEntries(unsigned Num) {
    NumEntries = Num;
  }

  unsigned getNumTombstones() const {
    return NumTombstones;
  }
  void setNumTombstones(unsigned Num) {
    NumTombstones = Num;
  }

  BucketT *getBuckets() const {
    return Buckets;
  }

  unsigned getNumBuckets() const {
    return NumBuckets;
  }

  bool allocateBuckets(unsigned Num) {
    NumBuckets = Num;
    if (NumBuckets == 0) {
      Buckets = 0;
      return false;
    }

    Buckets = static_cast<BucketT*>(operator new(sizeof(BucketT) * NumBuckets));
    return true;
  }
};

template<typename KeyT, typename ValueT,
         unsigned InlineBuckets = 4,
         typename KeyInfoT = DenseMapInfo<KeyT> >
class SmallDenseMap
    : public DenseMapBase<SmallDenseMap<KeyT, ValueT, InlineBuckets, KeyInfoT>,
                          KeyT, ValueT, KeyInfoT> {


  typedef DenseMapBase<SmallDenseMap, KeyT, ValueT, KeyInfoT> BaseT;
  typedef typename BaseT::BucketT BucketT;
  friend class DenseMapBase<SmallDenseMap, KeyT, ValueT, KeyInfoT>;

  unsigned Small : 1;
  unsigned NumEntries : 31;
  unsigned NumTombstones;

  struct LargeRep {
    BucketT *Buckets;
    unsigned NumBuckets;
  };



  AlignedCharArrayUnion<BucketT[InlineBuckets], LargeRep> storage;

public:
  explicit SmallDenseMap(unsigned NumInitBuckets = 0) {
    init(NumInitBuckets);
  }

  SmallDenseMap(const SmallDenseMap &other) : BaseT() {
    init(0);
    copyFrom(other);
  }
# 729 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMap.h"
  template<typename InputIt>
  SmallDenseMap(const InputIt &I, const InputIt &E) {
    init(NextPowerOf2(std::distance(I, E)));
    this->insert(I, E);
  }

  ~SmallDenseMap() {
    this->destroyAll();
    deallocateBuckets();
  }

  void swap(SmallDenseMap& RHS) {
    unsigned TmpNumEntries = RHS.NumEntries;
    RHS.NumEntries = NumEntries;
    NumEntries = TmpNumEntries;
    std::swap(NumTombstones, RHS.NumTombstones);

    const KeyT EmptyKey = this->getEmptyKey();
    const KeyT TombstoneKey = this->getTombstoneKey();
    if (Small && RHS.Small) {




      for (unsigned i = 0, e = InlineBuckets; i != e; ++i) {
        BucketT *LHSB = &getInlineBuckets()[i],
                *RHSB = &RHS.getInlineBuckets()[i];
        bool hasLHSValue = (!KeyInfoT::isEqual(LHSB->first, EmptyKey) &&
                            !KeyInfoT::isEqual(LHSB->first, TombstoneKey));
        bool hasRHSValue = (!KeyInfoT::isEqual(RHSB->first, EmptyKey) &&
                            !KeyInfoT::isEqual(RHSB->first, TombstoneKey));
        if (hasLHSValue && hasRHSValue) {

          std::swap(*LHSB, *RHSB);
          continue;
        }

        std::swap(LHSB->first, RHSB->first);
        if (hasLHSValue) {
          new (&RHSB->second) ValueT((LHSB->second));
          LHSB->second.~ValueT();
        } else if (hasRHSValue) {
          new (&LHSB->second) ValueT((RHSB->second));
          RHSB->second.~ValueT();
        }
      }
      return;
    }
    if (!Small && !RHS.Small) {
      std::swap(getLargeRep()->Buckets, RHS.getLargeRep()->Buckets);
      std::swap(getLargeRep()->NumBuckets, RHS.getLargeRep()->NumBuckets);
      return;
    }

    SmallDenseMap &SmallSide = Small ? *this : RHS;
    SmallDenseMap &LargeSide = Small ? RHS : *this;


    LargeRep TmpRep = (*LargeSide.getLargeRep());
    LargeSide.getLargeRep()->~LargeRep();
    LargeSide.Small = true;




    for (unsigned i = 0, e = InlineBuckets; i != e; ++i) {
      BucketT *NewB = &LargeSide.getInlineBuckets()[i],
              *OldB = &SmallSide.getInlineBuckets()[i];
      new (&NewB->first) KeyT((OldB->first));
      OldB->first.~KeyT();
      if (!KeyInfoT::isEqual(NewB->first, EmptyKey) &&
          !KeyInfoT::isEqual(NewB->first, TombstoneKey)) {
        new (&NewB->second) ValueT((OldB->second));
        OldB->second.~ValueT();
      }
    }



    SmallSide.Small = false;
    new (SmallSide.getLargeRep()) LargeRep((TmpRep));
  }

  SmallDenseMap& operator=(const SmallDenseMap& other) {
    copyFrom(other);
    return *this;
  }
# 827 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMap.h"
  void copyFrom(const SmallDenseMap& other) {
    this->destroyAll();
    deallocateBuckets();
    Small = true;
    if (other.getNumBuckets() > InlineBuckets) {
      Small = false;
      allocateBuckets(other.getNumBuckets());
    }
    this->BaseT::copyFrom(other);
  }

  void init(unsigned InitBuckets) {
    Small = true;
    if (InitBuckets > InlineBuckets) {
      Small = false;
      new (getLargeRep()) LargeRep(allocateBuckets(InitBuckets));
    }
    this->BaseT::initEmpty();
  }

  void grow(unsigned AtLeast) {
    if (AtLeast >= InlineBuckets)
      AtLeast = std::max<unsigned>(64, NextPowerOf2(AtLeast-1));

    if (Small) {
      if (AtLeast < InlineBuckets)
        return;


      AlignedCharArrayUnion<BucketT[InlineBuckets]> TmpStorage;
      BucketT *TmpBegin = reinterpret_cast<BucketT *>(TmpStorage.buffer);
      BucketT *TmpEnd = TmpBegin;



      const KeyT EmptyKey = this->getEmptyKey();
      const KeyT TombstoneKey = this->getTombstoneKey();
      for (BucketT *P = getBuckets(), *E = P + InlineBuckets; P != E; ++P) {
        if (!KeyInfoT::isEqual(P->first, EmptyKey) &&
            !KeyInfoT::isEqual(P->first, TombstoneKey)) {
          ((void)((size_t(TmpEnd - TmpBegin) < InlineBuckets && "Too many inline buckets!") || (__assert_fail("size_t(TmpEnd - TmpBegin) < InlineBuckets && \"Too many inline buckets!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMap.h", 868, __func__),0)));

          new (&TmpEnd->first) KeyT((P->first));
          new (&TmpEnd->second) ValueT((P->second));
          ++TmpEnd;
          P->second.~ValueT();
        }
        P->first.~KeyT();
      }



      Small = false;
      new (getLargeRep()) LargeRep(allocateBuckets(AtLeast));
      this->moveFromOldBuckets(TmpBegin, TmpEnd);
      return;
    }

    LargeRep OldRep = (*getLargeRep());
    getLargeRep()->~LargeRep();
    if (AtLeast <= InlineBuckets) {
      Small = true;
    } else {
      new (getLargeRep()) LargeRep(allocateBuckets(AtLeast));
    }

    this->moveFromOldBuckets(OldRep.Buckets, OldRep.Buckets+OldRep.NumBuckets);


    operator delete(OldRep.Buckets);
  }

  void shrink_and_clear() {
    unsigned OldSize = this->size();
    this->destroyAll();


    unsigned NewNumBuckets = 0;
    if (OldSize) {
      NewNumBuckets = 1 << (Log2_32_Ceil(OldSize) + 1);
      if (NewNumBuckets > InlineBuckets && NewNumBuckets < 64u)
        NewNumBuckets = 64;
    }
    if ((Small && NewNumBuckets <= InlineBuckets) ||
        (!Small && NewNumBuckets == getLargeRep()->NumBuckets)) {
      this->BaseT::initEmpty();
      return;
    }

    deallocateBuckets();
    init(NewNumBuckets);
  }

private:
  unsigned getNumEntries() const {
    return NumEntries;
  }
  void setNumEntries(unsigned Num) {
    ((void)((Num < 0x7fffffff && "Cannot support more than INT_MAX entries") || (__assert_fail("Num < INT_MAX && \"Cannot support more than INT_MAX entries\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMap.h", 925, __func__),0)));
    NumEntries = Num;
  }

  unsigned getNumTombstones() const {
    return NumTombstones;
  }
  void setNumTombstones(unsigned Num) {
    NumTombstones = Num;
  }

  const BucketT *getInlineBuckets() const {
    ((void)((Small) || (__assert_fail("Small", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMap.h", 937, __func__),0)));



    return reinterpret_cast<const BucketT *>(storage.buffer);
  }
  BucketT *getInlineBuckets() {
    return const_cast<BucketT *>(
      const_cast<const SmallDenseMap *>(this)->getInlineBuckets());
  }
  const LargeRep *getLargeRep() const {
    ((void)((!Small) || (__assert_fail("!Small", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMap.h", 948, __func__),0)));

    return reinterpret_cast<const LargeRep *>(storage.buffer);
  }
  LargeRep *getLargeRep() {
    return const_cast<LargeRep *>(
      const_cast<const SmallDenseMap *>(this)->getLargeRep());
  }

  const BucketT *getBuckets() const {
    return Small ? getInlineBuckets() : getLargeRep()->Buckets;
  }
  BucketT *getBuckets() {
    return const_cast<BucketT *>(
      const_cast<const SmallDenseMap *>(this)->getBuckets());
  }
  unsigned getNumBuckets() const {
    return Small ? InlineBuckets : getLargeRep()->NumBuckets;
  }

  void deallocateBuckets() {
    if (Small)
      return;

    operator delete(getLargeRep()->Buckets);
    getLargeRep()->~LargeRep();
  }

  LargeRep allocateBuckets(unsigned Num) {
    ((void)((Num > InlineBuckets && "Must allocate more buckets than are inline") || (__assert_fail("Num > InlineBuckets && \"Must allocate more buckets than are inline\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DenseMap.h", 977, __func__),0)));
    LargeRep Rep = {
      static_cast<BucketT*>(operator new(sizeof(BucketT) * Num)), Num
    };
    return Rep;
  }
};

template<typename KeyT, typename ValueT,
         typename KeyInfoT, bool IsConst>
class DenseMapIterator {
  typedef std::pair<KeyT, ValueT> Bucket;
  typedef DenseMapIterator<KeyT, ValueT,
                           KeyInfoT, true> ConstIterator;
  friend class DenseMapIterator<KeyT, ValueT, KeyInfoT, true>;
public:
  typedef ptrdiff_t difference_type;
  typedef typename conditional<IsConst, const Bucket, Bucket>::type value_type;
  typedef value_type *pointer;
  typedef value_type &reference;
  typedef std::forward_iterator_tag iterator_category;
private:
  pointer Ptr, End;
public:
  DenseMapIterator() : Ptr(0), End(0) {}

  DenseMapIterator(pointer Pos, pointer E, bool NoAdvance = false)
    : Ptr(Pos), End(E) {
    if (!NoAdvance) AdvancePastEmptyBuckets();
  }




  DenseMapIterator(const DenseMapIterator<KeyT, ValueT,
                                          KeyInfoT, false>& I)
    : Ptr(I.Ptr), End(I.End) {}

  reference operator*() const {
    return *Ptr;
  }
  pointer operator->() const {
    return Ptr;
  }

  bool operator==(const ConstIterator &RHS) const {
    return Ptr == RHS.operator->();
  }
  bool operator!=(const ConstIterator &RHS) const {
    return Ptr != RHS.operator->();
  }

  inline DenseMapIterator& operator++() {
    ++Ptr;
    AdvancePastEmptyBuckets();
    return *this;
  }
  DenseMapIterator operator++(int) {
    DenseMapIterator tmp = *this; ++*this; return tmp;
  }

private:
  void AdvancePastEmptyBuckets() {
    const KeyT Empty = KeyInfoT::getEmptyKey();
    const KeyT Tombstone = KeyInfoT::getTombstoneKey();

    while (Ptr != End &&
           (KeyInfoT::isEqual(Ptr->first, Empty) ||
            KeyInfoT::isEqual(Ptr->first, Tombstone)))
      ++Ptr;
  }
};

template<typename KeyT, typename ValueT, typename KeyInfoT>
static inline size_t
capacity_in_bytes(const DenseMap<KeyT, ValueT, KeyInfoT> &X) {
  return X.getMemorySize();
}

}
# 41 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/AliasAnalysis.h" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CallSite.h" 1
# 29 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CallSite.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/PointerIntPair.h" 1
# 19 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/PointerIntPair.h"
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 1 3
# 21 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/assert.h" 1 3
# 12 "/mnt/home/ec2-user/build/emscripten/system/include/libc/assert.h" 3
extern "C" {



__attribute__((__noreturn__))

void __assert_fail (const char *, const char *, int, const char *);


}
# 22 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 2 3
# 25 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 3
# 20 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/PointerIntPair.h" 2

namespace llvm {

template<typename T>
struct DenseMapInfo;
# 40 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/PointerIntPair.h"
template <typename PointerTy, unsigned IntBits, typename IntType=unsigned,
          typename PtrTraits = PointerLikeTypeTraits<PointerTy> >
class PointerIntPair {
  intptr_t Value;
  enum {

    PointerBitMask =
      ~(uintptr_t)(((intptr_t)1 << PtrTraits::NumLowBitsAvailable)-1),



    IntShift = (uintptr_t)PtrTraits::NumLowBitsAvailable-IntBits,


    IntMask = (uintptr_t)(((intptr_t)1 << IntBits)-1),


    ShiftedIntMask = (uintptr_t)(IntMask << IntShift)
  };
public:
  PointerIntPair() : Value(0) {}
  PointerIntPair(PointerTy PtrVal, IntType IntVal) {
    ((void)((IntBits <= PtrTraits::NumLowBitsAvailable && "PointerIntPair formed with integer size too large for pointer") || (__assert_fail("IntBits <= PtrTraits::NumLowBitsAvailable && \"PointerIntPair formed with integer size too large for pointer\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/PointerIntPair.h", 63, __func__),0)));

    setPointerAndInt(PtrVal, IntVal);
  }
  explicit PointerIntPair(PointerTy PtrVal) {
    initWithPointer(PtrVal);
  }

  PointerTy getPointer() const {
    return PtrTraits::getFromVoidPointer(
                         reinterpret_cast<void*>(Value & PointerBitMask));
  }

  IntType getInt() const {
    return (IntType)((Value >> IntShift) & IntMask);
  }

  void setPointer(PointerTy PtrVal) {
    intptr_t PtrWord
      = reinterpret_cast<intptr_t>(PtrTraits::getAsVoidPointer(PtrVal));
    ((void)(((PtrWord & ((1 << PtrTraits::NumLowBitsAvailable)-1)) == 0 && "Pointer is not sufficiently aligned") || (__assert_fail("(PtrWord & ((1 << PtrTraits::NumLowBitsAvailable)-1)) == 0 && \"Pointer is not sufficiently aligned\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/PointerIntPair.h", 83, __func__),0)));


    Value = PtrWord | (Value & ~PointerBitMask);
  }

  void setInt(IntType IntVal) {
    intptr_t IntWord = static_cast<intptr_t>(IntVal);
    ((void)((IntWord < (1 << IntBits) && "Integer too large for field") || (__assert_fail("IntWord < (1 << IntBits) && \"Integer too large for field\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/PointerIntPair.h", 90, __func__),0)));


    Value &= ~ShiftedIntMask;
    Value |= IntWord << IntShift;
  }

  void initWithPointer(PointerTy PtrVal) {
    intptr_t PtrWord
      = reinterpret_cast<intptr_t>(PtrTraits::getAsVoidPointer(PtrVal));
    ((void)(((PtrWord & ((1 << PtrTraits::NumLowBitsAvailable)-1)) == 0 && "Pointer is not sufficiently aligned") || (__assert_fail("(PtrWord & ((1 << PtrTraits::NumLowBitsAvailable)-1)) == 0 && \"Pointer is not sufficiently aligned\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/PointerIntPair.h", 101, __func__),0)));

    Value = PtrWord;
  }

  void setPointerAndInt(PointerTy PtrVal, IntType IntVal) {
    intptr_t PtrWord
      = reinterpret_cast<intptr_t>(PtrTraits::getAsVoidPointer(PtrVal));
    ((void)(((PtrWord & ((1 << PtrTraits::NumLowBitsAvailable)-1)) == 0 && "Pointer is not sufficiently aligned") || (__assert_fail("(PtrWord & ((1 << PtrTraits::NumLowBitsAvailable)-1)) == 0 && \"Pointer is not sufficiently aligned\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/PointerIntPair.h", 109, __func__),0)));

    intptr_t IntWord = static_cast<intptr_t>(IntVal);
    ((void)((IntWord < (1 << IntBits) && "Integer too large for field") || (__assert_fail("IntWord < (1 << IntBits) && \"Integer too large for field\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/PointerIntPair.h", 111, __func__),0)));

    Value = PtrWord | (IntWord << IntShift);
  }

  PointerTy const *getAddrOfPointer() const {
    return const_cast<PointerIntPair *>(this)->getAddrOfPointer();
  }

  PointerTy *getAddrOfPointer() {
    ((void)((Value == reinterpret_cast<intptr_t>(getPointer()) && "Can only return the address if IntBits is cleared and " "PtrTraits doesn't change the pointer") || (__assert_fail("Value == reinterpret_cast<intptr_t>(getPointer()) && \"Can only return the address if IntBits is cleared and \" \"PtrTraits doesn't change the pointer\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/PointerIntPair.h", 123, __func__),0)));


    return reinterpret_cast<PointerTy *>(&Value);
  }

  void *getOpaqueValue() const { return reinterpret_cast<void*>(Value); }
  void setFromOpaqueValue(void *Val) { Value = reinterpret_cast<intptr_t>(Val);}

  static PointerIntPair getFromOpaqueValue(void *V) {
    PointerIntPair P; P.setFromOpaqueValue(V); return P;
  }



  static PointerIntPair getFromOpaqueValue(const void *V) {
    (void)PtrTraits::getFromVoidPointer(V);
    return getFromOpaqueValue(const_cast<void *>(V));
  }

  bool operator==(const PointerIntPair &RHS) const {return Value == RHS.Value;}
  bool operator!=(const PointerIntPair &RHS) const {return Value != RHS.Value;}
  bool operator<(const PointerIntPair &RHS) const {return Value < RHS.Value;}
  bool operator>(const PointerIntPair &RHS) const {return Value > RHS.Value;}
  bool operator<=(const PointerIntPair &RHS) const {return Value <= RHS.Value;}
  bool operator>=(const PointerIntPair &RHS) const {return Value >= RHS.Value;}
};

template <typename T> struct isPodLike;
template<typename PointerTy, unsigned IntBits, typename IntType>
struct isPodLike<PointerIntPair<PointerTy, IntBits, IntType> > {
   static const bool value = true;
};


template<typename PointerTy, unsigned IntBits, typename IntType>
struct DenseMapInfo<PointerIntPair<PointerTy, IntBits, IntType> > {
  typedef PointerIntPair<PointerTy, IntBits, IntType> Ty;
  static Ty getEmptyKey() {
    uintptr_t Val = static_cast<uintptr_t>(-1);
    Val <<= PointerLikeTypeTraits<PointerTy>::NumLowBitsAvailable;
    return Ty(reinterpret_cast<PointerTy>(Val), IntType((1 << IntBits)-1));
  }
  static Ty getTombstoneKey() {
    uintptr_t Val = static_cast<uintptr_t>(-2);
    Val <<= PointerLikeTypeTraits<PointerTy>::NumLowBitsAvailable;
    return Ty(reinterpret_cast<PointerTy>(Val), IntType(0));
  }
  static unsigned getHashValue(Ty V) {
    uintptr_t IV = reinterpret_cast<uintptr_t>(V.getOpaqueValue());
    return unsigned(IV) ^ unsigned(IV >> 9);
  }
  static bool isEqual(const Ty &LHS, const Ty &RHS) { return LHS == RHS; }
};


template<typename PointerTy, unsigned IntBits, typename IntType,
         typename PtrTraits>
class PointerLikeTypeTraits<PointerIntPair<PointerTy, IntBits, IntType,
                                           PtrTraits> > {
public:
  static inline void *
  getAsVoidPointer(const PointerIntPair<PointerTy, IntBits, IntType> &P) {
    return P.getOpaqueValue();
  }
  static inline PointerIntPair<PointerTy, IntBits, IntType>
  getFromVoidPointer(void *P) {
    return PointerIntPair<PointerTy, IntBits, IntType>::getFromOpaqueValue(P);
  }
  static inline PointerIntPair<PointerTy, IntBits, IntType>
  getFromVoidPointer(const void *P) {
    return PointerIntPair<PointerTy, IntBits, IntType>::getFromOpaqueValue(P);
  }
  enum {
    NumLowBitsAvailable = PtrTraits::NumLowBitsAvailable - IntBits
  };
};

}
# 30 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CallSite.h" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Attributes.h" 1
# 19 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Attributes.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ArrayRef.h" 1
# 13 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ArrayRef.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/None.h" 1
# 19 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/None.h"
namespace llvm {


enum NoneType {
  None
};
}
# 14 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ArrayRef.h" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallVector.h" 1
# 22 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallVector.h"
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 1 3
# 21 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/assert.h" 1 3
# 12 "/mnt/home/ec2-user/build/emscripten/system/include/libc/assert.h" 3
extern "C" {



__attribute__((__noreturn__))

void __assert_fail (const char *, const char *, int, const char *);


}
# 22 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 2 3
# 25 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 3
# 23 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallVector.h" 2

# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cstdlib" 1 3
# 86 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cstdlib" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/compat/stdlib.h" 1 3




extern "C" {


int getloadavg(double loadavg[], int nelem);


}



# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/stdlib.h" 1 3




extern "C" {
# 19 "/mnt/home/ec2-user/build/emscripten/system/include/libc/stdlib.h" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 1 3
# 20 "/mnt/home/ec2-user/build/emscripten/system/include/libc/stdlib.h" 2 3

int atoi (const char *);
long atol (const char *);
long long atoll (const char *);
double atof (const char *);

float strtof (const char *__restrict, char **__restrict);
double strtod (const char *__restrict, char **__restrict);
long double strtold (const char *__restrict, char **__restrict);

long strtol (const char *__restrict, char **__restrict, int);
unsigned long strtoul (const char *__restrict, char **__restrict, int);
long long strtoll (const char *__restrict, char **__restrict, int);
unsigned long long strtoull (const char *__restrict, char **__restrict, int);

int rand (void);
void srand (unsigned);

void *malloc (size_t);
void *calloc (size_t, size_t);
void *realloc (void *, size_t);
void free (void *);
void *aligned_alloc(size_t alignment, size_t size);

__attribute__((__noreturn__)) void abort (void);
int atexit (void (*) (void));
__attribute__((__noreturn__)) void exit (int);
__attribute__((__noreturn__)) void _Exit (int);
int at_quick_exit (void (*) (void));
__attribute__((__noreturn__)) void quick_exit (int);

char *getenv (const char *);

int system (const char *);

void *bsearch (const void *, const void *, size_t, size_t, int (*)(const void *, const void *));
void qsort (void *, size_t, size_t, int (*)(const void *, const void *));

int abs (int);
long labs (long);
long long llabs (long long);

typedef struct { int quot, rem; } div_t;
typedef struct { long quot, rem; } ldiv_t;
typedef struct { long long quot, rem; } lldiv_t;

div_t div (int, int);
ldiv_t ldiv (long, long);
lldiv_t lldiv (long long, long long);

int mblen (const char *, size_t);
int mbtowc (wchar_t *__restrict, const char *__restrict, size_t);
int wctomb (char *, wchar_t);
size_t mbstowcs (wchar_t *__restrict, const char *__restrict, size_t);
size_t wcstombs (char *__restrict, const wchar_t *__restrict, size_t);
# 98 "/mnt/home/ec2-user/build/emscripten/system/include/libc/stdlib.h" 3
int posix_memalign (void **, size_t, size_t);
int setenv (const char *, const char *, int);
int unsetenv (const char *);
int mkstemp (char *);
int mkostemp (char *, int);
char *mkdtemp (char *);
int getsubopt (char **, char *const *, char **);
int rand_r (unsigned *);






char *realpath (const char *__restrict, char *__restrict);
long int random (void);
void srandom (unsigned int);
char *initstate (unsigned int, char *, size_t);
char *setstate (char *);



int putenv (char *);
int posix_openpt (int);
int grantpt (int);
int unlockpt (int);
char *ptsname (int);
char *l64a (long);
long a64l (const char *);
void setkey (const char *);
double drand48 (void);
double erand48 (unsigned short [3]);
long int lrand48 (void);
long int nrand48 (unsigned short [3]);
long mrand48 (void);
long jrand48 (unsigned short [3]);
void srand48 (long);
unsigned short *seed48 (unsigned short [3]);
void lcong48 (unsigned short [7]);




# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/alloca.h" 1 3




extern "C" {




# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 1 3
# 10 "/mnt/home/ec2-user/build/emscripten/system/include/libc/alloca.h" 2 3

void *alloca(size_t);






}
# 141 "/mnt/home/ec2-user/build/emscripten/system/include/libc/stdlib.h" 2 3
char *mktemp (char *);
int mkstemps (char *, int);
int mkostemps (char *, int, int);
void *valloc (size_t);
void *memalign(size_t, size_t);
int getloadavg(double *, int);





int clearenv(void);
int ptsname_r(int, char *, size_t);
char *ecvt(double, int, int *, int *);
char *fcvt(double, int, int *, int *);
char *gcvt(double, int, char *);
struct __locale_struct;
float strtof_l(const char *__restrict, char **__restrict, struct __locale_struct *);
double strtod_l(const char *__restrict, char **__restrict, struct __locale_struct *);
long double strtold_l(const char *__restrict, char **__restrict, struct __locale_struct *);
# 173 "/mnt/home/ec2-user/build/emscripten/system/include/libc/stdlib.h" 3
}
# 15 "/mnt/home/ec2-user/build/emscripten/system/include/compat/stdlib.h" 2 3
# 87 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cstdlib" 2 3
# 93 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cstdlib" 3


namespace std {inline namespace __1 {

using ::size_t;
using ::div_t;
using ::ldiv_t;

using ::lldiv_t;

using ::atof;
using ::atoi;
using ::atol;

using ::atoll;

using ::strtod;
using ::strtof;
using ::strtold;
using ::strtol;

using ::strtoll;

using ::strtoul;

using ::strtoull;

using ::rand;
using ::srand;
using ::calloc;
using ::free;
using ::malloc;
using ::realloc;
using ::abort;
using ::atexit;
using ::exit;
using ::_Exit;
using ::getenv;
using ::system;
using ::bsearch;
using ::qsort;
using ::abs;
using ::labs;

using ::llabs;

using ::div;
using ::ldiv;

using ::lldiv;

using ::mblen;
using ::mbtowc;
using ::wctomb;
using ::mbstowcs;
using ::wcstombs;
# 159 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cstdlib" 3
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long abs( long __x) throw() {return labs(__x);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long abs(long long __x) throw() {return llabs(__x);}


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) ldiv_t div( long __x, long __y) throw() {return ldiv(__x, __y);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) lldiv_t div(long long __x, long long __y) throw() {return lldiv(__x, __y);}



} }
# 25 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallVector.h" 2




namespace llvm {



class SmallVectorBase {
protected:
  void *BeginX, *EndX, *CapacityX;

protected:
  SmallVectorBase(void *FirstEl, size_t Size)
    : BeginX(FirstEl), EndX(FirstEl), CapacityX((char*)FirstEl+Size) {}



  void grow_pod(void *FirstEl, size_t MinSizeInBytes, size_t TSize);

public:

  size_t size_in_bytes() const {
    return size_t((char*)EndX - (char*)BeginX);
  }


  size_t capacity_in_bytes() const {
    return size_t((char*)CapacityX - (char*)BeginX);
  }

  bool __attribute__((__warn_unused_result__)) empty() const { return BeginX == EndX; }
};

template <typename T, unsigned N> struct SmallVectorStorage;





template <typename T, typename = void>
class SmallVectorTemplateCommon : public SmallVectorBase {
private:
  template <typename, unsigned> friend struct SmallVectorStorage;




  typedef llvm::AlignedCharArrayUnion<T> U;
  U FirstEl;


protected:
  SmallVectorTemplateCommon(size_t Size) : SmallVectorBase(&FirstEl, Size) {}

  void grow_pod(size_t MinSizeInBytes, size_t TSize) {
    SmallVectorBase::grow_pod(&FirstEl, MinSizeInBytes, TSize);
  }



  bool isSmall() const {
    return BeginX == static_cast<const void*>(&FirstEl);
  }


  void resetToSmall() {
    BeginX = EndX = CapacityX = &FirstEl;
  }

  void setEnd(T *P) { this->EndX = P; }
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef T value_type;
  typedef T *iterator;
  typedef const T *const_iterator;

  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;

  typedef T &reference;
  typedef const T &const_reference;
  typedef T *pointer;
  typedef const T *const_pointer;


  iterator begin() { return (iterator)this->BeginX; }
  const_iterator begin() const { return (const_iterator)this->BeginX; }
  iterator end() { return (iterator)this->EndX; }
  const_iterator end() const { return (const_iterator)this->EndX; }
protected:
  iterator capacity_ptr() { return (iterator)this->CapacityX; }
  const_iterator capacity_ptr() const { return (const_iterator)this->CapacityX;}
public:


  reverse_iterator rbegin() { return reverse_iterator(end()); }
  const_reverse_iterator rbegin() const{ return const_reverse_iterator(end()); }
  reverse_iterator rend() { return reverse_iterator(begin()); }
  const_reverse_iterator rend() const { return const_reverse_iterator(begin());}

  size_type size() const { return end()-begin(); }
  size_type max_size() const { return size_type(-1) / sizeof(T); }



  size_t capacity() const { return capacity_ptr() - begin(); }


  pointer data() { return pointer(begin()); }

  const_pointer data() const { return const_pointer(begin()); }

  reference operator[](unsigned idx) {
    ((void)((begin() + idx < end()) || (__assert_fail("begin() + idx < end()", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallVector.h", 140, __func__),0)));
    return begin()[idx];
  }
  const_reference operator[](unsigned idx) const {
    ((void)((begin() + idx < end()) || (__assert_fail("begin() + idx < end()", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallVector.h", 144, __func__),0)));
    return begin()[idx];
  }

  reference front() {
    ((void)((!empty()) || (__assert_fail("!empty()", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallVector.h", 149, __func__),0)));
    return begin()[0];
  }
  const_reference front() const {
    ((void)((!empty()) || (__assert_fail("!empty()", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallVector.h", 153, __func__),0)));
    return begin()[0];
  }

  reference back() {
    ((void)((!empty()) || (__assert_fail("!empty()", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallVector.h", 158, __func__),0)));
    return end()[-1];
  }
  const_reference back() const {
    ((void)((!empty()) || (__assert_fail("!empty()", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallVector.h", 162, __func__),0)));
    return end()[-1];
  }
};



template <typename T, bool isPodLike>
class SmallVectorTemplateBase : public SmallVectorTemplateCommon<T> {
protected:
  SmallVectorTemplateBase(size_t Size) : SmallVectorTemplateCommon<T>(Size) {}

  static void destroy_range(T *S, T *E) {
    while (S != E) {
      --E;
      E->~T();
    }
  }




  template<typename It1, typename It2>
  static It2 move(It1 I, It1 E, It2 Dest) {





    return ::std::copy(I, E, Dest);

  }





  template<typename It1, typename It2>
  static It2 move_backward(It1 I, It1 E, It2 Dest) {





    return ::std::copy_backward(I, E, Dest);

  }



  template<typename It1, typename It2>
  static void uninitialized_move(It1 I, It1 E, It2 Dest) {




    ::std::uninitialized_copy(I, E, Dest);

  }



  template<typename It1, typename It2>
  static void uninitialized_copy(It1 I, It1 E, It2 Dest) {
    std::uninitialized_copy(I, E, Dest);
  }





  void grow(size_t MinSize = 0);

public:
  void push_back(const T &Elt) {
    if (this->EndX < this->CapacityX) {
    Retry:
      ::new ((void*) this->end()) T(Elt);
      this->setEnd(this->end()+1);
      return;
    }
    this->grow();
    goto Retry;
  }
# 260 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallVector.h"
  void pop_back() {
    this->setEnd(this->end()-1);
    this->end()->~T();
  }
};


template <typename T, bool isPodLike>
void SmallVectorTemplateBase<T, isPodLike>::grow(size_t MinSize) {
  size_t CurCapacity = this->capacity();
  size_t CurSize = this->size();

  size_t NewCapacity = size_t(NextPowerOf2(CurCapacity+2));
  if (NewCapacity < MinSize)
    NewCapacity = MinSize;
  T *NewElts = static_cast<T*>(malloc(NewCapacity*sizeof(T)));


  this->uninitialized_move(this->begin(), this->end(), NewElts);


  destroy_range(this->begin(), this->end());


  if (!this->isSmall())
    free(this->begin());

  this->setEnd(NewElts+CurSize);
  this->BeginX = NewElts;
  this->CapacityX = this->begin()+NewCapacity;
}




template <typename T>
class SmallVectorTemplateBase<T, true> : public SmallVectorTemplateCommon<T> {
protected:
  SmallVectorTemplateBase(size_t Size) : SmallVectorTemplateCommon<T>(Size) {}


  static void destroy_range(T *, T *) {}



  template<typename It1, typename It2>
  static It2 move(It1 I, It1 E, It2 Dest) {
    return ::std::copy(I, E, Dest);
  }




  template<typename It1, typename It2>
  static It2 move_backward(It1 I, It1 E, It2 Dest) {
    return ::std::copy_backward(I, E, Dest);
  }



  template<typename It1, typename It2>
  static void uninitialized_move(It1 I, It1 E, It2 Dest) {

    uninitialized_copy(I, E, Dest);
  }



  template<typename It1, typename It2>
  static void uninitialized_copy(It1 I, It1 E, It2 Dest) {

    std::uninitialized_copy(I, E, Dest);
  }



  template<typename T1, typename T2>
  static void uninitialized_copy(T1 *I, T1 *E, T2 *Dest) {



    memcpy(Dest, I, (E-I)*sizeof(T));
  }



  void grow(size_t MinSize = 0) {
    this->grow_pod(MinSize*sizeof(T), sizeof(T));
  }
public:
  void push_back(const T &Elt) {
    if (this->EndX < this->CapacityX) {
    Retry:
      memcpy(this->end(), &Elt, sizeof(T));
      this->setEnd(this->end()+1);
      return;
    }
    this->grow();
    goto Retry;
  }

  void pop_back() {
    this->setEnd(this->end()-1);
  }
};





template <typename T>
class SmallVectorImpl : public SmallVectorTemplateBase<T, isPodLike<T>::value> {
  typedef SmallVectorTemplateBase<T, isPodLike<T>::value > SuperClass;

  SmallVectorImpl(const SmallVectorImpl&) ;
public:
  typedef typename SuperClass::iterator iterator;
  typedef typename SuperClass::size_type size_type;

protected:

  explicit SmallVectorImpl(unsigned N)
    : SmallVectorTemplateBase<T, isPodLike<T>::value>(N*sizeof(T)) {
  }

public:
  ~SmallVectorImpl() {

    this->destroy_range(this->begin(), this->end());


    if (!this->isSmall())
      free(this->begin());
  }


  void clear() {
    this->destroy_range(this->begin(), this->end());
    this->EndX = this->BeginX;
  }

  void resize(unsigned N) {
    if (N < this->size()) {
      this->destroy_range(this->begin()+N, this->end());
      this->setEnd(this->begin()+N);
    } else if (N > this->size()) {
      if (this->capacity() < N)
        this->grow(N);
      std::uninitialized_fill(this->end(), this->begin()+N, T());
      this->setEnd(this->begin()+N);
    }
  }

  void resize(unsigned N, const T &NV) {
    if (N < this->size()) {
      this->destroy_range(this->begin()+N, this->end());
      this->setEnd(this->begin()+N);
    } else if (N > this->size()) {
      if (this->capacity() < N)
        this->grow(N);
      std::uninitialized_fill(this->end(), this->begin()+N, NV);
      this->setEnd(this->begin()+N);
    }
  }

  void reserve(unsigned N) {
    if (this->capacity() < N)
      this->grow(N);
  }

  T __attribute__((__warn_unused_result__)) pop_back_val() {



    T Result = this->back();

    this->pop_back();
    return Result;
  }

  void swap(SmallVectorImpl &RHS);



  template<typename in_iter>
  void append(in_iter in_start, in_iter in_end) {
    size_type NumInputs = std::distance(in_start, in_end);

    if (NumInputs > size_type(this->capacity_ptr()-this->end()))
      this->grow(this->size()+NumInputs);




    std::uninitialized_copy(in_start, in_end, this->end());
    this->setEnd(this->end() + NumInputs);
  }



  void append(size_type NumInputs, const T &Elt) {

    if (NumInputs > size_type(this->capacity_ptr()-this->end()))
      this->grow(this->size()+NumInputs);


    std::uninitialized_fill_n(this->end(), NumInputs, Elt);
    this->setEnd(this->end() + NumInputs);
  }

  void assign(unsigned NumElts, const T &Elt) {
    clear();
    if (this->capacity() < NumElts)
      this->grow(NumElts);
    this->setEnd(this->begin()+NumElts);
    std::uninitialized_fill(this->begin(), this->end(), Elt);
  }

  iterator erase(iterator I) {
    ((void)((I >= this->begin() && "Iterator to erase is out of bounds.") || (__assert_fail("I >= this->begin() && \"Iterator to erase is out of bounds.\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallVector.h", 479, __func__),0)));
    ((void)((I < this->end() && "Erasing at past-the-end iterator.") || (__assert_fail("I < this->end() && \"Erasing at past-the-end iterator.\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallVector.h", 480, __func__),0)));

    iterator N = I;

    this->move(I+1, this->end(), I);

    this->pop_back();
    return(N);
  }

  iterator erase(iterator S, iterator E) {
    ((void)((S >= this->begin() && "Range to erase is out of bounds.") || (__assert_fail("S >= this->begin() && \"Range to erase is out of bounds.\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallVector.h", 491, __func__),0)));
    ((void)((S <= E && "Trying to erase invalid range.") || (__assert_fail("S <= E && \"Trying to erase invalid range.\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallVector.h", 492, __func__),0)));
    ((void)((E <= this->end() && "Trying to erase past the end.") || (__assert_fail("E <= this->end() && \"Trying to erase past the end.\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallVector.h", 493, __func__),0)));

    iterator N = S;

    iterator I = this->move(E, this->end(), S);

    this->destroy_range(I, this->end());
    this->setEnd(I);
    return(N);
  }
# 537 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallVector.h"
  iterator insert(iterator I, const T &Elt) {
    if (I == this->end()) {
      this->push_back(Elt);
      return this->end()-1;
    }

    ((void)((I >= this->begin() && "Insertion iterator is out of bounds.") || (__assert_fail("I >= this->begin() && \"Insertion iterator is out of bounds.\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallVector.h", 543, __func__),0)));
    ((void)((I <= this->end() && "Inserting past the end of the vector.") || (__assert_fail("I <= this->end() && \"Inserting past the end of the vector.\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallVector.h", 544, __func__),0)));

    if (this->EndX < this->CapacityX) {
    Retry:
      ::new ((void*) this->end()) T(this->back());
      this->setEnd(this->end()+1);

      this->move_backward(I, this->end()-1, this->end());



      const T *EltPtr = &Elt;
      if (I <= EltPtr && EltPtr < this->EndX)
        ++EltPtr;

      *I = *EltPtr;
      return I;
    }
    size_t EltNo = I-this->begin();
    this->grow();
    I = this->begin()+EltNo;
    goto Retry;
  }

  iterator insert(iterator I, size_type NumToInsert, const T &Elt) {

    size_t InsertElt = I - this->begin();

    if (I == this->end()) {
      append(NumToInsert, Elt);
      return this->begin()+InsertElt;
    }

    ((void)((I >= this->begin() && "Insertion iterator is out of bounds.") || (__assert_fail("I >= this->begin() && \"Insertion iterator is out of bounds.\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallVector.h", 577, __func__),0)));
    ((void)((I <= this->end() && "Inserting past the end of the vector.") || (__assert_fail("I <= this->end() && \"Inserting past the end of the vector.\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallVector.h", 578, __func__),0)));


    reserve(static_cast<unsigned>(this->size() + NumToInsert));


    I = this->begin()+InsertElt;





    if (size_t(this->end()-I) >= NumToInsert) {
      T *OldEnd = this->end();
      append(this->end()-NumToInsert, this->end());


      this->move_backward(I, OldEnd-NumToInsert, OldEnd);

      std::fill_n(I, NumToInsert, Elt);
      return I;
    }





    T *OldEnd = this->end();
    this->setEnd(this->end() + NumToInsert);
    size_t NumOverwritten = OldEnd-I;
    this->uninitialized_move(I, OldEnd, this->end()-NumOverwritten);


    std::fill_n(I, NumOverwritten, Elt);


    std::uninitialized_fill_n(OldEnd, NumToInsert-NumOverwritten, Elt);
    return I;
  }

  template<typename ItTy>
  iterator insert(iterator I, ItTy From, ItTy To) {

    size_t InsertElt = I - this->begin();

    if (I == this->end()) {
      append(From, To);
      return this->begin()+InsertElt;
    }

    ((void)((I >= this->begin() && "Insertion iterator is out of bounds.") || (__assert_fail("I >= this->begin() && \"Insertion iterator is out of bounds.\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallVector.h", 628, __func__),0)));
    ((void)((I <= this->end() && "Inserting past the end of the vector.") || (__assert_fail("I <= this->end() && \"Inserting past the end of the vector.\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallVector.h", 629, __func__),0)));

    size_t NumToInsert = std::distance(From, To);


    reserve(static_cast<unsigned>(this->size() + NumToInsert));


    I = this->begin()+InsertElt;





    if (size_t(this->end()-I) >= NumToInsert) {
      T *OldEnd = this->end();
      append(this->end()-NumToInsert, this->end());


      this->move_backward(I, OldEnd-NumToInsert, OldEnd);

      std::copy(From, To, I);
      return I;
    }





    T *OldEnd = this->end();
    this->setEnd(this->end() + NumToInsert);
    size_t NumOverwritten = OldEnd-I;
    this->uninitialized_move(I, OldEnd, this->end()-NumOverwritten);


    for (T *J = I; NumOverwritten > 0; --NumOverwritten) {
      *J = *From;
      ++J; ++From;
    }


    this->uninitialized_copy(From, To, OldEnd);
    return I;
  }

  SmallVectorImpl &operator=(const SmallVectorImpl &RHS);





  bool operator==(const SmallVectorImpl &RHS) const {
    if (this->size() != RHS.size()) return false;
    return std::equal(this->begin(), this->end(), RHS.begin());
  }
  bool operator!=(const SmallVectorImpl &RHS) const {
    return !(*this == RHS);
  }

  bool operator<(const SmallVectorImpl &RHS) const {
    return std::lexicographical_compare(this->begin(), this->end(),
                                        RHS.begin(), RHS.end());
  }
# 702 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallVector.h"
  void set_size(unsigned N) {
    ((void)((N <= this->capacity()) || (__assert_fail("N <= this->capacity()", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallVector.h", 703, __func__),0)));
    this->setEnd(this->begin() + N);
  }
};


template <typename T>
void SmallVectorImpl<T>::swap(SmallVectorImpl<T> &RHS) {
  if (this == &RHS) return;


  if (!this->isSmall() && !RHS.isSmall()) {
    std::swap(this->BeginX, RHS.BeginX);
    std::swap(this->EndX, RHS.EndX);
    std::swap(this->CapacityX, RHS.CapacityX);
    return;
  }
  if (RHS.size() > this->capacity())
    this->grow(RHS.size());
  if (this->size() > RHS.capacity())
    RHS.grow(this->size());


  size_t NumShared = this->size();
  if (NumShared > RHS.size()) NumShared = RHS.size();
  for (unsigned i = 0; i != static_cast<unsigned>(NumShared); ++i)
    std::swap((*this)[i], RHS[i]);


  if (this->size() > RHS.size()) {
    size_t EltDiff = this->size() - RHS.size();
    this->uninitialized_copy(this->begin()+NumShared, this->end(), RHS.end());
    RHS.setEnd(RHS.end()+EltDiff);
    this->destroy_range(this->begin()+NumShared, this->end());
    this->setEnd(this->begin()+NumShared);
  } else if (RHS.size() > this->size()) {
    size_t EltDiff = RHS.size() - this->size();
    this->uninitialized_copy(RHS.begin()+NumShared, RHS.end(), this->end());
    this->setEnd(this->end() + EltDiff);
    this->destroy_range(RHS.begin()+NumShared, RHS.end());
    RHS.setEnd(RHS.begin()+NumShared);
  }
}

template <typename T>
SmallVectorImpl<T> &SmallVectorImpl<T>::
  operator=(const SmallVectorImpl<T> &RHS) {

  if (this == &RHS) return *this;



  size_t RHSSize = RHS.size();
  size_t CurSize = this->size();
  if (CurSize >= RHSSize) {

    iterator NewEnd;
    if (RHSSize)
      NewEnd = std::copy(RHS.begin(), RHS.begin()+RHSSize, this->begin());
    else
      NewEnd = this->begin();


    this->destroy_range(NewEnd, this->end());


    this->setEnd(NewEnd);
    return *this;
  }




  if (this->capacity() < RHSSize) {

    this->destroy_range(this->begin(), this->end());
    this->setEnd(this->begin());
    CurSize = 0;
    this->grow(RHSSize);
  } else if (CurSize) {

    std::copy(RHS.begin(), RHS.begin()+CurSize, this->begin());
  }


  this->uninitialized_copy(RHS.begin()+CurSize, RHS.end(),
                           this->begin()+CurSize);


  this->setEnd(this->begin()+RHSSize);
  return *this;
}
# 864 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallVector.h"
template <typename T, unsigned N>
struct SmallVectorStorage {
  typename SmallVectorTemplateCommon<T>::U InlineElts[N - 1];
};
template <typename T> struct SmallVectorStorage<T, 1> {};
template <typename T> struct SmallVectorStorage<T, 0> {};
# 879 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallVector.h"
template <typename T, unsigned N>
class SmallVector : public SmallVectorImpl<T> {

  SmallVectorStorage<T, N> Storage;
public:
  SmallVector() : SmallVectorImpl<T>(N) {
  }

  explicit SmallVector(unsigned Size, const T &Value = T())
    : SmallVectorImpl<T>(N) {
    this->assign(Size, Value);
  }

  template<typename ItTy>
  SmallVector(ItTy S, ItTy E) : SmallVectorImpl<T>(N) {
    this->append(S, E);
  }

  SmallVector(const SmallVector &RHS) : SmallVectorImpl<T>(N) {
    if (!RHS.empty())
      SmallVectorImpl<T>::operator=(RHS);
  }

  const SmallVector &operator=(const SmallVector &RHS) {
    SmallVectorImpl<T>::operator=(RHS);
    return *this;
  }
# 919 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallVector.h"
};

template<typename T, unsigned N>
static inline size_t capacity_in_bytes(const SmallVector<T, N> &X) {
  return X.capacity_in_bytes();
}

}

namespace std {

  template<typename T>
  inline void
  swap(llvm::SmallVectorImpl<T> &LHS, llvm::SmallVectorImpl<T> &RHS) {
    LHS.swap(RHS);
  }


  template<typename T, unsigned N>
  inline void
  swap(llvm::SmallVector<T, N> &LHS, llvm::SmallVector<T, N> &RHS) {
    LHS.swap(RHS);
  }
}
# 15 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ArrayRef.h" 2
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector" 1 3
# 265 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__bit_reference" 1 3
# 17 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__bit_reference" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__undef_min_max" 1 3
# 18 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__bit_reference" 2 3
# 21 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__bit_reference" 3


namespace std {inline namespace __1 {

template <class _Cp, bool _IsConst, typename _Cp::__storage_type = 0> class __bit_iterator;
template <class _Cp> class __bit_const_reference;

template <class _Tp>
struct __has_storage_type
{
    static const bool value = false;
};

template <class _Cp, bool = __has_storage_type<_Cp>::value>
class __bit_reference
{
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__storage_pointer __storage_pointer;

    __storage_pointer __seg_;
    __storage_type __mask_;


    friend typename _Cp::__self;



    friend class __bit_const_reference<_Cp>;
    friend class __bit_iterator<_Cp, false>;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator bool() const throw()
        {return static_cast<bool>(*__seg_ & __mask_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator ~() const throw()
        {return !static_cast<bool>(*this);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_reference& operator=(bool __x) throw()
    {
        if (__x)
            *__seg_ |= __mask_;
        else
            *__seg_ &= ~__mask_;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_reference& operator=(const __bit_reference& __x) throw()
        {return operator=(static_cast<bool>(__x));}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void flip() throw() {*__seg_ ^= __mask_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator<_Cp, false> operator&() const throw()
        {return __bit_iterator<_Cp, false>(__seg_, static_cast<unsigned>(__ctz(__mask_)));}
private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_reference(__storage_pointer __s, __storage_type __m) throw()
        : __seg_(__s), __mask_(__m) {}
};

template <class _Cp>
class __bit_reference<_Cp, false>
{
};

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(__bit_reference<_Cp> __x, __bit_reference<_Cp> __y) throw()
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp, class _Dp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(__bit_reference<_Cp> __x, __bit_reference<_Dp> __y) throw()
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(__bit_reference<_Cp> __x, bool& __y) throw()
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(bool& __x, __bit_reference<_Cp> __y) throw()
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
class __bit_const_reference
{
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__const_storage_pointer __storage_pointer;

    __storage_pointer __seg_;
    __storage_type __mask_;


    friend typename _Cp::__self;



    friend class __bit_iterator<_Cp, true>;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_const_reference(const __bit_reference<_Cp>& __x) throw()
        : __seg_(__x.__seg_), __mask_(__x.__mask_) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator bool() const throw()
        {return static_cast<bool>(*__seg_ & __mask_);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator<_Cp, true> operator&() const throw()
        {return __bit_iterator<_Cp, true>(__seg_, static_cast<unsigned>(__ctz(__mask_)));}
private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))

    __bit_const_reference(__storage_pointer __s, __storage_type __m) throw()
        : __seg_(__s), __mask_(__m) {}

    __bit_const_reference& operator=(const __bit_const_reference& __x);
};



template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, _IsConst>
__find_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __storage_type __b = *__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
        if (__n == __dn)
            return __first + __n;
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        if (*__first.__seg_)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(*__first.__seg_)));

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = *__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
    }
    return _It(__first.__seg_, static_cast<unsigned>(__n));
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, _IsConst>
__find_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __storage_type __b = ~*__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
        if (__n == __dn)
            return __first + __n;
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
    {
        __storage_type __b = ~*__first.__seg_;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
    }

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = ~*__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
    }
    return _It(__first.__seg_, static_cast<unsigned>(__n));
}

template <class _Cp, bool _IsConst, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<_Cp, _IsConst>
find(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value_)
{
    if (static_cast<bool>(__value_))
        return __find_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
    return __find_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
}



template <class _Cp, bool _IsConst>
typename __bit_iterator<_Cp, _IsConst>::difference_type
__count_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    typedef typename _It::difference_type difference_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;
    difference_type __r = 0;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __r = std::__1::__pop_count(*__first.__seg_ & __m);
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        __r += std::__1::__pop_count(*__first.__seg_);

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __r += std::__1::__pop_count(*__first.__seg_ & __m);
    }
    return __r;
}

template <class _Cp, bool _IsConst>
typename __bit_iterator<_Cp, _IsConst>::difference_type
__count_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    typedef typename _It::difference_type difference_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;
    difference_type __r = 0;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __r = std::__1::__pop_count(~*__first.__seg_ & __m);
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        __r += std::__1::__pop_count(~*__first.__seg_);

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __r += std::__1::__pop_count(~*__first.__seg_ & __m);
    }
    return __r;
}

template <class _Cp, bool _IsConst, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __bit_iterator<_Cp, _IsConst>::difference_type
count(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value_)
{
    if (static_cast<bool>(__value_))
        return __count_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
    return __count_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
}



template <class _Cp>
void
__fill_n_false(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, false> _It;
    typedef typename _It::__storage_type __storage_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        *__first.__seg_ &= ~__m;
        __n -= __dn;
        ++__first.__seg_;
    }

    __storage_type __nw = __n / __bits_per_word;
    std::__1::memset(std::__1::__to_raw_pointer(__first.__seg_), 0, __nw * sizeof(__storage_type));
    __n -= __nw * __bits_per_word;

    if (__n > 0)
    {
        __first.__seg_ += __nw;
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        *__first.__seg_ &= ~__m;
    }
}

template <class _Cp>
void
__fill_n_true(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, false> _It;
    typedef typename _It::__storage_type __storage_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        *__first.__seg_ |= __m;
        __n -= __dn;
        ++__first.__seg_;
    }

    __storage_type __nw = __n / __bits_per_word;
    std::__1::memset(std::__1::__to_raw_pointer(__first.__seg_), -1, __nw * sizeof(__storage_type));
    __n -= __nw * __bits_per_word;

    if (__n > 0)
    {
        __first.__seg_ += __nw;
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        *__first.__seg_ |= __m;
    }
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
fill_n(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n, bool __value_)
{
    if (__n > 0)
    {
        if (__value_)
            __fill_n_true(__first, __n);
        else
            __fill_n_false(__first, __n);
    }
}



template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
fill(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __last, bool __value_)
{
    std::__1::fill_n(__first, static_cast<typename _Cp::size_type>(__last - __first), __value_);
}



template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                     __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    static const unsigned __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            __storage_type __b = *__first.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            ++__first.__seg_;

        }


        __storage_type __nw = __n / __bits_per_word;
        std::__1::memmove(std::__1::__to_raw_pointer(__result.__seg_),
                       std::__1::__to_raw_pointer(__first.__seg_),
                       __nw * sizeof(__storage_type));
        __n -= __nw * __bits_per_word;
        __result.__seg_ += __nw;

        if (__n > 0)
        {
            __first.__seg_ += __nw;
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(__n);
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                       __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    static const unsigned __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b = *__first.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            *__result.__seg_ &= ~__m;
            if (__result.__ctz_ > __first.__ctz_)
                *__result.__seg_ |= __b << (__result.__ctz_ - __first.__ctz_);
            else
                *__result.__seg_ |= __b >> (__first.__ctz_ - __result.__ctz_);
            __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b >> (__first.__ctz_ + __ddn);
                __result.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first.__seg_;

        }


        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        __storage_type __m = ~__storage_type(0) << __result.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_)
        {
            __storage_type __b = *__first.__seg_;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b << __result.__ctz_;
            ++__result.__seg_;
            *__result.__seg_ &= __m;
            *__result.__seg_ |= __b >> __clz_r;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first.__seg_ & __m;
            __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__clz_r));
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b << __result.__ctz_;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b >> __dn;
                __result.__ctz_ = static_cast<unsigned>(__n);
            }
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<_Cp, false>
copy(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    if (__first.__ctz_ == __result.__ctz_)
        return __copy_aligned(__first, __last, __result);
    return __copy_unaligned(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_backward_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                     __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    static const unsigned __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__last.__ctz_ != 0)
        {
            difference_type __dn = std::__1::min(static_cast<difference_type>(__last.__ctz_), __n);
            __n -= __dn;
            unsigned __clz = __bits_per_word - __last.__ctz_;
            __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz);
            __storage_type __b = *__last.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +
                                                       __result.__ctz_) % __bits_per_word);

         }



        __storage_type __nw = __n / __bits_per_word;
        __result.__seg_ -= __nw;
        __last.__seg_ -= __nw;
        std::__1::memmove(std::__1::__to_raw_pointer(__result.__seg_),
                       std::__1::__to_raw_pointer(__last.__seg_),
                       __nw * sizeof(__storage_type));
        __n -= __nw * __bits_per_word;

        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) << (__bits_per_word - __n);
            __storage_type __b = *--__last.__seg_ & __m;
            *--__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_backward_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                       __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    static const unsigned __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__last.__ctz_ != 0)
        {
            difference_type __dn = std::__1::min(static_cast<difference_type>(__last.__ctz_), __n);
            __n -= __dn;
            unsigned __clz_l = __bits_per_word - __last.__ctz_;
            __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_l);
            __storage_type __b = *__last.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__1::min(__dn, static_cast<difference_type>(__result.__ctz_));
            if (__ddn > 0)
            {
                __m = (~__storage_type(0) << (__result.__ctz_ - __ddn)) & (~__storage_type(0) >> __clz_r);
                *__result.__seg_ &= ~__m;
                if (__result.__ctz_ > __last.__ctz_)
                    *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
                else
                    *__result.__seg_ |= __b >> (__last.__ctz_ - __result.__ctz_);
                __result.__ctz_ = static_cast<unsigned>(((-__ddn & (__bits_per_word - 1)) +
                                                         __result.__ctz_) % __bits_per_word);
                __dn -= __ddn;
            }
            if (__dn > 0)
            {

                --__result.__seg_;
                __result.__ctz_ = static_cast<unsigned>(-__dn & (__bits_per_word - 1));
                __m = ~__storage_type(0) << __result.__ctz_;
                *__result.__seg_ &= ~__m;
                __last.__ctz_ -= __dn + __ddn;
                *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
            }

         }



        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        __storage_type __m = ~__storage_type(0) >> __clz_r;
        for (; __n >= __bits_per_word; __n -= __bits_per_word)
        {
            __storage_type __b = *--__last.__seg_;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b >> __clz_r;
            *--__result.__seg_ &= __m;
            *__result.__seg_ |= __b << __result.__ctz_;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) << (__bits_per_word - __n);
            __storage_type __b = *--__last.__seg_ & __m;
            __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__result.__ctz_));
            __m = (~__storage_type(0) << (__result.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_r);
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b >> (__bits_per_word - __result.__ctz_);
            __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +
                                                     __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {

                --__result.__seg_;
                __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
                __m = ~__storage_type(0) << __result.__ctz_;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b << (__result.__ctz_ - (__bits_per_word - __n - __dn));
            }
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<_Cp, false>
copy_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    if (__last.__ctz_ == __result.__ctz_)
        return __copy_backward_aligned(__first, __last, __result);
    return __copy_backward_unaligned(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<_Cp, false>
move(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    return std::__1::copy(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<_Cp, false>
move_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    return std::__1::copy(__first, __last, __result);
}



template <class __C1, class __C2>
__bit_iterator<__C2, false>
__swap_ranges_aligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last,
                      __bit_iterator<__C2, false> __result)
{
    typedef __bit_iterator<__C1, false> _I1;
    typedef typename _I1::difference_type difference_type;
    typedef typename _I1::__storage_type __storage_type;
    static const unsigned __bits_per_word = _I1::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1;
            *__first.__seg_ |= __b2;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            ++__first.__seg_;

        }


        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_, ++__result.__seg_)
            swap(*__first.__seg_, *__result.__seg_);

        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1;
            *__first.__seg_ |= __b2;
            __result.__ctz_ = static_cast<unsigned>(__n);
        }
    }
    return __result;
}

template <class __C1, class __C2>
__bit_iterator<__C2, false>
__swap_ranges_unaligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last,
                        __bit_iterator<__C2, false> __result)
{
    typedef __bit_iterator<__C1, false> _I1;
    typedef typename _I1::difference_type difference_type;
    typedef typename _I1::__storage_type __storage_type;
    static const unsigned __bits_per_word = _I1::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            if (__result.__ctz_ > __first.__ctz_)
            {
                unsigned __s = __result.__ctz_ - __first.__ctz_;
                *__result.__seg_ |= __b1 << __s;
                *__first.__seg_ |= __b2 >> __s;
            }
            else
            {
                unsigned __s = __first.__ctz_ - __result.__ctz_;
                *__result.__seg_ |= __b1 >> __s;
                *__first.__seg_ |= __b2 << __s;
            }
            __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                __b2 = *__result.__seg_ & __m;
                *__result.__seg_ &= ~__m;
                unsigned __s = __first.__ctz_ + __ddn;
                *__result.__seg_ |= __b1 >> __s;
                *__first.__seg_ |= __b2 << __s;
                __result.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first.__seg_;

        }


        __storage_type __m = ~__storage_type(0) << __result.__ctz_;
        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_)
        {
            __storage_type __b1 = *__first.__seg_;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1 << __result.__ctz_;
            *__first.__seg_ = __b2 >> __result.__ctz_;
            ++__result.__seg_;
            __b2 = *__result.__seg_ & ~__m;
            *__result.__seg_ &= __m;
            *__result.__seg_ |= __b1 >> __clz_r;
            *__first.__seg_ |= __b2 << __clz_r;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __dn = std::__1::min<__storage_type>(__n, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1 << __result.__ctz_;
            *__first.__seg_ |= __b2 >> __result.__ctz_;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                __b2 = *__result.__seg_ & __m;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b1 >> __dn;
                *__first.__seg_ |= __b2 << __dn;
                __result.__ctz_ = static_cast<unsigned>(__n);
            }
        }
    }
    return __result;
}

template <class __C1, class __C2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<__C2, false>
swap_ranges(__bit_iterator<__C1, false> __first1, __bit_iterator<__C1, false> __last1,
            __bit_iterator<__C2, false> __first2)
{
    if (__first1.__ctz_ == __first2.__ctz_)
        return __swap_ranges_aligned(__first1, __last1, __first2);
    return __swap_ranges_unaligned(__first1, __last1, __first2);
}



template <class _Cp>
struct __bit_array
{
    typedef typename _Cp::difference_type difference_type;
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__storage_pointer __storage_pointer;
    typedef typename _Cp::iterator iterator;
    static const unsigned __bits_per_word = _Cp::__bits_per_word;
    static const unsigned _Np = 4;

    difference_type __size_;
    __storage_type __word_[_Np];

    __attribute__ ((__visibility__("hidden"), __always_inline__)) static difference_type capacity()
        {return static_cast<difference_type>(_Np * __bits_per_word);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __bit_array(difference_type __s) : __size_(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator begin()
    {
        return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]), 0);
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator end()
    {
        return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]) + __size_ / __bits_per_word,
                                                  static_cast<unsigned>(__size_ % __bits_per_word));
    }
};

template <class _Cp>
__bit_iterator<_Cp, false>
rotate(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __middle, __bit_iterator<_Cp, false> __last)
{
    typedef __bit_iterator<_Cp, false> _I1;
    typedef typename _I1::difference_type difference_type;
    typedef typename _I1::__storage_type __storage_type;
    difference_type __d1 = __middle - __first;
    difference_type __d2 = __last - __middle;
    _I1 __r = __first + __d2;
    while (__d1 != 0 && __d2 != 0)
    {
        if (__d1 <= __d2)
        {
            if (__d1 <= __bit_array<_Cp>::capacity())
            {
                __bit_array<_Cp> __b(__d1);
                std::__1::copy(__first, __middle, __b.begin());
                std::__1::copy(__b.begin(), __b.end(), std::__1::copy(__middle, __last, __first));
                break;
            }
            else
            {
                __bit_iterator<_Cp, false> __mp = std::__1::swap_ranges(__first, __middle, __middle);
                __first = __middle;
                __middle = __mp;
                __d2 -= __d1;
            }
        }
        else
        {
            if (__d2 <= __bit_array<_Cp>::capacity())
            {
                __bit_array<_Cp> __b(__d2);
                std::__1::copy(__middle, __last, __b.begin());
                std::__1::copy_backward(__b.begin(), __b.end(), std::__1::copy_backward(__first, __middle, __last));
                break;
            }
            else
            {
                __bit_iterator<_Cp, false> __mp = __first + __d2;
                std::__1::swap_ranges(__first, __mp, __middle);
                __first = __mp;
                __d1 -= __d2;
            }
        }
    }
    return __r;
}



template <class _Cp, bool _IC1, bool _IC2>
bool
__equal_unaligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,
                  __bit_iterator<_Cp, _IC2> __first2)
{
    typedef __bit_iterator<_Cp, _IC1> _It;
    typedef typename _It::difference_type difference_type;
    typedef typename _It::__storage_type __storage_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;
    difference_type __n = __last1 - __first1;
    if (__n > 0)
    {

        if (__first1.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first1.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b = *__first1.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __first2.__ctz_;
            __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            if (__first2.__ctz_ > __first1.__ctz_)
            {
                if ((*__first2.__seg_ & __m) != (__b << (__first2.__ctz_ - __first1.__ctz_)))
                    return false;
            }
            else
            {
                if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ - __first2.__ctz_)))
                    return false;
            }
            __first2.__seg_ += (__ddn + __first2.__ctz_) / __bits_per_word;
            __first2.__ctz_ = static_cast<unsigned>((__ddn + __first2.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ + __ddn)))
                    return false;
                __first2.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first1.__seg_;

        }


        unsigned __clz_r = __bits_per_word - __first2.__ctz_;
        __storage_type __m = ~__storage_type(0) << __first2.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_)
        {
            __storage_type __b = *__first1.__seg_;
            if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
                return false;
            ++__first2.__seg_;
            if ((*__first2.__seg_ & ~__m) != (__b >> __clz_r))
                return false;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first1.__seg_ & __m;
            __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__clz_r));
            __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
                return false;
            __first2.__seg_ += (__dn + __first2.__ctz_) / __bits_per_word;
            __first2.__ctz_ = static_cast<unsigned>((__dn + __first2.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                if ((*__first2.__seg_ & __m) != (__b >> __dn))
                    return false;
            }
        }
    }
    return true;
}

template <class _Cp, bool _IC1, bool _IC2>
bool
__equal_aligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,
                __bit_iterator<_Cp, _IC2> __first2)
{
    typedef __bit_iterator<_Cp, _IC1> _It;
    typedef typename _It::difference_type difference_type;
    typedef typename _It::__storage_type __storage_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;
    difference_type __n = __last1 - __first1;
    if (__n > 0)
    {

        if (__first1.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first1.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
                return false;
            ++__first2.__seg_;
            ++__first1.__seg_;


        }



        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_, ++__first2.__seg_)
            if (*__first2.__seg_ != *__first1.__seg_)
                return false;

        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
                return false;
        }
    }
    return true;
}

template <class _Cp, bool _IC1, bool _IC2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
equal(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1, __bit_iterator<_Cp, _IC2> __first2)
{
    if (__first1.__ctz_ == __first2.__ctz_)
        return __equal_aligned(__first1, __last1, __first2);
    return __equal_unaligned(__first1, __last1, __first2);
}

template <class _Cp, bool _IsConst,
          typename _Cp::__storage_type>
class __bit_iterator
{
public:
    typedef typename _Cp::difference_type difference_type;
    typedef bool value_type;
    typedef __bit_iterator pointer;
    typedef typename conditional<_IsConst, __bit_const_reference<_Cp>, __bit_reference<_Cp> >::type reference;
    typedef random_access_iterator_tag iterator_category;

private:
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename conditional<_IsConst, typename _Cp::__const_storage_pointer,
                                           typename _Cp::__storage_pointer>::type __storage_pointer;
    static const unsigned __bits_per_word = _Cp::__bits_per_word;

    __storage_pointer __seg_;
    unsigned __ctz_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator() throw()



    {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_iterator(const __bit_iterator<_Cp, false>& __it) throw()
        : __seg_(__it.__seg_), __ctz_(__it.__ctz_) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator*() const throw()
        {return reference(__seg_, __storage_type(1) << __ctz_);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator& operator++()
    {
        if (__ctz_ != __bits_per_word-1)
            ++__ctz_;
        else
        {
            __ctz_ = 0;
            ++__seg_;
        }
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator operator++(int)
    {
        __bit_iterator __tmp = *this;
        ++(*this);
        return __tmp;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator& operator--()
    {
        if (__ctz_ != 0)
            --__ctz_;
        else
        {
            __ctz_ = __bits_per_word - 1;
            --__seg_;
        }
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator operator--(int)
    {
        __bit_iterator __tmp = *this;
        --(*this);
        return __tmp;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator& operator+=(difference_type __n)
    {
        if (__n >= 0)
            __seg_ += (__n + __ctz_) / __bits_per_word;
        else
            __seg_ += static_cast<difference_type>(__n - __bits_per_word + __ctz_ + 1)
                    / static_cast<difference_type>(__bits_per_word);
        __n &= (__bits_per_word - 1);
        __ctz_ = static_cast<unsigned>((__n + __ctz_) % __bits_per_word);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator& operator-=(difference_type __n)
    {
        return *this += -__n;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator operator+(difference_type __n) const
    {
        __bit_iterator __t(*this);
        __t += __n;
        return __t;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator operator-(difference_type __n) const
    {
        __bit_iterator __t(*this);
        __t -= __n;
        return __t;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    friend __bit_iterator operator+(difference_type __n, const __bit_iterator& __it) {return __it + __n;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    friend difference_type operator-(const __bit_iterator& __x, const __bit_iterator& __y)
        {return (__x.__seg_ - __y.__seg_) * __bits_per_word + __x.__ctz_ - __y.__ctz_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](difference_type __n) const {return *(*this + __n);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator==(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __x.__seg_ == __y.__seg_ && __x.__ctz_ == __y.__ctz_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator!=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__x == __y);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator<(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __x.__seg_ < __y.__seg_ || (__x.__seg_ == __y.__seg_ && __x.__ctz_ < __y.__ctz_);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator>(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __y < __x;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator<=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__y < __x);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator>=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__x < __y);}

private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_iterator(__storage_pointer __s, unsigned __ctz) throw()
        : __seg_(__s), __ctz_(__ctz) {}


    friend typename _Cp::__self;



    friend class __bit_reference<_Cp>;
    friend class __bit_const_reference<_Cp>;
    friend class __bit_iterator<_Cp, true>;
    template <class _Dp> friend struct __bit_array;
    template <class _Dp> friend void __fill_n_false(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
    template <class _Dp> friend void __fill_n_true(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_aligned(__bit_iterator<_Dp, _IC> __first,
                                                                                  __bit_iterator<_Dp, _IC> __last,
                                                                                  __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_unaligned(__bit_iterator<_Dp, _IC> __first,
                                                                                    __bit_iterator<_Dp, _IC> __last,
                                                                                    __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> copy(__bit_iterator<_Dp, _IC> __first,
                                                                        __bit_iterator<_Dp, _IC> __last,
                                                                        __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_backward_aligned(__bit_iterator<_Dp, _IC> __first,
                                                                                           __bit_iterator<_Dp, _IC> __last,
                                                                                           __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_backward_unaligned(__bit_iterator<_Dp, _IC> __first,
                                                                                             __bit_iterator<_Dp, _IC> __last,
                                                                                             __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> copy_backward(__bit_iterator<_Dp, _IC> __first,
                                                                                 __bit_iterator<_Dp, _IC> __last,
                                                                                 __bit_iterator<_Dp, false> __result);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> __swap_ranges_aligned(__bit_iterator<__C1, false>,
                                                                                           __bit_iterator<__C1, false>,
                                                                                           __bit_iterator<__C2, false>);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> __swap_ranges_unaligned(__bit_iterator<__C1, false>,
                                                                                             __bit_iterator<__C1, false>,
                                                                                             __bit_iterator<__C2, false>);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false>,
                                                                                 __bit_iterator<__C1, false>,
                                                                                 __bit_iterator<__C2, false>);
    template <class _Dp> friend __bit_iterator<_Dp, false> rotate(__bit_iterator<_Dp, false>,
                                                                __bit_iterator<_Dp, false>,
                                                                __bit_iterator<_Dp, false>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool __equal_aligned(__bit_iterator<_Dp, _IC1>,
                                                    __bit_iterator<_Dp, _IC1>,
                                                    __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool __equal_unaligned(__bit_iterator<_Dp, _IC1>,
                                                      __bit_iterator<_Dp, _IC1>,
                                                      __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool equal(__bit_iterator<_Dp, _IC1>,
                                                                __bit_iterator<_Dp, _IC1>,
                                                                __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, _IC> __find_bool_true(__bit_iterator<_Dp, _IC>,
                                                                          typename _Dp::size_type);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, _IC> __find_bool_false(__bit_iterator<_Dp, _IC>,
                                                                           typename _Dp::size_type);
    template <class _Dp, bool _IC> friend typename __bit_iterator<_Dp, _IC>::difference_type
                   __count_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
    template <class _Dp, bool _IC> friend typename __bit_iterator<_Dp, _IC>::difference_type
                   __count_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
};

} }
# 266 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector" 2 3





# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/stdexcept" 1 3
# 51 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/stdexcept" 3



namespace std {inline namespace __1 {
class __attribute__ ((__visibility__("hidden"))) __libcpp_refstring {
    const char *__imp_;
};
} }


namespace std
{

class __attribute__ ((__visibility__("default"))) logic_error
    : public exception
{
private:
    std::__1::__libcpp_refstring __imp_;
public:
    explicit logic_error(const string&);
    explicit logic_error(const char*);

    logic_error(const logic_error&) throw();
    logic_error& operator=(const logic_error&) throw();

    virtual ~logic_error() throw();

    virtual const char* what() const throw();
};

class __attribute__ ((__visibility__("default"))) runtime_error
    : public exception
{
private:
    std::__1::__libcpp_refstring __imp_;
public:
    explicit runtime_error(const string&);
    explicit runtime_error(const char*);

    runtime_error(const runtime_error&) throw();
    runtime_error& operator=(const runtime_error&) throw();

    virtual ~runtime_error() throw();

    virtual const char* what() const throw();
};

class __attribute__ ((__visibility__("default"))) domain_error
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit domain_error(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit domain_error(const char* __s) : logic_error(__s) {}

    virtual ~domain_error() throw();
};

class __attribute__ ((__visibility__("default"))) invalid_argument
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit invalid_argument(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit invalid_argument(const char* __s) : logic_error(__s) {}

    virtual ~invalid_argument() throw();
};

class __attribute__ ((__visibility__("default"))) length_error
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit length_error(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit length_error(const char* __s) : logic_error(__s) {}

    virtual ~length_error() throw();
};

class __attribute__ ((__visibility__("default"))) out_of_range
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit out_of_range(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit out_of_range(const char* __s) : logic_error(__s) {}

    virtual ~out_of_range() throw();
};

class __attribute__ ((__visibility__("default"))) range_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit range_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit range_error(const char* __s) : runtime_error(__s) {}

    virtual ~range_error() throw();
};

class __attribute__ ((__visibility__("default"))) overflow_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit overflow_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit overflow_error(const char* __s) : runtime_error(__s) {}

    virtual ~overflow_error() throw();
};

class __attribute__ ((__visibility__("default"))) underflow_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit underflow_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit underflow_error(const char* __s) : runtime_error(__s) {}

    virtual ~underflow_error() throw();
};

}
# 272 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector" 2 3


# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__split_buffer" 1 3








# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__undef_min_max" 1 3
# 10 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__split_buffer" 2 3
# 13 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__split_buffer" 3


namespace std {inline namespace __1 {

template <bool>
class __split_buffer_common
{
protected:
    void __throw_length_error() const;
    void __throw_out_of_range() const;
};

template <class _Tp, class _Allocator = allocator<_Tp> >
struct __split_buffer
    : private __split_buffer_common<true>
{
private:
    __split_buffer(const __split_buffer&);
    __split_buffer& operator=(const __split_buffer&);
public:
    typedef _Tp value_type;
    typedef _Allocator allocator_type;
    typedef typename remove_reference<allocator_type>::type __alloc_rr;
    typedef allocator_traits<__alloc_rr> __alloc_traits;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef pointer iterator;
    typedef const_pointer const_iterator;

    pointer __first_;
    pointer __begin_;
    pointer __end_;
    __compressed_pair<pointer, allocator_type> __end_cap_;

    typedef typename add_lvalue_reference<allocator_type>::type __alloc_ref;
    typedef typename add_lvalue_reference<allocator_type>::type __alloc_const_ref;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __alloc_rr& __alloc() throw() {return __end_cap_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const __alloc_rr& __alloc() const throw() {return __end_cap_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer& __end_cap() throw() {return __end_cap_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const pointer& __end_cap() const throw() {return __end_cap_.first();}

    __split_buffer()
                                                                           ;
    explicit __split_buffer(__alloc_rr& __a);
    explicit __split_buffer(const __alloc_rr& __a);
    __split_buffer(size_type __cap, size_type __start, __alloc_rr& __a);
    ~__split_buffer();
# 76 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__split_buffer" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator begin() throw() {return __begin_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_iterator begin() const throw() {return __begin_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator end() throw() {return __end_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_iterator end() const throw() {return __end_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void clear() throw()
        {__destruct_at_end(__begin_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type size() const {return static_cast<size_type>(__end_ - __begin_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool empty() const {return __end_ == __begin_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type capacity() const {return static_cast<size_type>(__end_cap() - __first_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type __front_spare() const {return static_cast<size_type>(__begin_ - __first_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type __back_spare() const {return static_cast<size_type>(__end_cap() - __end_);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference front() {return *__begin_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference front() const {return *__begin_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference back() {return *(__end_ - 1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference back() const {return *(__end_ - 1);}

    void reserve(size_type __n);
    void shrink_to_fit() throw();
    void push_front(const_reference __x);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void push_back(const_reference __x);
# 108 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__split_buffer" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void pop_front() {__destruct_at_begin(__begin_+1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void pop_back() {__destruct_at_end(__end_-1);}

    void __construct_at_end(size_type __n);
    void __construct_at_end(size_type __n, const_reference __x);
    template <class _InputIter>
        typename enable_if
        <
            __is_input_iterator<_InputIter>::value &&
           !__is_forward_iterator<_InputIter>::value,
            void
        >::type
        __construct_at_end(_InputIter __first, _InputIter __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
            void
        >::type
        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __destruct_at_begin(pointer __new_begin)
        {__destruct_at_begin(__new_begin, is_trivially_destructible<value_type>());}
        void __destruct_at_begin(pointer __new_begin, false_type);
        void __destruct_at_begin(pointer __new_begin, true_type);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __destruct_at_end(pointer __new_last) throw()
        {__destruct_at_end(__new_last, false_type());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        void __destruct_at_end(pointer __new_last, false_type) throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        void __destruct_at_end(pointer __new_last, true_type) throw();

    void swap(__split_buffer& __x)

                                                             ;

    bool __invariants() const;

private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign_alloc(__split_buffer& __c, true_type)

        {
            __alloc() = std::__1::move(__c.__alloc());
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign_alloc(__split_buffer&, false_type) throw()
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void __swap_alloc(__alloc_rr& __x, __alloc_rr& __y)


        {__swap_alloc(__x, __y, integral_constant<bool,
                      __alloc_traits::propagate_on_container_swap::value>());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void __swap_alloc(__alloc_rr& __x, __alloc_rr& __y, true_type)

        {
            using std::__1::swap;
            swap(__x, __y);
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void __swap_alloc(__alloc_rr&, __alloc_rr&, false_type) throw()
        {}
};

template <class _Tp, class _Allocator>
bool
__split_buffer<_Tp, _Allocator>::__invariants() const
{
    if (__first_ == std::__1::__get_nullptr_t())
    {
        if (__begin_ != std::__1::__get_nullptr_t())
            return false;
        if (__end_ != std::__1::__get_nullptr_t())
            return false;
        if (__end_cap() != std::__1::__get_nullptr_t())
            return false;
    }
    else
    {
        if (__begin_ < __first_)
            return false;
        if (__end_ < __begin_)
            return false;
        if (__end_cap() < __end_)
            return false;
    }
    return true;
}






template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n)
{
    __alloc_rr& __a = this->__alloc();
    do
    {
        __alloc_traits::construct(__a, std::__1::__to_raw_pointer(this->__end_));
        ++this->__end_;
        --__n;
    } while (__n > 0);
}







template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)
{
    __alloc_rr& __a = this->__alloc();
    do
    {
        __alloc_traits::construct(__a, std::__1::__to_raw_pointer(this->__end_), __x);
        ++this->__end_;
        --__n;
    } while (__n > 0);
}

template <class _Tp, class _Allocator>
template <class _InputIter>
typename enable_if
<
     __is_input_iterator<_InputIter>::value &&
    !__is_forward_iterator<_InputIter>::value,
    void
>::type
__split_buffer<_Tp, _Allocator>::__construct_at_end(_InputIter __first, _InputIter __last)
{
    __alloc_rr& __a = this->__alloc();
    for (; __first != __last; ++__first)
    {
        if (__end_ == __end_cap())
        {
            size_type __old_cap = __end_cap() - __first_;
            size_type __new_cap = std::__1::max<size_type>(2 * __old_cap, 8);
            __split_buffer __buf(__new_cap, 0, __a);
            for (pointer __p = __begin_; __p != __end_; ++__p, ++__buf.__end_)
                __alloc_traits::construct(__buf.__alloc(),
                        std::__1::__to_raw_pointer(__buf.__end_), std::__1::move(*__p));
            swap(__buf);
        }
        __alloc_traits::construct(__a, std::__1::__to_raw_pointer(this->__end_), *__first);
        ++this->__end_;
    }
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    void
>::type
__split_buffer<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)
{
    __alloc_rr& __a = this->__alloc();
    for (; __first != __last; ++__first)
    {
        __alloc_traits::construct(__a, std::__1::__to_raw_pointer(this->__end_), *__first);
        ++this->__end_;
    }
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, false_type)
{
    while (__begin_ != __new_begin)
        __alloc_traits::destroy(__alloc(), __to_raw_pointer(__begin_++));
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, true_type)
{
    __begin_ = __new_begin;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, false_type) throw()
{
    while (__new_last != __end_)
        __alloc_traits::destroy(__alloc(), __to_raw_pointer(--__end_));
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, true_type) throw()
{
    __end_ = __new_last;
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::__split_buffer(size_type __cap, size_type __start, __alloc_rr& __a)
    : __end_cap_(std::__1::__get_nullptr_t(), __a)
{
    __first_ = __cap != 0 ? __alloc_traits::allocate(__alloc(), __cap) : std::__1::__get_nullptr_t();
    __begin_ = __end_ = __first_ + __start;
    __end_cap() = __first_ + __cap;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__split_buffer<_Tp, _Allocator>::__split_buffer()

    : __first_(std::__1::__get_nullptr_t()), __begin_(std::__1::__get_nullptr_t()), __end_(std::__1::__get_nullptr_t()), __end_cap_(std::__1::__get_nullptr_t())
{
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__split_buffer<_Tp, _Allocator>::__split_buffer(__alloc_rr& __a)
    : __first_(std::__1::__get_nullptr_t()), __begin_(std::__1::__get_nullptr_t()), __end_(std::__1::__get_nullptr_t()), __end_cap_(std::__1::__get_nullptr_t(), __a)
{
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__split_buffer<_Tp, _Allocator>::__split_buffer(const __alloc_rr& __a)
    : __first_(std::__1::__get_nullptr_t()), __begin_(std::__1::__get_nullptr_t()), __end_(std::__1::__get_nullptr_t()), __end_cap_(std::__1::__get_nullptr_t(), __a)
{
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::~__split_buffer()
{
    clear();
    if (__first_)
        __alloc_traits::deallocate(__alloc(), __first_, capacity());
}
# 424 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__split_buffer" 3
template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::swap(__split_buffer& __x)


{
    std::__1::swap(__first_, __x.__first_);
    std::__1::swap(__begin_, __x.__begin_);
    std::__1::swap(__end_, __x.__end_);
    std::__1::swap(__end_cap(), __x.__end_cap());
    __swap_alloc(__alloc(), __x.__alloc());
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::reserve(size_type __n)
{
    if (__n < capacity())
    {
        __split_buffer<value_type, __alloc_rr&> __t(__n, 0, __alloc());
        __t.__construct_at_end(move_iterator<pointer>(__begin_),
                               move_iterator<pointer>(__end_));
        std::__1::swap(__first_, __t.__first_);
        std::__1::swap(__begin_, __t.__begin_);
        std::__1::swap(__end_, __t.__end_);
        std::__1::swap(__end_cap(), __t.__end_cap());
    }
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::shrink_to_fit() throw()
{
    if (capacity() > size())
    {




            __split_buffer<value_type, __alloc_rr&> __t(size(), 0, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            __t.__end_ = __t.__begin_ + (__end_ - __begin_);
            std::__1::swap(__first_, __t.__first_);
            std::__1::swap(__begin_, __t.__begin_);
            std::__1::swap(__end_, __t.__end_);
            std::__1::swap(__end_cap(), __t.__end_cap());






    }
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::push_front(const_reference __x)
{
    if (__begin_ == __first_)
    {
        if (__end_ < __end_cap())
        {
            difference_type __d = __end_cap() - __end_;
            __d = (__d + 1) / 2;
            __begin_ = std::__1::move_backward(__begin_, __end_, __end_ + __d);
            __end_ += __d;
        }
        else
        {
            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::__1::swap(__first_, __t.__first_);
            std::__1::swap(__begin_, __t.__begin_);
            std::__1::swap(__end_, __t.__end_);
            std::__1::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__1::__to_raw_pointer(__begin_-1), __x);
    --__begin_;
}
# 543 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__split_buffer" 3
template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__split_buffer<_Tp, _Allocator>::push_back(const_reference __x)
{
    if (__end_ == __end_cap())
    {
        if (__begin_ > __first_)
        {
            difference_type __d = __begin_ - __first_;
            __d = (__d + 1) / 2;
            __end_ = std::__1::move(__begin_, __end_, __begin_ - __d);
            __begin_ -= __d;
        }
        else
        {
            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::__1::swap(__first_, __t.__first_);
            std::__1::swap(__begin_, __t.__begin_);
            std::__1::swap(__end_, __t.__end_);
            std::__1::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__1::__to_raw_pointer(__end_), __x);
    ++__end_;
}
# 642 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__split_buffer" 3
template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(__split_buffer<_Tp, _Allocator>& __x, __split_buffer<_Tp, _Allocator>& __y)

{
    __x.swap(__y);
}


} }
# 275 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector" 2 3


# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__undef_min_max" 1 3
# 278 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector" 2 3
# 283 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector" 3


namespace std {inline namespace __1 {

template <bool>
class __vector_base_common
{
protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __vector_base_common() {}
    void __throw_length_error() const;
    void __throw_out_of_range() const;
};

template <bool __b>
void
__vector_base_common<__b>::__throw_length_error() const
{



    ((void)((!"vector length_error") || (__assert_fail("!\"vector length_error\"", "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector", 303, __func__),0)));

}

template <bool __b>
void
__vector_base_common<__b>::__throw_out_of_range() const
{



    ((void)((!"vector out_of_range") || (__assert_fail("!\"vector out_of_range\"", "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector", 314, __func__),0)));

}





extern template class __attribute__ ((__type_visibility__("default"))) __vector_base_common<true>;




template <class _Tp, class _Allocator>
class __vector_base
    : protected __vector_base_common<true>
{
protected:
    typedef _Tp value_type;
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef pointer iterator;
    typedef const_pointer const_iterator;

    pointer __begin_;
    pointer __end_;
    __compressed_pair<pointer, allocator_type> __end_cap_;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    allocator_type& __alloc() throw()
        {return __end_cap_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const allocator_type& __alloc() const throw()
        {return __end_cap_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pointer& __end_cap() throw()
        {return __end_cap_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const pointer& __end_cap() const throw()
        {return __end_cap_.first();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __vector_base()
                                                                           ;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __vector_base(const allocator_type& __a);
    ~__vector_base();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void clear() throw() {__destruct_at_end(__begin_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type capacity() const throw()
        {return static_cast<size_type>(__end_cap() - __begin_);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __destruct_at_end(pointer __new_last) throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __copy_assign_alloc(const __vector_base& __c)
        {__copy_assign_alloc(__c, integral_constant<bool,
                      __alloc_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign_alloc(__vector_base& __c)



        {__move_assign_alloc(__c, integral_constant<bool,
                      __alloc_traits::propagate_on_container_move_assignment::value>());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void __swap_alloc(allocator_type& __x, allocator_type& __y)



        {__swap_alloc(__x, __y, integral_constant<bool,
                      __alloc_traits::propagate_on_container_swap::value>());}
private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __copy_assign_alloc(const __vector_base& __c, true_type)
        {
            if (__alloc() != __c.__alloc())
            {
                clear();
                __alloc_traits::deallocate(__alloc(), __begin_, capacity());
                __begin_ = __end_ = __end_cap() = std::__1::__get_nullptr_t();
            }
            __alloc() = __c.__alloc();
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __copy_assign_alloc(const __vector_base&, false_type)
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign_alloc(__vector_base& __c, true_type)

        {
            __alloc() = std::__1::move(__c.__alloc());
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign_alloc(__vector_base&, false_type)
        throw()
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void __swap_alloc(allocator_type& __x, allocator_type& __y, true_type)

        {
            using std::__1::swap;
            swap(__x, __y);
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void __swap_alloc(allocator_type&, allocator_type&, false_type)
        throw()
        {}
};

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__vector_base<_Tp, _Allocator>::__destruct_at_end(pointer __new_last) throw()
{
    while (__new_last != __end_)
        __alloc_traits::destroy(__alloc(), std::__1::__to_raw_pointer(--__end_));
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__vector_base<_Tp, _Allocator>::__vector_base()

    : __begin_(std::__1::__get_nullptr_t()),
      __end_(std::__1::__get_nullptr_t()),
      __end_cap_(std::__1::__get_nullptr_t())
{
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__vector_base<_Tp, _Allocator>::__vector_base(const allocator_type& __a)
    : __begin_(std::__1::__get_nullptr_t()),
      __end_(std::__1::__get_nullptr_t()),
      __end_cap_(std::__1::__get_nullptr_t(), __a)
{
}

template <class _Tp, class _Allocator>
__vector_base<_Tp, _Allocator>::~__vector_base()
{
    if (__begin_ != std::__1::__get_nullptr_t())
    {
        clear();
        __alloc_traits::deallocate(__alloc(), __begin_, capacity());
    }
}

template <class _Tp, class _Allocator = allocator<_Tp> >
class __attribute__ ((__type_visibility__("default"))) vector
    : private __vector_base<_Tp, _Allocator>
{
private:
    typedef __vector_base<_Tp, _Allocator> __base;
    typedef allocator<_Tp> __default_allocator_type;
public:
    typedef vector __self;
    typedef _Tp value_type;
    typedef _Allocator allocator_type;
    typedef typename __base::__alloc_traits __alloc_traits;
    typedef typename __base::reference reference;
    typedef typename __base::const_reference const_reference;
    typedef typename __base::size_type size_type;
    typedef typename __base::difference_type difference_type;
    typedef typename __base::pointer pointer;
    typedef typename __base::const_pointer const_pointer;
    typedef __wrap_iter<pointer> iterator;
    typedef __wrap_iter<const_pointer> const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

    typedef __static_assert_check<sizeof(__static_assert_test<((is_same<typename allocator_type::value_type, value_type>::value))>)> __t500;


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    vector()

        {



        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit vector(const allocator_type& __a)
        : __base(__a)
    {



    }
    explicit vector(size_type __n);



    vector(size_type __n, const_reference __x);
    vector(size_type __n, const_reference __x, const allocator_type& __a);
    template <class _InputIterator>
        vector(_InputIterator __first,
               typename enable_if<__is_input_iterator <_InputIterator>::value &&
                                 !__is_forward_iterator<_InputIterator>::value &&
                                 is_constructible<
                                    value_type,
                                    typename iterator_traits<_InputIterator>::reference>::value,
                                 _InputIterator>::type __last);
    template <class _InputIterator>
        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
               typename enable_if<__is_input_iterator <_InputIterator>::value &&
                                 !__is_forward_iterator<_InputIterator>::value &&
                                 is_constructible<
                                    value_type,
                                    typename iterator_traits<_InputIterator>::reference>::value>::type* = 0);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first,
               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&
                                 is_constructible<
                                    value_type,
                                    typename iterator_traits<_ForwardIterator>::reference>::value,
                                 _ForwardIterator>::type __last);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&
                                 is_constructible<
                                    value_type,
                                    typename iterator_traits<_ForwardIterator>::reference>::value>::type* = 0);
# 565 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector" 3
    vector(const vector& __x);
    vector(const vector& __x, const allocator_type& __a);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    vector& operator=(const vector& __x);
# 587 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector" 3
    template <class _InputIterator>
        typename enable_if
        <
             __is_input_iterator <_InputIterator>::value &&
            !__is_forward_iterator<_InputIterator>::value &&
            is_constructible<
                 value_type,
                 typename iterator_traits<_InputIterator>::reference>::value,
            void
        >::type
        assign(_InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value &&
            is_constructible<
                 value_type,
                 typename iterator_traits<_ForwardIterator>::reference>::value,
            void
        >::type
        assign(_ForwardIterator __first, _ForwardIterator __last);

    void assign(size_type __n, const_reference __u);






    __attribute__ ((__visibility__("hidden"), __always_inline__))
    allocator_type get_allocator() const throw()
        {return this->__alloc();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator begin() throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_iterator begin() const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator end() throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_iterator end() const throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    reverse_iterator rbegin() throw()
        {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator rbegin() const throw()
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    reverse_iterator rend() throw()
        {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator rend() const throw()
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator cbegin() const throw()
        {return begin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator cend() const throw()
        {return end();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator crbegin() const throw()
        {return rbegin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator crend() const throw()
        {return rend();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type size() const throw()
        {return static_cast<size_type>(this->__end_ - this->__begin_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type capacity() const throw()
        {return __base::capacity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool empty() const throw()
        {return this->__begin_ == this->__end_;}
    size_type max_size() const throw();
    void reserve(size_type __n);
    void shrink_to_fit() throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](size_type __n);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference operator[](size_type __n) const;
    reference at(size_type __n);
    const_reference at(size_type __n) const;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference front()
    {
        ((void)0);
        return *this->__begin_;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference front() const
    {
        ((void)0);
        return *this->__begin_;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference back()
    {
        ((void)0);
        return *(this->__end_ - 1);
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference back() const
    {
        ((void)0);
        return *(this->__end_ - 1);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    value_type* data() throw()
        {return std::__1::__to_raw_pointer(this->__begin_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const value_type* data() const throw()
        {return std::__1::__to_raw_pointer(this->__begin_);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void push_back(const_reference __x);







    void pop_back();

    iterator insert(const_iterator __position, const_reference __x);







    iterator insert(const_iterator __position, size_type __n, const_reference __x);
    template <class _InputIterator>
        typename enable_if
        <
             __is_input_iterator <_InputIterator>::value &&
            !__is_forward_iterator<_InputIterator>::value &&
            is_constructible<
                 value_type,
                 typename iterator_traits<_InputIterator>::reference>::value,
            iterator
        >::type
        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value &&
            is_constructible<
                 value_type,
                 typename iterator_traits<_ForwardIterator>::reference>::value,
            iterator
        >::type
        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);






    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator erase(const_iterator __position);
    iterator erase(const_iterator __first, const_iterator __last);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void clear() throw()
    {
        size_type __old_size = size();
        __base::clear();
        __annotate_shrink(__old_size);
        __invalidate_all_iterators();
    }

    void resize(size_type __sz);
    void resize(size_type __sz, const_reference __x);

    void swap(vector&)

                                                                 ;

    bool __invariants() const;
# 773 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector" 3
private:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __invalidate_all_iterators();
    void allocate(size_type __n);
    void deallocate() throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type __recommend(size_type __new_size) const;
    void __construct_at_end(size_type __n);
    void __construct_at_end(size_type __n, const_reference __x);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
            void
        >::type
        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);
    void __append(size_type __n);
    void __append(size_type __n, const_reference __x);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator __make_iter(pointer __p) throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator __make_iter(const_pointer __p) const throw();
    void __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v);
    pointer __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p);
    void __move_range(pointer __from_s, pointer __from_e, pointer __to);
    void __move_assign(vector& __c, true_type)
                                                                     ;
    void __move_assign(vector& __c, false_type);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __destruct_at_end(pointer __new_last) throw()
    {
# 817 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector" 3
        size_type __old_size = size();
        __base::__destruct_at_end(__new_last);
        __annotate_shrink(__old_size);
    }
    template <class _Up>
        void



        __push_back_slow_path(_Up& __x);
# 837 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector" 3
    void __annotate_contiguous_container
    (const void *__beg, const void *__end, const void *__old_mid, const void *__new_mid) const
    {




    }

    void __annotate_new(size_type __current_size) const
    {
      __annotate_contiguous_container(data(), data() + capacity(),
                                      data() + capacity(), data() + __current_size);
    }
    void __annotate_delete() const
    {
      __annotate_contiguous_container(data(), data() + capacity(),
                                      data() + size(), data() + capacity());
    }
    void __annotate_increase(size_type __n) const
    {
      __annotate_contiguous_container(data(), data() + capacity(),
                                      data() + size(), data() + size() + __n);
    }
    void __annotate_shrink(size_type __old_size) const
    {
      __annotate_contiguous_container(data(), data() + capacity(),
                                      data() + __old_size, data() + size());
    }
# 884 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector" 3
    struct __RAII_IncreaseAnnotator {
      inline __RAII_IncreaseAnnotator(const vector &, size_type __n = 1) {}
      inline void __done() {}
    };


};

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v)
{
    __annotate_delete();
    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, this->__end_, __v.__begin_);
    std::__1::swap(this->__begin_, __v.__begin_);
    std::__1::swap(this->__end_, __v.__end_);
    std::__1::swap(this->__end_cap(), __v.__end_cap());
    __v.__first_ = __v.__begin_;
    __annotate_new(size());
    __invalidate_all_iterators();
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::pointer
vector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p)
{
    __annotate_delete();
    pointer __r = __v.__begin_;
    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, __p, __v.__begin_);
    __alloc_traits::__construct_forward(this->__alloc(), __p, this->__end_, __v.__end_);
    std::__1::swap(this->__begin_, __v.__begin_);
    std::__1::swap(this->__end_, __v.__end_);
    std::__1::swap(this->__end_cap(), __v.__end_cap());
    __v.__first_ = __v.__begin_;
    __annotate_new(size());
    __invalidate_all_iterators();
    return __r;
}
# 930 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector" 3
template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::allocate(size_type __n)
{
    if (__n > max_size())
        this->__throw_length_error();
    this->__begin_ = this->__end_ = __alloc_traits::allocate(this->__alloc(), __n);
    this->__end_cap() = this->__begin_ + __n;
    __annotate_new(0);
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::deallocate() throw()
{
    if (this->__begin_ != std::__1::__get_nullptr_t())
    {
        clear();
        __alloc_traits::deallocate(this->__alloc(), this->__begin_, capacity());
        this->__begin_ = this->__end_ = this->__end_cap() = std::__1::__get_nullptr_t();
    }
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::size_type
vector<_Tp, _Allocator>::max_size() const throw()
{
    return std::__1::min<size_type>(__alloc_traits::max_size(this->__alloc()), numeric_limits<size_type>::max() / 2);
}


template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename vector<_Tp, _Allocator>::size_type
vector<_Tp, _Allocator>::__recommend(size_type __new_size) const
{
    const size_type __ms = max_size();
    if (__new_size > __ms)
        this->__throw_length_error();
    const size_type __cap = capacity();
    if (__cap >= __ms / 2)
        return __ms;
    return std::__1::max<size_type>(2*__cap, __new_size);
}






template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__construct_at_end(size_type __n)
{
    allocator_type& __a = this->__alloc();
    do
    {
        __RAII_IncreaseAnnotator __annotator(*this);
        __alloc_traits::construct(__a, std::__1::__to_raw_pointer(this->__end_));
        ++this->__end_;
        --__n;
        __annotator.__done();
    } while (__n > 0);
}







template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
vector<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)
{
    allocator_type& __a = this->__alloc();
    do
    {
        __RAII_IncreaseAnnotator __annotator(*this);
        __alloc_traits::construct(__a, std::__1::__to_raw_pointer(this->__end_), __x);
        ++this->__end_;
        --__n;
        __annotator.__done();
    } while (__n > 0);
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    void
>::type
vector<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)
{
    allocator_type& __a = this->__alloc();
    for (; __first != __last; ++__first)
    {
        __RAII_IncreaseAnnotator __annotator(*this);
        __alloc_traits::construct(__a, std::__1::__to_raw_pointer(this->__end_), *__first);
        __annotator.__done();
        ++this->__end_;
    }
}





template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__append(size_type __n)
{
    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)
        this->__construct_at_end(__n);
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);
        __v.__construct_at_end(__n);
        __swap_out_circular_buffer(__v);
    }
}





template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__append(size_type __n, const_reference __x)
{
    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)
        this->__construct_at_end(__n, __x);
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);
        __v.__construct_at_end(__n, __x);
        __swap_out_circular_buffer(__v);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n)
{



    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__n);
    }
}
# 1103 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector" 3
template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n, const_reference __x)
{



    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n, const_reference __x, const allocator_type& __a)
    : __base(__a)
{



    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
vector<_Tp, _Allocator>::vector(_InputIterator __first,
       typename enable_if<__is_input_iterator <_InputIterator>::value &&
                         !__is_forward_iterator<_InputIterator>::value &&
                         is_constructible<
                            value_type,
                            typename iterator_traits<_InputIterator>::reference>::value,
                          _InputIterator>::type __last)
{



    for (; __first != __last; ++__first)
        push_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
vector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
       typename enable_if<__is_input_iterator <_InputIterator>::value &&
                         !__is_forward_iterator<_InputIterator>::value &&
                         is_constructible<
                            value_type,
                            typename iterator_traits<_InputIterator>::reference>::value>::type*)
    : __base(__a)
{



    for (; __first != __last; ++__first)
        push_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
vector<_Tp, _Allocator>::vector(_ForwardIterator __first,
                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&
                                is_constructible<
                                   value_type,
                                   typename iterator_traits<_ForwardIterator>::reference>::value,
                                                   _ForwardIterator>::type __last)
{



    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__first, __last);
    }
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
vector<_Tp, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&
                                is_constructible<
                                   value_type,
                                   typename iterator_traits<_ForwardIterator>::reference>::value>::type*)
    : __base(__a)
{



    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__first, __last);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(const vector& __x)
    : __base(__alloc_traits::select_on_container_copy_construction(__x.__alloc()))
{



    size_type __n = __x.size();
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__x.__begin_, __x.__end_);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(const vector& __x, const allocator_type& __a)
    : __base(__a)
{



    size_type __n = __x.size();
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__x.__begin_, __x.__end_);
    }
}
# 1354 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector" 3
template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
vector<_Tp, _Allocator>&
vector<_Tp, _Allocator>::operator=(const vector& __x)
{
    if (this != &__x)
    {
        __base::__copy_assign_alloc(__x);
        assign(__x.__begin_, __x.__end_);
    }
    return *this;
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
typename enable_if
<
     __is_input_iterator <_InputIterator>::value &&
    !__is_forward_iterator<_InputIterator>::value &&
    is_constructible<
       _Tp,
       typename iterator_traits<_InputIterator>::reference>::value,
    void
>::type
vector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
    clear();
    for (; __first != __last; ++__first)
        push_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value &&
    is_constructible<
       _Tp,
       typename iterator_traits<_ForwardIterator>::reference>::value,
    void
>::type
vector<_Tp, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
    typename iterator_traits<_ForwardIterator>::difference_type __new_size = std::__1::distance(__first, __last);
    if (static_cast<size_type>(__new_size) <= capacity())
    {
        _ForwardIterator __mid = __last;
        bool __growing = false;
        if (static_cast<size_type>(__new_size) > size())
        {
            __growing = true;
            __mid = __first;
            std::__1::advance(__mid, size());
        }
        pointer __m = std::__1::copy(__first, __mid, this->__begin_);
        if (__growing)
            __construct_at_end(__mid, __last);
        else
            this->__destruct_at_end(__m);
    }
    else
    {
        deallocate();
        allocate(__recommend(static_cast<size_type>(__new_size)));
        __construct_at_end(__first, __last);
    }
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::assign(size_type __n, const_reference __u)
{
    if (__n <= capacity())
    {
        size_type __s = size();
        std::__1::fill_n(this->__begin_, std::__1::min(__n, __s), __u);
        if (__n > __s)
            __construct_at_end(__n - __s, __u);
        else
            this->__destruct_at_end(this->__begin_ + __n);
    }
    else
    {
        deallocate();
        allocate(__recommend(static_cast<size_type>(__n)));
        __construct_at_end(__n, __u);
    }
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::__make_iter(pointer __p) throw()
{



    return iterator(__p);

}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename vector<_Tp, _Allocator>::const_iterator
vector<_Tp, _Allocator>::__make_iter(const_pointer __p) const throw()
{



    return const_iterator(__p);

}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::begin() throw()
{
    return __make_iter(this->__begin_);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename vector<_Tp, _Allocator>::const_iterator
vector<_Tp, _Allocator>::begin() const throw()
{
    return __make_iter(this->__begin_);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::end() throw()
{
    return __make_iter(this->__end_);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename vector<_Tp, _Allocator>::const_iterator
vector<_Tp, _Allocator>::end() const throw()
{
    return __make_iter(this->__end_);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename vector<_Tp, _Allocator>::reference
vector<_Tp, _Allocator>::operator[](size_type __n)
{
    ((void)0);
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename vector<_Tp, _Allocator>::const_reference
vector<_Tp, _Allocator>::operator[](size_type __n) const
{
    ((void)0);
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::reference
vector<_Tp, _Allocator>::at(size_type __n)
{
    if (__n >= size())
        this->__throw_out_of_range();
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::const_reference
vector<_Tp, _Allocator>::at(size_type __n) const
{
    if (__n >= size())
        this->__throw_out_of_range();
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::reserve(size_type __n)
{
    if (__n > capacity())
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__n, size(), __a);
        __swap_out_circular_buffer(__v);
    }
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::shrink_to_fit() throw()
{
    if (capacity() > size())
    {




            allocator_type& __a = this->__alloc();
            __split_buffer<value_type, allocator_type&> __v(size(), size(), __a);
            __swap_out_circular_buffer(__v);






    }
}

template <class _Tp, class _Allocator>
template <class _Up>
void



vector<_Tp, _Allocator>::__push_back_slow_path(_Up& __x)

{
    allocator_type& __a = this->__alloc();
    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);

    __alloc_traits::construct(__a, std::__1::__to_raw_pointer(__v.__end_), std::__1::forward<_Up>(__x));
    __v.__end_++;
    __swap_out_circular_buffer(__v);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
vector<_Tp, _Allocator>::push_back(const_reference __x)
{
    if (this->__end_ != this->__end_cap())
    {
        __RAII_IncreaseAnnotator __annotator(*this);
        __alloc_traits::construct(this->__alloc(),
                                  std::__1::__to_raw_pointer(this->__end_), __x);
        __annotator.__done();
        ++this->__end_;
    }
    else
        __push_back_slow_path(__x);
}
# 1660 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector" 3
template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
vector<_Tp, _Allocator>::pop_back()
{
    ((void)0);
    this->__destruct_at_end(this->__end_ - 1);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::erase(const_iterator __position)
{





    ((void)0);

    difference_type __ps = __position - cbegin();
    pointer __p = this->__begin_ + __ps;
    iterator __r = __make_iter(__p);
    this->__destruct_at_end(std::__1::move(__p + 1, this->__end_, __p));
    return __r;
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::erase(const_iterator __first, const_iterator __last)
{





    ((void)0);
    pointer __p = this->__begin_ + (__first - begin());
    iterator __r = __make_iter(__p);
    if (__first != __last)
        this->__destruct_at_end(std::__1::move(__p + (__last - __first), this->__end_, __p));
    return __r;
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__move_range(pointer __from_s, pointer __from_e, pointer __to)
{
    pointer __old_last = this->__end_;
    difference_type __n = __old_last - __to;
    for (pointer __i = __from_s + __n; __i < __from_e; ++__i, ++this->__end_)
        __alloc_traits::construct(this->__alloc(),
                                  std::__1::__to_raw_pointer(this->__end_),
                                  std::__1::move(*__i));
    std::__1::move_backward(__from_s, __from_s + __n, __old_last);
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, const_reference __x)
{





    pointer __p = this->__begin_ + (__position - begin());
    if (this->__end_ < this->__end_cap())
    {
        __RAII_IncreaseAnnotator __annotator(*this);
        if (__p == this->__end_)
        {
            __alloc_traits::construct(this->__alloc(),
                                      std::__1::__to_raw_pointer(this->__end_), __x);
            ++this->__end_;
        }
        else
        {
            __move_range(__p, this->__end_, __p + 1);
            const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);
            if (__p <= __xr && __xr < this->__end_)
                ++__xr;
            *__p = *__xr;
        }
        __annotator.__done();
    }
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);
        __v.push_back(__x);
        __p = __swap_out_circular_buffer(__v, __p);
    }
    return __make_iter(__p);
}
# 1840 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector" 3
template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, size_type __n, const_reference __x)
{





    pointer __p = this->__begin_ + (__position - begin());
    if (__n > 0)
    {
        if (__n <= static_cast<size_type>(this->__end_cap() - this->__end_))
        {
            size_type __old_n = __n;
            pointer __old_last = this->__end_;
            if (__n > static_cast<size_type>(this->__end_ - __p))
            {
                size_type __cx = __n - (this->__end_ - __p);
                __construct_at_end(__cx, __x);
                __n -= __cx;
            }
            if (__n > 0)
            {
                __RAII_IncreaseAnnotator __annotator(*this);
                __move_range(__p, __old_last, __p + __old_n);
                __annotator.__done();
                const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);
                if (__p <= __xr && __xr < this->__end_)
                    __xr += __old_n;
                std::__1::fill_n(__p, __n, *__xr);
            }
        }
        else
        {
            allocator_type& __a = this->__alloc();
            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);
            __v.__construct_at_end(__n, __x);
            __p = __swap_out_circular_buffer(__v, __p);
        }
    }
    return __make_iter(__p);
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
typename enable_if
<
     __is_input_iterator <_InputIterator>::value &&
    !__is_forward_iterator<_InputIterator>::value &&
    is_constructible<
       _Tp,
       typename iterator_traits<_InputIterator>::reference>::value,
    typename vector<_Tp, _Allocator>::iterator
>::type
vector<_Tp, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)
{





    difference_type __off = __position - begin();
    pointer __p = this->__begin_ + __off;
    allocator_type& __a = this->__alloc();
    pointer __old_last = this->__end_;
    for (; this->__end_ != this->__end_cap() && __first != __last; ++__first)
    {
        __alloc_traits::construct(__a, std::__1::__to_raw_pointer(this->__end_),
                                  *__first);
        ++this->__end_;
    }
    __split_buffer<value_type, allocator_type&> __v(__a);
    if (__first != __last)
    {




            __v.__construct_at_end(__first, __last);
            difference_type __old_size = __old_last - this->__begin_;
            difference_type __old_p = __p - this->__begin_;
            reserve(__recommend(size() + __v.size()));
            __p = this->__begin_ + __old_p;
            __old_last = this->__begin_ + __old_size;
# 1933 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector" 3
    }
    __p = std::__1::rotate(__p, __old_last, this->__end_);
    insert(__make_iter(__p), make_move_iterator(__v.begin()),
                                    make_move_iterator(__v.end()));
    return begin() + __off;
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value &&
    is_constructible<
       _Tp,
       typename iterator_traits<_ForwardIterator>::reference>::value,
    typename vector<_Tp, _Allocator>::iterator
>::type
vector<_Tp, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)
{





    pointer __p = this->__begin_ + (__position - begin());
    difference_type __n = std::__1::distance(__first, __last);
    if (__n > 0)
    {
        if (__n <= this->__end_cap() - this->__end_)
        {
            size_type __old_n = __n;
            pointer __old_last = this->__end_;
            _ForwardIterator __m = __last;
            difference_type __dx = this->__end_ - __p;
            if (__n > __dx)
            {
                __m = __first;
                std::__1::advance(__m, this->__end_ - __p);
                __construct_at_end(__m, __last);
                __n = __dx;
            }
            if (__n > 0)
            {
                __RAII_IncreaseAnnotator __annotator(*this, __n);
                __move_range(__p, __old_last, __p + __old_n);
                __annotator.__done();
                std::__1::copy(__first, __m, __p);
            }
        }
        else
        {
            allocator_type& __a = this->__alloc();
            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);
            __v.__construct_at_end(__first, __last);
            __p = __swap_out_circular_buffer(__v, __p);
        }
    }
    return __make_iter(__p);
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::resize(size_type __sz)
{
    size_type __cs = size();
    if (__cs < __sz)
        this->__append(__sz - __cs);
    else if (__cs > __sz)
        this->__destruct_at_end(this->__begin_ + __sz);
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::resize(size_type __sz, const_reference __x)
{
    size_type __cs = size();
    if (__cs < __sz)
        this->__append(__sz - __cs, __x);
    else if (__cs > __sz)
        this->__destruct_at_end(this->__begin_ + __sz);
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::swap(vector& __x)


{
    ((void)0);



    std::__1::swap(this->__begin_, __x.__begin_);
    std::__1::swap(this->__end_, __x.__end_);
    std::__1::swap(this->__end_cap(), __x.__end_cap());
    __base::__swap_alloc(this->__alloc(), __x.__alloc());



}

template <class _Tp, class _Allocator>
bool
vector<_Tp, _Allocator>::__invariants() const
{
    if (this->__begin_ == std::__1::__get_nullptr_t())
    {
        if (this->__end_ != std::__1::__get_nullptr_t() || this->__end_cap() != std::__1::__get_nullptr_t())
            return false;
    }
    else
    {
        if (this->__begin_ > this->__end_)
            return false;
        if (this->__begin_ == this->__end_cap())
            return false;
        if (this->__end_ > this->__end_cap())
            return false;
    }
    return true;
}
# 2089 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector" 3
template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
vector<_Tp, _Allocator>::__invalidate_all_iterators()
{



}



template <class _Allocator> class vector<bool, _Allocator>;

template <class _Allocator> struct hash<vector<bool, _Allocator> >;

template <class _Allocator>
struct __has_storage_type<vector<bool, _Allocator> >
{
    static const bool value = true;
};

template <class _Allocator>
class __attribute__ ((__type_visibility__("default"))) vector<bool, _Allocator>
    : private __vector_base_common<true>
{
public:
    typedef vector __self;
    typedef bool value_type;
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef size_type __storage_type;
    typedef __bit_iterator<vector, false> pointer;
    typedef __bit_iterator<vector, true> const_pointer;
    typedef pointer iterator;
    typedef const_pointer const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

private:
    typedef typename __alloc_traits::template



                rebind_alloc<__storage_type>::other

                                                     __storage_allocator;
    typedef allocator_traits<__storage_allocator> __storage_traits;
    typedef typename __storage_traits::pointer __storage_pointer;
    typedef typename __storage_traits::const_pointer __const_storage_pointer;

    __storage_pointer __begin_;
    size_type __size_;
    __compressed_pair<size_type, __storage_allocator> __cap_alloc_;
public:
    typedef __bit_reference<vector> reference;
    typedef __bit_const_reference<vector> const_reference;
private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type& __cap() throw()
        {return __cap_alloc_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const size_type& __cap() const throw()
        {return __cap_alloc_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __storage_allocator& __alloc() throw()
        {return __cap_alloc_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const __storage_allocator& __alloc() const throw()
        {return __cap_alloc_.second();}

    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static size_type __internal_cap_to_external(size_type __n) throw()
        {return __n * __bits_per_word;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static size_type __external_cap_to_internal(size_type __n) throw()
        {return (__n - 1) / __bits_per_word + 1;}

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    vector()
                                                                           ;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit vector(const allocator_type& __a);
    ~vector();
    explicit vector(size_type __n);



    vector(size_type __n, const value_type& __v);
    vector(size_type __n, const value_type& __v, const allocator_type& __a);
    template <class _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
               typename enable_if<__is_input_iterator <_InputIterator>::value &&
                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);
    template <class _InputIterator>
        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
               typename enable_if<__is_input_iterator <_InputIterator>::value &&
                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first, _ForwardIterator __last,
               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);

    vector(const vector& __v);
    vector(const vector& __v, const allocator_type& __a);
    vector& operator=(const vector& __v);
# 2223 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector" 3
    template <class _InputIterator>
        typename enable_if
        <
            __is_input_iterator<_InputIterator>::value &&
           !__is_forward_iterator<_InputIterator>::value,
           void
        >::type
        assign(_InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
           void
        >::type
        assign(_ForwardIterator __first, _ForwardIterator __last);

    void assign(size_type __n, const value_type& __x);






    __attribute__ ((__visibility__("hidden"), __always_inline__)) allocator_type get_allocator() const throw()
        {return allocator_type(this->__alloc());}

    size_type max_size() const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type capacity() const throw()
        {return __internal_cap_to_external(__cap());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type size() const throw()
        {return __size_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool empty() const throw()
        {return __size_ == 0;}
    void reserve(size_type __n);
    void shrink_to_fit() throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator begin() throw()
        {return __make_iter(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator begin() const throw()
        {return __make_iter(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator end() throw()
        {return __make_iter(__size_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator end() const throw()
        {return __make_iter(__size_);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    reverse_iterator rbegin() throw()
        {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator rbegin() const throw()
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    reverse_iterator rend() throw()
        {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator rend() const throw()
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator cbegin() const throw()
        {return __make_iter(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator cend() const throw()
        {return __make_iter(__size_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator crbegin() const throw()
        {return rbegin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator crend() const throw()
        {return rend();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](size_type __n) {return __make_ref(__n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference operator[](size_type __n) const {return __make_ref(__n);}
    reference at(size_type __n);
    const_reference at(size_type __n) const;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference front() {return __make_ref(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference front() const {return __make_ref(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference back() {return __make_ref(__size_ - 1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference back() const {return __make_ref(__size_ - 1);}

    void push_back(const value_type& __x);






    __attribute__ ((__visibility__("hidden"), __always_inline__)) void pop_back() {--__size_;}







    iterator insert(const_iterator __position, const value_type& __x);
    iterator insert(const_iterator __position, size_type __n, const value_type& __x);
    iterator insert(const_iterator __position, size_type __n, const_reference __x);
    template <class _InputIterator>
        typename enable_if
        <
             __is_input_iterator <_InputIterator>::value &&
            !__is_forward_iterator<_InputIterator>::value,
            iterator
        >::type
        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
            iterator
        >::type
        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);






    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator erase(const_iterator __position);
    iterator erase(const_iterator __first, const_iterator __last);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void clear() throw() {__size_ = 0;}

    void swap(vector&)

                                                                 ;

    void resize(size_type __sz, value_type __x = false);
    void flip() throw();

    bool __invariants() const;

private:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __invalidate_all_iterators();
    void allocate(size_type __n);
    void deallocate() throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static size_type __align_it(size_type __new_size) throw()
        {return __new_size + (__bits_per_word-1) & ~((size_type)__bits_per_word-1);};
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type __recommend(size_type __new_size) const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __construct_at_end(size_type __n, bool __x);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
            void
        >::type
        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);
    void __append(size_type __n, const_reference __x);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    reference __make_ref(size_type __pos) throw()
        {return reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reference __make_ref(size_type __pos) const throw()
        {return const_reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator __make_iter(size_type __pos) throw()
        {return iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator __make_iter(size_type __pos) const throw()
        {return const_iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator __const_iterator_cast(const_iterator __p) throw()
        {return begin() + (__p - cbegin());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __copy_assign_alloc(const vector& __v)
        {__copy_assign_alloc(__v, integral_constant<bool,
                      __storage_traits::propagate_on_container_copy_assignment::value>());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __copy_assign_alloc(const vector& __c, true_type)
        {
            if (__alloc() != __c.__alloc())
                deallocate();
            __alloc() = __c.__alloc();
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __copy_assign_alloc(const vector&, false_type)
        {}

    void __move_assign(vector& __c, false_type);
    void __move_assign(vector& __c, true_type)
                                                                     ;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign_alloc(vector& __c)



        {__move_assign_alloc(__c, integral_constant<bool,
                      __storage_traits::propagate_on_container_move_assignment::value>());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign_alloc(vector& __c, true_type)

        {
            __alloc() = std::__1::move(__c.__alloc());
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign_alloc(vector&, false_type)
        throw()
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void __swap_alloc(__storage_allocator& __x, __storage_allocator& __y)



        {__swap_alloc(__x, __y, integral_constant<bool,
                      __storage_traits::propagate_on_container_swap::value>());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void __swap_alloc(__storage_allocator& __x, __storage_allocator& __y, true_type)

        {
            using std::__1::swap;
            swap(__x, __y);
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void __swap_alloc(__storage_allocator&, __storage_allocator&, false_type)
        throw()
        {}

    size_t __hash_code() const throw();

    friend class __bit_reference<vector>;
    friend class __bit_const_reference<vector>;
    friend class __bit_iterator<vector, false>;
    friend class __bit_iterator<vector, true>;
    friend struct __bit_array<vector>;
    friend struct __attribute__ ((__type_visibility__("default"))) hash<vector>;
};

template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
vector<bool, _Allocator>::__invalidate_all_iterators()
{
}
# 2480 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector" 3
template <class _Allocator>
void
vector<bool, _Allocator>::allocate(size_type __n)
{
    if (__n > max_size())
        this->__throw_length_error();
    __n = __external_cap_to_internal(__n);
    this->__begin_ = __storage_traits::allocate(this->__alloc(), __n);
    this->__size_ = 0;
    this->__cap() = __n;
}

template <class _Allocator>
void
vector<bool, _Allocator>::deallocate() throw()
{
    if (this->__begin_ != std::__1::__get_nullptr_t())
    {
        __storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());
        __invalidate_all_iterators();
        this->__begin_ = std::__1::__get_nullptr_t();
        this->__size_ = this->__cap() = 0;
    }
}

template <class _Allocator>
typename vector<bool, _Allocator>::size_type
vector<bool, _Allocator>::max_size() const throw()
{
    size_type __amax = __storage_traits::max_size(__alloc());
    size_type __nmax = numeric_limits<size_type>::max() / 2;
    if (__nmax / __bits_per_word <= __amax)
        return __nmax;
    return __internal_cap_to_external(__amax);
}


template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename vector<bool, _Allocator>::size_type
vector<bool, _Allocator>::__recommend(size_type __new_size) const
{
    const size_type __ms = max_size();
    if (__new_size > __ms)
        this->__throw_length_error();
    const size_type __cap = capacity();
    if (__cap >= __ms / 2)
        return __ms;
    return std::__1::max(2*__cap, __align_it(__new_size));
}





template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
vector<bool, _Allocator>::__construct_at_end(size_type __n, bool __x)
{
    size_type __old_size = this->__size_;
    this->__size_ += __n;
    std::__1::fill_n(__make_iter(__old_size), __n, __x);
}

template <class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    void
>::type
vector<bool, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __old_size = this->__size_;
    this->__size_ += std::__1::distance(__first, __last);
    std::__1::copy(__first, __last, __make_iter(__old_size));
}

template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
vector<bool, _Allocator>::vector()

    : __begin_(std::__1::__get_nullptr_t()),
      __size_(0),
      __cap_alloc_(0)
{
}

template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
vector<bool, _Allocator>::vector(const allocator_type& __a)
    : __begin_(std::__1::__get_nullptr_t()),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
}

template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n)
    : __begin_(std::__1::__get_nullptr_t()),
      __size_(0),
      __cap_alloc_(0)
{
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__n, false);
    }
}
# 2606 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector" 3
template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n, const value_type& __x)
    : __begin_(std::__1::__get_nullptr_t()),
      __size_(0),
      __cap_alloc_(0)
{
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)
    : __begin_(std::__1::__get_nullptr_t()),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Allocator>
template <class _InputIterator>
vector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last,
       typename enable_if<__is_input_iterator <_InputIterator>::value &&
                         !__is_forward_iterator<_InputIterator>::value>::type*)
    : __begin_(std::__1::__get_nullptr_t()),
      __size_(0),
      __cap_alloc_(0)
{




        for (; __first != __last; ++__first)
            push_back(*__first);
# 2657 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector" 3
}

template <class _Allocator>
template <class _InputIterator>
vector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
       typename enable_if<__is_input_iterator <_InputIterator>::value &&
                         !__is_forward_iterator<_InputIterator>::value>::type*)
    : __begin_(std::__1::__get_nullptr_t()),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{




        for (; __first != __last; ++__first)
            push_back(*__first);
# 2684 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector" 3
}

template <class _Allocator>
template <class _ForwardIterator>
vector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last,
                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)
    : __begin_(std::__1::__get_nullptr_t()),
      __size_(0),
      __cap_alloc_(0)
{
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__first, __last);
    }
}

template <class _Allocator>
template <class _ForwardIterator>
vector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)
    : __begin_(std::__1::__get_nullptr_t()),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n > 0)
    {
        allocate(__n);
        __construct_at_end(__first, __last);
    }
}
# 2750 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector" 3
template <class _Allocator>
vector<bool, _Allocator>::~vector()
{
    if (__begin_ != std::__1::__get_nullptr_t())
        __storage_traits::deallocate(__alloc(), __begin_, __cap());
    __invalidate_all_iterators();
}

template <class _Allocator>
vector<bool, _Allocator>::vector(const vector& __v)
    : __begin_(std::__1::__get_nullptr_t()),
      __size_(0),
      __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(__v.__alloc()))
{
    if (__v.size() > 0)
    {
        allocate(__v.size());
        __construct_at_end(__v.begin(), __v.end());
    }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(const vector& __v, const allocator_type& __a)
    : __begin_(std::__1::__get_nullptr_t()),
      __size_(0),
      __cap_alloc_(0, __a)
{
    if (__v.size() > 0)
    {
        allocate(__v.size());
        __construct_at_end(__v.begin(), __v.end());
    }
}

template <class _Allocator>
vector<bool, _Allocator>&
vector<bool, _Allocator>::operator=(const vector& __v)
{
    if (this != &__v)
    {
        __copy_assign_alloc(__v);
        if (__v.__size_)
        {
            if (__v.__size_ > capacity())
            {
                deallocate();
                allocate(__v.__size_);
            }
            std::__1::copy(__v.__begin_, __v.__begin_ + __external_cap_to_internal(__v.__size_), __begin_);
        }
        __size_ = __v.__size_;
    }
    return *this;
}
# 2880 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector" 3
template <class _Allocator>
void
vector<bool, _Allocator>::assign(size_type __n, const value_type& __x)
{
    __size_ = 0;
    if (__n > 0)
    {
        size_type __c = capacity();
        if (__n <= __c)
            __size_ = __n;
        else
        {
            vector __v(__alloc());
            __v.reserve(__recommend(__n));
            __v.__size_ = __n;
            swap(__v);
        }
        std::__1::fill_n(begin(), __n, __x);
    }
}

template <class _Allocator>
template <class _InputIterator>
typename enable_if
<
    __is_input_iterator<_InputIterator>::value &&
   !__is_forward_iterator<_InputIterator>::value,
   void
>::type
vector<bool, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
    clear();
    for (; __first != __last; ++__first)
        push_back(*__first);
}

template <class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
   void
>::type
vector<bool, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
    clear();
    difference_type __n = std::__1::distance(__first, __last);
    if (__n)
    {
        if (__n > capacity())
        {
            deallocate();
            allocate(__n);
        }
        __construct_at_end(__first, __last);
    }
}

template <class _Allocator>
void
vector<bool, _Allocator>::reserve(size_type __n)
{
    if (__n > capacity())
    {
        vector __v(this->__alloc());
        __v.allocate(__n);
        __v.__construct_at_end(this->begin(), this->end());
        swap(__v);
        __invalidate_all_iterators();
    }
}

template <class _Allocator>
void
vector<bool, _Allocator>::shrink_to_fit() throw()
{
    if (__external_cap_to_internal(size()) > __cap())
    {




            vector(*this, allocator_type(__alloc())).swap(*this);






    }
}

template <class _Allocator>
typename vector<bool, _Allocator>::reference
vector<bool, _Allocator>::at(size_type __n)
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _Allocator>
typename vector<bool, _Allocator>::const_reference
vector<bool, _Allocator>::at(size_type __n) const
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _Allocator>
void
vector<bool, _Allocator>::push_back(const value_type& __x)
{
    if (this->__size_ == this->capacity())
        reserve(__recommend(this->__size_ + 1));
    ++this->__size_;
    back() = __x;
}

template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::insert(const_iterator __position, const value_type& __x)
{
    iterator __r;
    if (size() < capacity())
    {
        const_iterator __old_end = end();
        ++__size_;
        std::__1::copy_backward(__position, __old_end, end());
        __r = __const_iterator_cast(__position);
    }
    else
    {
        vector __v(__alloc());
        __v.reserve(__recommend(__size_ + 1));
        __v.__size_ = __size_ + 1;
        __r = std::__1::copy(cbegin(), __position, __v.begin());
        std::__1::copy_backward(__position, cend(), __v.end());
        swap(__v);
    }
    *__r = __x;
    return __r;
}

template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::insert(const_iterator __position, size_type __n, const value_type& __x)
{
    iterator __r;
    size_type __c = capacity();
    if (__n <= __c && size() <= __c - __n)
    {
        const_iterator __old_end = end();
        __size_ += __n;
        std::__1::copy_backward(__position, __old_end, end());
        __r = __const_iterator_cast(__position);
    }
    else
    {
        vector __v(__alloc());
        __v.reserve(__recommend(__size_ + __n));
        __v.__size_ = __size_ + __n;
        __r = std::__1::copy(cbegin(), __position, __v.begin());
        std::__1::copy_backward(__position, cend(), __v.end());
        swap(__v);
    }
    std::__1::fill_n(__r, __n, __x);
    return __r;
}

template <class _Allocator>
template <class _InputIterator>
typename enable_if
<
     __is_input_iterator <_InputIterator>::value &&
    !__is_forward_iterator<_InputIterator>::value,
    typename vector<bool, _Allocator>::iterator
>::type
vector<bool, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)
{
    difference_type __off = __position - begin();
    iterator __p = __const_iterator_cast(__position);
    iterator __old_end = end();
    for (; size() != capacity() && __first != __last; ++__first)
    {
        ++this->__size_;
        back() = *__first;
    }
    vector __v(__alloc());
    if (__first != __last)
    {




            __v.assign(__first, __last);
            difference_type __old_size = static_cast<difference_type>(__old_end - begin());
            difference_type __old_p = __p - begin();
            reserve(__recommend(size() + __v.size()));
            __p = begin() + __old_p;
            __old_end = begin() + __old_size;
# 3090 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/vector" 3
    }
    __p = std::__1::rotate(__p, __old_end, end());
    insert(__p, __v.begin(), __v.end());
    return begin() + __off;
}

template <class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    typename vector<bool, _Allocator>::iterator
>::type
vector<bool, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)
{
    difference_type __n = std::__1::distance(__first, __last);
    iterator __r;
    size_type __c = capacity();
    if (__n <= __c && size() <= __c - __n)
    {
        const_iterator __old_end = end();
        __size_ += __n;
        std::__1::copy_backward(__position, __old_end, end());
        __r = __const_iterator_cast(__position);
    }
    else
    {
        vector __v(__alloc());
        __v.reserve(__recommend(__size_ + __n));
        __v.__size_ = __size_ + __n;
        __r = std::__1::copy(cbegin(), __position, __v.begin());
        std::__1::copy_backward(__position, cend(), __v.end());
        swap(__v);
    }
    std::__1::copy(__first, __last, __r);
    return __r;
}

template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::erase(const_iterator __position)
{
    iterator __r = __const_iterator_cast(__position);
    std::__1::copy(__position + 1, this->cend(), __r);
    --__size_;
    return __r;
}

template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::erase(const_iterator __first, const_iterator __last)
{
    iterator __r = __const_iterator_cast(__first);
    difference_type __d = __last - __first;
    std::__1::copy(__last, this->cend(), __r);
    __size_ -= __d;
    return __r;
}

template <class _Allocator>
void
vector<bool, _Allocator>::swap(vector& __x)


{
    std::__1::swap(this->__begin_, __x.__begin_);
    std::__1::swap(this->__size_, __x.__size_);
    std::__1::swap(this->__cap(), __x.__cap());
    __swap_alloc(this->__alloc(), __x.__alloc());
}

template <class _Allocator>
void
vector<bool, _Allocator>::resize(size_type __sz, value_type __x)
{
    size_type __cs = size();
    if (__cs < __sz)
    {
        iterator __r;
        size_type __c = capacity();
        size_type __n = __sz - __cs;
        if (__n <= __c && __cs <= __c - __n)
        {
            __r = end();
            __size_ += __n;
        }
        else
        {
            vector __v(__alloc());
            __v.reserve(__recommend(__size_ + __n));
            __v.__size_ = __size_ + __n;
            __r = std::__1::copy(cbegin(), cend(), __v.begin());
            swap(__v);
        }
        std::__1::fill_n(__r, __n, __x);
    }
    else
        __size_ = __sz;
}

template <class _Allocator>
void
vector<bool, _Allocator>::flip() throw()
{

    size_type __n = __size_;
    __storage_pointer __p = __begin_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        *__p = ~*__p;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = *__p & __m;
        *__p &= ~__m;
        *__p |= ~__b & __m;
    }
}

template <class _Allocator>
bool
vector<bool, _Allocator>::__invariants() const
{
    if (this->__begin_ == std::__1::__get_nullptr_t())
    {
        if (this->__size_ != 0 || this->__cap() != 0)
            return false;
    }
    else
    {
        if (this->__cap() == 0)
            return false;
        if (this->__size_ > this->capacity())
            return false;
    }
    return true;
}

template <class _Allocator>
size_t
vector<bool, _Allocator>::__hash_code() const throw()
{
    size_t __h = 0;

    size_type __n = __size_;
    __storage_pointer __p = __begin_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        __h ^= *__p;

    if (__n > 0)
    {
        const __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __h ^= *__p & __m;
    }
    return __h;
}

template <class _Allocator>
struct __attribute__ ((__type_visibility__("default"))) hash<vector<bool, _Allocator> >
    : public unary_function<vector<bool, _Allocator>, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(const vector<bool, _Allocator>& __vec) const throw()
        {return __vec.__hash_code();}
};

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();
    return __sz == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(vector<_Tp, _Allocator>& __x, vector<_Tp, _Allocator>& __y)

{
    __x.swap(__y);
}

} }
# 16 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ArrayRef.h" 2

namespace llvm {
# 30 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ArrayRef.h"
  template<typename T>
  class ArrayRef {
  public:
    typedef const T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;

    typedef std::reverse_iterator<iterator> reverse_iterator;

  private:

    const T *Data;


    size_type Length;

  public:




                 ArrayRef() : Data(0), Length(0) {}


                 ArrayRef(NoneType) : Data(0), Length(0) {}


                 ArrayRef(const T &OneElt)
      : Data(&OneElt), Length(1) {}


                 ArrayRef(const T *data, size_t length)
      : Data(data), Length(length) {}


    ArrayRef(const T *begin, const T *end)
      : Data(begin), Length(end - begin) {}




    template<typename U>
                 ArrayRef(const SmallVectorTemplateCommon<T, U> &Vec)
      : Data(Vec.data()), Length(Vec.size()) {
    }


    template<typename A>
                 ArrayRef(const std::vector<T, A> &Vec)
      : Data(Vec.empty() ? (T*)0 : &Vec[0]), Length(Vec.size()) {}


    template <size_t N>
                                ArrayRef(const T (&Arr)[N])
      : Data(Arr), Length(N) {}
# 97 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ArrayRef.h"
    iterator begin() const { return Data; }
    iterator end() const { return Data + Length; }

    reverse_iterator rbegin() const { return reverse_iterator(end()); }
    reverse_iterator rend() const { return reverse_iterator(begin()); }


    bool empty() const { return Length == 0; }

    const T *data() const { return Data; }


    size_t size() const { return Length; }


    const T &front() const {
      ((void)((!empty()) || (__assert_fail("!empty()", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ArrayRef.h", 113, __func__),0)));
      return Data[0];
    }


    const T &back() const {
      ((void)((!empty()) || (__assert_fail("!empty()", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ArrayRef.h", 119, __func__),0)));
      return Data[Length-1];
    }


    bool equals(ArrayRef RHS) const {
      if (Length != RHS.Length)
        return false;
      for (size_type i = 0; i != Length; i++)
        if (Data[i] != RHS.Data[i])
          return false;
      return true;
    }


    ArrayRef<T> slice(unsigned N) const {
      ((void)((N <= size() && "Invalid specifier") || (__assert_fail("N <= size() && \"Invalid specifier\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ArrayRef.h", 135, __func__),0)));
      return ArrayRef<T>(data()+N, size()-N);
    }



    ArrayRef<T> slice(unsigned N, unsigned M) const {
      ((void)((N+M <= size() && "Invalid specifier") || (__assert_fail("N+M <= size() && \"Invalid specifier\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ArrayRef.h", 142, __func__),0)));
      return ArrayRef<T>(data()+N, M);
    }




    const T &operator[](size_t Index) const {
      ((void)((Index < Length && "Invalid index!") || (__assert_fail("Index < Length && \"Invalid index!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ArrayRef.h", 150, __func__),0)));
      return Data[Index];
    }




    std::vector<T> vec() const {
      return std::vector<T>(Data, Data+Length);
    }




    operator std::vector<T>() const {
      return std::vector<T>(Data, Data+Length);
    }


  };
# 183 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ArrayRef.h"
  template<typename T>
  class MutableArrayRef : public ArrayRef<T> {
  public:
    typedef T *iterator;


                 MutableArrayRef() : ArrayRef<T>() {}


                 MutableArrayRef(NoneType) : ArrayRef<T>() {}


                 MutableArrayRef(T &OneElt) : ArrayRef<T>(OneElt) {}


                 MutableArrayRef(T *data, size_t length)
      : ArrayRef<T>(data, length) {}


    MutableArrayRef(T *begin, T *end) : ArrayRef<T>(begin, end) {}


                 MutableArrayRef(SmallVectorImpl<T> &Vec)
    : ArrayRef<T>(Vec) {}


                 MutableArrayRef(std::vector<T> &Vec)
    : ArrayRef<T>(Vec) {}


    template <size_t N>
                 MutableArrayRef(T (&Arr)[N])
      : ArrayRef<T>(Arr) {}

    T *data() const { return const_cast<T*>(ArrayRef<T>::data()); }

    iterator begin() const { return data(); }
    iterator end() const { return data() + this->size(); }


    T &front() const {
      ((void)((!this->empty()) || (__assert_fail("!this->empty()", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ArrayRef.h", 224, __func__),0)));
      return data()[0];
    }


    T &back() const {
      ((void)((!this->empty()) || (__assert_fail("!this->empty()", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ArrayRef.h", 230, __func__),0)));
      return data()[this->size()-1];
    }


    MutableArrayRef<T> slice(unsigned N) const {
      ((void)((N <= this->size() && "Invalid specifier") || (__assert_fail("N <= this->size() && \"Invalid specifier\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ArrayRef.h", 236, __func__),0)));
      return MutableArrayRef<T>(data()+N, this->size()-N);
    }



    MutableArrayRef<T> slice(unsigned N, unsigned M) const {
      ((void)((N+M <= this->size() && "Invalid specifier") || (__assert_fail("N+M <= this->size() && \"Invalid specifier\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ArrayRef.h", 243, __func__),0)));
      return MutableArrayRef<T>(data()+N, M);
    }




    T &operator[](size_t Index) const {
      ((void)((Index < this->size() && "Invalid index!") || (__assert_fail("Index < this->size() && \"Invalid index!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ArrayRef.h", 251, __func__),0)));
      return data()[Index];
    }
  };





  template<typename T>
  ArrayRef<T> makeArrayRef(const T &OneElt) {
    return OneElt;
  }


  template<typename T>
  ArrayRef<T> makeArrayRef(const T *data, size_t length) {
    return ArrayRef<T>(data, length);
  }


  template<typename T>
  ArrayRef<T> makeArrayRef(const T *begin, const T *end) {
    return ArrayRef<T>(begin, end);
  }


  template <typename T>
  ArrayRef<T> makeArrayRef(const SmallVectorImpl<T> &Vec) {
    return Vec;
  }


  template <typename T, unsigned N>
  ArrayRef<T> makeArrayRef(const SmallVector<T, N> &Vec) {
    return Vec;
  }


  template<typename T>
  ArrayRef<T> makeArrayRef(const std::vector<T> &Vec) {
    return Vec;
  }


  template<typename T, size_t N>
  ArrayRef<T> makeArrayRef(const T (&Arr)[N]) {
    return ArrayRef<T>(Arr);
  }





  template<typename T>
  inline bool operator==(ArrayRef<T> LHS, ArrayRef<T> RHS) {
    return LHS.equals(RHS);
  }

  template<typename T>
  inline bool operator!=(ArrayRef<T> LHS, ArrayRef<T> RHS) {
    return !(LHS == RHS);
  }




  template <typename T> struct isPodLike;
  template <typename T> struct isPodLike<ArrayRef<T> > {
    static const bool value = true;
  };
}
# 20 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Attributes.h" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/FoldingSet.h" 1
# 20 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/FoldingSet.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/StringRef.h" 1
# 15 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/StringRef.h"
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 1 3
# 21 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/assert.h" 1 3
# 12 "/mnt/home/ec2-user/build/emscripten/system/include/libc/assert.h" 3
extern "C" {



__attribute__((__noreturn__))

void __assert_fail (const char *, const char *, int, const char *);


}
# 22 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 2 3
# 25 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 3
# 16 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/StringRef.h" 2


# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/string" 1 3
# 437 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/string" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cstdio" 1 3
# 100 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cstdio" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/stdio.h" 1 3




extern "C" {
# 22 "/mnt/home/ec2-user/build/emscripten/system/include/libc/stdio.h" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 1 3
# 23 "/mnt/home/ec2-user/build/emscripten/system/include/libc/stdio.h" 2 3
# 50 "/mnt/home/ec2-user/build/emscripten/system/include/libc/stdio.h" 3
typedef union _G_fpos64_t {
 char __opaque[16];
 double __align;
} fpos_t;

extern FILE *const stdin;
extern FILE *const stdout;
extern FILE *const stderr;





FILE *fopen(const char *__restrict, const char *__restrict);
FILE *freopen(const char *__restrict, const char *__restrict, FILE *__restrict);
int fclose(FILE *);

int remove(const char *);
int rename(const char *, const char *);

int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
void clearerr(FILE *);

int fseek(FILE *, long, int);
long ftell(FILE *);
void rewind(FILE *);

int fgetpos(FILE *__restrict, fpos_t *__restrict);
int fsetpos(FILE *, const fpos_t *);

size_t fread(void *__restrict, size_t, size_t, FILE *__restrict);
size_t fwrite(const void *__restrict, size_t, size_t, FILE *__restrict);

int fgetc(FILE *);
int getc(FILE *);
int getchar(void);
int ungetc(int, FILE *);

int fputc(int, FILE *);
int putc(int, FILE *);
int putchar(int);

char *fgets(char *__restrict, int, FILE *__restrict);

char *gets(char *);


int fputs(const char *__restrict, FILE *__restrict);
int puts(const char *);

int printf(const char *__restrict, ...);
int fprintf(FILE *__restrict, const char *__restrict, ...);
int sprintf(char *__restrict, const char *__restrict, ...);
int snprintf(char *__restrict, size_t, const char *__restrict, ...);

int vprintf(const char *__restrict, __isoc_va_list);
int vfprintf(FILE *__restrict, const char *__restrict, __isoc_va_list);
int vsprintf(char *__restrict, const char *__restrict, __isoc_va_list);
int vsnprintf(char *__restrict, size_t, const char *__restrict, __isoc_va_list);

int scanf(const char *__restrict, ...);
int fscanf(FILE *__restrict, const char *__restrict, ...);
int sscanf(const char *__restrict, const char *__restrict, ...);
int vscanf(const char *__restrict, __isoc_va_list);
int vfscanf(FILE *__restrict, const char *__restrict, __isoc_va_list);
int vsscanf(const char *__restrict, const char *__restrict, __isoc_va_list);

void perror(const char *);

int setvbuf(FILE *__restrict, char *__restrict, int, size_t);
void setbuf(FILE *__restrict, char *__restrict);

char *tmpnam(char *);
FILE *tmpfile(void);




FILE *fmemopen(void *__restrict, size_t, const char *__restrict);
FILE *open_memstream(char **, size_t *);
FILE *fdopen(int, const char *);
FILE *popen(const char *, const char *);
int pclose(FILE *);
int fileno(FILE *);
int fseeko(FILE *, off_t, int);
off_t ftello(FILE *);
int dprintf(int, const char *__restrict, ...);
int vdprintf(int, const char *__restrict, __isoc_va_list);
void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int getc_unlocked(FILE *);
int getchar_unlocked(void);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);
ssize_t getdelim(char **__restrict, size_t *__restrict, int, FILE *__restrict);
ssize_t getline(char **__restrict, size_t *__restrict, FILE *__restrict);
int renameat(int, const char *, int, const char *);
char *ctermid(char *);







char *tempnam(const char *, const char *);




char *cuserid(char *);
void setlinebuf(FILE *);
void setbuffer(FILE *, char *, size_t);
int fgetc_unlocked(FILE *);
int fputc_unlocked(int, FILE *);
int fflush_unlocked(FILE *);
size_t fread_unlocked(void *, size_t, size_t, FILE *);
size_t fwrite_unlocked(const void *, size_t, size_t, FILE *);
void clearerr_unlocked(FILE *);
int feof_unlocked(FILE *);
int ferror_unlocked(FILE *);
int fileno_unlocked(FILE *);
int getw(FILE *);
int putw(int, FILE *);
char *fgetln(FILE *, size_t *);
int asprintf(char **, const char *, ...);
int vasprintf(char **, const char *, __isoc_va_list);



char *fgets_unlocked(char *, int, FILE *);
int fputs_unlocked(const char *, FILE *);
# 200 "/mnt/home/ec2-user/build/emscripten/system/include/libc/stdio.h" 3
}
# 101 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cstdio" 2 3
# 104 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cstdio" 3
# 123 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cstdio" 3
namespace std {inline namespace __1 {

using ::FILE;
using ::fpos_t;
using ::size_t;

using ::remove;
using ::rename;
using ::tmpfile;
using ::tmpnam;
using ::fclose;
using ::fflush;
using ::fopen;
using ::freopen;
using ::setbuf;
using ::setvbuf;
using ::fprintf;
using ::fscanf;
using ::printf;
using ::scanf;
using ::snprintf;
using ::sprintf;
using ::sscanf;

using ::vfprintf;
using ::vfscanf;
using ::vscanf;
using ::vsscanf;

using ::vprintf;
using ::vsnprintf;
using ::vsprintf;
using ::fgetc;
using ::fgets;
using ::fputc;
using ::fputs;
using ::getc;
using ::getchar;

using ::gets;

using ::putc;
using ::putchar;
using ::puts;
using ::ungetc;
using ::fread;
using ::fwrite;
using ::fgetpos;
using ::fseek;
using ::fsetpos;
using ::ftell;
using ::rewind;
using ::clearerr;
using ::feof;
using ::ferror;
using ::perror;

} }
# 438 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/string" 2 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cwchar" 1 3
# 107 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cwchar" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cwctype" 1 3
# 54 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cwctype" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cctype" 1 3
# 39 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cctype" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/compat/ctype.h" 1 3
# 15 "/mnt/home/ec2-user/build/emscripten/system/include/compat/ctype.h" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/ctype.h" 1 3




extern "C" {




int isalnum(int);
int isalpha(int);
int isblank(int);
int iscntrl(int);
int isdigit(int);
int isgraph(int);
int islower(int);
int isprint(int);
int ispunct(int);
int isspace(int);
int isupper(int);
int isxdigit(int);
int tolower(int);
int toupper(int);
# 39 "/mnt/home/ec2-user/build/emscripten/system/include/libc/ctype.h" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 1 3
# 40 "/mnt/home/ec2-user/build/emscripten/system/include/libc/ctype.h" 2 3

int isalnum_l(int, locale_t);
int isalpha_l(int, locale_t);
int isblank_l(int, locale_t);
int iscntrl_l(int, locale_t);
int isdigit_l(int, locale_t);
int isgraph_l(int, locale_t);
int islower_l(int, locale_t);
int isprint_l(int, locale_t);
int ispunct_l(int, locale_t);
int isspace_l(int, locale_t);
int isupper_l(int, locale_t);
int isxdigit_l(int, locale_t);
int tolower_l(int, locale_t);
int toupper_l(int, locale_t);

int isascii(int);
int toascii(int);






}
# 16 "/mnt/home/ec2-user/build/emscripten/system/include/compat/ctype.h" 2 3
# 40 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cctype" 2 3
# 46 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cctype" 3


namespace std {inline namespace __1 {






using ::isalnum;







using ::isalpha;







using ::isblank;







using ::iscntrl;







using ::isdigit;







using ::isgraph;







using ::islower;







using ::isprint;







using ::ispunct;







using ::isspace;







using ::isupper;







using ::isxdigit;







using ::tolower;







using ::toupper;


} }
# 55 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cwctype" 2 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/compat/wctype.h" 1 3



# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/wctype.h" 1 3




extern "C" {
# 18 "/mnt/home/ec2-user/build/emscripten/system/include/libc/wctype.h" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 1 3
# 19 "/mnt/home/ec2-user/build/emscripten/system/include/libc/wctype.h" 2 3

typedef const int * wctrans_t;






int iswalnum(wint_t);
int iswalpha(wint_t);
int iswblank(wint_t);
int iswcntrl(wint_t);
int iswdigit(wint_t);
int iswgraph(wint_t);
int iswlower(wint_t);
int iswprint(wint_t);
int iswpunct(wint_t);
int iswspace(wint_t);
int iswupper(wint_t);
int iswxdigit(wint_t);
int iswctype(wint_t, wctype_t);
wint_t towctrans(wint_t, wctrans_t);
wint_t towlower(wint_t);
wint_t towupper(wint_t);
wctrans_t wctrans(const char *);
wctype_t wctype(const char *);







int iswalnum_l(wint_t, locale_t);
int iswalpha_l(wint_t, locale_t);
int iswblank_l(wint_t, locale_t);
int iswcntrl_l(wint_t, locale_t);
int iswdigit_l(wint_t, locale_t);
int iswgraph_l(wint_t, locale_t);
int iswlower_l(wint_t, locale_t);
int iswprint_l(wint_t, locale_t);
int iswpunct_l(wint_t, locale_t);
int iswspace_l(wint_t, locale_t);
int iswupper_l(wint_t, locale_t);
int iswxdigit_l(wint_t, locale_t);
int iswctype_l(wint_t, wctype_t, locale_t);
wint_t towlower_l(wint_t, locale_t);
wint_t towupper_l(wint_t, locale_t);
wint_t towctrans_l(wint_t, wctrans_t, locale_t);
wctrans_t wctrans_l(const char *, locale_t);
wctype_t wctype_l(const char *, locale_t);




}
# 5 "/mnt/home/ec2-user/build/emscripten/system/include/compat/wctype.h" 2 3
# 56 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cwctype" 2 3
# 59 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cwctype" 3


namespace std {inline namespace __1 {

using ::wint_t;
using ::wctrans_t;
using ::wctype_t;






using ::iswalnum;







using ::iswalpha;







using ::iswblank;







using ::iswcntrl;







using ::iswdigit;







using ::iswgraph;







using ::iswlower;







using ::iswprint;







using ::iswpunct;







using ::iswspace;







using ::iswupper;







using ::iswxdigit;







using ::iswctype;







using ::wctype;







using ::towlower;







using ::towupper;







using ::towctrans;







using ::wctrans;


} }
# 108 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cwchar" 2 3
# 115 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cwchar" 3


namespace std {inline namespace __1 {

using ::mbstate_t;
using ::size_t;
using ::tm;
using ::wint_t;
using ::FILE;
using ::fwprintf;
using ::fwscanf;
using ::swprintf;
using ::vfwprintf;
using ::vswprintf;
using ::vwprintf;

using ::swscanf;
using ::vfwscanf;
using ::vswscanf;
using ::vwscanf;

using ::wprintf;
using ::wscanf;
using ::fgetwc;
using ::fgetws;
using ::fputwc;
using ::fputws;
using ::fwide;
using ::getwc;
using ::getwchar;
using ::putwc;
using ::putwchar;
using ::ungetwc;
using ::wcstod;

using ::wcstof;
using ::wcstold;

using ::wcstol;

using ::wcstoll;

using ::wcstoul;

using ::wcstoull;

using ::wcscpy;
using ::wcsncpy;
using ::wcscat;
using ::wcsncat;
using ::wcscmp;
using ::wcscoll;
using ::wcsncmp;
using ::wcsxfrm;
# 180 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cwchar" 3
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) const wchar_t* wcschr(const wchar_t* __s, wchar_t __c) {return ::wcschr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) wchar_t* wcschr( wchar_t* __s, wchar_t __c) {return ::wcschr(__s, __c);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) const wchar_t* wcspbrk(const wchar_t* __s1, const wchar_t* __s2) {return ::wcspbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) wchar_t* wcspbrk( wchar_t* __s1, const wchar_t* __s2) {return ::wcspbrk(__s1, __s2);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) const wchar_t* wcsrchr(const wchar_t* __s, wchar_t __c) {return ::wcsrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) wchar_t* wcsrchr( wchar_t* __s, wchar_t __c) {return ::wcsrchr(__s, __c);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) const wchar_t* wcsstr(const wchar_t* __s1, const wchar_t* __s2) {return ::wcsstr(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) wchar_t* wcsstr( wchar_t* __s1, const wchar_t* __s2) {return ::wcsstr(__s1, __s2);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) const wchar_t* wmemchr(const wchar_t* __s, wchar_t __c, size_t __n) {return ::wmemchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) wchar_t* wmemchr( wchar_t* __s, wchar_t __c, size_t __n) {return ::wmemchr(__s, __c, __n);}



using ::wcscspn;
using ::wcslen;
using ::wcsspn;
using ::wcstok;
using ::wmemcmp;
using ::wmemcpy;
using ::wmemmove;
using ::wmemset;
using ::wcsftime;
using ::btowc;
using ::wctob;
using ::mbsinit;
using ::mbrlen;
using ::mbrtowc;
using ::wcrtomb;
using ::mbsrtowcs;
using ::wcsrtombs;

} }
# 439 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/string" 2 3
# 451 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/string" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 1 3
# 21 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/assert.h" 1 3
# 12 "/mnt/home/ec2-user/build/emscripten/system/include/libc/assert.h" 3
extern "C" {



__attribute__((__noreturn__))

void __assert_fail (const char *, const char *, int, const char *);


}
# 22 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 2 3
# 25 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 3
# 452 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/string" 2 3


# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__undef_min_max" 1 3
# 455 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/string" 2 3
# 460 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/string" 3


namespace std {inline namespace __1 {



template <class _StateT>
class __attribute__ ((__type_visibility__("default"))) fpos
{
private:
    _StateT __st_;
    streamoff __off_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator streamoff() const {return __off_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _StateT state() const {return __st_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void state(_StateT __st) {__st_ = __st;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fpos operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fpos operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}
};

template <class _StateT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
    {return streamoff(__x) - streamoff(__y);}

template <class _StateT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
    {return streamoff(__x) == streamoff(__y);}

template <class _StateT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
    {return streamoff(__x) != streamoff(__y);}



template <class _CharT>
struct __attribute__ ((__type_visibility__("default"))) char_traits
{
    typedef _CharT char_type;
    typedef int int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    static inline void assign(char_type& __c1, const char_type& __c2) throw()
        {__c1 = __c2;}
    static inline bool eq(char_type __c1, char_type __c2) throw()
        {return __c1 == __c2;}
    static inline bool lt(char_type __c1, char_type __c2) throw()
        {return __c1 < __c2;}

    static int compare(const char_type* __s1, const char_type* __s2, size_t __n);
    static size_t length(const char_type* __s);
    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n);
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n);
    static char_type* assign(char_type* __s, size_t __n, char_type __a);

    static inline int_type not_eof(int_type __c) throw()
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline char_type to_char_type(int_type __c) throw()
        {return char_type(__c);}
    static inline int_type to_int_type(char_type __c) throw()
        {return int_type(__c);}
    static inline bool eq_int_type(int_type __c1, int_type __c2) throw()
        {return __c1 == __c2;}
    static inline int_type eof() throw()
        {return int_type((-1));}
};

template <class _CharT>
int
char_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
size_t
char_traits<_CharT>::length(const char_type* __s)
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _CharT*
char_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return 0;
}

template <class _CharT>
_CharT*
char_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)
{
    char_type* __r = __s1;
    if (__s1 < __s2)
    {
        for (; __n; --__n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (__s2 < __s1)
    {
        __s1 += __n;
        __s2 += __n;
        for (; __n; --__n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_CharT*
char_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)
{
    ((void)0);
    char_type* __r = __s1;
    for (; __n; --__n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_CharT*
char_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)
{
    char_type* __r = __s;
    for (; __n; --__n, ++__s)
        assign(*__s, __a);
    return __r;
}



template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<char>
{
    typedef char char_type;
    typedef int int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    static inline void assign(char_type& __c1, const char_type& __c2) throw()
        {__c1 = __c2;}
    static inline bool eq(char_type __c1, char_type __c2) throw()
            {return __c1 == __c2;}
    static inline bool lt(char_type __c1, char_type __c2) throw()
        {return (unsigned char)__c1 < (unsigned char)__c2;}

    static inline int compare(const char_type* __s1, const char_type* __s2, size_t __n)
        {return memcmp(__s1, __s2, __n);}
    static inline size_t length(const char_type* __s) {return strlen(__s);}
    static inline const char_type* find(const char_type* __s, size_t __n, const char_type& __a)
        {return (const char_type*)memchr(__s, to_int_type(__a), __n);}
    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n)
        {return (char_type*)memmove(__s1, __s2, __n);}
    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)
        {
            ((void)0);
            return (char_type*)memcpy(__s1, __s2, __n);
        }
    static inline char_type* assign(char_type* __s, size_t __n, char_type __a)
        {return (char_type*)memset(__s, to_int_type(__a), __n);}

    static inline int_type not_eof(int_type __c) throw()
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline char_type to_char_type(int_type __c) throw()
        {return char_type(__c);}
    static inline int_type to_int_type(char_type __c) throw()
        {return int_type((unsigned char)__c);}
    static inline bool eq_int_type(int_type __c1, int_type __c2) throw()
        {return __c1 == __c2;}
    static inline int_type eof() throw()
        {return int_type((-1));}
};



template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<wchar_t>
{
    typedef wchar_t char_type;
    typedef wint_t int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    static inline void assign(char_type& __c1, const char_type& __c2) throw()
        {__c1 = __c2;}
    static inline bool eq(char_type __c1, char_type __c2) throw()
        {return __c1 == __c2;}
    static inline bool lt(char_type __c1, char_type __c2) throw()
        {return __c1 < __c2;}

    static inline int compare(const char_type* __s1, const char_type* __s2, size_t __n)
        {return wmemcmp(__s1, __s2, __n);}
    static inline size_t length(const char_type* __s)
        {return wcslen(__s);}
    static inline const char_type* find(const char_type* __s, size_t __n, const char_type& __a)
        {return (const char_type*)wmemchr(__s, __a, __n);}
    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n)
        {return (char_type*)wmemmove(__s1, __s2, __n);}
    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)
        {
            ((void)0);
            return (char_type*)wmemcpy(__s1, __s2, __n);
        }
    static inline char_type* assign(char_type* __s, size_t __n, char_type __a)
        {return (char_type*)wmemset(__s, __a, __n);}

    static inline int_type not_eof(int_type __c) throw()
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline char_type to_char_type(int_type __c) throw()
        {return char_type(__c);}
    static inline int_type to_int_type(char_type __c) throw()
        {return int_type(__c);}
    static inline bool eq_int_type(int_type __c1, int_type __c2) throw()
        {return __c1 == __c2;}
    static inline int_type eof() throw()
        {return int_type(0xffffffffU);}
};



template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<char16_t>
{
    typedef char16_t char_type;
    typedef uint_least16_t int_type;
    typedef streamoff off_type;
    typedef u16streampos pos_type;
    typedef mbstate_t state_type;

    static inline void assign(char_type& __c1, const char_type& __c2) throw()
        {__c1 = __c2;}
    static inline bool eq(char_type __c1, char_type __c2) throw()
        {return __c1 == __c2;}
    static inline bool lt(char_type __c1, char_type __c2) throw()
        {return __c1 < __c2;}

    static int compare(const char_type* __s1, const char_type* __s2, size_t __n);
    static size_t length(const char_type* __s);
    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n);
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n);
    static char_type* assign(char_type* __s, size_t __n, char_type __a);

    static inline int_type not_eof(int_type __c) throw()
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline char_type to_char_type(int_type __c) throw()
        {return char_type(__c);}
    static inline int_type to_int_type(char_type __c) throw()
        {return int_type(__c);}
    static inline bool eq_int_type(int_type __c1, int_type __c2) throw()
        {return __c1 == __c2;}
    static inline int_type eof() throw()
        {return int_type(0xDFFF);}
};

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int
char_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
size_t
char_traits<char16_t>::length(const char_type* __s)
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const char16_t*
char_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a)
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char16_t*
char_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n)
{
    char_type* __r = __s1;
    if (__s1 < __s2)
    {
        for (; __n; --__n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (__s2 < __s1)
    {
        __s1 += __n;
        __s2 += __n;
        for (; __n; --__n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char16_t*
char_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)
{
    ((void)0);
    char_type* __r = __s1;
    for (; __n; --__n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char16_t*
char_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a)
{
    char_type* __r = __s;
    for (; __n; --__n, ++__s)
        assign(*__s, __a);
    return __r;
}

template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<char32_t>
{
    typedef char32_t char_type;
    typedef uint_least32_t int_type;
    typedef streamoff off_type;
    typedef u32streampos pos_type;
    typedef mbstate_t state_type;

    static inline void assign(char_type& __c1, const char_type& __c2) throw()
        {__c1 = __c2;}
    static inline bool eq(char_type __c1, char_type __c2) throw()
        {return __c1 == __c2;}
    static inline bool lt(char_type __c1, char_type __c2) throw()
        {return __c1 < __c2;}

    static int compare(const char_type* __s1, const char_type* __s2, size_t __n);
    static size_t length(const char_type* __s);
    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n);
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n);
    static char_type* assign(char_type* __s, size_t __n, char_type __a);

    static inline int_type not_eof(int_type __c) throw()
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline char_type to_char_type(int_type __c) throw()
        {return char_type(__c);}
    static inline int_type to_int_type(char_type __c) throw()
        {return int_type(__c);}
    static inline bool eq_int_type(int_type __c1, int_type __c2) throw()
        {return __c1 == __c2;}
    static inline int_type eof() throw()
        {return int_type(0xFFFFFFFF);}
};

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int
char_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
size_t
char_traits<char32_t>::length(const char_type* __s)
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const char32_t*
char_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a)
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char32_t*
char_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n)
{
    char_type* __r = __s1;
    if (__s1 < __s2)
    {
        for (; __n; --__n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (__s2 < __s1)
    {
        __s1 += __n;
        __s2 += __n;
        for (; __n; --__n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char32_t*
char_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)
{
    ((void)0);
    char_type* __r = __s1;
    for (; __n; --__n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char32_t*
char_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a)
{
    char_type* __r = __s;
    for (; __n; --__n, ++__s)
        assign(*__s, __a);
    return __r;
}






template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_find(const _CharT *__p, _SizeT __sz,
             _CharT __c, _SizeT __pos) throw()
{
    if (__pos >= __sz)
        return __npos;
    const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);
    if (__r == 0)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}

template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_find(const _CharT *__p, _SizeT __sz,
       const _CharT* __s, _SizeT __pos, _SizeT __n) throw()
{
    if (__pos > __sz || __sz - __pos < __n)
        return __npos;
    if (__n == 0)
        return __pos;
    const _CharT* __r =
        std::__1::__search(__p + __pos, __p + __sz,
                        __s, __s + __n, _Traits::eq,
                        random_access_iterator_tag(), random_access_iterator_tag());
    if (__r == __p + __sz)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}




template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_rfind(const _CharT *__p, _SizeT __sz,
              _CharT __c, _SizeT __pos) throw()
{
    if (__sz < 1)
        return __npos;
    if (__pos < __sz)
        ++__pos;
    else
        __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;)
    {
        if (_Traits::eq(*--__ps, __c))
            return static_cast<_SizeT>(__ps - __p);
    }
    return __npos;
}

template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_rfind(const _CharT *__p, _SizeT __sz,
        const _CharT* __s, _SizeT __pos, _SizeT __n) throw()
{
    __pos = std::__1::min(__pos, __sz);
    if (__n < __sz - __pos)
        __pos += __n;
    else
        __pos = __sz;
    const _CharT* __r = std::__1::__find_end(
                  __p, __p + __pos, __s, __s + __n, _Traits::eq,
                        random_access_iterator_tag(), random_access_iterator_tag());
    if (__n > 0 && __r == __p + __pos)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_find_first_of(const _CharT *__p, _SizeT __sz,
                const _CharT* __s, _SizeT __pos, _SizeT __n) throw()
{
    if (__pos >= __sz || __n == 0)
        return __npos;
    const _CharT* __r = std::__1::__find_first_of_ce
        (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );
    if (__r == __p + __sz)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}



template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_find_last_of(const _CharT *__p, _SizeT __sz,
               const _CharT* __s, _SizeT __pos, _SizeT __n) throw()
    {
    if (__n != 0)
    {
        if (__pos < __sz)
            ++__pos;
        else
            __pos = __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __p;)
        {
            const _CharT* __r = _Traits::find(__s, __n, *--__ps);
            if (__r)
                return static_cast<_SizeT>(__ps - __p);
        }
    }
    return __npos;
}



template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_find_first_not_of(const _CharT *__p, _SizeT __sz,
                    const _CharT* __s, _SizeT __pos, _SizeT __n) throw()
{
    if (__pos < __sz)
    {
        const _CharT* __pe = __p + __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)
            if (_Traits::find(__s, __n, *__ps) == 0)
                return static_cast<_SizeT>(__ps - __p);
    }
    return __npos;
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_find_first_not_of(const _CharT *__p, _SizeT __sz,
                          _CharT __c, _SizeT __pos) throw()
{
    if (__pos < __sz)
    {
        const _CharT* __pe = __p + __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)
            if (!_Traits::eq(*__ps, __c))
                return static_cast<_SizeT>(__ps - __p);
    }
    return __npos;
}



template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_find_last_not_of(const _CharT *__p, _SizeT __sz,
                   const _CharT* __s, _SizeT __pos, _SizeT __n) throw()
{
    if (__pos < __sz)
        ++__pos;
    else
        __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;)
        if (_Traits::find(__s, __n, *--__ps) == 0)
            return static_cast<_SizeT>(__ps - __p);
    return __npos;
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__))
__str_find_last_not_of(const _CharT *__p, _SizeT __sz,
                         _CharT __c, _SizeT __pos) throw()
{
    if (__pos < __sz)
        ++__pos;
    else
        __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;)
        if (!_Traits::eq(*--__ps, __c))
            return static_cast<_SizeT>(__ps - __p);
    return __npos;
}

template<class _Ptr>
size_t __attribute__ ((__visibility__("hidden"), __always_inline__)) __do_string_hash(_Ptr __p, _Ptr __e)
{
    typedef typename iterator_traits<_Ptr>::value_type value_type;
    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));
}



template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x,
          const basic_string<_CharT, _Traits, _Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);

template <bool>
class __attribute__ ((__type_visibility__("default"))) __basic_string_common
{
protected:
    void __throw_length_error() const;
    void __throw_out_of_range() const;
};

template <bool __b>
void
__basic_string_common<__b>::__throw_length_error() const
{



    ((void)((!"basic_string length_error") || (__assert_fail("!\"basic_string length_error\"", "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/string", 1164, __func__),0)));

}

template <bool __b>
void
__basic_string_common<__b>::__throw_out_of_range() const
{



    ((void)((!"basic_string out_of_range") || (__assert_fail("!\"basic_string out_of_range\"", "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/string", 1175, __func__),0)));

}





extern template class __attribute__ ((__type_visibility__("default"))) __basic_string_common<true>;
# 1203 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/string" 3
template<class _CharT, class _Traits, class _Allocator>
class __attribute__ ((__type_visibility__("default"))) basic_string
    : private __basic_string_common<true>
{
public:
    typedef basic_string __self;
    typedef _Traits traits_type;
    typedef typename traits_type::char_type value_type;
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;

    typedef __static_assert_check<sizeof(__static_assert_test<(is_pod<value_type>::value)>)> __t1220;
    typedef __static_assert_check<sizeof(__static_assert_test<((is_same<_CharT, value_type>::value))>)> __t1222;

    typedef __static_assert_check<sizeof(__static_assert_test<((is_same<typename allocator_type::value_type, value_type>::value))>)> __t1224;





    typedef __wrap_iter<pointer> iterator;
    typedef __wrap_iter<const_pointer> const_iterator;

    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

private:
# 1269 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/string" 3
    struct __long
    {
        size_type __cap_;
        size_type __size_;
        pointer __data_;
    };





    enum {__short_mask = 0x01};
    enum {__long_mask = 0x1ul};


    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?
                      (sizeof(__long) - 1)/sizeof(value_type) : 2};

    struct __short
    {
        union
        {
            unsigned char __size_;
            value_type __lx;
        };
        value_type __data_[__min_cap];
    };



    union __ulx{__long __lx; __short __lxx;};

    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};

    struct __raw
    {
        size_type __words[__n_words];
    };

    struct __rep
    {
        union
        {
            __long __l;
            __short __s;
            __raw __r;
        };
    };

    __compressed_pair<__rep, allocator_type> __r_;

public:
    static const size_type npos = -1;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string()
                                                                           ;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit basic_string(const allocator_type& __a);
    basic_string(const basic_string& __str);
    basic_string(const basic_string& __str, const allocator_type& __a);







    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string(const value_type* __s);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(const value_type* __s, const allocator_type& __a);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(const value_type* __s, size_type __n);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(const value_type* __s, size_type __n, const allocator_type& __a);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(size_type __n, value_type __c);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(size_type __n, value_type __c, const allocator_type& __a);
    basic_string(const basic_string& __str, size_type __pos, size_type __n = npos,
                 const allocator_type& __a = allocator_type());
    template<class _InputIterator>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        basic_string(_InputIterator __first, _InputIterator __last);
    template<class _InputIterator>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);







    ~basic_string();

    basic_string& operator=(const basic_string& __str);






    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string& operator=(const value_type* __s) {return assign(__s);}
    basic_string& operator=(value_type __c);
# 1391 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/string" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator begin() throw()
        {return iterator(__get_pointer());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator begin() const throw()
        {return const_iterator(__get_pointer());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator end() throw()
        {return iterator(__get_pointer() + size());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator end() const throw()
        {return const_iterator(__get_pointer() + size());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    reverse_iterator rbegin() throw()
        {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator rbegin() const throw()
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    reverse_iterator rend() throw()
        {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator rend() const throw()
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator cbegin() const throw()
        {return begin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator cend() const throw()
        {return end();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator crbegin() const throw()
        {return rbegin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator crend() const throw()
        {return rend();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type size() const throw()
        {return __is_long() ? __get_long_size() : __get_short_size();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type length() const throw() {return size();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type max_size() const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type capacity() const throw()
        {return (__is_long() ? __get_long_cap() : __min_cap) - 1;}

    void resize(size_type __n, value_type __c);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void resize(size_type __n) {resize(__n, value_type());}

    void reserve(size_type res_arg = 0);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void shrink_to_fit() throw() {reserve();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void clear() throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool empty() const throw() {return size() == 0;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference operator[](size_type __pos) const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](size_type __pos);

    const_reference at(size_type __n) const;
    reference at(size_type __n);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string& operator+=(const basic_string& __str) {return append(__str);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string& operator+=(const value_type* __s) {return append(__s);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string& operator+=(value_type __c) {push_back(__c); return *this;}




    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& append(const basic_string& __str);
    basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);
    basic_string& append(const value_type* __s, size_type __n);
    basic_string& append(const value_type* __s);
    basic_string& append(size_type __n, value_type __c);
    template<class _InputIterator>
        typename enable_if
        <
             __is_input_iterator <_InputIterator>::value &&
            !__is_forward_iterator<_InputIterator>::value,
            basic_string&
        >::type
        append(_InputIterator __first, _InputIterator __last);
    template<class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
            basic_string&
        >::type
        append(_ForwardIterator __first, _ForwardIterator __last);





    void push_back(value_type __c);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void pop_back();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference front();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference front() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference back();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference back() const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& assign(const basic_string& __str);





    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);
    basic_string& assign(const value_type* __s, size_type __n);
    basic_string& assign(const value_type* __s);
    basic_string& assign(size_type __n, value_type __c);
    template<class _InputIterator>
        typename enable_if
        <
             __is_input_iterator <_InputIterator>::value &&
            !__is_forward_iterator<_InputIterator>::value,
            basic_string&
        >::type
        assign(_InputIterator __first, _InputIterator __last);
    template<class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
            basic_string&
        >::type
        assign(_ForwardIterator __first, _ForwardIterator __last);





    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& insert(size_type __pos1, const basic_string& __str);
    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n=npos);
    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);
    basic_string& insert(size_type __pos, const value_type* __s);
    basic_string& insert(size_type __pos, size_type __n, value_type __c);
    iterator insert(const_iterator __pos, value_type __c);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator insert(const_iterator __pos, size_type __n, value_type __c);
    template<class _InputIterator>
        typename enable_if
        <
             __is_input_iterator <_InputIterator>::value &&
            !__is_forward_iterator<_InputIterator>::value,
            iterator
        >::type
        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);
    template<class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
            iterator
        >::type
        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);






    basic_string& erase(size_type __pos = 0, size_type __n = npos);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator erase(const_iterator __pos);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator erase(const_iterator __first, const_iterator __last);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);
    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos);
    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);
    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);
    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);
    template<class _InputIterator>
        typename enable_if
        <
            __is_input_iterator<_InputIterator>::value,
            basic_string&
        >::type
        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);






    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string substr(size_type __pos = 0, size_type __n = npos) const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(basic_string& __str)

                                                                 ;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const value_type* c_str() const throw() {return data();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const value_type* data() const throw() {return std::__1::__to_raw_pointer(__get_pointer());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    allocator_type get_allocator() const throw() {return __alloc();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find(const basic_string& __str, size_type __pos = 0) const throw();
    size_type find(const value_type* __s, size_type __pos, size_type __n) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find(const value_type* __s, size_type __pos = 0) const throw();
    size_type find(value_type __c, size_type __pos = 0) const throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type rfind(const basic_string& __str, size_type __pos = npos) const throw();
    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type rfind(const value_type* __s, size_type __pos = npos) const throw();
    size_type rfind(value_type __c, size_type __pos = npos) const throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const throw();
    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_of(const value_type* __s, size_type __pos = 0) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_of(value_type __c, size_type __pos = 0) const throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const throw();
    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_of(const value_type* __s, size_type __pos = npos) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_of(value_type __c, size_type __pos = npos) const throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const throw();
    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_not_of(value_type __c, size_type __pos = 0) const throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const throw();
    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_not_of(value_type __c, size_type __pos = npos) const throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int compare(const basic_string& __str) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;
    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos) const;
    int compare(const value_type* __s) const throw();
    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;
    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool __invariants() const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool __is_long() const throw()
        {return bool(__r_.first().__s.__size_ & __short_mask);}
# 1675 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/string" 3
private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    allocator_type& __alloc() throw()
        {return __r_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const allocator_type& __alloc() const throw()
        {return __r_.second();}
# 1703 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/string" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __set_short_size(size_type __s) throw()



        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type __get_short_size() const throw()



        {return __r_.first().__s.__size_ >> 1;}




    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __set_long_size(size_type __s) throw()
        {__r_.first().__l.__size_ = __s;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type __get_long_size() const throw()
        {return __r_.first().__l.__size_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __set_size(size_type __s) throw()
        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __set_long_cap(size_type __s) throw()
        {__r_.first().__l.__cap_ = __long_mask | __s;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type __get_long_cap() const throw()
        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __set_long_pointer(pointer __p) throw()
        {__r_.first().__l.__data_ = __p;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pointer __get_long_pointer() throw()
        {return __r_.first().__l.__data_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_pointer __get_long_pointer() const throw()
        {return __r_.first().__l.__data_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pointer __get_short_pointer() throw()
        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_pointer __get_short_pointer() const throw()
        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pointer __get_pointer() throw()
        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_pointer __get_pointer() const throw()
        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __zero() throw()
        {
            size_type (&__a)[__n_words] = __r_.first().__r.__words;
            for (unsigned __i = 0; __i < __n_words; ++__i)
                __a[__i] = 0;
        }

    template <size_type __a> static
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        size_type __align_it(size_type __s) throw()
            {return __s + (__a-1) & ~(__a-1);}
    enum {__alignment = 16};
    static __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type __recommend(size_type __s) throw()
        {return (__s < __min_cap ? __min_cap :
                 __align_it<sizeof(value_type) < __alignment ?
                            __alignment/sizeof(value_type) : 1 > (__s+1)) - 1;}

    void __init(const value_type* __s, size_type __sz, size_type __reserve);
    void __init(const value_type* __s, size_type __sz);
    void __init(size_type __n, value_type __c);

    template <class _InputIterator>
    typename enable_if
    <
         __is_input_iterator <_InputIterator>::value &&
        !__is_forward_iterator<_InputIterator>::value,
        void
    >::type
    __init(_InputIterator __first, _InputIterator __last);

    template <class _ForwardIterator>
    typename enable_if
    <
        __is_forward_iterator<_ForwardIterator>::value,
        void
    >::type
    __init(_ForwardIterator __first, _ForwardIterator __last);

    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                   size_type __n_copy, size_type __n_del, size_type __n_add = 0);
    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                               size_type __n_copy, size_type __n_del,
                               size_type __n_add, const value_type* __p_new_stuff);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __erase_to_end(size_type __pos);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __copy_assign_alloc(const basic_string& __str)
        {__copy_assign_alloc(__str, integral_constant<bool,
                      __alloc_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __copy_assign_alloc(const basic_string& __str, true_type)
        {
            if (__alloc() != __str.__alloc())
            {
                clear();
                shrink_to_fit();
            }
            __alloc() = __str.__alloc();
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __copy_assign_alloc(const basic_string&, false_type) throw()
        {}
# 1837 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/string" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void
    __move_assign_alloc(basic_string& __str)



    {__move_assign_alloc(__str, integral_constant<bool,
                      __alloc_traits::propagate_on_container_move_assignment::value>());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign_alloc(basic_string& __c, true_type)

        {
            __alloc() = std::__1::move(__c.__alloc());
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign_alloc(basic_string&, false_type)
        throw()
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void __swap_alloc(allocator_type& __x, allocator_type& __y)


        {__swap_alloc(__x, __y, integral_constant<bool,
                      __alloc_traits::propagate_on_container_swap::value>());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void __swap_alloc(allocator_type& __x, allocator_type& __y, true_type)

        {
            using std::__1::swap;
            swap(__x, __y);
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void __swap_alloc(allocator_type&, allocator_type&, false_type) throw()
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __invalidate_all_iterators();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __invalidate_iterators_past(size_type);

    friend basic_string operator+<>(const basic_string&, const basic_string&);
    friend basic_string operator+<>(const value_type*, const basic_string&);
    friend basic_string operator+<>(value_type, const basic_string&);
    friend basic_string operator+<>(const basic_string&, const value_type*);
    friend basic_string operator+<>(const basic_string&, value_type);
};

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()
{



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type



                                                                      )
{
# 1924 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/string" 3
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string()

{



    __zero();
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)
    : __r_(__a)
{



    __zero();
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz, size_type __reserve)
{
    if (__reserve > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__reserve < __min_cap)
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__reserve);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    traits_type::copy(std::__1::__to_raw_pointer(__p), __s, __sz);
    traits_type::assign(__p[__sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)
{
    if (__sz > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__sz < __min_cap)
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__sz);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    traits_type::copy(std::__1::__to_raw_pointer(__p), __s, __sz);
    traits_type::assign(__p[__sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s)
{
    ((void)0);
    __init(__s, traits_type::length(__s));



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, const allocator_type& __a)
    : __r_(__a)
{
    ((void)0);
    __init(__s, traits_type::length(__s));



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n)
{
    ((void)0);
    __init(__s, __n);



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n, const allocator_type& __a)
    : __r_(__a)
{
    ((void)0);
    __init(__s, __n);



}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)
    : __r_(__alloc_traits::select_on_container_copy_construction(__str.__alloc()))
{
    if (!__str.__is_long())
        __r_.first().__r = __str.__r_.first().__r;
    else
        __init(std::__1::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());



}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, const allocator_type& __a)
    : __r_(__a)
{
    if (!__str.__is_long())
        __r_.first().__r = __str.__r_.first().__r;
    else
        __init(std::__1::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());



}
# 2105 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/string" 3
template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)
{
    if (__n > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__n < __min_cap)
    {
        __set_short_size(__n);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__n);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__n);
    }
    traits_type::assign(std::__1::__to_raw_pointer(__p), __n, __c);
    traits_type::assign(__p[__n], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c)
{
    __init(__n, __c);



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c, const allocator_type& __a)
    : __r_(__a)
{
    __init(__n, __c);



}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos, size_type __n,
                                                        const allocator_type& __a)
    : __r_(__a)
{
    size_type __str_sz = __str.size();
    if (__pos > __str_sz)
        this->__throw_out_of_range();
    __init(__str.data() + __pos, std::__1::min(__n, __str_sz - __pos));



}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator>
typename enable_if
<
     __is_input_iterator <_InputIterator>::value &&
    !__is_forward_iterator<_InputIterator>::value,
    void
>::type
basic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)
{
    __zero();




    for (; __first != __last; ++__first)
        push_back(*__first);
# 2190 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/string" 3
}

template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    void
>::type
basic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __sz = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__sz > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__sz < __min_cap)
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__sz);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    for (; __first != __last; ++__first, ++__p)
        traits_type::assign(*__p, *__first);
    traits_type::assign(*__p, value_type());
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)
{
    __init(__first, __last);



}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,
                                                        const allocator_type& __a)
    : __r_(__a)
{
    __init(__first, __last);



}
# 2272 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/string" 3
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::~basic_string()
{



    if (__is_long())
        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace
    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,
     size_type __n_copy, size_type __n_del, size_type __n_add, const value_type* __p_new_stuff)
{
    size_type __ms = max_size();
    if (__delta_cap > __ms - __old_cap - 1)
        this->__throw_length_error();
    pointer __old_p = __get_pointer();
    size_type __cap = __old_cap < __ms / 2 - __alignment ?
                          __recommend(std::__1::max(__old_cap + __delta_cap, 2 * __old_cap)) :
                          __ms - 1;
    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);
    __invalidate_all_iterators();
    if (__n_copy != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p),
                          std::__1::__to_raw_pointer(__old_p), __n_copy);
    if (__n_add != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);
    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
    if (__sec_cp_sz != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p) + __n_copy + __n_add,
                          std::__1::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);
    if (__old_cap+1 != __min_cap)
        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);
    __set_long_pointer(__p);
    __set_long_cap(__cap+1);
    __old_sz = __n_copy + __n_add + __sec_cp_sz;
    __set_long_size(__old_sz);
    traits_type::assign(__p[__old_sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                                                     size_type __n_copy, size_type __n_del, size_type __n_add)
{
    size_type __ms = max_size();
    if (__delta_cap > __ms - __old_cap)
        this->__throw_length_error();
    pointer __old_p = __get_pointer();
    size_type __cap = __old_cap < __ms / 2 - __alignment ?
                          __recommend(std::__1::max(__old_cap + __delta_cap, 2 * __old_cap)) :
                          __ms - 1;
    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);
    __invalidate_all_iterators();
    if (__n_copy != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p),
                          std::__1::__to_raw_pointer(__old_p), __n_copy);
    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
    if (__sec_cp_sz != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p) + __n_copy + __n_add,
                          std::__1::__to_raw_pointer(__old_p) + __n_copy + __n_del,
                          __sec_cp_sz);
    if (__old_cap+1 != __min_cap)
        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);
    __set_long_pointer(__p);
    __set_long_cap(__cap+1);
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __cap = capacity();
    if (__cap >= __n)
    {
        value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
        traits_type::move(__p, __s, __n);
        traits_type::assign(__p[__n], value_type());
        __set_size(__n);
        __invalidate_iterators_past(__n);
    }
    else
    {
        size_type __sz = size();
        __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)
{
    size_type __cap = capacity();
    if (__cap < __n)
    {
        size_type __sz = size();
        __grow_by(__cap, __n - __cap, __sz, 0, __sz);
    }
    else
        __invalidate_iterators_past(__n);
    value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
    traits_type::assign(__p, __n, __c);
    traits_type::assign(__p[__n], value_type());
    __set_size(__n);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)
{
    pointer __p;
    if (__is_long())
    {
        __p = __get_long_pointer();
        __set_long_size(1);
    }
    else
    {
        __p = __get_short_pointer();
        __set_short_size(1);
    }
    traits_type::assign(*__p, __c);
    traits_type::assign(*++__p, value_type());
    __invalidate_iterators_past(1);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)
{
    if (this != &__str)
    {
        __copy_assign_alloc(__str);
        assign(__str);
    }
    return *this;
}
# 2459 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/string" 3
template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
typename enable_if
<
     __is_input_iterator <_InputIterator>::value &&
    !__is_forward_iterator<_InputIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
    clear();
    for (; __first != __last; ++__first)
        push_back(*__first);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    size_type __cap = capacity();
    if (__cap < __n)
    {
        size_type __sz = size();
        __grow_by(__cap, __n - __cap, __sz, 0, __sz);
    }
    else
        __invalidate_iterators_past(__n);
    pointer __p = __get_pointer();
    for (; __first != __last; ++__first, ++__p)
        traits_type::assign(*__p, *__first);
    traits_type::assign(*__p, value_type());
    __set_size(__n);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str)
{
    return assign(__str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)
{
    size_type __sz = __str.size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    return assign(__str.data() + __pos, std::__1::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)
{
    ((void)0);
    return assign(__s, traits_type::length(__s));
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __cap = capacity();
    size_type __sz = size();
    if (__cap - __sz >= __n)
    {
        if (__n)
        {
            value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
            traits_type::copy(__p + __sz, __s, __n);
            __sz += __n;
            __set_size(__sz);
            traits_type::assign(__p[__sz], value_type());
        }
    }
    else
        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)
{
    if (__n)
    {
        size_type __cap = capacity();
        size_type __sz = size();
        if (__cap - __sz < __n)
            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
        pointer __p = __get_pointer();
        traits_type::assign(std::__1::__to_raw_pointer(__p) + __sz, __n, __c);
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)
{
    bool __is_short = !__is_long();
    size_type __cap;
    size_type __sz;
    if (__is_short)
    {
        __cap = __min_cap - 1;
        __sz = __get_short_size();
    }
    else
    {
        __cap = __get_long_cap() - 1;
        __sz = __get_long_size();
    }
    if (__sz == __cap)
    {
        __grow_by(__cap, 1, __sz, __sz, 0);
        __is_short = !__is_long();
    }
    pointer __p;
    if (__is_short)
    {
        __p = __get_short_pointer() + __sz;
        __set_short_size(__sz+1);
    }
    else
    {
        __p = __get_long_pointer() + __sz;
        __set_long_size(__sz+1);
    }
    traits_type::assign(*__p, __c);
    traits_type::assign(*++__p, value_type());
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
typename enable_if
<
     __is_input_iterator <_InputIterator>::value &&
    !__is_forward_iterator<_InputIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::append(_InputIterator __first, _InputIterator __last)
{
    for (; __first != __last; ++__first)
        push_back(*__first);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::append(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __sz = size();
    size_type __cap = capacity();
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n)
    {
        if (__cap - __sz < __n)
            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
        pointer __p = __get_pointer() + __sz;
        for (; __first != __last; ++__p, ++__first)
            traits_type::assign(*__p, *__first);
        traits_type::assign(*__p, value_type());
        __set_size(__sz + __n);
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)
{
    return append(__str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)
{
    size_type __sz = __str.size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    return append(__str.data() + __pos, std::__1::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)
{
    ((void)0);
    return append(__s, traits_type::length(__s));
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    size_type __cap = capacity();
    if (__cap - __sz >= __n)
    {
        if (__n)
        {
            value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
            size_type __n_move = __sz - __pos;
            if (__n_move != 0)
            {
                if (__p + __pos <= __s && __s < __p + __sz)
                    __s += __n;
                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
            }
            traits_type::move(__p + __pos, __s, __n);
            __sz += __n;
            __set_size(__sz);
            traits_type::assign(__p[__sz], value_type());
        }
    }
    else
        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    if (__n)
    {
        size_type __cap = capacity();
        value_type* __p;
        if (__cap - __sz >= __n)
        {
            __p = std::__1::__to_raw_pointer(__get_pointer());
            size_type __n_move = __sz - __pos;
            if (__n_move != 0)
                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
        }
        else
        {
            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);
            __p = std::__1::__to_raw_pointer(__get_long_pointer());
        }
        traits_type::assign(__p + __pos, __n, __c);
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
typename enable_if
<
     __is_input_iterator <_InputIterator>::value &&
    !__is_forward_iterator<_InputIterator>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::iterator
>::type
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)
{





    size_type __old_sz = size();
    difference_type __ip = __pos - begin();
    for (; __first != __last; ++__first)
        push_back(*__first);
    pointer __p = __get_pointer();
    std::__1::rotate(__p + __ip, __p + __old_sz, __p + size());



    return iterator(__p + __ip);

}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::iterator
>::type
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)
{





    size_type __ip = static_cast<size_type>(__pos - begin());
    size_type __sz = size();
    size_type __cap = capacity();
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n)
    {
        value_type* __p;
        if (__cap - __sz >= __n)
        {
            __p = std::__1::__to_raw_pointer(__get_pointer());
            size_type __n_move = __sz - __ip;
            if (__n_move != 0)
                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);
        }
        else
        {
            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);
            __p = std::__1::__to_raw_pointer(__get_long_pointer());
        }
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
        for (__p += __ip; __first != __last; ++__p, ++__first)
            traits_type::assign(*__p, *__first);
    }
    return begin() + __ip;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)
{
    return insert(__pos1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,
                                                  size_type __pos2, size_type __n)
{
    size_type __str_sz = __str.size();
    if (__pos2 > __str_sz)
        this->__throw_out_of_range();
    return insert(__pos1, __str.data() + __pos2, std::__1::min(__n, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)
{
    ((void)0);
    return insert(__pos, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)
{
    size_type __ip = static_cast<size_type>(__pos - begin());
    size_type __sz = size();
    size_type __cap = capacity();
    value_type* __p;
    if (__cap == __sz)
    {
        __grow_by(__cap, 1, __sz, __ip, 0, 1);
        __p = std::__1::__to_raw_pointer(__get_long_pointer());
    }
    else
    {
        __p = std::__1::__to_raw_pointer(__get_pointer());
        size_type __n_move = __sz - __ip;
        if (__n_move != 0)
            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);
    }
    traits_type::assign(__p[__ip], __c);
    traits_type::assign(__p[++__sz], value_type());
    __set_size(__sz);
    return begin() + static_cast<difference_type>(__ip);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)
{





    difference_type __p = __pos - begin();
    insert(static_cast<size_type>(__p), __n, __c);
    return begin() + __p;
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)
{
    ((void)0);
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    __n1 = std::__1::min(__n1, __sz - __pos);
    size_type __cap = capacity();
    if (__cap - __sz + __n1 >= __n2)
    {
        value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
        if (__n1 != __n2)
        {
            size_type __n_move = __sz - __pos - __n1;
            if (__n_move != 0)
            {
                if (__n1 > __n2)
                {
                    traits_type::move(__p + __pos, __s, __n2);
                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
                    goto __finish;
                }
                if (__p + __pos < __s && __s < __p + __sz)
                {
                    if (__p + __pos + __n1 <= __s)
                        __s += __n2 - __n1;
                    else
                    {
                        traits_type::move(__p + __pos, __s, __n1);
                        __pos += __n1;
                        __s += __n2;
                        __n2 -= __n1;
                        __n1 = 0;
                    }
                }
                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
            }
        }
        traits_type::move(__p + __pos, __s, __n2);
__finish:
        __sz += __n2 - __n1;
        __set_size(__sz);
        __invalidate_iterators_past(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    else
        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    __n1 = std::__1::min(__n1, __sz - __pos);
    size_type __cap = capacity();
    value_type* __p;
    if (__cap - __sz + __n1 >= __n2)
    {
        __p = std::__1::__to_raw_pointer(__get_pointer());
        if (__n1 != __n2)
        {
            size_type __n_move = __sz - __pos - __n1;
            if (__n_move != 0)
                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
        }
    }
    else
    {
        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);
        __p = std::__1::__to_raw_pointer(__get_long_pointer());
    }
    traits_type::assign(__p + __pos, __n2, __c);
    __sz += __n2 - __n1;
    __set_size(__sz);
    __invalidate_iterators_past(__sz);
    traits_type::assign(__p[__sz], value_type());
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
typename enable_if
<
    __is_input_iterator<_InputIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,
                                                   _InputIterator __j1, _InputIterator __j2)
{
    for (; true; ++__i1, ++__j1)
    {
        if (__i1 == __i2)
        {
            if (__j1 != __j2)
                insert(__i1, __j1, __j2);
            break;
        }
        if (__j1 == __j2)
        {
            erase(__i1, __i2);
            break;
        }
        traits_type::assign(const_cast<value_type&>(*__i1), *__j1);
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)
{
    return replace(__pos1, __n1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,
                                                   size_type __pos2, size_type __n2)
{
    size_type __str_sz = __str.size();
    if (__pos2 > __str_sz)
        this->__throw_out_of_range();
    return replace(__pos1, __n1, __str.data() + __pos2, std::__1::min(__n2, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)
{
    ((void)0);
    return replace(__pos, __n1, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),
                   __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n)
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    if (__n)
    {
        value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
        __n = std::__1::min(__n, __sz - __pos);
        size_type __n_move = __sz - __pos - __n;
        if (__n_move != 0)
            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);
        __sz -= __n;
        __set_size(__sz);
        __invalidate_iterators_past(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)
{





    ((void)0);

    iterator __b = begin();
    size_type __r = static_cast<size_type>(__pos - __b);
    erase(__r, 1);
    return __b + static_cast<difference_type>(__r);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)
{





    ((void)0);
    iterator __b = begin();
    size_type __r = static_cast<size_type>(__first - __b);
    erase(__r, static_cast<size_type>(__last - __first));
    return __b + static_cast<difference_type>(__r);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::pop_back()
{
    ((void)0);
    size_type __sz;
    if (__is_long())
    {
        __sz = __get_long_size() - 1;
        __set_long_size(__sz);
        traits_type::assign(*(__get_long_pointer() + __sz), value_type());
    }
    else
    {
        __sz = __get_short_size() - 1;
        __set_short_size(__sz);
        traits_type::assign(*(__get_short_pointer() + __sz), value_type());
    }
    __invalidate_iterators_past(__sz);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::clear() throw()
{
    __invalidate_all_iterators();
    if (__is_long())
    {
        traits_type::assign(*__get_long_pointer(), value_type());
        __set_long_size(0);
    }
    else
    {
        traits_type::assign(*__get_short_pointer(), value_type());
        __set_short_size(0);
    }
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)
{
    if (__is_long())
    {
        traits_type::assign(*(__get_long_pointer() + __pos), value_type());
        __set_long_size(__pos);
    }
    else
    {
        traits_type::assign(*(__get_short_pointer() + __pos), value_type());
        __set_short_size(__pos);
    }
    __invalidate_iterators_past(__pos);
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)
{
    size_type __sz = size();
    if (__n > __sz)
        append(__n - __sz, __c);
    else
        __erase_to_end(__n);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::max_size() const throw()
{
    size_type __m = __alloc_traits::max_size(__alloc());



    return __m - __alignment;

}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg)
{
    if (__res_arg > max_size())
        this->__throw_length_error();
    size_type __cap = capacity();
    size_type __sz = size();
    __res_arg = std::__1::max(__res_arg, __sz);
    __res_arg = __recommend(__res_arg);
    if (__res_arg != __cap)
    {
        pointer __new_data, __p;
        bool __was_long, __now_long;
        if (__res_arg == __min_cap - 1)
        {
            __was_long = true;
            __now_long = false;
            __new_data = __get_short_pointer();
            __p = __get_long_pointer();
        }
        else
        {
            if (__res_arg > __cap)
                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);
            else
            {




                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);







                if (__new_data == std::__1::__get_nullptr_t())
                    return;

            }
            __now_long = true;
            __was_long = __is_long();
            __p = __get_pointer();
        }
        traits_type::copy(std::__1::__to_raw_pointer(__new_data),
                          std::__1::__to_raw_pointer(__p), size()+1);
        if (__was_long)
            __alloc_traits::deallocate(__alloc(), __p, __cap+1);
        if (__now_long)
        {
            __set_long_cap(__res_arg+1);
            __set_long_size(__sz);
            __set_long_pointer(__new_data);
        }
        else
            __set_short_size(__sz);
        __invalidate_all_iterators();
    }
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const
{
    ((void)0);
    return *(data() + __pos);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos)
{
    ((void)0);
    return *(__get_pointer() + __pos);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n)
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::front()
{
    ((void)0);
    return *__get_pointer();
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::front() const
{
    ((void)0);
    return *data();
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::back()
{
    ((void)0);
    return *(__get_pointer() + size() - 1);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::back() const
{
    ((void)0);
    return *(data() + size() - 1);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    size_type __rlen = std::__1::min(__n, __sz - __pos);
    traits_type::copy(__s, data() + __pos, __rlen);
    return __rlen;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>
basic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const
{
    return basic_string(*this, __pos, __n, __alloc());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)


{







    std::__1::swap(__r_.first(), __str.__r_.first());
    __swap_alloc(__alloc(), __str.__alloc());
}



template <class _Traits>
struct __attribute__ ((__visibility__("hidden"))) __traits_eq
{
    typedef typename _Traits::char_type char_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const char_type& __x, const char_type& __y) throw()
        {return _Traits::eq(__x, __y);}
};

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,
                                                size_type __pos,
                                                size_type __n) const throw()
{
    ((void)0);
    return std::__1::__str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,
                                                size_type __pos) const throw()
{
    return std::__1::__str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,
                                                size_type __pos) const throw()
{
    ((void)0);
    return std::__1::__str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(value_type __c,
                                                size_type __pos) const throw()
{
    return std::__1::__str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,
                                                 size_type __pos,
                                                 size_type __n) const throw()
{
    ((void)0);
    return std::__1::__str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,
                                                 size_type __pos) const throw()
{
    return std::__1::__str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,
                                                 size_type __pos) const throw()
{
    ((void)0);
    return std::__1::__str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,
                                                 size_type __pos) const throw()
{
    return std::__1::__str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,
                                                         size_type __pos,
                                                         size_type __n) const throw()
{
    ((void)0);
    return std::__1::__str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,
                                                         size_type __pos) const throw()
{
    return std::__1::__str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,
                                                         size_type __pos) const throw()
{
    ((void)0);
    return std::__1::__str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,
                                                         size_type __pos) const throw()
{
    return find(__c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,
                                                        size_type __pos,
                                                        size_type __n) const throw()
{
    ((void)0);
    return std::__1::__str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,
                                                        size_type __pos) const throw()
{
    return std::__1::__str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,
                                                        size_type __pos) const throw()
{
    ((void)0);
    return std::__1::__str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,
                                                        size_type __pos) const throw()
{
    return rfind(__c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,
                                                             size_type __pos,
                                                             size_type __n) const throw()
{
    ((void)0);
    return std::__1::__str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,
                                                             size_type __pos) const throw()
{
    return std::__1::__str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,
                                                             size_type __pos) const throw()
{
    ((void)0);
    return std::__1::__str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,
                                                             size_type __pos) const throw()
{
    return std::__1::__str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,
                                                            size_type __pos,
                                                            size_type __n) const throw()
{
    ((void)0);
    return std::__1::__str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,
                                                            size_type __pos) const throw()
{
    return std::__1::__str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,
                                                            size_type __pos) const throw()
{
    ((void)0);
    return std::__1::__str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,
                                                            size_type __pos) const throw()
{
    return std::__1::__str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int
basic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const throw()
{
    size_t __lhs_sz = size();
    size_t __rhs_sz = __str.size();
    int __result = traits_type::compare(data(), __str.data(),
                                        std::__1::min(__lhs_sz, __rhs_sz));
    if (__result != 0)
        return __result;
    if (__lhs_sz < __rhs_sz)
        return -1;
    if (__lhs_sz > __rhs_sz)
        return 1;
    return 0;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const basic_string& __str) const
{
    return compare(__pos1, __n1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const basic_string& __str,
                                                   size_type __pos2,
                                                   size_type __n2) const
{
    size_type __sz = __str.size();
    if (__pos2 > __sz)
        this->__throw_out_of_range();
    return compare(__pos1, __n1, __str.data() + __pos2, std::__1::min(__n2,
                                                                  __sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const throw()
{
    ((void)0);
    return compare(0, npos, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const value_type* __s) const
{
    ((void)0);
    return compare(__pos1, __n1, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const value_type* __s,
                                                   size_type __n2) const
{
    ((void)0);
    size_type __sz = size();
    if (__pos1 > __sz || __n2 == npos)
        this->__throw_out_of_range();
    size_type __rlen = std::__1::min(__n1, __sz - __pos1);
    int __r = traits_type::compare(data() + __pos1, __s, std::__1::min(__rlen, __n2));
    if (__r == 0)
    {
        if (__rlen < __n2)
            __r = -1;
        else if (__rlen > __n2)
            __r = 1;
    }
    return __r;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
basic_string<_CharT, _Traits, _Allocator>::__invariants() const
{
    if (size() > capacity())
        return false;
    if (capacity() < __min_cap - 1)
        return false;
    if (data() == 0)
        return false;
    if (data()[size()] != value_type(0))
        return false;
    return true;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    size_t __lhs_sz = __lhs.size();
    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),
                                                        __rhs.data(),
                                                        __lhs_sz) == 0;
}

template<class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,
           const basic_string<char, char_traits<char>, _Allocator>& __rhs) throw()
{
    size_t __lhs_sz = __lhs.size();
    if (__lhs_sz != __rhs.size())
        return false;
    const char* __lp = __lhs.data();
    const char* __rp = __rhs.data();
    if (__lhs.__is_long())
        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;
    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)
        if (*__lp != *__rp)
            return false;
    return true;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return __rhs.compare(__lhs) == 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,
           const _CharT* __rhs) throw()
{
    return __lhs.compare(__rhs) == 0;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return !(__lhs == __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return !(__lhs == __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) throw()
{
    return !(__lhs == __rhs);
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return __lhs.compare(__rhs) < 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) throw()
{
    return __lhs.compare(__rhs) < 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return __rhs.compare(__lhs) > 0;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return __rhs < __lhs;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) throw()
{
    return __rhs < __lhs;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return __rhs < __lhs;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return !(__rhs < __lhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) throw()
{
    return !(__rhs < __lhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return !(__rhs < __lhs);
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return !(__lhs < __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) throw()
{
    return !(__lhs < __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return !(__lhs < __rhs);
}



template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
          const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
    __r.append(__rhs.data(), __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);
    __r.append(__rhs.data(), __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
    __r.__init(&__lhs, 1, 1 + __rhs_sz);
    __r.append(__rhs.data(), __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);
    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
    __r.append(__rhs, __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);
    __r.push_back(__rhs);
    return __r;
}
# 4060 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/string" 3
template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(basic_string<_CharT, _Traits, _Allocator>& __lhs,
     basic_string<_CharT, _Traits, _Allocator>& __rhs)

{
    __lhs.swap(__rhs);
}



typedef basic_string<char16_t> u16string;
typedef basic_string<char32_t> u32string;



__attribute__ ((__visibility__("default"))) int stoi (const string& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) long stol (const string& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long stoul (const string& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) long long stoll (const string& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);

__attribute__ ((__visibility__("default"))) float stof (const string& __str, size_t* __idx = 0);
__attribute__ ((__visibility__("default"))) double stod (const string& __str, size_t* __idx = 0);
__attribute__ ((__visibility__("default"))) long double stold(const string& __str, size_t* __idx = 0);

__attribute__ ((__visibility__("default"))) string to_string(int __val);
__attribute__ ((__visibility__("default"))) string to_string(unsigned __val);
__attribute__ ((__visibility__("default"))) string to_string(long __val);
__attribute__ ((__visibility__("default"))) string to_string(unsigned long __val);
__attribute__ ((__visibility__("default"))) string to_string(long long __val);
__attribute__ ((__visibility__("default"))) string to_string(unsigned long long __val);
__attribute__ ((__visibility__("default"))) string to_string(float __val);
__attribute__ ((__visibility__("default"))) string to_string(double __val);
__attribute__ ((__visibility__("default"))) string to_string(long double __val);

__attribute__ ((__visibility__("default"))) int stoi (const wstring& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) long stol (const wstring& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) long long stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);

__attribute__ ((__visibility__("default"))) float stof (const wstring& __str, size_t* __idx = 0);
__attribute__ ((__visibility__("default"))) double stod (const wstring& __str, size_t* __idx = 0);
__attribute__ ((__visibility__("default"))) long double stold(const wstring& __str, size_t* __idx = 0);

__attribute__ ((__visibility__("default"))) wstring to_wstring(int __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(unsigned __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(unsigned long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(long long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(unsigned long long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(float __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(double __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(long double __val);

template<class _CharT, class _Traits, class _Allocator>
    const typename basic_string<_CharT, _Traits, _Allocator>::size_type
                   basic_string<_CharT, _Traits, _Allocator>::npos;

template<class _CharT, class _Traits, class _Allocator>
struct __attribute__ ((__type_visibility__("default"))) hash<basic_string<_CharT, _Traits, _Allocator> >
    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>
{
    size_t
        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const throw();
};

template<class _CharT, class _Traits, class _Allocator>
size_t
hash<basic_string<_CharT, _Traits, _Allocator> >::operator()(
        const basic_string<_CharT, _Traits, _Allocator>& __val) const throw()
{
    return __do_string_hash(__val.data(), __val.data() + __val.size());
}

template<class _CharT, class _Traits, class _Allocator>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const basic_string<_CharT, _Traits, _Allocator>& __str);

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           basic_string<_CharT, _Traits, _Allocator>& __str);

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str);
# 4243 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/string" 3
extern template class __attribute__ ((__type_visibility__("default"))) basic_string<char>;
extern template class __attribute__ ((__type_visibility__("default"))) basic_string<wchar_t>;
extern template string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&);

} }
# 19 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/StringRef.h" 2


namespace llvm {
  template <typename T>
  class SmallVectorImpl;
  class APInt;
  class hash_code;
  class StringRef;


  bool getAsUnsignedInteger(StringRef Str, unsigned Radix,
                            unsigned long long &Result);

  bool getAsSignedInteger(StringRef Str, unsigned Radix, long long &Result);
# 41 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/StringRef.h"
  class StringRef {
  public:
    typedef const char *iterator;
    typedef const char *const_iterator;
    static const size_t npos = ~size_t(0);
    typedef size_t size_type;

  private:

    const char *Data;


    size_t Length;




    static size_t min(size_t a, size_t b) { return a < b ? a : b; }
    static size_t max(size_t a, size_t b) { return a > b ? a : b; }



    static int compareMemory(const char *Lhs, const char *Rhs, size_t Length) {
      if (Length == 0) { return 0; }
      return ::memcmp(Lhs,Rhs,Length);
    }

  public:




                 StringRef() : Data(0), Length(0) {}


                 StringRef(const char *Str)
      : Data(Str) {
        ((void)((Str && "StringRef cannot be built from a NULL argument") || (__assert_fail("Str && \"StringRef cannot be built from a NULL argument\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/StringRef.h", 78, __func__),0)));
        Length = ::strlen(Str);
      }


                 StringRef(const char *data, size_t length)
      : Data(data), Length(length) {
        ((void)(((data || length == 0) && "StringRef cannot be built from a NULL argument with non-null length") || (__assert_fail("(data || length == 0) && \"StringRef cannot be built from a NULL argument with non-null length\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/StringRef.h", 86, __func__),0)));

      }


                 StringRef(const std::string &Str)
      : Data(Str.data()), Length(Str.length()) {}





    iterator begin() const { return Data; }

    iterator end() const { return Data + Length; }







    const char *data() const { return Data; }


    bool empty() const { return Length == 0; }


    size_t size() const { return Length; }


    char front() const {
      ((void)((!empty()) || (__assert_fail("!empty()", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/StringRef.h", 117, __func__),0)));
      return Data[0];
    }


    char back() const {
      ((void)((!empty()) || (__assert_fail("!empty()", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/StringRef.h", 123, __func__),0)));
      return Data[Length-1];
    }



    bool equals(StringRef RHS) const {
      return (Length == RHS.Length &&
              compareMemory(Data, RHS.Data, RHS.Length) == 0);
    }


    bool equals_lower(StringRef RHS) const {
      return Length == RHS.Length && compare_lower(RHS) == 0;
    }



    int compare(StringRef RHS) const {

      if (int Res = compareMemory(Data, RHS.Data, min(Length, RHS.Length)))
        return Res < 0 ? -1 : 1;


      if (Length == RHS.Length)
        return 0;
      return Length < RHS.Length ? -1 : 1;
    }


    int compare_lower(StringRef RHS) const;



    int compare_numeric(StringRef RHS) const;
# 177 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/StringRef.h"
    unsigned edit_distance(StringRef Other, bool AllowReplacements = true,
                           unsigned MaxEditDistance = 0) const;


    std::string str() const {
      if (Data == 0) return std::string();
      return std::string(Data, Length);
    }





    char operator[](size_t Index) const {
      ((void)((Index < Length && "Invalid index!") || (__assert_fail("Index < Length && \"Invalid index!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/StringRef.h", 191, __func__),0)));
      return Data[Index];
    }





    operator std::string() const {
      return str();
    }






    bool startswith(StringRef Prefix) const {
      return Length >= Prefix.Length &&
             compareMemory(Data, Prefix.Data, Prefix.Length) == 0;
    }


    bool startswith_lower(StringRef Prefix) const;


    bool endswith(StringRef Suffix) const {
      return Length >= Suffix.Length &&
        compareMemory(end() - Suffix.Length, Suffix.Data, Suffix.Length) == 0;
    }


    bool endswith_lower(StringRef Suffix) const;
# 233 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/StringRef.h"
    size_t find(char C, size_t From = 0) const {
      for (size_t i = min(From, Length), e = Length; i != e; ++i)
        if (Data[i] == C)
          return i;
      return npos;
    }





    size_t find(StringRef Str, size_t From = 0) const;





    size_t rfind(char C, size_t From = npos) const {
      From = min(From, Length);
      size_t i = From;
      while (i != 0) {
        --i;
        if (Data[i] == C)
          return i;
      }
      return npos;
    }





    size_t rfind(StringRef Str) const;



    size_t find_first_of(char C, size_t From = 0) const {
      return find(C, From);
    }





    size_t find_first_of(StringRef Chars, size_t From = 0) const;



    size_t find_first_not_of(char C, size_t From = 0) const;





    size_t find_first_not_of(StringRef Chars, size_t From = 0) const;



    size_t find_last_of(char C, size_t From = npos) const {
      return rfind(C, From);
    }





    size_t find_last_of(StringRef Chars, size_t From = npos) const;



    size_t find_last_not_of(char C, size_t From = npos) const;





    size_t find_last_not_of(StringRef Chars, size_t From = npos) const;






    size_t count(char C) const {
      size_t Count = 0;
      for (size_t i = 0, e = Length; i != e; ++i)
        if (Data[i] == C)
          ++Count;
      return Count;
    }



    size_t count(StringRef Str) const;
# 335 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/StringRef.h"
    template <typename T>
    typename enable_if_c<std::numeric_limits<T>::is_signed, bool>::type
    getAsInteger(unsigned Radix, T &Result) const {
      long long LLVal;
      if (getAsSignedInteger(*this, Radix, LLVal) ||
            static_cast<T>(LLVal) != LLVal)
        return true;
      Result = LLVal;
      return false;
    }

    template <typename T>
    typename enable_if_c<!std::numeric_limits<T>::is_signed, bool>::type
    getAsInteger(unsigned Radix, T &Result) const {
      unsigned long long ULLVal;
      if (getAsUnsignedInteger(*this, Radix, ULLVal) ||
            static_cast<T>(ULLVal) != ULLVal)
        return true;
      Result = ULLVal;
      return false;
    }
# 367 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/StringRef.h"
    bool getAsInteger(unsigned Radix, APInt &Result) const;






    std::string lower() const;


    std::string upper() const;
# 392 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/StringRef.h"
    StringRef substr(size_t Start, size_t N = npos) const {
      Start = min(Start, Length);
      return StringRef(Data + Start, min(N, Length - Start));
    }



    StringRef drop_front(size_t N = 1) const {
      ((void)((size() >= N && "Dropping more elements than exist") || (__assert_fail("size() >= N && \"Dropping more elements than exist\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/StringRef.h", 400, __func__),0)));
      return substr(N);
    }



    StringRef drop_back(size_t N = 1) const {
      ((void)((size() >= N && "Dropping more elements than exist") || (__assert_fail("size() >= N && \"Dropping more elements than exist\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/StringRef.h", 407, __func__),0)));
      return substr(0, size()-N);
    }
# 421 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/StringRef.h"
    StringRef slice(size_t Start, size_t End) const {
      Start = min(Start, Length);
      End = min(max(Start, End), Length);
      return StringRef(Data + Start, End - Start);
    }
# 437 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/StringRef.h"
    std::pair<StringRef, StringRef> split(char Separator) const {
      size_t Idx = find(Separator);
      if (Idx == npos)
        return std::make_pair(*this, StringRef());
      return std::make_pair(slice(0, Idx), slice(Idx+1, npos));
    }
# 454 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/StringRef.h"
    std::pair<StringRef, StringRef> split(StringRef Separator) const {
      size_t Idx = find(Separator);
      if (Idx == npos)
        return std::make_pair(*this, StringRef());
      return std::make_pair(slice(0, Idx), slice(Idx + Separator.size(), npos));
    }
# 475 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/StringRef.h"
    void split(SmallVectorImpl<StringRef> &A,
               StringRef Separator, int MaxSplit = -1,
               bool KeepEmpty = true) const;
# 489 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/StringRef.h"
    std::pair<StringRef, StringRef> rsplit(char Separator) const {
      size_t Idx = rfind(Separator);
      if (Idx == npos)
        return std::make_pair(*this, StringRef());
      return std::make_pair(slice(0, Idx), slice(Idx+1, npos));
    }



    StringRef ltrim(StringRef Chars = " \t\n\v\f\r") const {
      return drop_front(std::min(Length, find_first_not_of(Chars)));
    }



    StringRef rtrim(StringRef Chars = " \t\n\v\f\r") const {
      return drop_back(Length - std::min(Length, find_last_not_of(Chars) + 1));
    }



    StringRef trim(StringRef Chars = " \t\n\v\f\r") const {
      return ltrim(Chars).rtrim(Chars);
    }


  };




  inline bool operator==(StringRef LHS, StringRef RHS) {
    return LHS.equals(RHS);
  }

  inline bool operator!=(StringRef LHS, StringRef RHS) {
    return !(LHS == RHS);
  }

  inline bool operator<(StringRef LHS, StringRef RHS) {
    return LHS.compare(RHS) == -1;
  }

  inline bool operator<=(StringRef LHS, StringRef RHS) {
    return LHS.compare(RHS) != 1;
  }

  inline bool operator>(StringRef LHS, StringRef RHS) {
    return LHS.compare(RHS) == 1;
  }

  inline bool operator>=(StringRef LHS, StringRef RHS) {
    return LHS.compare(RHS) != -1;
  }

  inline std::string &operator+=(std::string &buffer, StringRef string) {
    return buffer.append(string.data(), string.size());
  }




  hash_code hash_value(StringRef S);


  template <typename T> struct isPodLike;
  template <> struct isPodLike<StringRef> { static const bool value = true; };


  inline StringRef toStringRef(bool B) {
    return StringRef(B ? "true" : "false");
  }
}
# 21 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/FoldingSet.h" 2


namespace llvm {
  class APFloat;
  class APInt;
  class BumpPtrAllocator;
# 102 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/FoldingSet.h"
class FoldingSetNodeID;
# 111 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/FoldingSet.h"
class FoldingSetImpl {
protected:


  void **Buckets;



  unsigned NumBuckets;



  unsigned NumNodes;

public:
  explicit FoldingSetImpl(unsigned Log2InitSize = 6);
  virtual ~FoldingSetImpl();





  class Node {
  private:

    void *NextInFoldingSetBucket;

  public:

    Node() : NextInFoldingSetBucket(0) {}


    void *getNextInBucket() const { return NextInFoldingSetBucket; }
    void SetNextInBucket(void *N) { NextInFoldingSetBucket = N; }
  };


  void clear();



  bool RemoveNode(Node *N);




  Node *GetOrInsertNode(Node *N);




  Node *FindNodeOrInsertPos(const FoldingSetNodeID &ID, void *&InsertPos);




  void InsertNode(Node *N, void *InsertPos);



  void InsertNode(Node *N) {
    Node *Inserted = GetOrInsertNode(N);
    (void)Inserted;
    ((void)((Inserted == N && "Node already inserted!") || (__assert_fail("Inserted == N && \"Node already inserted!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/FoldingSet.h", 174, __func__),0)));
  }


  unsigned size() const { return NumNodes; }


  bool empty() const { return NumNodes == 0; }

private:



  void GrowHashTable();

protected:



  virtual void GetNodeProfile(Node *N, FoldingSetNodeID &ID) const = 0;


  virtual bool NodeEquals(Node *N, const FoldingSetNodeID &ID, unsigned IDHash,
                          FoldingSetNodeID &TempID) const=0;


  virtual unsigned ComputeNodeHash(Node *N, FoldingSetNodeID &TempID) const = 0;
};



template<typename T> struct FoldingSetTrait;




template<typename T> struct DefaultFoldingSetTrait {
  static void Profile(const T &X, FoldingSetNodeID &ID) {
    X.Profile(ID);
  }
  static void Profile(T &X, FoldingSetNodeID &ID) {
    X.Profile(ID);
  }





  static inline bool Equals(T &X, const FoldingSetNodeID &ID, unsigned IDHash,
                            FoldingSetNodeID &TempID);






  static inline unsigned ComputeHash(T &X, FoldingSetNodeID &TempID);
};







template<typename T> struct FoldingSetTrait
  : public DefaultFoldingSetTrait<T> {};

template<typename T, typename Ctx> struct ContextualFoldingSetTrait;



template<typename T, typename Ctx>
struct DefaultContextualFoldingSetTrait {
  static void Profile(T &X, FoldingSetNodeID &ID, Ctx Context) {
    X.Profile(ID, Context);
  }
  static inline bool Equals(T &X, const FoldingSetNodeID &ID, unsigned IDHash,
                            FoldingSetNodeID &TempID, Ctx Context);
  static inline unsigned ComputeHash(T &X, FoldingSetNodeID &TempID,
                                     Ctx Context);
};



template<typename T, typename Ctx> struct ContextualFoldingSetTrait
  : public DefaultContextualFoldingSetTrait<T, Ctx> {};







class FoldingSetNodeIDRef {
  const unsigned *Data;
  size_t Size;
public:
  FoldingSetNodeIDRef() : Data(0), Size(0) {}
  FoldingSetNodeIDRef(const unsigned *D, size_t S) : Data(D), Size(S) {}



  unsigned ComputeHash() const;

  bool operator==(FoldingSetNodeIDRef) const;



  bool operator<(FoldingSetNodeIDRef) const;

  const unsigned *getData() const { return Data; }
  size_t getSize() const { return Size; }
};






class FoldingSetNodeID {


  SmallVector<unsigned, 32> Bits;

public:
  FoldingSetNodeID() {}

  FoldingSetNodeID(FoldingSetNodeIDRef Ref)
    : Bits(Ref.getData(), Ref.getData() + Ref.getSize()) {}



  void AddPointer(const void *Ptr);
  void AddInteger(signed I);
  void AddInteger(unsigned I);
  void AddInteger(long I);
  void AddInteger(unsigned long I);
  void AddInteger(long long I);
  void AddInteger(unsigned long long I);
  void AddBoolean(bool B) { AddInteger(B ? 1U : 0U); }
  void AddString(StringRef String);
  void AddNodeID(const FoldingSetNodeID &ID);

  template <typename T>
  inline void Add(const T &x) { FoldingSetTrait<T>::Profile(x, *this); }



  inline void clear() { Bits.clear(); }



  unsigned ComputeHash() const;



  bool operator==(const FoldingSetNodeID &RHS) const;
  bool operator==(const FoldingSetNodeIDRef RHS) const;



  bool operator<(const FoldingSetNodeID &RHS) const;
  bool operator<(const FoldingSetNodeIDRef RHS) const;




  FoldingSetNodeIDRef Intern(BumpPtrAllocator &Allocator) const;
};


typedef FoldingSetImpl::Node FoldingSetNode;
template<class T> class FoldingSetIterator;
template<class T> class FoldingSetBucketIterator;



template<typename T>
inline bool
DefaultFoldingSetTrait<T>::Equals(T &X, const FoldingSetNodeID &ID,
                                  unsigned ,
                                  FoldingSetNodeID &TempID) {
  FoldingSetTrait<T>::Profile(X, TempID);
  return TempID == ID;
}
template<typename T>
inline unsigned
DefaultFoldingSetTrait<T>::ComputeHash(T &X, FoldingSetNodeID &TempID) {
  FoldingSetTrait<T>::Profile(X, TempID);
  return TempID.ComputeHash();
}
template<typename T, typename Ctx>
inline bool
DefaultContextualFoldingSetTrait<T, Ctx>::Equals(T &X,
                                                 const FoldingSetNodeID &ID,
                                                 unsigned ,
                                                 FoldingSetNodeID &TempID,
                                                 Ctx Context) {
  ContextualFoldingSetTrait<T, Ctx>::Profile(X, TempID, Context);
  return TempID == ID;
}
template<typename T, typename Ctx>
inline unsigned
DefaultContextualFoldingSetTrait<T, Ctx>::ComputeHash(T &X,
                                                      FoldingSetNodeID &TempID,
                                                      Ctx Context) {
  ContextualFoldingSetTrait<T, Ctx>::Profile(X, TempID, Context);
  return TempID.ComputeHash();
}






template<class T> class FoldingSet : public FoldingSetImpl {
private:


  virtual void GetNodeProfile(Node *N, FoldingSetNodeID &ID) const {
    T *TN = static_cast<T *>(N);
    FoldingSetTrait<T>::Profile(*TN, ID);
  }


  virtual bool NodeEquals(Node *N, const FoldingSetNodeID &ID, unsigned IDHash,
                          FoldingSetNodeID &TempID) const {
    T *TN = static_cast<T *>(N);
    return FoldingSetTrait<T>::Equals(*TN, ID, IDHash, TempID);
  }


  virtual unsigned ComputeNodeHash(Node *N, FoldingSetNodeID &TempID) const {
    T *TN = static_cast<T *>(N);
    return FoldingSetTrait<T>::ComputeHash(*TN, TempID);
  }

public:
  explicit FoldingSet(unsigned Log2InitSize = 6)
  : FoldingSetImpl(Log2InitSize)
  {}

  typedef FoldingSetIterator<T> iterator;
  iterator begin() { return iterator(Buckets); }
  iterator end() { return iterator(Buckets+NumBuckets); }

  typedef FoldingSetIterator<const T> const_iterator;
  const_iterator begin() const { return const_iterator(Buckets); }
  const_iterator end() const { return const_iterator(Buckets+NumBuckets); }

  typedef FoldingSetBucketIterator<T> bucket_iterator;

  bucket_iterator bucket_begin(unsigned hash) {
    return bucket_iterator(Buckets + (hash & (NumBuckets-1)));
  }

  bucket_iterator bucket_end(unsigned hash) {
    return bucket_iterator(Buckets + (hash & (NumBuckets-1)), true);
  }




  T *GetOrInsertNode(Node *N) {
    return static_cast<T *>(FoldingSetImpl::GetOrInsertNode(N));
  }




  T *FindNodeOrInsertPos(const FoldingSetNodeID &ID, void *&InsertPos) {
    return static_cast<T *>(FoldingSetImpl::FindNodeOrInsertPos(ID, InsertPos));
  }
};
# 459 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/FoldingSet.h"
template <class T, class Ctx>
class ContextualFoldingSet : public FoldingSetImpl {





private:
  Ctx Context;



  virtual void GetNodeProfile(FoldingSetImpl::Node *N,
                              FoldingSetNodeID &ID) const {
    T *TN = static_cast<T *>(N);
    ContextualFoldingSetTrait<T, Ctx>::Profile(*TN, ID, Context);
  }
  virtual bool NodeEquals(FoldingSetImpl::Node *N,
                          const FoldingSetNodeID &ID, unsigned IDHash,
                          FoldingSetNodeID &TempID) const {
    T *TN = static_cast<T *>(N);
    return ContextualFoldingSetTrait<T, Ctx>::Equals(*TN, ID, IDHash, TempID,
                                                     Context);
  }
  virtual unsigned ComputeNodeHash(FoldingSetImpl::Node *N,
                                   FoldingSetNodeID &TempID) const {
    T *TN = static_cast<T *>(N);
    return ContextualFoldingSetTrait<T, Ctx>::ComputeHash(*TN, TempID, Context);
  }

public:
  explicit ContextualFoldingSet(Ctx Context, unsigned Log2InitSize = 6)
  : FoldingSetImpl(Log2InitSize), Context(Context)
  {}

  Ctx getContext() const { return Context; }


  typedef FoldingSetIterator<T> iterator;
  iterator begin() { return iterator(Buckets); }
  iterator end() { return iterator(Buckets+NumBuckets); }

  typedef FoldingSetIterator<const T> const_iterator;
  const_iterator begin() const { return const_iterator(Buckets); }
  const_iterator end() const { return const_iterator(Buckets+NumBuckets); }

  typedef FoldingSetBucketIterator<T> bucket_iterator;

  bucket_iterator bucket_begin(unsigned hash) {
    return bucket_iterator(Buckets + (hash & (NumBuckets-1)));
  }

  bucket_iterator bucket_end(unsigned hash) {
    return bucket_iterator(Buckets + (hash & (NumBuckets-1)), true);
  }




  T *GetOrInsertNode(Node *N) {
    return static_cast<T *>(FoldingSetImpl::GetOrInsertNode(N));
  }




  T *FindNodeOrInsertPos(const FoldingSetNodeID &ID, void *&InsertPos) {
    return static_cast<T *>(FoldingSetImpl::FindNodeOrInsertPos(ID, InsertPos));
  }
};
# 537 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/FoldingSet.h"
template <class T, class VectorIteratorT>
class FoldingSetVectorIterator {


  typedef FoldingSetVectorIterator<T, VectorIteratorT> SelfT;

  VectorIteratorT Iterator;

public:
  FoldingSetVectorIterator(VectorIteratorT I) : Iterator(I) {}

  bool operator==(const SelfT &RHS) const {
    return Iterator == RHS.Iterator;
  }
  bool operator!=(const SelfT &RHS) const {
    return Iterator != RHS.Iterator;
  }

  T &operator*() const { return **Iterator; }

  T *operator->() const { return *Iterator; }

  inline SelfT &operator++() {
    ++Iterator;
    return *this;
  }
  SelfT operator++(int) {
    SelfT tmp = *this;
    ++*this;
    return tmp;
  }
};






template <class T, class VectorT = SmallVector<T*, 8> >
class FoldingSetVector {
  FoldingSet<T> Set;
  VectorT Vector;

public:
  explicit FoldingSetVector(unsigned Log2InitSize = 6)
      : Set(Log2InitSize) {
  }

  typedef FoldingSetVectorIterator<T, typename VectorT::iterator> iterator;
  iterator begin() { return Vector.begin(); }
  iterator end() { return Vector.end(); }

  typedef FoldingSetVectorIterator<const T, typename VectorT::const_iterator>
    const_iterator;
  const_iterator begin() const { return Vector.begin(); }
  const_iterator end() const { return Vector.end(); }


  void clear() { Set.clear(); Vector.clear(); }




  T *FindNodeOrInsertPos(const FoldingSetNodeID &ID, void *&InsertPos) {
    return Set.FindNodeOrInsertPos(ID, InsertPos);
  }




  T *GetOrInsertNode(T *N) {
    T *Result = Set.GetOrInsertNode(N);
    if (Result == N) Vector.push_back(N);
    return Result;
  }




  void InsertNode(T *N, void *InsertPos) {
    Set.InsertNode(N, InsertPos);
    Vector.push_back(N);
  }



  void InsertNode(T *N) {
    Set.InsertNode(N);
    Vector.push_back(N);
  }


  unsigned size() const { return Set.size(); }


  bool empty() const { return Set.empty(); }
};




class FoldingSetIteratorImpl {
protected:
  FoldingSetNode *NodePtr;
  FoldingSetIteratorImpl(void **Bucket);
  void advance();

public:
  bool operator==(const FoldingSetIteratorImpl &RHS) const {
    return NodePtr == RHS.NodePtr;
  }
  bool operator!=(const FoldingSetIteratorImpl &RHS) const {
    return NodePtr != RHS.NodePtr;
  }
};


template<class T>
class FoldingSetIterator : public FoldingSetIteratorImpl {
public:
  explicit FoldingSetIterator(void **Bucket) : FoldingSetIteratorImpl(Bucket) {}

  T &operator*() const {
    return *static_cast<T*>(NodePtr);
  }

  T *operator->() const {
    return static_cast<T*>(NodePtr);
  }

  inline FoldingSetIterator &operator++() {
    advance();
    return *this;
  }
  FoldingSetIterator operator++(int) {
    FoldingSetIterator tmp = *this; ++*this; return tmp;
  }
};






class FoldingSetBucketIteratorImpl {
protected:
  void *Ptr;

  explicit FoldingSetBucketIteratorImpl(void **Bucket);

  FoldingSetBucketIteratorImpl(void **Bucket, bool)
    : Ptr(Bucket) {}

  void advance() {
    void *Probe = static_cast<FoldingSetNode*>(Ptr)->getNextInBucket();
    uintptr_t x = reinterpret_cast<uintptr_t>(Probe) & ~0x1;
    Ptr = reinterpret_cast<void*>(x);
  }

public:
  bool operator==(const FoldingSetBucketIteratorImpl &RHS) const {
    return Ptr == RHS.Ptr;
  }
  bool operator!=(const FoldingSetBucketIteratorImpl &RHS) const {
    return Ptr != RHS.Ptr;
  }
};


template<class T>
class FoldingSetBucketIterator : public FoldingSetBucketIteratorImpl {
public:
  explicit FoldingSetBucketIterator(void **Bucket) :
    FoldingSetBucketIteratorImpl(Bucket) {}

  FoldingSetBucketIterator(void **Bucket, bool) :
    FoldingSetBucketIteratorImpl(Bucket, true) {}

  T &operator*() const { return *static_cast<T*>(Ptr); }
  T *operator->() const { return static_cast<T*>(Ptr); }

  inline FoldingSetBucketIterator &operator++() {
    advance();
    return *this;
  }
  FoldingSetBucketIterator operator++(int) {
    FoldingSetBucketIterator tmp = *this; ++*this; return tmp;
  }
};




template <typename T>
class FoldingSetNodeWrapper : public FoldingSetNode {
  T data;
public:
  explicit FoldingSetNodeWrapper(const T &x) : data(x) {}
  virtual ~FoldingSetNodeWrapper() {}

  template<typename A1>
  explicit FoldingSetNodeWrapper(const A1 &a1)
    : data(a1) {}

  template <typename A1, typename A2>
  explicit FoldingSetNodeWrapper(const A1 &a1, const A2 &a2)
    : data(a1,a2) {}

  template <typename A1, typename A2, typename A3>
  explicit FoldingSetNodeWrapper(const A1 &a1, const A2 &a2, const A3 &a3)
    : data(a1,a2,a3) {}

  template <typename A1, typename A2, typename A3, typename A4>
  explicit FoldingSetNodeWrapper(const A1 &a1, const A2 &a2, const A3 &a3,
                                 const A4 &a4)
    : data(a1,a2,a3,a4) {}

  template <typename A1, typename A2, typename A3, typename A4, typename A5>
  explicit FoldingSetNodeWrapper(const A1 &a1, const A2 &a2, const A3 &a3,
                                 const A4 &a4, const A5 &a5)
  : data(a1,a2,a3,a4,a5) {}


  void Profile(FoldingSetNodeID &ID) { FoldingSetTrait<T>::Profile(data, ID); }

  T &getValue() { return data; }
  const T &getValue() const { return data; }

  operator T&() { return data; }
  operator const T&() const { return data; }
};







class FastFoldingSetNode : public FoldingSetNode {
  FoldingSetNodeID FastID;
protected:
  explicit FastFoldingSetNode(const FoldingSetNodeID &ID) : FastID(ID) {}
public:
  void Profile(FoldingSetNodeID &ID) const {
    ID.AddNodeID(FastID);
  }
};




template<typename T> struct FoldingSetTrait<T*> {
  static inline void Profile(T *X, FoldingSetNodeID &ID) {
    ID.AddPointer(X);
  }
};
}
# 21 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Attributes.h" 2


# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/bitset" 1 3
# 118 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/bitset" 3
# 129 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/bitset" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 1 3
# 21 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/assert.h" 1 3
# 12 "/mnt/home/ec2-user/build/emscripten/system/include/libc/assert.h" 3
extern "C" {



__attribute__((__noreturn__))

void __assert_fail (const char *, const char *, int, const char *);


}
# 22 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 2 3
# 25 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 3
# 130 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/bitset" 2 3


# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__undef_min_max" 1 3
# 133 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/bitset" 2 3

namespace std {inline namespace __1 {

template <size_t _N_words, size_t _Size>
class __bitset;

template <size_t _N_words, size_t _Size>
struct __has_storage_type<__bitset<_N_words, _Size> >
{
    static const bool value = true;
};

template <size_t _N_words, size_t _Size>
class __bitset
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    __storage_type __first_[_N_words];

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

                      __bitset() throw();
    explicit __bitset(unsigned long long __v) throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference __make_ref(size_t __pos) throw()
        {return reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference __make_ref(size_t __pos) const throw()
        {return const_reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator __make_iter(size_t __pos) throw()
        {return iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_iterator __make_iter(size_t __pos) const throw()
        {return const_iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}

    void operator&=(const __bitset& __v) throw();
    void operator|=(const __bitset& __v) throw();
    void operator^=(const __bitset& __v) throw();

    void flip() throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unsigned long to_ulong() const
        {return to_ulong(integral_constant<bool, _Size < sizeof(unsigned long) * 8>());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unsigned long long to_ullong() const
        {return to_ullong(integral_constant<bool, _Size < sizeof(unsigned long long) * 8>());}

    bool all() const throw();
    bool any() const throw();
    size_t __hash_code() const throw();
private:

    void __init(unsigned long long __v, false_type) throw();
    void __init(unsigned long long __v, true_type) throw();

    unsigned long to_ulong(false_type) const;
    unsigned long to_ulong(true_type) const;
    unsigned long long to_ullong(false_type) const;
    unsigned long long to_ullong(true_type) const;
    unsigned long long to_ullong(true_type, false_type) const;
    unsigned long long to_ullong(true_type, true_type) const;
};

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

__bitset<_N_words, _Size>::__bitset() throw()



{

    std::__1::fill_n(__first_, _N_words, __storage_type(0));

}



template <size_t _N_words, size_t _Size>
void
__bitset<_N_words, _Size>::__init(unsigned long long __v, false_type) throw()
{
    __storage_type __t[sizeof(unsigned long long) / sizeof(__storage_type)];
    for (size_t __i = 0; __i < sizeof(__t)/sizeof(__t[0]); ++__i, __v >>= __bits_per_word)
        __t[__i] = static_cast<__storage_type>(__v);
    std::__1::copy(__t, __t + sizeof(__t)/sizeof(__t[0]), __first_);
    std::__1::fill(__first_ + sizeof(__t)/sizeof(__t[0]), __first_ + sizeof(__first_)/sizeof(__first_[0]),
               __storage_type(0));
}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<_N_words, _Size>::__init(unsigned long long __v, true_type) throw()
{
    __first_[0] = __v;
    std::__1::fill(__first_ + 1, __first_ + sizeof(__first_)/sizeof(__first_[0]), __storage_type(0));
}



template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

__bitset<_N_words, _Size>::__bitset(unsigned long long __v) throw()
# 260 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/bitset" 3
{

    __init(__v, integral_constant<bool, sizeof(unsigned long long) == sizeof(__storage_type)>());

}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<_N_words, _Size>::operator&=(const __bitset& __v) throw()
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] &= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<_N_words, _Size>::operator|=(const __bitset& __v) throw()
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] |= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<_N_words, _Size>::operator^=(const __bitset& __v) throw()
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] ^= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
void
__bitset<_N_words, _Size>::flip() throw()
{

    size_type __n = _Size;
    __storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        *__p = ~*__p;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = *__p & __m;
        *__p &= ~__m;
        *__p |= ~__b & __m;
    }
}

template <size_t _N_words, size_t _Size>
unsigned long
__bitset<_N_words, _Size>::to_ulong(false_type) const
{
    const_iterator __e = __make_iter(_Size);
    const_iterator __i = std::__1::find(__make_iter(sizeof(unsigned long) * 8), __e, true);
    if (__i != __e)



        ((void)((!"bitset to_ulong overflow error") || (__assert_fail("!\"bitset to_ulong overflow error\"", "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/bitset", 322, __func__),0)));

    return __first_[0];
}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long
__bitset<_N_words, _Size>::to_ulong(true_type) const
{
    return __first_[0];
}

template <size_t _N_words, size_t _Size>
unsigned long long
__bitset<_N_words, _Size>::to_ullong(false_type) const
{
    const_iterator __e = __make_iter(_Size);
    const_iterator __i = std::__1::find(__make_iter(sizeof(unsigned long long) * 8), __e, true);
    if (__i != __e)



        ((void)((!"bitset to_ullong overflow error") || (__assert_fail("!\"bitset to_ullong overflow error\"", "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/bitset", 345, __func__),0)));

    return to_ullong(true_type());
}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type) const
{
    return to_ullong(true_type(), integral_constant<bool, sizeof(__storage_type) < sizeof(unsigned long long)>());
}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type, false_type) const
{
    return __first_[0];
}

template <size_t _N_words, size_t _Size>
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type, true_type) const
{
    unsigned long long __r = __first_[0];
    for (std::size_t __i = 1; __i < sizeof(unsigned long long) / sizeof(__storage_type); ++__i)
        __r |= static_cast<unsigned long long>(__first_[__i]) << (sizeof(__storage_type) * 8);
    return __r;
}

template <size_t _N_words, size_t _Size>
bool
__bitset<_N_words, _Size>::all() const throw()
{

    size_type __n = _Size;
    __const_storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        if (~*__p)
            return false;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        if (~*__p & __m)
            return false;
    }
    return true;
}

template <size_t _N_words, size_t _Size>
bool
__bitset<_N_words, _Size>::any() const throw()
{

    size_type __n = _Size;
    __const_storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        if (*__p)
            return true;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        if (*__p & __m)
            return true;
    }
    return false;
}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
size_t
__bitset<_N_words, _Size>::__hash_code() const throw()
{
    size_t __h = 0;
    for (size_type __i = 0; __i < _N_words; ++__i)
        __h ^= __first_[__i];
    return __h;
}

template <size_t _Size>
class __bitset<1, _Size>
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    __storage_type __first_;

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

                      __bitset() throw();
    explicit __bitset(unsigned long long __v) throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference __make_ref(size_t __pos) throw()
        {return reference(&__first_, __storage_type(1) << __pos);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference __make_ref(size_t __pos) const throw()
        {return const_reference(&__first_, __storage_type(1) << __pos);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator __make_iter(size_t __pos) throw()
        {return iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_iterator __make_iter(size_t __pos) const throw()
        {return const_iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}

    void operator&=(const __bitset& __v) throw();
    void operator|=(const __bitset& __v) throw();
    void operator^=(const __bitset& __v) throw();

    void flip() throw();

    unsigned long to_ulong() const;
    unsigned long long to_ullong() const;

    bool all() const throw();
    bool any() const throw();

    size_t __hash_code() const throw();
};

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

__bitset<1, _Size>::__bitset() throw()
    : __first_(0)
{
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

__bitset<1, _Size>::__bitset(unsigned long long __v) throw()
    : __first_(static_cast<__storage_type>(__v))
{
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<1, _Size>::operator&=(const __bitset& __v) throw()
{
    __first_ &= __v.__first_;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<1, _Size>::operator|=(const __bitset& __v) throw()
{
    __first_ |= __v.__first_;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<1, _Size>::operator^=(const __bitset& __v) throw()
{
    __first_ ^= __v.__first_;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<1, _Size>::flip() throw()
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    __first_ = ~__first_;
    __first_ &= __m;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long
__bitset<1, _Size>::to_ulong() const
{
    return __first_;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long
__bitset<1, _Size>::to_ullong() const
{
    return __first_;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__bitset<1, _Size>::all() const throw()
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    return !(~__first_ & __m);
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__bitset<1, _Size>::any() const throw()
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    return __first_ & __m;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
size_t
__bitset<1, _Size>::__hash_code() const throw()
{
    return __first_;
}

template <>
class __bitset<0, 0>
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

                      __bitset() throw();
    explicit __bitset(unsigned long long) throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference __make_ref(size_t) throw()
        {return reference(0, 1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference __make_ref(size_t) const throw()
        {return const_reference(0, 1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator __make_iter(size_t) throw()
        {return iterator(0, 0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_iterator __make_iter(size_t) const throw()
        {return const_iterator(0, 0);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator&=(const __bitset&) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator|=(const __bitset&) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator^=(const __bitset&) throw() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void flip() throw() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unsigned long to_ulong() const {return 0;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unsigned long long to_ullong() const {return 0;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool all() const throw() {return true;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool any() const throw() {return false;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_t __hash_code() const throw() {return 0;}
};

inline __attribute__ ((__visibility__("hidden"), __always_inline__))

__bitset<0, 0>::__bitset() throw()
{
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))

__bitset<0, 0>::__bitset(unsigned long long) throw()
{
}

template <size_t _Size> class __attribute__ ((__type_visibility__("default"))) bitset;
template <size_t _Size> struct __attribute__ ((__type_visibility__("default"))) hash<bitset<_Size> >;

template <size_t _Size>
class __attribute__ ((__type_visibility__("default"))) bitset
    : private __bitset<_Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1, _Size>
{
public:
    static const unsigned __n_words = _Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1;
    typedef __bitset<__n_words, _Size> base;

public:
    typedef typename base::reference reference;
    typedef typename base::const_reference const_reference;


    __attribute__ ((__visibility__("hidden"), __always_inline__)) bitset() throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        bitset(unsigned long long __v) throw() : base(__v) {}
    template<class _CharT>
        explicit bitset(const _CharT* __str,
                        typename basic_string<_CharT>::size_type __n = basic_string<_CharT>::npos,
                        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));
    template<class _CharT, class _Traits, class _Allocator>
        explicit bitset(const basic_string<_CharT,_Traits,_Allocator>& __str,
                        typename basic_string<_CharT,_Traits,_Allocator>::size_type __pos = 0,
                        typename basic_string<_CharT,_Traits,_Allocator>::size_type __n =
                                (basic_string<_CharT,_Traits,_Allocator>::npos),
                        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));


    bitset& operator&=(const bitset& __rhs) throw();
    bitset& operator|=(const bitset& __rhs) throw();
    bitset& operator^=(const bitset& __rhs) throw();
    bitset& operator<<=(size_t __pos) throw();
    bitset& operator>>=(size_t __pos) throw();
    bitset& set() throw();
    bitset& set(size_t __pos, bool __val = true);
    bitset& reset() throw();
    bitset& reset(size_t __pos);
    bitset operator~() const throw();
    bitset& flip() throw();
    bitset& flip(size_t __pos);


    __attribute__ ((__visibility__("hidden"), __always_inline__))
                              const_reference operator[](size_t __p) const {return base::__make_ref(__p);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](size_t __p) {return base::__make_ref(__p);}
    unsigned long to_ulong() const;
    unsigned long long to_ullong() const;
    template <class _CharT, class _Traits, class _Allocator>
        basic_string<_CharT, _Traits, _Allocator> to_string(_CharT __zero = _CharT('0'),
                                                            _CharT __one = _CharT('1')) const;
    template <class _CharT, class _Traits>
        basic_string<_CharT, _Traits, allocator<_CharT> > to_string(_CharT __zero = _CharT('0'),
                                                                    _CharT __one = _CharT('1')) const;
    template <class _CharT>
        basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> > to_string(_CharT __zero = _CharT('0'),
                                                                                _CharT __one = _CharT('1')) const;
    basic_string<char, char_traits<char>, allocator<char> > to_string(char __zero = '0',
                                                                      char __one = '1') const;
    size_t count() const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_t size() const throw() {return _Size;}
    bool operator==(const bitset& __rhs) const throw();
    bool operator!=(const bitset& __rhs) const throw();
    bool test(size_t __pos) const;
    bool all() const throw();
    bool any() const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool none() const throw() {return !any();}
    bitset operator<<(size_t __pos) const throw();
    bitset operator>>(size_t __pos) const throw();

private:

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t __hash_code() const throw() {return base::__hash_code();}

    friend struct hash<bitset>;
};

template <size_t _Size>
template<class _CharT>
bitset<_Size>::bitset(const _CharT* __str,
                      typename basic_string<_CharT>::size_type __n,
                      _CharT __zero, _CharT __one)
{
    size_t __rlen = std::__1::min(__n, char_traits<_CharT>::length(__str));
    for (size_t __i = 0; __i < __rlen; ++__i)
        if (__str[__i] != __zero && __str[__i] != __one)



            ((void)((!"bitset string ctor has invalid argument") || (__assert_fail("!\"bitset string ctor has invalid argument\"", "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/bitset", 727, __func__),0)));

    size_t _Mp = std::__1::min(__rlen, _Size);
    size_t __i = 0;
    for (; __i < _Mp; ++__i)
    {
        _CharT __c = __str[_Mp - 1 - __i];
        if (__c == __zero)
            (*this)[__i] = false;
        else
            (*this)[__i] = true;
    }
    std::__1::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
}

template <size_t _Size>
template<class _CharT, class _Traits, class _Allocator>
bitset<_Size>::bitset(const basic_string<_CharT,_Traits,_Allocator>& __str,
       typename basic_string<_CharT,_Traits,_Allocator>::size_type __pos,
       typename basic_string<_CharT,_Traits,_Allocator>::size_type __n,
       _CharT __zero, _CharT __one)
{
    if (__pos > __str.size())



        ((void)((!"bitset string pos out of range") || (__assert_fail("!\"bitset string pos out of range\"", "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/bitset", 753, __func__),0)));

    size_t __rlen = std::__1::min(__n, __str.size() - __pos);
    for (size_t __i = __pos; __i < __pos + __rlen; ++__i)
        if (!_Traits::eq(__str[__i], __zero) && !_Traits::eq(__str[__i], __one))



            ((void)((!"bitset string ctor has invalid argument") || (__assert_fail("!\"bitset string ctor has invalid argument\"", "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/bitset", 761, __func__),0)));

    size_t _Mp = std::__1::min(__rlen, _Size);
    size_t __i = 0;
    for (; __i < _Mp; ++__i)
    {
        _CharT __c = __str[__pos + _Mp - 1 - __i];
        if (_Traits::eq(__c, __zero))
            (*this)[__i] = false;
        else
            (*this)[__i] = true;
    }
    std::__1::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>&
bitset<_Size>::operator&=(const bitset& __rhs) throw()
{
    base::operator&=(__rhs);
    return *this;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>&
bitset<_Size>::operator|=(const bitset& __rhs) throw()
{
    base::operator|=(__rhs);
    return *this;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>&
bitset<_Size>::operator^=(const bitset& __rhs) throw()
{
    base::operator^=(__rhs);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::operator<<=(size_t __pos) throw()
{
    __pos = std::__1::min(__pos, _Size);
    std::__1::copy_backward(base::__make_iter(0), base::__make_iter(_Size - __pos), base::__make_iter(_Size));
    std::__1::fill_n(base::__make_iter(0), __pos, false);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::operator>>=(size_t __pos) throw()
{
    __pos = std::__1::min(__pos, _Size);
    std::__1::copy(base::__make_iter(__pos), base::__make_iter(_Size), base::__make_iter(0));
    std::__1::fill_n(base::__make_iter(_Size - __pos), __pos, false);
    return *this;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>&
bitset<_Size>::set() throw()
{
    std::__1::fill_n(base::__make_iter(0), _Size, true);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::set(size_t __pos, bool __val)
{
    if (__pos >= _Size)



        ((void)((!"bitset set argument out of range") || (__assert_fail("!\"bitset set argument out of range\"", "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/bitset", 840, __func__),0)));

    (*this)[__pos] = __val;
    return *this;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>&
bitset<_Size>::reset() throw()
{
    std::__1::fill_n(base::__make_iter(0), _Size, false);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::reset(size_t __pos)
{
    if (__pos >= _Size)



        ((void)((!"bitset reset argument out of range") || (__assert_fail("!\"bitset reset argument out of range\"", "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/bitset", 863, __func__),0)));

    (*this)[__pos] = false;
    return *this;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>
bitset<_Size>::operator~() const throw()
{
    bitset __x(*this);
    __x.flip();
    return __x;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>&
bitset<_Size>::flip() throw()
{
    base::flip();
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::flip(size_t __pos)
{
    if (__pos >= _Size)



        ((void)((!"bitset flip argument out of range") || (__assert_fail("!\"bitset flip argument out of range\"", "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/bitset", 896, __func__),0)));

    reference r = base::__make_ref(__pos);
    r = ~r;
    return *this;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long
bitset<_Size>::to_ulong() const
{
    return base::to_ulong();
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long
bitset<_Size>::to_ullong() const
{
    return base::to_ullong();
}

template <size_t _Size>
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    basic_string<_CharT, _Traits, _Allocator> __r(_Size, __zero);
    for (size_t __i = 0; __i < _Size; ++__i)
    {
        if ((*this)[__i])
            __r[_Size - 1 - __i] = __one;
    }
    return __r;
}

template <size_t _Size>
template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, allocator<_CharT> >
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    return to_string<_CharT, _Traits, allocator<_CharT> >(__zero, __one);
}

template <size_t _Size>
template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> >
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    return to_string<_CharT, char_traits<_CharT>, allocator<_CharT> >(__zero, __one);
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<char, char_traits<char>, allocator<char> >
bitset<_Size>::to_string(char __zero, char __one) const
{
    return to_string<char, char_traits<char>, allocator<char> >(__zero, __one);
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
size_t
bitset<_Size>::count() const throw()
{
    return static_cast<size_t>(std::__1::count(base::__make_iter(0), base::__make_iter(_Size), true));
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
bitset<_Size>::operator==(const bitset& __rhs) const throw()
{
    return std::__1::equal(base::__make_iter(0), base::__make_iter(_Size), __rhs.__make_iter(0));
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
bitset<_Size>::operator!=(const bitset& __rhs) const throw()
{
    return !(*this == __rhs);
}

template <size_t _Size>
bool
bitset<_Size>::test(size_t __pos) const
{
    if (__pos >= _Size)



        ((void)((!"bitset test argument out of range") || (__assert_fail("!\"bitset test argument out of range\"", "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/bitset", 991, __func__),0)));

    return (*this)[__pos];
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
bitset<_Size>::all() const throw()
{
    return base::all();
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
bitset<_Size>::any() const throw()
{
    return base::any();
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>
bitset<_Size>::operator<<(size_t __pos) const throw()
{
    bitset __r = *this;
    __r <<= __pos;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>
bitset<_Size>::operator>>(size_t __pos) const throw()
{
    bitset __r = *this;
    __r >>= __pos;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>
operator&(const bitset<_Size>& __x, const bitset<_Size>& __y) throw()
{
    bitset<_Size> __r = __x;
    __r &= __y;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>
operator|(const bitset<_Size>& __x, const bitset<_Size>& __y) throw()
{
    bitset<_Size> __r = __x;
    __r |= __y;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>
operator^(const bitset<_Size>& __x, const bitset<_Size>& __y) throw()
{
    bitset<_Size> __r = __x;
    __r ^= __y;
    return __r;
}

template <size_t _Size>
struct __attribute__ ((__type_visibility__("default"))) hash<bitset<_Size> >
    : public unary_function<bitset<_Size>, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(const bitset<_Size>& __bs) const throw()
        {return __bs.__hash_code();}
};

template <class _CharT, class _Traits, size_t _Size>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x);

template <class _CharT, class _Traits, size_t _Size>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x);

} }
# 24 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Attributes.h" 2
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 1 3
# 21 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/assert.h" 1 3
# 12 "/mnt/home/ec2-user/build/emscripten/system/include/libc/assert.h" 3
extern "C" {



__attribute__((__noreturn__))

void __assert_fail (const char *, const char *, int, const char *);


}
# 22 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 2 3
# 25 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 3
# 25 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Attributes.h" 2
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 1 3
# 423 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__tree" 1 3
# 22 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__tree" 3


namespace std {inline namespace __1 {

template <class _Tp, class _Compare, class _Allocator> class __tree;
template <class _Tp, class _NodePtr, class _DiffType>
    class __attribute__ ((__type_visibility__("default"))) __tree_iterator;
template <class _Tp, class _ConstNodePtr, class _DiffType>
    class __attribute__ ((__type_visibility__("default"))) __tree_const_iterator;
template <class _Key, class _Tp, class _Compare, class _Allocator>
    class __attribute__ ((__type_visibility__("default"))) map;
template <class _Key, class _Tp, class _Compare, class _Allocator>
    class __attribute__ ((__type_visibility__("default"))) multimap;
template <class _Key, class _Compare, class _Allocator>
    class __attribute__ ((__type_visibility__("default"))) set;
template <class _Key, class _Compare, class _Allocator>
    class __attribute__ ((__type_visibility__("default"))) multiset;
# 63 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__tree" 3
template <class _NodePtr>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__tree_is_left_child(_NodePtr __x) throw()
{
    return __x == __x->__parent_->__left_;
}




template <class _NodePtr>
unsigned
__tree_sub_invariant(_NodePtr __x)
{
    if (__x == std::__1::__get_nullptr_t())
        return 1;


    if (__x->__left_ != std::__1::__get_nullptr_t() && __x->__left_->__parent_ != __x)
        return 0;

    if (__x->__right_ != std::__1::__get_nullptr_t() && __x->__right_->__parent_ != __x)
        return 0;

    if (__x->__left_ == __x->__right_ && __x->__left_ != std::__1::__get_nullptr_t())
        return 0;

    if (!__x->__is_black_)
    {
        if (__x->__left_ && !__x->__left_->__is_black_)
            return 0;
        if (__x->__right_ && !__x->__right_->__is_black_)
            return 0;
    }
    unsigned __h = __tree_sub_invariant(__x->__left_);
    if (__h == 0)
        return 0;
    if (__h != __tree_sub_invariant(__x->__right_))
        return 0;
    return __h + __x->__is_black_;
}




template <class _NodePtr>
bool
__tree_invariant(_NodePtr __root)
{
    if (__root == std::__1::__get_nullptr_t())
        return true;

    if (__root->__parent_ == std::__1::__get_nullptr_t())
        return false;
    if (!__tree_is_left_child(__root))
        return false;

    if (!__root->__is_black_)
        return false;

    return __tree_sub_invariant(__root) != 0;
}



template <class _NodePtr>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_NodePtr
__tree_min(_NodePtr __x) throw()
{
    while (__x->__left_ != std::__1::__get_nullptr_t())
        __x = __x->__left_;
    return __x;
}



template <class _NodePtr>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_NodePtr
__tree_max(_NodePtr __x) throw()
{
    while (__x->__right_ != std::__1::__get_nullptr_t())
        __x = __x->__right_;
    return __x;
}



template <class _NodePtr>
_NodePtr
__tree_next(_NodePtr __x) throw()
{
    if (__x->__right_ != std::__1::__get_nullptr_t())
        return __tree_min(__x->__right_);
    while (!__tree_is_left_child(__x))
        __x = __x->__parent_;
    return __x->__parent_;
}



template <class _NodePtr>
_NodePtr
__tree_prev(_NodePtr __x) throw()
{
    if (__x->__left_ != std::__1::__get_nullptr_t())
        return __tree_max(__x->__left_);
    while (__tree_is_left_child(__x))
        __x = __x->__parent_;
    return __x->__parent_;
}



template <class _NodePtr>
_NodePtr
__tree_leaf(_NodePtr __x) throw()
{
    while (true)
    {
        if (__x->__left_ != std::__1::__get_nullptr_t())
        {
            __x = __x->__left_;
            continue;
        }
        if (__x->__right_ != std::__1::__get_nullptr_t())
        {
            __x = __x->__right_;
            continue;
        }
        break;
    }
    return __x;
}




template <class _NodePtr>
void
__tree_left_rotate(_NodePtr __x) throw()
{
    _NodePtr __y = __x->__right_;
    __x->__right_ = __y->__left_;
    if (__x->__right_ != std::__1::__get_nullptr_t())
        __x->__right_->__parent_ = __x;
    __y->__parent_ = __x->__parent_;
    if (__tree_is_left_child(__x))
        __x->__parent_->__left_ = __y;
    else
        __x->__parent_->__right_ = __y;
    __y->__left_ = __x;
    __x->__parent_ = __y;
}




template <class _NodePtr>
void
__tree_right_rotate(_NodePtr __x) throw()
{
    _NodePtr __y = __x->__left_;
    __x->__left_ = __y->__right_;
    if (__x->__left_ != std::__1::__get_nullptr_t())
        __x->__left_->__parent_ = __x;
    __y->__parent_ = __x->__parent_;
    if (__tree_is_left_child(__x))
        __x->__parent_->__left_ = __y;
    else
        __x->__parent_->__right_ = __y;
    __y->__right_ = __x;
    __x->__parent_ = __y;
}
# 248 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__tree" 3
template <class _NodePtr>
void
__tree_balance_after_insert(_NodePtr __root, _NodePtr __x) throw()
{
    __x->__is_black_ = __x == __root;
    while (__x != __root && !__x->__parent_->__is_black_)
    {

        if (__tree_is_left_child(__x->__parent_))
        {
            _NodePtr __y = __x->__parent_->__parent_->__right_;
            if (__y != std::__1::__get_nullptr_t() && !__y->__is_black_)
            {
                __x = __x->__parent_;
                __x->__is_black_ = true;
                __x = __x->__parent_;
                __x->__is_black_ = __x == __root;
                __y->__is_black_ = true;
            }
            else
            {
                if (!__tree_is_left_child(__x))
                {
                    __x = __x->__parent_;
                    __tree_left_rotate(__x);
                }
                __x = __x->__parent_;
                __x->__is_black_ = true;
                __x = __x->__parent_;
                __x->__is_black_ = false;
                __tree_right_rotate(__x);
                break;
            }
        }
        else
        {
            _NodePtr __y = __x->__parent_->__parent_->__left_;
            if (__y != std::__1::__get_nullptr_t() && !__y->__is_black_)
            {
                __x = __x->__parent_;
                __x->__is_black_ = true;
                __x = __x->__parent_;
                __x->__is_black_ = __x == __root;
                __y->__is_black_ = true;
            }
            else
            {
                if (__tree_is_left_child(__x))
                {
                    __x = __x->__parent_;
                    __tree_right_rotate(__x);
                }
                __x = __x->__parent_;
                __x->__is_black_ = true;
                __x = __x->__parent_;
                __x->__is_black_ = false;
                __tree_left_rotate(__x);
                break;
            }
        }
    }
}
# 318 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__tree" 3
template <class _NodePtr>
void
__tree_remove(_NodePtr __root, _NodePtr __z) throw()
{




    _NodePtr __y = (__z->__left_ == std::__1::__get_nullptr_t() || __z->__right_ == std::__1::__get_nullptr_t()) ?
                    __z : __tree_next(__z);

    _NodePtr __x = __y->__left_ != std::__1::__get_nullptr_t() ? __y->__left_ : __y->__right_;

    _NodePtr __w = std::__1::__get_nullptr_t();

    if (__x != std::__1::__get_nullptr_t())
        __x->__parent_ = __y->__parent_;
    if (__tree_is_left_child(__y))
    {
        __y->__parent_->__left_ = __x;
        if (__y != __root)
            __w = __y->__parent_->__right_;
        else
            __root = __x;
    }
    else
    {
        __y->__parent_->__right_ = __x;

        __w = __y->__parent_->__left_;
    }
    bool __removed_black = __y->__is_black_;


    if (__y != __z)
    {

        __y->__parent_ = __z->__parent_;
        if (__tree_is_left_child(__z))
            __y->__parent_->__left_ = __y;
        else
            __y->__parent_->__right_ = __y;
        __y->__left_ = __z->__left_;
        __y->__left_->__parent_ = __y;
        __y->__right_ = __z->__right_;
        if (__y->__right_ != std::__1::__get_nullptr_t())
            __y->__right_->__parent_ = __y;
        __y->__is_black_ = __z->__is_black_;
        if (__root == __z)
            __root = __y;
    }


    if (__removed_black && __root != std::__1::__get_nullptr_t())
    {
# 385 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__tree" 3
        if (__x != std::__1::__get_nullptr_t())
            __x->__is_black_ = true;
        else
        {





            while (true)
            {
                if (!__tree_is_left_child(__w))
                {
                    if (!__w->__is_black_)
                    {
                        __w->__is_black_ = true;
                        __w->__parent_->__is_black_ = false;
                        __tree_left_rotate(__w->__parent_);


                        if (__root == __w->__left_)
                            __root = __w;

                        __w = __w->__left_->__right_;
                    }

                    if ((__w->__left_ == std::__1::__get_nullptr_t() || __w->__left_->__is_black_) &&
                        (__w->__right_ == std::__1::__get_nullptr_t() || __w->__right_->__is_black_))
                    {
                        __w->__is_black_ = false;
                        __x = __w->__parent_;

                        if (__x == __root || !__x->__is_black_)
                        {
                            __x->__is_black_ = true;
                            break;
                        }

                        __w = __tree_is_left_child(__x) ?
                                    __x->__parent_->__right_ :
                                    __x->__parent_->__left_;

                    }
                    else
                    {
                        if (__w->__right_ == std::__1::__get_nullptr_t() || __w->__right_->__is_black_)
                        {

                            __w->__left_->__is_black_ = true;
                            __w->__is_black_ = false;
                            __tree_right_rotate(__w);


                            __w = __w->__parent_;
                        }

                        __w->__is_black_ = __w->__parent_->__is_black_;
                        __w->__parent_->__is_black_ = true;
                        __w->__right_->__is_black_ = true;
                        __tree_left_rotate(__w->__parent_);
                        break;
                    }
                }
                else
                {
                    if (!__w->__is_black_)
                    {
                        __w->__is_black_ = true;
                        __w->__parent_->__is_black_ = false;
                        __tree_right_rotate(__w->__parent_);


                        if (__root == __w->__right_)
                            __root = __w;

                        __w = __w->__right_->__left_;
                    }

                    if ((__w->__left_ == std::__1::__get_nullptr_t() || __w->__left_->__is_black_) &&
                        (__w->__right_ == std::__1::__get_nullptr_t() || __w->__right_->__is_black_))
                    {
                        __w->__is_black_ = false;
                        __x = __w->__parent_;

                        if (!__x->__is_black_ || __x == __root)
                        {
                            __x->__is_black_ = true;
                            break;
                        }

                        __w = __tree_is_left_child(__x) ?
                                    __x->__parent_->__right_ :
                                    __x->__parent_->__left_;

                    }
                    else
                    {
                        if (__w->__left_ == std::__1::__get_nullptr_t() || __w->__left_->__is_black_)
                        {

                            __w->__right_->__is_black_ = true;
                            __w->__is_black_ = false;
                            __tree_left_rotate(__w);


                            __w = __w->__parent_;
                        }

                        __w->__is_black_ = __w->__parent_->__is_black_;
                        __w->__parent_->__is_black_ = true;
                        __w->__left_->__is_black_ = true;
                        __tree_right_rotate(__w->__parent_);
                        break;
                    }
                }
            }
        }
    }
}

template <class _Allocator> class __map_node_destructor;

template <class _Allocator>
class __tree_node_destructor
{
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::value_type::value_type value_type;
public:
    typedef typename __alloc_traits::pointer pointer;
private:

    allocator_type& __na_;

    __tree_node_destructor& operator=(const __tree_node_destructor&);

public:
    bool __value_constructed;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __tree_node_destructor(allocator_type& __na) throw()
        : __na_(__na),
          __value_constructed(false)
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void operator()(pointer __p) throw()
    {
        if (__value_constructed)
            __alloc_traits::destroy(__na_, std::__1::addressof(__p->__value_));
        if (__p)
            __alloc_traits::deallocate(__na_, __p, 1);
    }

    template <class> friend class __map_node_destructor;
};



template <class _Pointer>
class __tree_end_node
{
public:
    typedef _Pointer pointer;
    pointer __left_;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __tree_end_node() throw() : __left_() {}
};

template <class _VoidPtr>
class __tree_node_base
    : public __tree_end_node
             <
                typename pointer_traits<_VoidPtr>::template



                     rebind<__tree_node_base<_VoidPtr> >::other

             >
{
    __tree_node_base(const __tree_node_base&);
    __tree_node_base& operator=(const __tree_node_base&);
public:
    typedef typename pointer_traits<_VoidPtr>::template



            rebind<__tree_node_base>::other

                                                pointer;
    typedef typename pointer_traits<_VoidPtr>::template



            rebind<const __tree_node_base>::other

                                                const_pointer;
    typedef __tree_end_node<pointer> base;

    pointer __right_;
    pointer __parent_;
    bool __is_black_;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __tree_node_base() throw()
        : __right_(), __parent_(), __is_black_(false) {}
};

template <class _Tp, class _VoidPtr>
class __tree_node
    : public __tree_node_base<_VoidPtr>
{
public:
    typedef __tree_node_base<_VoidPtr> base;
    typedef _Tp value_type;

    value_type __value_;







    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __tree_node(const value_type& __v)
            : __value_(__v) {}

};

template <class _TreeIterator> class __attribute__ ((__type_visibility__("default"))) __map_iterator;
template <class _TreeIterator> class __attribute__ ((__type_visibility__("default"))) __map_const_iterator;

template <class _Tp, class _NodePtr, class _DiffType>
class __attribute__ ((__type_visibility__("default"))) __tree_iterator
{
    typedef _NodePtr __node_pointer;
    typedef typename pointer_traits<__node_pointer>::element_type __node;
    typedef typename __node::base __node_base;
    typedef typename __node_base::pointer __node_base_pointer;

    __node_pointer __ptr_;

    typedef pointer_traits<__node_pointer> __pointer_traits;
public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef _DiffType difference_type;
    typedef value_type& reference;
    typedef typename pointer_traits<__node_pointer>::template



            rebind<value_type>::other

                                       pointer;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __tree_iterator() throw()



    {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator*() const {return __ptr_->__value_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer operator->() const
        {return pointer_traits<pointer>::pointer_to(__ptr_->__value_);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __tree_iterator& operator++()
        {__ptr_ = static_cast<__node_pointer>(__tree_next(static_cast<__node_base_pointer>(__ptr_)));
         return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __tree_iterator operator++(int)
        {__tree_iterator __t(*this); ++(*this); return __t;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __tree_iterator& operator--()
        {__ptr_ = static_cast<__node_pointer>(__tree_prev(static_cast<__node_base_pointer>(__ptr_)));
         return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __tree_iterator operator--(int)
        {__tree_iterator __t(*this); --(*this); return __t;}

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool operator==(const __tree_iterator& __x, const __tree_iterator& __y)
        {return __x.__ptr_ == __y.__ptr_;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool operator!=(const __tree_iterator& __x, const __tree_iterator& __y)
        {return !(__x == __y);}

private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __tree_iterator(__node_pointer __p) throw() : __ptr_(__p) {}
    template <class, class, class> friend class __tree;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) __tree_const_iterator;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __map_iterator;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) set;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multiset;
};

template <class _Tp, class _ConstNodePtr, class _DiffType>
class __attribute__ ((__type_visibility__("default"))) __tree_const_iterator
{
    typedef _ConstNodePtr __node_pointer;
    typedef typename pointer_traits<__node_pointer>::element_type __node;
    typedef typename __node::base __node_base;
    typedef typename pointer_traits<__node_pointer>::template



            rebind<__node_base>::other

                                                                  __node_base_pointer;

    __node_pointer __ptr_;

    typedef pointer_traits<__node_pointer> __pointer_traits;
public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef _DiffType difference_type;
    typedef const value_type& reference;
    typedef typename pointer_traits<__node_pointer>::template



            rebind<const value_type>::other

                                       pointer;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __tree_const_iterator() throw()



    {}

private:
    typedef typename remove_const<__node>::type __non_const_node;
    typedef typename pointer_traits<__node_pointer>::template



            rebind<__non_const_node>::other

                                                 __non_const_node_pointer;
    typedef __tree_iterator<value_type, __non_const_node_pointer, difference_type>
                                                 __non_const_iterator;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __tree_const_iterator(__non_const_iterator __p) throw()
        : __ptr_(__p.__ptr_) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator*() const {return __ptr_->__value_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer operator->() const
        {return pointer_traits<pointer>::pointer_to(__ptr_->__value_);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __tree_const_iterator& operator++()
        {__ptr_ = static_cast<__node_pointer>(__tree_next(static_cast<__node_base_pointer>(__ptr_)));
         return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __tree_const_iterator operator++(int)
        {__tree_const_iterator __t(*this); ++(*this); return __t;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __tree_const_iterator& operator--()
        {__ptr_ = static_cast<__node_pointer>(__tree_prev(static_cast<__node_base_pointer>(__ptr_)));
         return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __tree_const_iterator operator--(int)
        {__tree_const_iterator __t(*this); --(*this); return __t;}

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool operator==(const __tree_const_iterator& __x, const __tree_const_iterator& __y)
        {return __x.__ptr_ == __y.__ptr_;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool operator!=(const __tree_const_iterator& __x, const __tree_const_iterator& __y)
        {return !(__x == __y);}

private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __tree_const_iterator(__node_pointer __p) throw()
        : __ptr_(__p) {}
    template <class, class, class> friend class __tree;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) set;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multiset;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __map_const_iterator;
};

template <class _Tp, class _Compare, class _Allocator>
class __tree
{
public:
    typedef _Tp value_type;
    typedef _Compare value_compare;
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;

    typedef typename __alloc_traits::void_pointer __void_pointer;

    typedef __tree_node<value_type, __void_pointer> __node;
    typedef __tree_node_base<__void_pointer> __node_base;
    typedef typename __alloc_traits::template



            rebind_alloc<__node>::other

                                                     __node_allocator;
    typedef allocator_traits<__node_allocator> __node_traits;
    typedef typename __node_traits::pointer __node_pointer;
    typedef typename __node_traits::pointer __node_const_pointer;
    typedef typename __node_base::pointer __node_base_pointer;
    typedef typename __node_base::pointer __node_base_const_pointer;
private:
    typedef typename __node_base::base __end_node_t;
    typedef typename pointer_traits<__node_pointer>::template



            rebind<__end_node_t>::other

                                                     __end_node_ptr;
    typedef typename pointer_traits<__node_pointer>::template



            rebind<__end_node_t>::other

                                                     __end_node_const_ptr;

    __node_pointer __begin_node_;
    __compressed_pair<__end_node_t, __node_allocator> __pair1_;
    __compressed_pair<size_type, value_compare> __pair3_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __node_pointer __end_node() throw()
    {
        return static_cast<__node_pointer>
               (
                   pointer_traits<__end_node_ptr>::pointer_to(__pair1_.first())
               );
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __node_const_pointer __end_node() const throw()
    {
        return static_cast<__node_const_pointer>
               (
                   pointer_traits<__end_node_const_ptr>::pointer_to(const_cast<__end_node_t&>(__pair1_.first()))
               );
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
          __node_allocator& __node_alloc() throw() {return __pair1_.second();}
private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const __node_allocator& __node_alloc() const throw()
        {return __pair1_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
          __node_pointer& __begin_node() throw() {return __begin_node_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const __node_pointer& __begin_node() const throw() {return __begin_node_;}
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    allocator_type __alloc() const throw()
        {return allocator_type(__node_alloc());}
private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
          size_type& size() throw() {return __pair3_.first();}
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const size_type& size() const throw() {return __pair3_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
          value_compare& value_comp() throw() {return __pair3_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const value_compare& value_comp() const throw()
        {return __pair3_.second();}
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __node_pointer __root() throw()
        {return static_cast<__node_pointer> (__end_node()->__left_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __node_const_pointer __root() const throw()
        {return static_cast<__node_const_pointer>(__end_node()->__left_);}

    typedef __tree_iterator<value_type, __node_pointer, difference_type> iterator;
    typedef __tree_const_iterator<value_type, __node_pointer, difference_type> const_iterator;

    explicit __tree(const value_compare& __comp)


                                                                ;
    explicit __tree(const allocator_type& __a);
    __tree(const value_compare& __comp, const allocator_type& __a);
    __tree(const __tree& __t);
    __tree& operator=(const __tree& __t);
    template <class _InputIterator>
        void __assign_unique(_InputIterator __first, _InputIterator __last);
    template <class _InputIterator>
        void __assign_multi(_InputIterator __first, _InputIterator __last);
# 908 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__tree" 3
    ~__tree();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
          iterator begin() throw() {return iterator(__begin_node());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator begin() const throw() {return const_iterator(__begin_node());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
          iterator end() throw() {return iterator(__end_node());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator end() const throw() {return const_iterator(__end_node());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type max_size() const throw()
        {return __node_traits::max_size(__node_alloc());}

    void clear() throw();

    void swap(__tree& __t)



                                                              ;
# 958 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__tree" 3
    pair<iterator, bool> __insert_unique(const value_type& __v);
    iterator __insert_unique(const_iterator __p, const value_type& __v);
    iterator __insert_multi(const value_type& __v);
    iterator __insert_multi(const_iterator __p, const value_type& __v);

    pair<iterator, bool> __node_insert_unique(__node_pointer __nd);
    iterator __node_insert_unique(const_iterator __p,
                                              __node_pointer __nd);

    iterator __node_insert_multi(__node_pointer __nd);
    iterator __node_insert_multi(const_iterator __p, __node_pointer __nd);

    iterator erase(const_iterator __p);
    iterator erase(const_iterator __f, const_iterator __l);
    template <class _Key>
        size_type __erase_unique(const _Key& __k);
    template <class _Key>
        size_type __erase_multi(const _Key& __k);

    void __insert_node_at(__node_base_pointer __parent,
                          __node_base_pointer& __child,
                          __node_base_pointer __new_node);

    template <class _Key>
        iterator find(const _Key& __v);
    template <class _Key>
        const_iterator find(const _Key& __v) const;

    template <class _Key>
        size_type __count_unique(const _Key& __k) const;
    template <class _Key>
        size_type __count_multi(const _Key& __k) const;

    template <class _Key>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        iterator lower_bound(const _Key& __v)
            {return __lower_bound(__v, __root(), __end_node());}
    template <class _Key>
        iterator __lower_bound(const _Key& __v,
                               __node_pointer __root,
                               __node_pointer __result);
    template <class _Key>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        const_iterator lower_bound(const _Key& __v) const
            {return __lower_bound(__v, __root(), __end_node());}
    template <class _Key>
        const_iterator __lower_bound(const _Key& __v,
                                     __node_const_pointer __root,
                                     __node_const_pointer __result) const;
    template <class _Key>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        iterator upper_bound(const _Key& __v)
            {return __upper_bound(__v, __root(), __end_node());}
    template <class _Key>
        iterator __upper_bound(const _Key& __v,
                               __node_pointer __root,
                               __node_pointer __result);
    template <class _Key>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        const_iterator upper_bound(const _Key& __v) const
            {return __upper_bound(__v, __root(), __end_node());}
    template <class _Key>
        const_iterator __upper_bound(const _Key& __v,
                                     __node_const_pointer __root,
                                     __node_const_pointer __result) const;
    template <class _Key>
        pair<iterator, iterator>
        __equal_range_unique(const _Key& __k);
    template <class _Key>
        pair<const_iterator, const_iterator>
        __equal_range_unique(const _Key& __k) const;

    template <class _Key>
        pair<iterator, iterator>
        __equal_range_multi(const _Key& __k);
    template <class _Key>
        pair<const_iterator, const_iterator>
        __equal_range_multi(const _Key& __k) const;

    typedef __tree_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;

    __node_holder remove(const_iterator __p) throw();
private:
    typename __node_base::pointer&
        __find_leaf_low(typename __node_base::pointer& __parent, const value_type& __v);
    typename __node_base::pointer&
        __find_leaf_high(typename __node_base::pointer& __parent, const value_type& __v);
    typename __node_base::pointer&
        __find_leaf(const_iterator __hint,
                    typename __node_base::pointer& __parent, const value_type& __v);
    template <class _Key>
        typename __node_base::pointer&
        __find_equal(typename __node_base::pointer& __parent, const _Key& __v);
    template <class _Key>
        typename __node_base::pointer&
        __find_equal(const_iterator __hint, typename __node_base::pointer& __parent,
                     const _Key& __v);





        __node_holder __construct_node(const value_type& __v);


    void destroy(__node_pointer __nd) throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __copy_assign_alloc(const __tree& __t)
        {__copy_assign_alloc(__t, integral_constant<bool,
             __node_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __copy_assign_alloc(const __tree& __t, true_type)
        {__node_alloc() = __t.__node_alloc();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __copy_assign_alloc(const __tree& __t, false_type) {}

    void __move_assign(__tree& __t, false_type);
    void __move_assign(__tree& __t, true_type)

                                                                       ;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign_alloc(__tree& __t)



        {__move_assign_alloc(__t, integral_constant<bool,
             __node_traits::propagate_on_container_move_assignment::value>());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign_alloc(__tree& __t, true_type)

        {__node_alloc() = std::__1::move(__t.__node_alloc());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign_alloc(__tree& __t, false_type) throw() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y)



        {__swap_alloc(__x, __y, integral_constant<bool,
                      __node_traits::propagate_on_container_swap::value>());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y, true_type)

        {
            using std::__1::swap;
            swap(__x, __y);
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y, false_type)
        throw()
        {}

    __node_pointer __detach();
    static __node_pointer __detach(__node_pointer);

    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
};

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp)



    : __pair3_(0, __comp)
{
    __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const allocator_type& __a)
    : __pair1_(__node_allocator(__a)),
      __begin_node_(__node_pointer()),
      __pair3_(0)
{
    __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp,
                                           const allocator_type& __a)
    : __pair1_(__node_allocator(__a)),
      __begin_node_(__node_pointer()),
      __pair3_(0, __comp)
{
    __begin_node() = __end_node();
}


template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_pointer
__tree<_Tp, _Compare, _Allocator>::__detach()
{
    __node_pointer __cache = __begin_node();
    __begin_node() = __end_node();
    __end_node()->__left_->__parent_ = std::__1::__get_nullptr_t();
    __end_node()->__left_ = std::__1::__get_nullptr_t();
    size() = 0;

    if (__cache->__right_ != std::__1::__get_nullptr_t())
        __cache = static_cast<__node_pointer>(__cache->__right_);


    return __cache;
}





template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_pointer
__tree<_Tp, _Compare, _Allocator>::__detach(__node_pointer __cache)
{
    if (__cache->__parent_ == std::__1::__get_nullptr_t())
        return std::__1::__get_nullptr_t();
    if (__tree_is_left_child(static_cast<__node_base_pointer>(__cache)))
    {
        __cache->__parent_->__left_ = std::__1::__get_nullptr_t();
        __cache = static_cast<__node_pointer>(__cache->__parent_);
        if (__cache->__right_ == std::__1::__get_nullptr_t())
            return __cache;
        return static_cast<__node_pointer>(__tree_leaf(__cache->__right_));
    }

    __cache->__parent_->__right_ = std::__1::__get_nullptr_t();
    __cache = static_cast<__node_pointer>(__cache->__parent_);
    if (__cache->__left_ == std::__1::__get_nullptr_t())
        return __cache;
    return static_cast<__node_pointer>(__tree_leaf(__cache->__left_));
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>&
__tree<_Tp, _Compare, _Allocator>::operator=(const __tree& __t)
{
    if (this != &__t)
    {
        value_comp() = __t.value_comp();
        __copy_assign_alloc(__t);
        __assign_multi(__t.begin(), __t.end());
    }
    return *this;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _InputIterator>
void
__tree<_Tp, _Compare, _Allocator>::__assign_unique(_InputIterator __first, _InputIterator __last)
{
    if (size() != 0)
    {
        __node_pointer __cache = __detach();




            for (; __cache != std::__1::__get_nullptr_t() && __first != __last; ++__first)
            {
                __cache->__value_ = *__first;
                __node_pointer __next = __detach(__cache);
                __node_insert_unique(__cache);
                __cache = __next;
            }
# 1238 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__tree" 3
        if (__cache != std::__1::__get_nullptr_t())
        {
            while (__cache->__parent_ != std::__1::__get_nullptr_t())
                __cache = static_cast<__node_pointer>(__cache->__parent_);
            destroy(__cache);
        }
    }
    for (; __first != __last; ++__first)
        __insert_unique(*__first);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _InputIterator>
void
__tree<_Tp, _Compare, _Allocator>::__assign_multi(_InputIterator __first, _InputIterator __last)
{
    if (size() != 0)
    {
        __node_pointer __cache = __detach();




            for (; __cache != std::__1::__get_nullptr_t() && __first != __last; ++__first)
            {
                __cache->__value_ = *__first;
                __node_pointer __next = __detach(__cache);
                __node_insert_multi(__cache);
                __cache = __next;
            }
# 1278 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__tree" 3
        if (__cache != std::__1::__get_nullptr_t())
        {
            while (__cache->__parent_ != std::__1::__get_nullptr_t())
                __cache = static_cast<__node_pointer>(__cache->__parent_);
            destroy(__cache);
        }
    }
    for (; __first != __last; ++__first)
        __insert_multi(*__first);
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const __tree& __t)
    : __begin_node_(__node_pointer()),
      __pair1_(__node_traits::select_on_container_copy_construction(__t.__node_alloc())),
      __pair3_(0, __t.value_comp())
{
    __begin_node() = __end_node();
}
# 1430 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__tree" 3
template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::~__tree()
{
    destroy(__root());
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::destroy(__node_pointer __nd) throw()
{
    if (__nd != std::__1::__get_nullptr_t())
    {
        destroy(static_cast<__node_pointer>(__nd->__left_));
        destroy(static_cast<__node_pointer>(__nd->__right_));
        __node_allocator& __na = __node_alloc();
        __node_traits::destroy(__na, std::__1::addressof(__nd->__value_));
        __node_traits::deallocate(__na, __nd, 1);
    }
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::swap(__tree& __t)




{
    using std::__1::swap;
    swap(__begin_node_, __t.__begin_node_);
    swap(__pair1_.first(), __t.__pair1_.first());
    __swap_alloc(__node_alloc(), __t.__node_alloc());
    __pair3_.swap(__t.__pair3_);
    if (size() == 0)
        __begin_node() = __end_node();
    else
        __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());
    if (__t.size() == 0)
        __t.__begin_node() = __t.__end_node();
    else
        __t.__end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__t.__end_node());
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::clear() throw()
{
    destroy(__root());
    size() = 0;
    __begin_node() = __end_node();
    __end_node()->__left_ = std::__1::__get_nullptr_t();
}




template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&
__tree<_Tp, _Compare, _Allocator>::__find_leaf_low(typename __node_base::pointer& __parent,
                                                   const value_type& __v)
{
    __node_pointer __nd = __root();
    if (__nd != std::__1::__get_nullptr_t())
    {
        while (true)
        {
            if (value_comp()(__nd->__value_, __v))
            {
                if (__nd->__right_ != std::__1::__get_nullptr_t())
                    __nd = static_cast<__node_pointer>(__nd->__right_);
                else
                {
                    __parent = static_cast<__node_base_pointer>(__nd);
                    return __parent->__right_;
                }
            }
            else
            {
                if (__nd->__left_ != std::__1::__get_nullptr_t())
                    __nd = static_cast<__node_pointer>(__nd->__left_);
                else
                {
                    __parent = static_cast<__node_base_pointer>(__nd);
                    return __parent->__left_;
                }
            }
        }
    }
    __parent = static_cast<__node_base_pointer>(__end_node());
    return __parent->__left_;
}




template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&
__tree<_Tp, _Compare, _Allocator>::__find_leaf_high(typename __node_base::pointer& __parent,
                                                    const value_type& __v)
{
    __node_pointer __nd = __root();
    if (__nd != std::__1::__get_nullptr_t())
    {
        while (true)
        {
            if (value_comp()(__v, __nd->__value_))
            {
                if (__nd->__left_ != std::__1::__get_nullptr_t())
                    __nd = static_cast<__node_pointer>(__nd->__left_);
                else
                {
                    __parent = static_cast<__node_base_pointer>(__nd);
                    return __parent->__left_;
                }
            }
            else
            {
                if (__nd->__right_ != std::__1::__get_nullptr_t())
                    __nd = static_cast<__node_pointer>(__nd->__right_);
                else
                {
                    __parent = static_cast<__node_base_pointer>(__nd);
                    return __parent->__right_;
                }
            }
        }
    }
    __parent = static_cast<__node_base_pointer>(__end_node());
    return __parent->__left_;
}







template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&
__tree<_Tp, _Compare, _Allocator>::__find_leaf(const_iterator __hint,
                                               typename __node_base::pointer& __parent,
                                               const value_type& __v)
{
    if (__hint == end() || !value_comp()(*__hint, __v))
    {

        const_iterator __prior = __hint;
        if (__prior == begin() || !value_comp()(__v, *--__prior))
        {

            if (__hint.__ptr_->__left_ == std::__1::__get_nullptr_t())
            {
                __parent = static_cast<__node_base_pointer>(__hint.__ptr_);
                return __parent->__left_;
            }
            else
            {
                __parent = static_cast<__node_base_pointer>(__prior.__ptr_);
                return __parent->__right_;
            }
        }

        return __find_leaf_high(__parent, __v);
    }

    return __find_leaf_low(__parent, __v);
}





template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&
__tree<_Tp, _Compare, _Allocator>::__find_equal(typename __node_base::pointer& __parent,
                                                const _Key& __v)
{
    __node_pointer __nd = __root();
    if (__nd != std::__1::__get_nullptr_t())
    {
        while (true)
        {
            if (value_comp()(__v, __nd->__value_))
            {
                if (__nd->__left_ != std::__1::__get_nullptr_t())
                    __nd = static_cast<__node_pointer>(__nd->__left_);
                else
                {
                    __parent = static_cast<__node_base_pointer>(__nd);
                    return __parent->__left_;
                }
            }
            else if (value_comp()(__nd->__value_, __v))
            {
                if (__nd->__right_ != std::__1::__get_nullptr_t())
                    __nd = static_cast<__node_pointer>(__nd->__right_);
                else
                {
                    __parent = static_cast<__node_base_pointer>(__nd);
                    return __parent->__right_;
                }
            }
            else
            {
                __parent = static_cast<__node_base_pointer>(__nd);
                return __parent;
            }
        }
    }
    __parent = static_cast<__node_base_pointer>(__end_node());
    return __parent->__left_;
}
# 1651 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__tree" 3
template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&
__tree<_Tp, _Compare, _Allocator>::__find_equal(const_iterator __hint,
                                                typename __node_base::pointer& __parent,
                                                const _Key& __v)
{
    if (__hint == end() || value_comp()(__v, *__hint))
    {

        const_iterator __prior = __hint;
        if (__prior == begin() || value_comp()(*--__prior, __v))
        {

            if (__hint.__ptr_->__left_ == std::__1::__get_nullptr_t())
            {
                __parent = static_cast<__node_base_pointer>(__hint.__ptr_);
                return __parent->__left_;
            }
            else
            {
                __parent = static_cast<__node_base_pointer>(__prior.__ptr_);
                return __parent->__right_;
            }
        }

        return __find_equal(__parent, __v);
    }
    else if (value_comp()(*__hint, __v))
    {

        const_iterator __next = std::__1::next(__hint);
        if (__next == end() || value_comp()(__v, *__next))
        {

            if (__hint.__ptr_->__right_ == std::__1::__get_nullptr_t())
            {
                __parent = static_cast<__node_base_pointer>(__hint.__ptr_);
                return __parent->__right_;
            }
            else
            {
                __parent = static_cast<__node_base_pointer>(__next.__ptr_);
                return __parent->__left_;
            }
        }

        return __find_equal(__parent, __v);
    }

    __parent = static_cast<__node_base_pointer>(__hint.__ptr_);
    return __parent;
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::__insert_node_at(__node_base_pointer __parent,
                                                    __node_base_pointer& __child,
                                                    __node_base_pointer __new_node)
{
    __new_node->__left_ = std::__1::__get_nullptr_t();
    __new_node->__right_ = std::__1::__get_nullptr_t();
    __new_node->__parent_ = __parent;
    __child = __new_node;
    if (__begin_node()->__left_ != std::__1::__get_nullptr_t())
        __begin_node() = static_cast<__node_pointer>(__begin_node()->__left_);
    __tree_balance_after_insert(__end_node()->__left_, __child);
    ++size();
}
# 1849 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__tree" 3
template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_holder
__tree<_Tp, _Compare, _Allocator>::__construct_node(const value_type& __v)
{
    __node_allocator& __na = __node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
    __node_traits::construct(__na, std::__1::addressof(__h->__value_), __v);
    __h.get_deleter().__value_constructed = true;
    return std::__1::move(__h);
}



template <class _Tp, class _Compare, class _Allocator>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__insert_unique(const value_type& __v)
{
    __node_base_pointer __parent;
    __node_base_pointer& __child = __find_equal(__parent, __v);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    bool __inserted = false;
    if (__child == std::__1::__get_nullptr_t())
    {
        __node_holder __h = __construct_node(__v);
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
        __r = __h.release();
        __inserted = true;
    }
    return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__insert_unique(const_iterator __p, const value_type& __v)
{
    __node_base_pointer __parent;
    __node_base_pointer& __child = __find_equal(__p, __parent, __v);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    if (__child == std::__1::__get_nullptr_t())
    {
        __node_holder __h = __construct_node(__v);
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
        __r = __h.release();
    }
    return iterator(__r);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__insert_multi(const value_type& __v)
{
    __node_base_pointer __parent;
    __node_base_pointer& __child = __find_leaf_high(__parent, __v);
    __node_holder __h = __construct_node(__v);
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
    return iterator(__h.release());
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__insert_multi(const_iterator __p, const value_type& __v)
{
    __node_base_pointer __parent;
    __node_base_pointer& __child = __find_leaf(__p, __parent, __v);
    __node_holder __h = __construct_node(__v);
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
    return iterator(__h.release());
}

template <class _Tp, class _Compare, class _Allocator>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__node_insert_unique(__node_pointer __nd)
{
    __node_base_pointer __parent;
    __node_base_pointer& __child = __find_equal(__parent, __nd->__value_);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    bool __inserted = false;
    if (__child == std::__1::__get_nullptr_t())
    {
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
        __r = __nd;
        __inserted = true;
    }
    return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_insert_unique(const_iterator __p,
                                                        __node_pointer __nd)
{
    __node_base_pointer __parent;
    __node_base_pointer& __child = __find_equal(__p, __parent, __nd->__value_);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    if (__child == std::__1::__get_nullptr_t())
    {
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
        __r = __nd;
    }
    return iterator(__r);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(__node_pointer __nd)
{
    __node_base_pointer __parent;
    __node_base_pointer& __child = __find_leaf_high(__parent, __nd->__value_);
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
    return iterator(__nd);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(const_iterator __p,
                                                       __node_pointer __nd)
{
    __node_base_pointer __parent;
    __node_base_pointer& __child = __find_leaf(__p, __parent, __nd->__value_);
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
    return iterator(__nd);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __p)
{
    __node_pointer __np = __p.__ptr_;
    iterator __r(__np);
    ++__r;
    if (__begin_node() == __np)
        __begin_node() = __r.__ptr_;
    --size();
    __node_allocator& __na = __node_alloc();
    __tree_remove(__end_node()->__left_,
                  static_cast<__node_base_pointer>(__np));
    __node_traits::destroy(__na, const_cast<value_type*>(std::__1::addressof(*__p)));
    __node_traits::deallocate(__na, __np, 1);
    return __r;
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __f, const_iterator __l)
{
    while (__f != __l)
        __f = erase(__f);
    return iterator(__l.__ptr_);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__erase_unique(const _Key& __k)
{
    iterator __i = find(__k);
    if (__i == end())
        return 0;
    erase(__i);
    return 1;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__erase_multi(const _Key& __k)
{
    pair<iterator, iterator> __p = __equal_range_multi(__k);
    size_type __r = 0;
    for (; __p.first != __p.second; ++__r)
        __p.first = erase(__p.first);
    return __r;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v)
{
    iterator __p = __lower_bound(__v, __root(), __end_node());
    if (__p != end() && !value_comp()(__v, *__p))
        return __p;
    return end();
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v) const
{
    const_iterator __p = __lower_bound(__v, __root(), __end_node());
    if (__p != end() && !value_comp()(__v, *__p))
        return __p;
    return end();
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__count_unique(const _Key& __k) const
{
    __node_const_pointer __result = __end_node();
    __node_const_pointer __rt = __root();
    while (__rt != std::__1::__get_nullptr_t())
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = __rt;
            __rt = static_cast<__node_const_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_const_pointer>(__rt->__right_);
        else
            return 1;
    }
    return 0;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__count_multi(const _Key& __k) const
{
    typedef pair<const_iterator, const_iterator> _Pp;
    __node_const_pointer __result = __end_node();
    __node_const_pointer __rt = __root();
    while (__rt != std::__1::__get_nullptr_t())
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = __rt;
            __rt = static_cast<__node_const_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_const_pointer>(__rt->__right_);
        else
            return std::__1::distance(
                __lower_bound(__k, static_cast<__node_const_pointer>(__rt->__left_), __rt),
                __upper_bound(__k, static_cast<__node_const_pointer>(__rt->__right_), __result)
            );
    }
    return 0;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,
                                                 __node_pointer __root,
                                                 __node_pointer __result)
{
    while (__root != std::__1::__get_nullptr_t())
    {
        if (!value_comp()(__root->__value_, __v))
        {
            __result = __root;
            __root = static_cast<__node_pointer>(__root->__left_);
        }
        else
            __root = static_cast<__node_pointer>(__root->__right_);
    }
    return iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,
                                                 __node_const_pointer __root,
                                                 __node_const_pointer __result) const
{
    while (__root != std::__1::__get_nullptr_t())
    {
        if (!value_comp()(__root->__value_, __v))
        {
            __result = __root;
            __root = static_cast<__node_const_pointer>(__root->__left_);
        }
        else
            __root = static_cast<__node_const_pointer>(__root->__right_);
    }
    return const_iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,
                                                 __node_pointer __root,
                                                 __node_pointer __result)
{
    while (__root != std::__1::__get_nullptr_t())
    {
        if (value_comp()(__v, __root->__value_))
        {
            __result = __root;
            __root = static_cast<__node_pointer>(__root->__left_);
        }
        else
            __root = static_cast<__node_pointer>(__root->__right_);
    }
    return iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,
                                                 __node_const_pointer __root,
                                                 __node_const_pointer __result) const
{
    while (__root != std::__1::__get_nullptr_t())
    {
        if (value_comp()(__v, __root->__value_))
        {
            __result = __root;
            __root = static_cast<__node_const_pointer>(__root->__left_);
        }
        else
            __root = static_cast<__node_const_pointer>(__root->__right_);
    }
    return const_iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator,
     typename __tree<_Tp, _Compare, _Allocator>::iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k)
{
    typedef pair<iterator, iterator> _Pp;
    __node_pointer __result = __end_node();
    __node_pointer __rt = __root();
    while (__rt != std::__1::__get_nullptr_t())
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = __rt;
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return _Pp(iterator(__rt),
                      iterator(
                          __rt->__right_ != std::__1::__get_nullptr_t() ?
                              static_cast<__node_pointer>(__tree_min(__rt->__right_))
                            : __result));
    }
    return _Pp(iterator(__result), iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,
     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k) const
{
    typedef pair<const_iterator, const_iterator> _Pp;
    __node_const_pointer __result = __end_node();
    __node_const_pointer __rt = __root();
    while (__rt != std::__1::__get_nullptr_t())
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = __rt;
            __rt = static_cast<__node_const_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_const_pointer>(__rt->__right_);
        else
            return _Pp(const_iterator(__rt),
                      const_iterator(
                          __rt->__right_ != std::__1::__get_nullptr_t() ?
                              static_cast<__node_const_pointer>(__tree_min(__rt->__right_))
                            : __result));
    }
    return _Pp(const_iterator(__result), const_iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator,
     typename __tree<_Tp, _Compare, _Allocator>::iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k)
{
    typedef pair<iterator, iterator> _Pp;
    __node_pointer __result = __end_node();
    __node_pointer __rt = __root();
    while (__rt != std::__1::__get_nullptr_t())
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = __rt;
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), __rt),
                      __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));
    }
    return _Pp(iterator(__result), iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,
     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k) const
{
    typedef pair<const_iterator, const_iterator> _Pp;
    __node_const_pointer __result = __end_node();
    __node_const_pointer __rt = __root();
    while (__rt != std::__1::__get_nullptr_t())
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = __rt;
            __rt = static_cast<__node_const_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_const_pointer>(__rt->__right_);
        else
            return _Pp(__lower_bound(__k, static_cast<__node_const_pointer>(__rt->__left_), __rt),
                      __upper_bound(__k, static_cast<__node_const_pointer>(__rt->__right_), __result));
    }
    return _Pp(const_iterator(__result), const_iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_holder
__tree<_Tp, _Compare, _Allocator>::remove(const_iterator __p) throw()
{
    __node_pointer __np = __p.__ptr_;
    if (__begin_node() == __np)
    {
        if (__np->__right_ != std::__1::__get_nullptr_t())
            __begin_node() = static_cast<__node_pointer>(__np->__right_);
        else
            __begin_node() = static_cast<__node_pointer>(__np->__parent_);
    }
    --size();
    __tree_remove(__end_node()->__left_,
                  static_cast<__node_base_pointer>(__np));
    return __node_holder(__np, _Dp(__node_alloc()));
}

template <class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(__tree<_Tp, _Compare, _Allocator>& __x,
     __tree<_Tp, _Compare, _Allocator>& __y)

{
    __x.swap(__y);
}

} }
# 424 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 2 3



# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/functional" 1 3
# 484 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/functional" 3


namespace std {inline namespace __1 {




template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) plus : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x + __y;}
};
# 516 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) minus : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x - __y;}
};
# 541 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) multiplies : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x * __y;}
};
# 566 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) divides : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x / __y;}
};
# 591 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) modulus : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x % __y;}
};
# 616 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) negate : unary_function<_Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x) const
        {return -__x;}
};
# 641 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) equal_to : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x == __y;}
};
# 666 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) not_equal_to : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x != __y;}
};
# 691 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) greater : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x > __y;}
};
# 718 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) greater_equal : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x >= __y;}
};
# 743 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) less_equal : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x <= __y;}
};
# 768 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) logical_and : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x && __y;}
};
# 793 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) logical_or : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x || __y;}
};
# 818 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) logical_not : unary_function<_Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x) const
        {return !__x;}
};
# 843 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) bit_and : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x & __y;}
};
# 868 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) bit_or : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x | __y;}
};
# 893 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) bit_xor : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x ^ __y;}
};
# 935 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/functional" 3
template <class _Predicate>
class __attribute__ ((__type_visibility__("default"))) unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
{
    _Predicate __pred_;
public:
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit unary_negate(const _Predicate& __pred)
        : __pred_(__pred) {}
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const typename _Predicate::argument_type& __x) const
        {return !__pred_(__x);}
};

template <class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unary_negate<_Predicate>
not1(const _Predicate& __pred) {return unary_negate<_Predicate>(__pred);}

template <class _Predicate>
class __attribute__ ((__type_visibility__("default"))) binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
                             typename _Predicate::second_argument_type,
                             bool>
{
    _Predicate __pred_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit
    binary_negate(const _Predicate& __pred) : __pred_(__pred) {}

                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const typename _Predicate::first_argument_type& __x,
                    const typename _Predicate::second_argument_type& __y) const
        {return !__pred_(__x, __y);}
};

template <class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
binary_negate<_Predicate>
not2(const _Predicate& __pred) {return binary_negate<_Predicate>(__pred);}

template <class __Operation>
class __attribute__ ((__type_visibility__("default"))) binder1st
    : public unary_function<typename __Operation::second_argument_type,
                            typename __Operation::result_type>
{
protected:
    __Operation op;
    typename __Operation::first_argument_type value;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) binder1st(const __Operation& __x,
                               const typename __Operation::first_argument_type __y)
        : op(__x), value(__y) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename __Operation::result_type operator()
        (typename __Operation::second_argument_type& __x) const
            {return op(value, __x);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename __Operation::result_type operator()
        (const typename __Operation::second_argument_type& __x) const
            {return op(value, __x);}
};

template <class __Operation, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
binder1st<__Operation>
bind1st(const __Operation& __op, const _Tp& __x)
    {return binder1st<__Operation>(__op, __x);}

template <class __Operation>
class __attribute__ ((__type_visibility__("default"))) binder2nd
    : public unary_function<typename __Operation::first_argument_type,
                            typename __Operation::result_type>
{
protected:
    __Operation op;
    typename __Operation::second_argument_type value;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    binder2nd(const __Operation& __x, const typename __Operation::second_argument_type __y)
        : op(__x), value(__y) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename __Operation::result_type operator()
        ( typename __Operation::first_argument_type& __x) const
            {return op(__x, value);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename __Operation::result_type operator()
        (const typename __Operation::first_argument_type& __x) const
            {return op(__x, value);}
};

template <class __Operation, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
binder2nd<__Operation>
bind2nd(const __Operation& __op, const _Tp& __x)
    {return binder2nd<__Operation>(__op, __x);}

template <class _Arg, class _Result>
class __attribute__ ((__type_visibility__("default"))) pointer_to_unary_function
    : public unary_function<_Arg, _Result>
{
    _Result (*__f_)(_Arg);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit pointer_to_unary_function(_Result (*__f)(_Arg))
        : __f_(__f) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Result operator()(_Arg __x) const
        {return __f_(__x);}
};

template <class _Arg, class _Result>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pointer_to_unary_function<_Arg,_Result>
ptr_fun(_Result (*__f)(_Arg))
    {return pointer_to_unary_function<_Arg,_Result>(__f);}

template <class _Arg1, class _Arg2, class _Result>
class __attribute__ ((__type_visibility__("default"))) pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
{
    _Result (*__f_)(_Arg1, _Arg2);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit pointer_to_binary_function(_Result (*__f)(_Arg1, _Arg2))
        : __f_(__f) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Result operator()(_Arg1 __x, _Arg2 __y) const
        {return __f_(__x, __y);}
};

template <class _Arg1, class _Arg2, class _Result>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pointer_to_binary_function<_Arg1,_Arg2,_Result>
ptr_fun(_Result (*__f)(_Arg1,_Arg2))
    {return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__f);}

template<class _Sp, class _Tp>
class __attribute__ ((__type_visibility__("default"))) mem_fun_t : public unary_function<_Tp*, _Sp>
{
    _Sp (_Tp::*__p_)();
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit mem_fun_t(_Sp (_Tp::*__p)())
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(_Tp* __p) const
        {return (__p->*__p_)();}
};

template<class _Sp, class _Tp, class _Ap>
class __attribute__ ((__type_visibility__("default"))) mem_fun1_t : public binary_function<_Tp*, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit mem_fun1_t(_Sp (_Tp::*__p)(_Ap))
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(_Tp* __p, _Ap __x) const
        {return (__p->*__p_)(__x);}
};

template<class _Sp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
mem_fun_t<_Sp,_Tp>
mem_fun(_Sp (_Tp::*__f)())
    {return mem_fun_t<_Sp,_Tp>(__f);}

template<class _Sp, class _Tp, class _Ap>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
mem_fun1_t<_Sp,_Tp,_Ap>
mem_fun(_Sp (_Tp::*__f)(_Ap))
    {return mem_fun1_t<_Sp,_Tp,_Ap>(__f);}

template<class _Sp, class _Tp>
class __attribute__ ((__type_visibility__("default"))) mem_fun_ref_t : public unary_function<_Tp, _Sp>
{
    _Sp (_Tp::*__p_)();
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit mem_fun_ref_t(_Sp (_Tp::*__p)())
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(_Tp& __p) const
        {return (__p.*__p_)();}
};

template<class _Sp, class _Tp, class _Ap>
class __attribute__ ((__type_visibility__("default"))) mem_fun1_ref_t : public binary_function<_Tp, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap))
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(_Tp& __p, _Ap __x) const
        {return (__p.*__p_)(__x);}
};

template<class _Sp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
mem_fun_ref_t<_Sp,_Tp>
mem_fun_ref(_Sp (_Tp::*__f)())
    {return mem_fun_ref_t<_Sp,_Tp>(__f);}

template<class _Sp, class _Tp, class _Ap>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
mem_fun1_ref_t<_Sp,_Tp,_Ap>
mem_fun_ref(_Sp (_Tp::*__f)(_Ap))
    {return mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}

template <class _Sp, class _Tp>
class __attribute__ ((__type_visibility__("default"))) const_mem_fun_t : public unary_function<const _Tp*, _Sp>
{
    _Sp (_Tp::*__p_)() const;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit const_mem_fun_t(_Sp (_Tp::*__p)() const)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(const _Tp* __p) const
        {return (__p->*__p_)();}
};

template <class _Sp, class _Tp, class _Ap>
class __attribute__ ((__type_visibility__("default"))) const_mem_fun1_t : public binary_function<const _Tp*, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap) const;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit const_mem_fun1_t(_Sp (_Tp::*__p)(_Ap) const)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(const _Tp* __p, _Ap __x) const
        {return (__p->*__p_)(__x);}
};

template <class _Sp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const_mem_fun_t<_Sp,_Tp>
mem_fun(_Sp (_Tp::*__f)() const)
    {return const_mem_fun_t<_Sp,_Tp>(__f);}

template <class _Sp, class _Tp, class _Ap>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const_mem_fun1_t<_Sp,_Tp,_Ap>
mem_fun(_Sp (_Tp::*__f)(_Ap) const)
    {return const_mem_fun1_t<_Sp,_Tp,_Ap>(__f);}

template <class _Sp, class _Tp>
class __attribute__ ((__type_visibility__("default"))) const_mem_fun_ref_t : public unary_function<_Tp, _Sp>
{
    _Sp (_Tp::*__p_)() const;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit const_mem_fun_ref_t(_Sp (_Tp::*__p)() const)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(const _Tp& __p) const
        {return (__p.*__p_)();}
};

template <class _Sp, class _Tp, class _Ap>
class __attribute__ ((__type_visibility__("default"))) const_mem_fun1_ref_t
    : public binary_function<_Tp, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap) const;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit const_mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap) const)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(const _Tp& __p, _Ap __x) const
        {return (__p.*__p_)(__x);}
};

template <class _Sp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const_mem_fun_ref_t<_Sp,_Tp>
mem_fun_ref(_Sp (_Tp::*__f)() const)
    {return const_mem_fun_ref_t<_Sp,_Tp>(__f);}

template <class _Sp, class _Tp, class _Ap>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const_mem_fun1_ref_t<_Sp,_Tp,_Ap>
mem_fun_ref(_Sp (_Tp::*__f)(_Ap) const)
    {return const_mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}




# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__functional_03" 1 3
# 18 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__functional_03" 3


template <class _Tp>
class __mem_fn
    : public __weak_result_type<_Tp>
{
public:

    typedef _Tp type;
private:
    type __f_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __mem_fn(type __f) : __f_(__f) {}



    typename __invoke_return<type>::type
       operator() () const
       {
           return __invoke(__f_);
       }

    template <class _A0>
       typename __invoke_return0<type, _A0>::type
          operator() (_A0& __a0) const
          {
              return __invoke(__f_, __a0);
          }

    template <class _A0, class _A1>
       typename __invoke_return1<type, _A0, _A1>::type
          operator() (_A0& __a0, _A1& __a1) const
          {
              return __invoke(__f_, __a0, __a1);
          }

    template <class _A0, class _A1, class _A2>
       typename __invoke_return2<type, _A0, _A1, _A2>::type
          operator() (_A0& __a0, _A1& __a1, _A2& __a2) const
          {
              return __invoke(__f_, __a0, __a1, __a2);
          }
};

template<class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp _Tp::*>
mem_fn(_Rp _Tp::* __pm)
{
    return __mem_fn<_Rp _Tp::*>(__pm);
}

template<class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)()>
mem_fn(_Rp (_Tp::* __pm)())
{
    return __mem_fn<_Rp (_Tp::*)()>(__pm);
}

template<class _Rp, class _Tp, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0)>
mem_fn(_Rp (_Tp::* __pm)(_A0))
{
    return __mem_fn<_Rp (_Tp::*)(_A0)>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1)>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1))
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1)>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2)>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1, _A2))
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2)>(__pm);
}

template<class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)() const>
mem_fn(_Rp (_Tp::* __pm)() const)
{
    return __mem_fn<_Rp (_Tp::*)() const>(__pm);
}

template<class _Rp, class _Tp, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0) const>
mem_fn(_Rp (_Tp::* __pm)(_A0) const)
{
    return __mem_fn<_Rp (_Tp::*)(_A0) const>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1) const>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1) const)
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1) const>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2) const>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1, _A2) const)
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2) const>(__pm);
}

template<class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)() volatile>
mem_fn(_Rp (_Tp::* __pm)() volatile)
{
    return __mem_fn<_Rp (_Tp::*)() volatile>(__pm);
}

template<class _Rp, class _Tp, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0) volatile>
mem_fn(_Rp (_Tp::* __pm)(_A0) volatile)
{
    return __mem_fn<_Rp (_Tp::*)(_A0) volatile>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1) volatile>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1) volatile)
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1) volatile>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2) volatile>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1, _A2) volatile)
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2) volatile>(__pm);
}

template<class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)() const volatile>
mem_fn(_Rp (_Tp::* __pm)() const volatile)
{
    return __mem_fn<_Rp (_Tp::*)() const volatile>(__pm);
}

template<class _Rp, class _Tp, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0) const volatile>
mem_fn(_Rp (_Tp::* __pm)(_A0) const volatile)
{
    return __mem_fn<_Rp (_Tp::*)(_A0) const volatile>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1) const volatile>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1) const volatile)
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1) const volatile>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2) const volatile>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1, _A2) const volatile)
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2) const volatile>(__pm);
}



class __attribute__ ((__visibility__("default"))) bad_function_call
    : public exception
{
};

template<class _Fp> class __attribute__ ((__type_visibility__("default"))) function;

namespace __function
{

template<class _Fp>
struct __maybe_derive_from_unary_function
{
};

template<class _Rp, class _A1>
struct __maybe_derive_from_unary_function<_Rp(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template<class _Fp>
struct __maybe_derive_from_binary_function
{
};

template<class _Rp, class _A1, class _A2>
struct __maybe_derive_from_binary_function<_Rp(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template<class _Fp> class __base;

template<class _Rp>
class __base<_Rp()>
{
    __base(const __base&);
    __base& operator=(const __base&);
public:
    __base() {}
    virtual ~__base() {}
    virtual __base* __clone() const = 0;
    virtual void __clone(__base*) const = 0;
    virtual void destroy() = 0;
    virtual void destroy_deallocate() = 0;
    virtual _Rp operator()() = 0;




};

template<class _Rp, class _A0>
class __base<_Rp(_A0)>
{
    __base(const __base&);
    __base& operator=(const __base&);
public:
    __base() {}
    virtual ~__base() {}
    virtual __base* __clone() const = 0;
    virtual void __clone(__base*) const = 0;
    virtual void destroy() = 0;
    virtual void destroy_deallocate() = 0;
    virtual _Rp operator()(_A0) = 0;




};

template<class _Rp, class _A0, class _A1>
class __base<_Rp(_A0, _A1)>
{
    __base(const __base&);
    __base& operator=(const __base&);
public:
    __base() {}
    virtual ~__base() {}
    virtual __base* __clone() const = 0;
    virtual void __clone(__base*) const = 0;
    virtual void destroy() = 0;
    virtual void destroy_deallocate() = 0;
    virtual _Rp operator()(_A0, _A1) = 0;




};

template<class _Rp, class _A0, class _A1, class _A2>
class __base<_Rp(_A0, _A1, _A2)>
{
    __base(const __base&);
    __base& operator=(const __base&);
public:
    __base() {}
    virtual ~__base() {}
    virtual __base* __clone() const = 0;
    virtual void __clone(__base*) const = 0;
    virtual void destroy() = 0;
    virtual void destroy_deallocate() = 0;
    virtual _Rp operator()(_A0, _A1, _A2) = 0;




};

template<class _FD, class _Alloc, class _FB> class __func;

template<class _Fp, class _Alloc, class _Rp>
class __func<_Fp, _Alloc, _Rp()>
    : public __base<_Rp()>
{
    __compressed_pair<_Fp, _Alloc> __f_;
public:
    explicit __func(_Fp __f) : __f_(std::__1::move(__f)) {}
    explicit __func(_Fp __f, _Alloc __a) : __f_(std::__1::move(__f), std::__1::move(__a)) {}
    virtual __base<_Rp()>* __clone() const;
    virtual void __clone(__base<_Rp()>*) const;
    virtual void destroy();
    virtual void destroy_deallocate();
    virtual _Rp operator()();




};

template<class _Fp, class _Alloc, class _Rp>
__base<_Rp()>*
__func<_Fp, _Alloc, _Rp()>::__clone() const
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    typedef __allocator_destructor<_Ap> _Dp;
    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));
    return __hold.release();
}

template<class _Fp, class _Alloc, class _Rp>
void
__func<_Fp, _Alloc, _Rp()>::__clone(__base<_Rp()>* __p) const
{
    ::new (__p) __func(__f_.first(), __f_.second());
}

template<class _Fp, class _Alloc, class _Rp>
void
__func<_Fp, _Alloc, _Rp()>::destroy()
{
    __f_.~__compressed_pair<_Fp, _Alloc>();
}

template<class _Fp, class _Alloc, class _Rp>
void
__func<_Fp, _Alloc, _Rp()>::destroy_deallocate()
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    __f_.~__compressed_pair<_Fp, _Alloc>();
    __a.deallocate(this, 1);
}

template<class _Fp, class _Alloc, class _Rp>
_Rp
__func<_Fp, _Alloc, _Rp()>::operator()()
{
    return __invoke(__f_.first());
}
# 395 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__functional_03" 3
template<class _Fp, class _Alloc, class _Rp, class _A0>
class __func<_Fp, _Alloc, _Rp(_A0)>
    : public __base<_Rp(_A0)>
{
    __compressed_pair<_Fp, _Alloc> __f_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __func(_Fp __f) : __f_(std::__1::move(__f)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __func(_Fp __f, _Alloc __a)
        : __f_(std::__1::move(__f), std::__1::move(__a)) {}
    virtual __base<_Rp(_A0)>* __clone() const;
    virtual void __clone(__base<_Rp(_A0)>*) const;
    virtual void destroy();
    virtual void destroy_deallocate();
    virtual _Rp operator()(_A0);




};

template<class _Fp, class _Alloc, class _Rp, class _A0>
__base<_Rp(_A0)>*
__func<_Fp, _Alloc, _Rp(_A0)>::__clone() const
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    typedef __allocator_destructor<_Ap> _Dp;
    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));
    return __hold.release();
}

template<class _Fp, class _Alloc, class _Rp, class _A0>
void
__func<_Fp, _Alloc, _Rp(_A0)>::__clone(__base<_Rp(_A0)>* __p) const
{
    ::new (__p) __func(__f_.first(), __f_.second());
}

template<class _Fp, class _Alloc, class _Rp, class _A0>
void
__func<_Fp, _Alloc, _Rp(_A0)>::destroy()
{
    __f_.~__compressed_pair<_Fp, _Alloc>();
}

template<class _Fp, class _Alloc, class _Rp, class _A0>
void
__func<_Fp, _Alloc, _Rp(_A0)>::destroy_deallocate()
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    __f_.~__compressed_pair<_Fp, _Alloc>();
    __a.deallocate(this, 1);
}

template<class _Fp, class _Alloc, class _Rp, class _A0>
_Rp
__func<_Fp, _Alloc, _Rp(_A0)>::operator()(_A0 __a0)
{
    return __invoke(__f_.first(), __a0);
}
# 478 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__functional_03" 3
template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
class __func<_Fp, _Alloc, _Rp(_A0, _A1)>
    : public __base<_Rp(_A0, _A1)>
{
    __compressed_pair<_Fp, _Alloc> __f_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __func(_Fp __f) : __f_(std::__1::move(__f)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __func(_Fp __f, _Alloc __a)
        : __f_(std::__1::move(__f), std::__1::move(__a)) {}
    virtual __base<_Rp(_A0, _A1)>* __clone() const;
    virtual void __clone(__base<_Rp(_A0, _A1)>*) const;
    virtual void destroy();
    virtual void destroy_deallocate();
    virtual _Rp operator()(_A0, _A1);




};

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
__base<_Rp(_A0, _A1)>*
__func<_Fp, _Alloc, _Rp(_A0, _A1)>::__clone() const
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    typedef __allocator_destructor<_Ap> _Dp;
    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));
    return __hold.release();
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
void
__func<_Fp, _Alloc, _Rp(_A0, _A1)>::__clone(__base<_Rp(_A0, _A1)>* __p) const
{
    ::new (__p) __func(__f_.first(), __f_.second());
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
void
__func<_Fp, _Alloc, _Rp(_A0, _A1)>::destroy()
{
    __f_.~__compressed_pair<_Fp, _Alloc>();
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
void
__func<_Fp, _Alloc, _Rp(_A0, _A1)>::destroy_deallocate()
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    __f_.~__compressed_pair<_Fp, _Alloc>();
    __a.deallocate(this, 1);
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
_Rp
__func<_Fp, _Alloc, _Rp(_A0, _A1)>::operator()(_A0 __a0, _A1 __a1)
{
    return __invoke(__f_.first(), __a0, __a1);
}
# 561 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__functional_03" 3
template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
class __func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>
    : public __base<_Rp(_A0, _A1, _A2)>
{
    __compressed_pair<_Fp, _Alloc> __f_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __func(_Fp __f) : __f_(std::__1::move(__f)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __func(_Fp __f, _Alloc __a)
        : __f_(std::__1::move(__f), std::__1::move(__a)) {}
    virtual __base<_Rp(_A0, _A1, _A2)>* __clone() const;
    virtual void __clone(__base<_Rp(_A0, _A1, _A2)>*) const;
    virtual void destroy();
    virtual void destroy_deallocate();
    virtual _Rp operator()(_A0, _A1, _A2);




};

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
__base<_Rp(_A0, _A1, _A2)>*
__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>::__clone() const
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    typedef __allocator_destructor<_Ap> _Dp;
    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));
    return __hold.release();
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
void
__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>::__clone(__base<_Rp(_A0, _A1, _A2)>* __p) const
{
    ::new (__p) __func(__f_.first(), __f_.second());
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
void
__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>::destroy()
{
    __f_.~__compressed_pair<_Fp, _Alloc>();
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
void
__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>::destroy_deallocate()
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    __f_.~__compressed_pair<_Fp, _Alloc>();
    __a.deallocate(this, 1);
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
_Rp
__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>::operator()(_A0 __a0, _A1 __a1, _A2 __a2)
{
    return __invoke(__f_.first(), __a0, __a1, __a2);
}
# 644 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__functional_03" 3
}

template<class _Rp>
class __attribute__ ((__type_visibility__("default"))) function<_Rp()>
{
    typedef __function::__base<_Rp()> __base;
    aligned_storage<3*sizeof(void*)>::type __buf_;
    __base* __f_;

    template <class _Fp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const _Fp&) {return true;}
    template <class _R2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (*__p)()) {return __p;}
    template <class _R2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const function<_R2()>& __p) {return __p;}
public:
    typedef _Rp result_type;


    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit function() : __f_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) function(nullptr_t) : __f_(0) {}
    function(const function&);
    template<class _Fp>
      function(_Fp,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&) : __f_(0) {}
    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&, nullptr_t) : __f_(0) {}
    template<class _Alloc>
      function(allocator_arg_t, const _Alloc&, const function&);
    template<class _Fp, class _Alloc>
      function(allocator_arg_t, const _Alloc& __a, _Fp __f,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    function& operator=(const function&);
    function& operator=(nullptr_t);
    template<class _Fp>
      typename enable_if
      <
        !is_integral<_Fp>::value,
        function&
      >::type
      operator=(_Fp);

    ~function();


    void swap(function&);
    template<class _Fp, class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      void assign(_Fp __f, const _Alloc& __a)
        {function(allocator_arg, __a, __f).swap(*this);}


    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator bool() const {return __f_;}

private:

    template<class _R2>
      bool operator==(const function<_R2()>&) const;
    template<class _R2>
      bool operator!=(const function<_R2()>&) const;
public:

    _Rp operator()() const;







};

template<class _Rp>
function<_Rp()>::function(const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp>
template<class _Alloc>
function<_Rp()>::function(allocator_arg_t, const _Alloc&, const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp>
template <class _Fp>
function<_Rp()>::function(_Fp __f,
                                     typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, allocator<_Fp>, _Rp()> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef allocator<_FF> _Ap;
            _Ap __a;
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, allocator<_Fp>(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp>
template <class _Fp, class _Alloc>
function<_Rp()>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f,
                                     typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, _Alloc, _Rp()> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef typename __alloc_traits::template



                rebind_alloc<_FF>::other

                                                         _Ap;
            _Ap __a(__a0);
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, _Alloc(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp>
function<_Rp()>&
function<_Rp()>::operator=(const function& __f)
{
    function(__f).swap(*this);
    return *this;
}

template<class _Rp>
function<_Rp()>&
function<_Rp()>::operator=(nullptr_t)
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
    __f_ = 0;
}

template<class _Rp>
template <class _Fp>
typename enable_if
<
    !is_integral<_Fp>::value,
    function<_Rp()>&
>::type
function<_Rp()>::operator=(_Fp __f)
{
    function(std::__1::move(__f)).swap(*this);
    return *this;
}

template<class _Rp>
function<_Rp()>::~function()
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
}

template<class _Rp>
void
function<_Rp()>::swap(function& __f)
{
    if (__f_ == (__base*)&__buf_ && __f.__f_ == (__base*)&__f.__buf_)
    {
        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
        __base* __t = (__base*)&__tempbuf;
        __f_->__clone(__t);
        __f_->destroy();
        __f_ = 0;
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = 0;
        __f_ = (__base*)&__buf_;
        __t->__clone((__base*)&__f.__buf_);
        __t->destroy();
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f_ == (__base*)&__buf_)
    {
        __f_->__clone((__base*)&__f.__buf_);
        __f_->destroy();
        __f_ = __f.__f_;
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f.__f_ == (__base*)&__f.__buf_)
    {
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = __f_;
        __f_ = (__base*)&__buf_;
    }
    else
        std::__1::swap(__f_, __f.__f_);
}

template<class _Rp>
_Rp
function<_Rp()>::operator()() const
{




    return (*__f_)();
}
# 935 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__functional_03" 3
template<class _Rp, class _A0>
class __attribute__ ((__type_visibility__("default"))) function<_Rp(_A0)>
    : public unary_function<_A0, _Rp>
{
    typedef __function::__base<_Rp(_A0)> __base;
    aligned_storage<3*sizeof(void*)>::type __buf_;
    __base* __f_;

    template <class _Fp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const _Fp&) {return true;}
    template <class _R2, class _B0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (*__p)(_B0)) {return __p;}
    template <class _R2, class _Cp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)()) {return __p;}
    template <class _R2, class _Cp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)() const) {return __p;}
    template <class _R2, class _Cp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)() volatile) {return __p;}
    template <class _R2, class _Cp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)() const volatile) {return __p;}
    template <class _R2, class _B0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const function<_R2(_B0)>& __p) {return __p;}
public:
    typedef _Rp result_type;


    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit function() : __f_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) function(nullptr_t) : __f_(0) {}
    function(const function&);
    template<class _Fp>
      function(_Fp,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&) : __f_(0) {}
    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&, nullptr_t) : __f_(0) {}
    template<class _Alloc>
      function(allocator_arg_t, const _Alloc&, const function&);
    template<class _Fp, class _Alloc>
      function(allocator_arg_t, const _Alloc& __a, _Fp __f,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    function& operator=(const function&);
    function& operator=(nullptr_t);
    template<class _Fp>
      typename enable_if
      <
        !is_integral<_Fp>::value,
        function&
      >::type
      operator=(_Fp);

    ~function();


    void swap(function&);
    template<class _Fp, class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      void assign(_Fp __f, const _Alloc& __a)
        {function(allocator_arg, __a, __f).swap(*this);}


    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator bool() const {return __f_;}

private:

    template<class _R2, class _B0>
      bool operator==(const function<_R2(_B0)>&) const;
    template<class _R2, class _B0>
      bool operator!=(const function<_R2(_B0)>&) const;
public:

    _Rp operator()(_A0) const;







};

template<class _Rp, class _A0>
function<_Rp(_A0)>::function(const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp, class _A0>
template<class _Alloc>
function<_Rp(_A0)>::function(allocator_arg_t, const _Alloc&, const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp, class _A0>
template <class _Fp>
function<_Rp(_A0)>::function(_Fp __f,
                                     typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, allocator<_Fp>, _Rp(_A0)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef allocator<_FF> _Ap;
            _Ap __a;
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, allocator<_Fp>(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp, class _A0>
template <class _Fp, class _Alloc>
function<_Rp(_A0)>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f,
                                     typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, _Alloc, _Rp(_A0)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef typename __alloc_traits::template



                rebind_alloc<_FF>::other

                                                         _Ap;
            _Ap __a(__a0);
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, _Alloc(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp, class _A0>
function<_Rp(_A0)>&
function<_Rp(_A0)>::operator=(const function& __f)
{
    function(__f).swap(*this);
    return *this;
}

template<class _Rp, class _A0>
function<_Rp(_A0)>&
function<_Rp(_A0)>::operator=(nullptr_t)
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
    __f_ = 0;
}

template<class _Rp, class _A0>
template <class _Fp>
typename enable_if
<
    !is_integral<_Fp>::value,
    function<_Rp(_A0)>&
>::type
function<_Rp(_A0)>::operator=(_Fp __f)
{
    function(std::__1::move(__f)).swap(*this);
    return *this;
}

template<class _Rp, class _A0>
function<_Rp(_A0)>::~function()
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
}

template<class _Rp, class _A0>
void
function<_Rp(_A0)>::swap(function& __f)
{
    if (__f_ == (__base*)&__buf_ && __f.__f_ == (__base*)&__f.__buf_)
    {
        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
        __base* __t = (__base*)&__tempbuf;
        __f_->__clone(__t);
        __f_->destroy();
        __f_ = 0;
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = 0;
        __f_ = (__base*)&__buf_;
        __t->__clone((__base*)&__f.__buf_);
        __t->destroy();
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f_ == (__base*)&__buf_)
    {
        __f_->__clone((__base*)&__f.__buf_);
        __f_->destroy();
        __f_ = __f.__f_;
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f.__f_ == (__base*)&__f.__buf_)
    {
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = __f_;
        __f_ = (__base*)&__buf_;
    }
    else
        std::__1::swap(__f_, __f.__f_);
}

template<class _Rp, class _A0>
_Rp
function<_Rp(_A0)>::operator()(_A0 __a0) const
{




    return (*__f_)(__a0);
}
# 1237 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__functional_03" 3
template<class _Rp, class _A0, class _A1>
class __attribute__ ((__type_visibility__("default"))) function<_Rp(_A0, _A1)>
    : public binary_function<_A0, _A1, _Rp>
{
    typedef __function::__base<_Rp(_A0, _A1)> __base;
    aligned_storage<3*sizeof(void*)>::type __buf_;
    __base* __f_;

    template <class _Fp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const _Fp&) {return true;}
    template <class _R2, class _B0, class _B1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (*__p)(_B0, _B1)) {return __p;}
    template <class _R2, class _Cp, class _B1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1)) {return __p;}
    template <class _R2, class _Cp, class _B1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1) const) {return __p;}
    template <class _R2, class _Cp, class _B1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1) volatile) {return __p;}
    template <class _R2, class _Cp, class _B1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1) const volatile) {return __p;}
    template <class _R2, class _B0, class _B1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const function<_R2(_B0, _B1)>& __p) {return __p;}
public:
    typedef _Rp result_type;


    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit function() : __f_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) function(nullptr_t) : __f_(0) {}
    function(const function&);
    template<class _Fp>
      function(_Fp,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&) : __f_(0) {}
    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&, nullptr_t) : __f_(0) {}
    template<class _Alloc>
      function(allocator_arg_t, const _Alloc&, const function&);
    template<class _Fp, class _Alloc>
      function(allocator_arg_t, const _Alloc& __a, _Fp __f,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    function& operator=(const function&);
    function& operator=(nullptr_t);
    template<class _Fp>
      typename enable_if
      <
        !is_integral<_Fp>::value,
        function&
      >::type
      operator=(_Fp);

    ~function();


    void swap(function&);
    template<class _Fp, class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      void assign(_Fp __f, const _Alloc& __a)
        {function(allocator_arg, __a, __f).swap(*this);}


    operator bool() const {return __f_;}

private:

    template<class _R2, class _B0, class _B1>
      bool operator==(const function<_R2(_B0, _B1)>&) const;
    template<class _R2, class _B0, class _B1>
      bool operator!=(const function<_R2(_B0, _B1)>&) const;
public:

    _Rp operator()(_A0, _A1) const;







};

template<class _Rp, class _A0, class _A1>
function<_Rp(_A0, _A1)>::function(const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp, class _A0, class _A1>
template<class _Alloc>
function<_Rp(_A0, _A1)>::function(allocator_arg_t, const _Alloc&, const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp, class _A0, class _A1>
template <class _Fp>
function<_Rp(_A0, _A1)>::function(_Fp __f,
                                 typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, allocator<_Fp>, _Rp(_A0, _A1)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef allocator<_FF> _Ap;
            _Ap __a;
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, allocator<_Fp>(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp, class _A0, class _A1>
template <class _Fp, class _Alloc>
function<_Rp(_A0, _A1)>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f,
                                 typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, _Alloc, _Rp(_A0, _A1)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef typename __alloc_traits::template



                rebind_alloc<_FF>::other

                                                         _Ap;
            _Ap __a(__a0);
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, _Alloc(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp, class _A0, class _A1>
function<_Rp(_A0, _A1)>&
function<_Rp(_A0, _A1)>::operator=(const function& __f)
{
    function(__f).swap(*this);
    return *this;
}

template<class _Rp, class _A0, class _A1>
function<_Rp(_A0, _A1)>&
function<_Rp(_A0, _A1)>::operator=(nullptr_t)
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
    __f_ = 0;
}

template<class _Rp, class _A0, class _A1>
template <class _Fp>
typename enable_if
<
    !is_integral<_Fp>::value,
    function<_Rp(_A0, _A1)>&
>::type
function<_Rp(_A0, _A1)>::operator=(_Fp __f)
{
    function(std::__1::move(__f)).swap(*this);
    return *this;
}

template<class _Rp, class _A0, class _A1>
function<_Rp(_A0, _A1)>::~function()
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
}

template<class _Rp, class _A0, class _A1>
void
function<_Rp(_A0, _A1)>::swap(function& __f)
{
    if (__f_ == (__base*)&__buf_ && __f.__f_ == (__base*)&__f.__buf_)
    {
        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
        __base* __t = (__base*)&__tempbuf;
        __f_->__clone(__t);
        __f_->destroy();
        __f_ = 0;
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = 0;
        __f_ = (__base*)&__buf_;
        __t->__clone((__base*)&__f.__buf_);
        __t->destroy();
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f_ == (__base*)&__buf_)
    {
        __f_->__clone((__base*)&__f.__buf_);
        __f_->destroy();
        __f_ = __f.__f_;
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f.__f_ == (__base*)&__f.__buf_)
    {
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = __f_;
        __f_ = (__base*)&__buf_;
    }
    else
        std::__1::swap(__f_, __f.__f_);
}

template<class _Rp, class _A0, class _A1>
_Rp
function<_Rp(_A0, _A1)>::operator()(_A0 __a0, _A1 __a1) const
{




    return (*__f_)(__a0, __a1);
}
# 1539 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__functional_03" 3
template<class _Rp, class _A0, class _A1, class _A2>
class __attribute__ ((__type_visibility__("default"))) function<_Rp(_A0, _A1, _A2)>
{
    typedef __function::__base<_Rp(_A0, _A1, _A2)> __base;
    aligned_storage<3*sizeof(void*)>::type __buf_;
    __base* __f_;

    template <class _Fp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const _Fp&) {return true;}
    template <class _R2, class _B0, class _B1, class _B2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (*__p)(_B0, _B1, _B2)) {return __p;}
    template <class _R2, class _Cp, class _B1, class _B2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1, _B2)) {return __p;}
    template <class _R2, class _Cp, class _B1, class _B2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1, _B2) const) {return __p;}
    template <class _R2, class _Cp, class _B1, class _B2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1, _B2) volatile) {return __p;}
    template <class _R2, class _Cp, class _B1, class _B2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1, _B2) const volatile) {return __p;}
    template <class _R2, class _B0, class _B1, class _B2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const function<_R2(_B0, _B1, _B2)>& __p) {return __p;}
public:
    typedef _Rp result_type;


    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit function() : __f_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) function(nullptr_t) : __f_(0) {}
    function(const function&);
    template<class _Fp>
      function(_Fp,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&) : __f_(0) {}
    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&, nullptr_t) : __f_(0) {}
    template<class _Alloc>
      function(allocator_arg_t, const _Alloc&, const function&);
    template<class _Fp, class _Alloc>
      function(allocator_arg_t, const _Alloc& __a, _Fp __f,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    function& operator=(const function&);
    function& operator=(nullptr_t);
    template<class _Fp>
      typename enable_if
      <
        !is_integral<_Fp>::value,
        function&
      >::type
      operator=(_Fp);

    ~function();


    void swap(function&);
    template<class _Fp, class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      void assign(_Fp __f, const _Alloc& __a)
        {function(allocator_arg, __a, __f).swap(*this);}


    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator bool() const {return __f_;}

private:

    template<class _R2, class _B0, class _B1, class _B2>
      bool operator==(const function<_R2(_B0, _B1, _B2)>&) const;
    template<class _R2, class _B0, class _B1, class _B2>
      bool operator!=(const function<_R2(_B0, _B1, _B2)>&) const;
public:

    _Rp operator()(_A0, _A1, _A2) const;







};

template<class _Rp, class _A0, class _A1, class _A2>
function<_Rp(_A0, _A1, _A2)>::function(const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp, class _A0, class _A1, class _A2>
template<class _Alloc>
function<_Rp(_A0, _A1, _A2)>::function(allocator_arg_t, const _Alloc&,
                                      const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp, class _A0, class _A1, class _A2>
template <class _Fp>
function<_Rp(_A0, _A1, _A2)>::function(_Fp __f,
                                     typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, allocator<_Fp>, _Rp(_A0, _A1, _A2)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef allocator<_FF> _Ap;
            _Ap __a;
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, allocator<_Fp>(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp, class _A0, class _A1, class _A2>
template <class _Fp, class _Alloc>
function<_Rp(_A0, _A1, _A2)>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f,
                                     typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef typename __alloc_traits::template



                rebind_alloc<_FF>::other

                                                         _Ap;
            _Ap __a(__a0);
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, _Alloc(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp, class _A0, class _A1, class _A2>
function<_Rp(_A0, _A1, _A2)>&
function<_Rp(_A0, _A1, _A2)>::operator=(const function& __f)
{
    function(__f).swap(*this);
    return *this;
}

template<class _Rp, class _A0, class _A1, class _A2>
function<_Rp(_A0, _A1, _A2)>&
function<_Rp(_A0, _A1, _A2)>::operator=(nullptr_t)
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
    __f_ = 0;
}

template<class _Rp, class _A0, class _A1, class _A2>
template <class _Fp>
typename enable_if
<
    !is_integral<_Fp>::value,
    function<_Rp(_A0, _A1, _A2)>&
>::type
function<_Rp(_A0, _A1, _A2)>::operator=(_Fp __f)
{
    function(std::__1::move(__f)).swap(*this);
    return *this;
}

template<class _Rp, class _A0, class _A1, class _A2>
function<_Rp(_A0, _A1, _A2)>::~function()
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
}

template<class _Rp, class _A0, class _A1, class _A2>
void
function<_Rp(_A0, _A1, _A2)>::swap(function& __f)
{
    if (__f_ == (__base*)&__buf_ && __f.__f_ == (__base*)&__f.__buf_)
    {
        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
        __base* __t = (__base*)&__tempbuf;
        __f_->__clone(__t);
        __f_->destroy();
        __f_ = 0;
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = 0;
        __f_ = (__base*)&__buf_;
        __t->__clone((__base*)&__f.__buf_);
        __t->destroy();
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f_ == (__base*)&__buf_)
    {
        __f_->__clone((__base*)&__f.__buf_);
        __f_->destroy();
        __f_ = __f.__f_;
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f.__f_ == (__base*)&__f.__buf_)
    {
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = __f_;
        __f_ = (__base*)&__buf_;
    }
    else
        std::__1::swap(__f_, __f.__f_);
}

template<class _Rp, class _A0, class _A1, class _A2>
_Rp
function<_Rp(_A0, _A1, _A2)>::operator()(_A0 __a0, _A1 __a1, _A2 __a2) const
{




    return (*__f_)(__a0, __a1, __a2);
}
# 1841 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__functional_03" 3
template <class _Fp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const function<_Fp>& __f, nullptr_t) {return !__f;}

template <class _Fp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(nullptr_t, const function<_Fp>& __f) {return !__f;}

template <class _Fp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const function<_Fp>& __f, nullptr_t) {return (bool)__f;}

template <class _Fp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(nullptr_t, const function<_Fp>& __f) {return (bool)__f;}

template <class _Fp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(function<_Fp>& __x, function<_Fp>& __y)
{return __x.swap(__y);}

template<class _Tp> struct __is_bind_expression : public false_type {};
template<class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_bind_expression
    : public __is_bind_expression<typename remove_cv<_Tp>::type> {};

template<class _Tp> struct __is_placeholder : public integral_constant<int, 0> {};
template<class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_placeholder
    : public __is_placeholder<typename remove_cv<_Tp>::type> {};

namespace placeholders
{

template <int _Np> struct __ph {};

extern __ph<1> _1;
extern __ph<2> _2;
extern __ph<3> _3;
extern __ph<4> _4;
extern __ph<5> _5;
extern __ph<6> _6;
extern __ph<7> _7;
extern __ph<8> _8;
extern __ph<9> _9;
extern __ph<10> _10;

}

template<int _Np>
struct __is_placeholder<placeholders::__ph<_Np> >
    : public integral_constant<int, _Np> {};

template <class _Tp, class _Uj>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp&
__mu(reference_wrapper<_Tp> __t, _Uj&)
{
    return __t.get();
}
# 1204 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/functional" 2 3
# 2201 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/functional" 3
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<bool>
    : public unary_function<bool, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(bool __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char>
    : public unary_function<char, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(char __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<signed char>
    : public unary_function<signed char, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(signed char __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned char>
    : public unary_function<unsigned char, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(unsigned char __v) const throw() {return static_cast<size_t>(__v);}
};



template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char16_t>
    : public unary_function<char16_t, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(char16_t __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char32_t>
    : public unary_function<char32_t, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(char32_t __v) const throw() {return static_cast<size_t>(__v);}
};



template <>
struct __attribute__ ((__type_visibility__("default"))) hash<wchar_t>
    : public unary_function<wchar_t, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(wchar_t __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<short>
    : public unary_function<short, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(short __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned short>
    : public unary_function<unsigned short, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(unsigned short __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<int>
    : public unary_function<int, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(int __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned int>
    : public unary_function<unsigned int, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(unsigned int __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long>
    : public unary_function<long, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(long __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned long>
    : public unary_function<unsigned long, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(unsigned long __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long long>
    : public __scalar_hash<long long>
{
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned long long>
    : public __scalar_hash<unsigned long long>
{
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<float>
    : public __scalar_hash<float>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(float __v) const throw()
    {

       if (__v == 0)
           return 0;
        return __scalar_hash<float>::operator()(__v);
    }
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<double>
    : public __scalar_hash<double>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(double __v) const throw()
    {

       if (__v == 0)
           return 0;
        return __scalar_hash<double>::operator()(__v);
    }
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long double>
    : public __scalar_hash<long double>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(long double __v) const throw()
    {

        if (__v == 0)
            return 0;
# 2394 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/functional" 3
        return __scalar_hash<long double>::operator()(__v);

    }
};
# 2417 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/functional" 3
} }
# 428 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 2 3
# 432 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 3


namespace std {inline namespace __1 {

template <class _Key, class _CP, class _Compare, bool = is_empty<_Compare>::value

                                                        && !__is_final(_Compare)

         >
class __map_value_compare
    : private _Compare
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __map_value_compare()

        : _Compare() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __map_value_compare(_Compare c)

        : _Compare(c) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const _Compare& key_comp() const throw() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _CP& __x, const _CP& __y) const
        {return static_cast<const _Compare&>(*this)(__x.__cc.first, __y.__cc.first);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _CP& __x, const _Key& __y) const
        {return static_cast<const _Compare&>(*this)(__x.__cc.first, __y);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Key& __x, const _CP& __y) const
        {return static_cast<const _Compare&>(*this)(__x, __y.__cc.first);}
# 478 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 3
};

template <class _Key, class _CP, class _Compare>
class __map_value_compare<_Key, _CP, _Compare, false>
{
    _Compare comp;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __map_value_compare()

        : comp() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __map_value_compare(_Compare c)

        : comp(c) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const _Compare& key_comp() const throw() {return comp;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _CP& __x, const _CP& __y) const
        {return comp(__x.__cc.first, __y.__cc.first);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _CP& __x, const _Key& __y) const
        {return comp(__x.__cc.first, __y);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Key& __x, const _CP& __y) const
        {return comp(__x, __y.__cc.first);}
# 520 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 3
};

template <class _Allocator>
class __map_node_destructor
{
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::value_type::value_type value_type;
public:
    typedef typename __alloc_traits::pointer pointer;
private:
    typedef typename value_type::value_type::first_type first_type;
    typedef typename value_type::value_type::second_type second_type;

    allocator_type& __na_;

    __map_node_destructor& operator=(const __map_node_destructor&);

public:
    bool __first_constructed;
    bool __second_constructed;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __map_node_destructor(allocator_type& __na) throw()
        : __na_(__na),
          __first_constructed(false),
          __second_constructed(false)
        {}
# 560 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void operator()(pointer __p) throw()
    {
        if (__second_constructed)
            __alloc_traits::destroy(__na_, std::__1::addressof(__p->__value_.__cc.second));
        if (__first_constructed)
            __alloc_traits::destroy(__na_, std::__1::addressof(__p->__value_.__cc.first));
        if (__p)
            __alloc_traits::deallocate(__na_, __p, 1);
    }
};

template <class _Key, class _Tp, class _Compare, class _Allocator>
    class map;
template <class _Key, class _Tp, class _Compare, class _Allocator>
    class multimap;
template <class _TreeIterator> class __map_const_iterator;
# 622 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 3
template <class _Key, class _Tp>
struct __value_type
{
    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef pair<const key_type, mapped_type> value_type;

    value_type __cc;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __value_type() {}

    template <class _A0>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __value_type(const _A0& __a0)
        : __cc(__a0) {}

    template <class _A0, class _A1>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __value_type(const _A0& __a0, const _A1& __a1)
        : __cc(__a0, __a1) {}
};



template <class _TreeIterator>
class __attribute__ ((__type_visibility__("default"))) __map_iterator
{
    _TreeIterator __i_;

    typedef typename _TreeIterator::__pointer_traits __pointer_traits;
    typedef const typename _TreeIterator::value_type::value_type::first_type __key_type;
    typedef typename _TreeIterator::value_type::value_type::second_type __mapped_type;
public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef pair<__key_type, __mapped_type> value_type;
    typedef typename _TreeIterator::difference_type difference_type;
    typedef value_type& reference;
    typedef typename __pointer_traits::template



            rebind<value_type>::other

                                                                 pointer;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __map_iterator() throw() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __map_iterator(_TreeIterator __i) throw() : __i_(__i) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    reference operator*() const {return __i_->__cc;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __map_iterator& operator++() {++__i_; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __map_iterator operator++(int)
    {
        __map_iterator __t(*this);
        ++(*this);
        return __t;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __map_iterator& operator--() {--__i_; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __map_iterator operator--(int)
    {
        __map_iterator __t(*this);
        --(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const __map_iterator& __x, const __map_iterator& __y)
        {return __x.__i_ == __y.__i_;}
    friend
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const __map_iterator& __x, const __map_iterator& __y)
        {return __x.__i_ != __y.__i_;}

    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __map_const_iterator;
};

template <class _TreeIterator>
class __attribute__ ((__type_visibility__("default"))) __map_const_iterator
{
    _TreeIterator __i_;

    typedef typename _TreeIterator::__pointer_traits __pointer_traits;
    typedef const typename _TreeIterator::value_type::value_type::first_type __key_type;
    typedef typename _TreeIterator::value_type::value_type::second_type __mapped_type;
public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef pair<__key_type, __mapped_type> value_type;
    typedef typename _TreeIterator::difference_type difference_type;
    typedef const value_type& reference;
    typedef typename __pointer_traits::template



            rebind<const value_type>::other

                                                                 pointer;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __map_const_iterator() throw() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __map_const_iterator(_TreeIterator __i) throw() : __i_(__i) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __map_const_iterator(
            __map_iterator<typename _TreeIterator::__non_const_iterator> __i)
                throw()
                : __i_(__i.__i_) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    reference operator*() const {return __i_->__cc;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __map_const_iterator& operator++() {++__i_; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __map_const_iterator operator++(int)
    {
        __map_const_iterator __t(*this);
        ++(*this);
        return __t;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __map_const_iterator& operator--() {--__i_; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __map_const_iterator operator--(int)
    {
        __map_const_iterator __t(*this);
        --(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const __map_const_iterator& __x, const __map_const_iterator& __y)
        {return __x.__i_ == __y.__i_;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const __map_const_iterator& __x, const __map_const_iterator& __y)
        {return __x.__i_ != __y.__i_;}

    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) __tree_const_iterator;
};

template <class _Key, class _Tp, class _Compare = less<_Key>,
          class _Allocator = allocator<pair<const _Key, _Tp> > >
class __attribute__ ((__type_visibility__("default"))) map
{
public:

    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef pair<key_type, mapped_type> __nc_value_type;
    typedef _Compare key_compare;
    typedef _Allocator allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;

    class __attribute__ ((__type_visibility__("default"))) value_compare
        : public binary_function<value_type, value_type, bool>
    {
        friend class map;
    protected:
        key_compare comp;

        __attribute__ ((__visibility__("hidden"), __always_inline__)) value_compare(key_compare c) : comp(c) {}
    public:
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool operator()(const value_type& __x, const value_type& __y) const
            {return comp(__x.first, __y.first);}
    };

private:

    typedef std::__1::__value_type<key_type, mapped_type> __value_type;
    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;
    typedef typename allocator_traits<allocator_type>::template



            rebind_alloc<__value_type>::other

                                                           __allocator_type;
    typedef __tree<__value_type, __vc, __allocator_type> __base;
    typedef typename __base::__node_traits __node_traits;
    typedef allocator_traits<allocator_type> __alloc_traits;

    __base __tree_;

public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef __map_iterator<typename __base::iterator> iterator;
    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    map()




        : __tree_(__vc(key_compare())) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit map(const key_compare& __comp)



        : __tree_(__vc(__comp)) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit map(const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), __a) {}

    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        map(_InputIterator __f, _InputIterator __l,
            const key_compare& __comp = key_compare())
        : __tree_(__vc(__comp))
        {
            insert(__f, __l);
        }

    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        map(_InputIterator __f, _InputIterator __l,
            const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), __a)
        {
            insert(__f, __l);
        }
# 881 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    map(const map& __m)
        : __tree_(__m.__tree_)
        {
            insert(__m.begin(), __m.end());
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    map& operator=(const map& __m)
        {



            if (this != &__m) {
                __tree_.clear();
                __tree_.value_comp() = __m.__tree_.value_comp();
                __tree_.__copy_assign_alloc(__m.__tree_);
                insert(__m.begin(), __m.end());
            }

            return *this;
        }
# 956 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit map(const allocator_type& __a)
        : __tree_(__a)
        {
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    map(const map& __m, const allocator_type& __a)
        : __tree_(__m.__tree_.value_comp(), __a)
        {
            insert(__m.begin(), __m.end());
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
          iterator begin() throw() {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator begin() const throw() {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
          iterator end() throw() {return __tree_.end();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator end() const throw() {return __tree_.end();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
          reverse_iterator rbegin() throw() {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator rbegin() const throw()
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
          reverse_iterator rend() throw()
            {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator rend() const throw()
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator cbegin() const throw() {return begin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator cend() const throw() {return end();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator crbegin() const throw() {return rbegin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator crend() const throw() {return rend();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool empty() const throw() {return __tree_.size() == 0;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type size() const throw() {return __tree_.size();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type max_size() const throw() {return __tree_.max_size();}

    mapped_type& operator[](const key_type& __k);




          mapped_type& at(const key_type& __k);
    const mapped_type& at(const key_type& __k) const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    allocator_type get_allocator() const throw() {return __tree_.__alloc();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    key_compare key_comp() const {return __tree_.value_comp().key_comp();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    value_compare value_comp() const {return value_compare(__tree_.value_comp().key_comp());}
# 1048 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair<iterator, bool>
        insert(const value_type& __v) {return __tree_.__insert_unique(__v);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator
        insert(const_iterator __p, const value_type& __v)
            {return __tree_.__insert_unique(__p.__i_, __v);}

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void insert(_InputIterator __f, _InputIterator __l)
        {
            for (const_iterator __e = cend(); __f != __l; ++__f)
                insert(__e.__i_, *__f);
        }
# 1073 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type erase(const key_type& __k)
        {return __tree_.__erase_unique(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator erase(const_iterator __f, const_iterator __l)
        {return __tree_.erase(__f.__i_, __l.__i_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void clear() throw() {__tree_.clear();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(map& __m)

        {__tree_.swap(__m.__tree_);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator find(const key_type& __k) {return __tree_.find(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}
# 1104 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type count(const key_type& __k) const
        {return __tree_.__count_unique(__k);}






    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator lower_bound(const key_type& __k)
        {return __tree_.lower_bound(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator lower_bound(const key_type& __k) const
        {return __tree_.lower_bound(__k);}
# 1131 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator upper_bound(const key_type& __k)
        {return __tree_.upper_bound(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator upper_bound(const key_type& __k) const
        {return __tree_.upper_bound(__k);}
# 1148 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair<iterator,iterator> equal_range(const key_type& __k)
        {return __tree_.__equal_range_unique(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const
        {return __tree_.__equal_range_unique(__k);}
# 1165 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 3
private:
    typedef typename __base::__node __node;
    typedef typename __base::__node_allocator __node_allocator;
    typedef typename __base::__node_pointer __node_pointer;
    typedef typename __base::__node_const_pointer __node_const_pointer;
    typedef typename __base::__node_base_pointer __node_base_pointer;
    typedef typename __base::__node_base_const_pointer __node_base_const_pointer;
    typedef __map_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;
# 1185 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 3
    __node_holder __construct_node_with_key(const key_type& __k);

    __node_base_pointer&
        __find_equal_key(__node_base_pointer& __parent, const key_type& __k);
    __node_base_const_pointer
        __find_equal_key(__node_base_const_pointer& __parent, const key_type& __k) const;
};





template <class _Key, class _Tp, class _Compare, class _Allocator>
typename map<_Key, _Tp, _Compare, _Allocator>::__node_base_pointer&
map<_Key, _Tp, _Compare, _Allocator>::__find_equal_key(__node_base_pointer& __parent,
                                                       const key_type& __k)
{
    __node_pointer __nd = __tree_.__root();
    if (__nd != std::__1::__get_nullptr_t())
    {
        while (true)
        {
            if (__tree_.value_comp().key_comp()(__k, __nd->__value_.__cc.first))
            {
                if (__nd->__left_ != std::__1::__get_nullptr_t())
                    __nd = static_cast<__node_pointer>(__nd->__left_);
                else
                {
                    __parent = static_cast<__node_base_pointer>(__nd);
                    return __parent->__left_;
                }
            }
            else if (__tree_.value_comp().key_comp()(__nd->__value_.__cc.first, __k))
            {
                if (__nd->__right_ != std::__1::__get_nullptr_t())
                    __nd = static_cast<__node_pointer>(__nd->__right_);
                else
                {
                    __parent = static_cast<__node_base_pointer>(__nd);
                    return __parent->__right_;
                }
            }
            else
            {
                __parent = static_cast<__node_base_pointer>(__nd);
                return __parent;
            }
        }
    }
    __parent = static_cast<__node_base_pointer>(__tree_.__end_node());
    return __parent->__left_;
}





template <class _Key, class _Tp, class _Compare, class _Allocator>
typename map<_Key, _Tp, _Compare, _Allocator>::__node_base_const_pointer
map<_Key, _Tp, _Compare, _Allocator>::__find_equal_key(__node_base_const_pointer& __parent,
                                                       const key_type& __k) const
{
    __node_const_pointer __nd = __tree_.__root();
    if (__nd != std::__1::__get_nullptr_t())
    {
        while (true)
        {
            if (__tree_.value_comp().key_comp()(__k, __nd->__value_.__cc.first))
            {
                if (__nd->__left_ != std::__1::__get_nullptr_t())
                    __nd = static_cast<__node_pointer>(__nd->__left_);
                else
                {
                    __parent = static_cast<__node_base_pointer>(__nd);
                    return const_cast<const __node_base_const_pointer&>(__parent->__left_);
                }
            }
            else if (__tree_.value_comp().key_comp()(__nd->__value_.__cc.first, __k))
            {
                if (__nd->__right_ != std::__1::__get_nullptr_t())
                    __nd = static_cast<__node_pointer>(__nd->__right_);
                else
                {
                    __parent = static_cast<__node_base_pointer>(__nd);
                    return const_cast<const __node_base_const_pointer&>(__parent->__right_);
                }
            }
            else
            {
                __parent = static_cast<__node_base_pointer>(__nd);
                return __parent;
            }
        }
    }
    __parent = static_cast<__node_base_pointer>(__tree_.__end_node());
    return const_cast<const __node_base_const_pointer&>(__parent->__left_);
}
# 1358 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 3
template <class _Key, class _Tp, class _Compare, class _Allocator>
typename map<_Key, _Tp, _Compare, _Allocator>::__node_holder
map<_Key, _Tp, _Compare, _Allocator>::__construct_node_with_key(const key_type& __k)
{
    __node_allocator& __na = __tree_.__node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
    __node_traits::construct(__na, std::__1::addressof(__h->__value_.__cc.first), __k);
    __h.get_deleter().__first_constructed = true;
    __node_traits::construct(__na, std::__1::addressof(__h->__value_.__cc.second));
    __h.get_deleter().__second_constructed = true;
    return std::__1::move(__h);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp&
map<_Key, _Tp, _Compare, _Allocator>::operator[](const key_type& __k)
{
    __node_base_pointer __parent;
    __node_base_pointer& __child = __find_equal_key(__parent, __k);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    if (__child == std::__1::__get_nullptr_t())
    {
        __node_holder __h = __construct_node_with_key(__k);
        __tree_.__insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
        __r = __h.release();
    }
    return __r->__value_.__cc.second;
}
# 1407 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 3
template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp&
map<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k)
{
    __node_base_pointer __parent;
    __node_base_pointer& __child = __find_equal_key(__parent, __k);




    return static_cast<__node_pointer>(__child)->__value_.__cc.second;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
const _Tp&
map<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k) const
{
    __node_base_const_pointer __parent;
    __node_base_const_pointer __child = __find_equal_key(__parent, __k);




    return static_cast<__node_const_pointer>(__child)->__value_.__cc.second;
}
# 1462 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 3
template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return __x.size() == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(map<_Key, _Tp, _Compare, _Allocator>& __x,
     map<_Key, _Tp, _Compare, _Allocator>& __y)

{
    __x.swap(__y);
}

template <class _Key, class _Tp, class _Compare = less<_Key>,
          class _Allocator = allocator<pair<const _Key, _Tp> > >
class __attribute__ ((__type_visibility__("default"))) multimap
{
public:

    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef pair<key_type, mapped_type> __nc_value_type;
    typedef _Compare key_compare;
    typedef _Allocator allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;

    class __attribute__ ((__type_visibility__("default"))) value_compare
        : public binary_function<value_type, value_type, bool>
    {
        friend class multimap;
    protected:
        key_compare comp;

        __attribute__ ((__visibility__("hidden"), __always_inline__))
        value_compare(key_compare c) : comp(c) {}
    public:
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool operator()(const value_type& __x, const value_type& __y) const
            {return comp(__x.first, __y.first);}
    };

private:

    typedef std::__1::__value_type<key_type, mapped_type> __value_type;
    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;
    typedef typename allocator_traits<allocator_type>::template



            rebind_alloc<__value_type>::other

                                                                    __allocator_type;
    typedef __tree<__value_type, __vc, __allocator_type> __base;
    typedef typename __base::__node_traits __node_traits;
    typedef allocator_traits<allocator_type> __alloc_traits;

    __base __tree_;

public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef __map_iterator<typename __base::iterator> iterator;
    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    multimap()




        : __tree_(__vc(key_compare())) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit multimap(const key_compare& __comp)



        : __tree_(__vc(__comp)) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit multimap(const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), __a) {}

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        multimap(_InputIterator __f, _InputIterator __l,
            const key_compare& __comp = key_compare())
        : __tree_(__vc(__comp))
        {
            insert(__f, __l);
        }

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        multimap(_InputIterator __f, _InputIterator __l,
            const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), __a)
        {
            insert(__f, __l);
        }
# 1627 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    multimap(const multimap& __m)
        : __tree_(__m.__tree_.value_comp(),
          __alloc_traits::select_on_container_copy_construction(__m.__tree_.__alloc()))
        {
            insert(__m.begin(), __m.end());
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    multimap& operator=(const multimap& __m)
        {



            if (this != &__m) {
                __tree_.clear();
                __tree_.value_comp() = __m.__tree_.value_comp();
                __tree_.__copy_assign_alloc(__m.__tree_);
                insert(__m.begin(), __m.end());
            }

            return *this;
        }
# 1703 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit multimap(const allocator_type& __a)
        : __tree_(__a)
        {
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    multimap(const multimap& __m, const allocator_type& __a)
        : __tree_(__m.__tree_.value_comp(), __a)
        {
            insert(__m.begin(), __m.end());
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
          iterator begin() throw() {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator begin() const throw() {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
          iterator end() throw() {return __tree_.end();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator end() const throw() {return __tree_.end();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
          reverse_iterator rbegin() throw() {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator rbegin() const throw()
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
          reverse_iterator rend() throw() {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator rend() const throw()
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator cbegin() const throw() {return begin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator cend() const throw() {return end();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator crbegin() const throw() {return rbegin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator crend() const throw() {return rend();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool empty() const throw() {return __tree_.size() == 0;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type size() const throw() {return __tree_.size();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type max_size() const throw() {return __tree_.max_size();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    allocator_type get_allocator() const throw() {return __tree_.__alloc();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    key_compare key_comp() const {return __tree_.value_comp().key_comp();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    value_compare value_comp() const
        {return value_compare(__tree_.value_comp().key_comp());}
# 1787 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator insert(const value_type& __v) {return __tree_.__insert_multi(__v);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator insert(const_iterator __p, const value_type& __v)
            {return __tree_.__insert_multi(__p.__i_, __v);}

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void insert(_InputIterator __f, _InputIterator __l)
        {
            for (const_iterator __e = cend(); __f != __l; ++__f)
                __tree_.__insert_multi(__e.__i_, *__f);
        }
# 1810 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator erase(const_iterator __f, const_iterator __l)
        {return __tree_.erase(__f.__i_, __l.__i_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void clear() {__tree_.clear();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(multimap& __m)

        {__tree_.swap(__m.__tree_);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator find(const key_type& __k) {return __tree_.find(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}
# 1840 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type count(const key_type& __k) const
        {return __tree_.__count_multi(__k);}






    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator lower_bound(const key_type& __k)
        {return __tree_.lower_bound(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator lower_bound(const key_type& __k) const
            {return __tree_.lower_bound(__k);}
# 1867 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator upper_bound(const key_type& __k)
            {return __tree_.upper_bound(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator upper_bound(const key_type& __k) const
            {return __tree_.upper_bound(__k);}
# 1884 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair<iterator,iterator> equal_range(const key_type& __k)
            {return __tree_.__equal_range_multi(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const
            {return __tree_.__equal_range_multi(__k);}
# 1901 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 3
private:
    typedef typename __base::__node __node;
    typedef typename __base::__node_allocator __node_allocator;
    typedef typename __base::__node_pointer __node_pointer;
    typedef typename __base::__node_const_pointer __node_const_pointer;
    typedef __map_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;
# 1919 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 3
};
# 2009 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/map" 3
template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return __x.size() == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(multimap<_Key, _Tp, _Compare, _Allocator>& __x,
     multimap<_Key, _Tp, _Compare, _Allocator>& __y)

{
    __x.swap(__y);
}

} }
# 26 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Attributes.h" 2


namespace llvm {

class AttrBuilder;
class AttributeImpl;
class AttributeSetImpl;
class AttributeSetNode;
class Constant;
template<typename T> struct DenseMapInfo;
class LLVMContext;
class Type;







class Attribute {
public:
# 64 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Attributes.h"
  enum AttrKind {

    None,
    Alignment,


    AlwaysInline,
    Builtin,

    ByVal,
    Cold,
    InlineHint,
    InReg,
    MinSize,
    Naked,
    Nest,
    NoAlias,
    NoBuiltin,
    NoCapture,
    NoDuplicate,
    NoImplicitFloat,
    NoInline,
    NonLazyBind,

    NoRedZone,
    NoReturn,
    NoUnwind,
    OptimizeForSize,
    OptimizeNone,
    ReadNone,
    ReadOnly,
    Returned,
    ReturnsTwice,
    SExt,
    StackAlignment,



    StackProtect,
    StackProtectReq,
    StackProtectStrong,
    StructRet,
    SanitizeAddress,
    SanitizeThread,
    SanitizeMemory,
    UWTable,
    ZExt,

    EndAttrKinds
  };
private:
  AttributeImpl *pImpl;
  Attribute(AttributeImpl *A) : pImpl(A) {}
public:
  Attribute() : pImpl(0) {}






  static Attribute get(LLVMContext &Context, AttrKind Kind, uint64_t Val = 0);
  static Attribute get(LLVMContext &Context, StringRef Kind,
                       StringRef Val = StringRef());



  static Attribute getWithAlignment(LLVMContext &Context, uint64_t Align);
  static Attribute getWithStackAlignment(LLVMContext &Context, uint64_t Align);






  bool isEnumAttribute() const;


  bool isAlignAttribute() const;



  bool isStringAttribute() const;


  bool hasAttribute(AttrKind Val) const;


  bool hasAttribute(StringRef Val) const;



  Attribute::AttrKind getKindAsEnum() const;



  uint64_t getValueAsInt() const;



  StringRef getKindAsString() const;



  StringRef getValueAsString() const;



  unsigned getAlignment() const;



  unsigned getStackAlignment() const;



  std::string getAsString(bool InAttrGrp = false) const;


  bool operator==(Attribute A) const { return pImpl == A.pImpl; }
  bool operator!=(Attribute A) const { return pImpl != A.pImpl; }


  bool operator<(Attribute A) const;

  void Profile(FoldingSetNodeID &ID) const {
    ID.AddPointer(pImpl);
  }
};
# 202 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Attributes.h"
class AttributeSet {
public:
  enum AttrIndex {
    ReturnIndex = 0U,
    FunctionIndex = ~0U
  };
private:
  friend class AttrBuilder;
  friend class AttributeSetImpl;
  template <typename Ty> friend struct DenseMapInfo;



  AttributeSetImpl *pImpl;


  AttributeSetNode *getAttributes(unsigned Index) const;


  static AttributeSet get(LLVMContext &C,
                          ArrayRef<std::pair<unsigned, Attribute> > Attrs);
  static AttributeSet get(LLVMContext &C,
                          ArrayRef<std::pair<unsigned,
                                             AttributeSetNode*> > Attrs);

  static AttributeSet getImpl(LLVMContext &C,
                              ArrayRef<std::pair<unsigned,
                                                 AttributeSetNode*> > Attrs);


  explicit AttributeSet(AttributeSetImpl *LI) : pImpl(LI) {}
public:
  AttributeSet() : pImpl(0) {}






  static AttributeSet get(LLVMContext &C, ArrayRef<AttributeSet> Attrs);
  static AttributeSet get(LLVMContext &C, unsigned Index,
                          ArrayRef<Attribute::AttrKind> Kind);
  static AttributeSet get(LLVMContext &C, unsigned Index, AttrBuilder &B);



  AttributeSet addAttribute(LLVMContext &C, unsigned Index,
                            Attribute::AttrKind Attr) const;



  AttributeSet addAttribute(LLVMContext &C, unsigned Index,
                            StringRef Kind) const;
  AttributeSet addAttribute(LLVMContext &C, unsigned Index,
                            StringRef Kind, StringRef Value) const;



  AttributeSet addAttributes(LLVMContext &C, unsigned Index,
                             AttributeSet Attrs) const;




  AttributeSet removeAttribute(LLVMContext &C, unsigned Index,
                               Attribute::AttrKind Attr) const;




  AttributeSet removeAttributes(LLVMContext &C, unsigned Index,
                                AttributeSet Attrs) const;






  LLVMContext &getContext() const;


  AttributeSet getParamAttributes(unsigned Index) const;


  AttributeSet getRetAttributes() const;


  AttributeSet getFnAttributes() const;


  bool hasAttribute(unsigned Index, Attribute::AttrKind Kind) const;


  bool hasAttribute(unsigned Index, StringRef Kind) const;


  bool hasAttributes(unsigned Index) const;



  bool hasAttrSomewhere(Attribute::AttrKind Attr) const;


  Attribute getAttribute(unsigned Index, Attribute::AttrKind Kind) const;


  Attribute getAttribute(unsigned Index, StringRef Kind) const;


  unsigned getParamAlignment(unsigned Index) const;


  unsigned getStackAlignment(unsigned Index) const;


  std::string getAsString(unsigned Index, bool InAttrGrp = false) const;

  typedef ArrayRef<Attribute>::iterator iterator;

  iterator begin(unsigned Slot) const;
  iterator end(unsigned Slot) const;


  bool operator==(const AttributeSet &RHS) const {
    return pImpl == RHS.pImpl;
  }
  bool operator!=(const AttributeSet &RHS) const {
    return pImpl != RHS.pImpl;
  }






  uint64_t Raw(unsigned Index) const;


  void *getRawPointer() const {
    return pImpl;
  }


  bool isEmpty() const {
    return getNumSlots() == 0;
  }




  unsigned getNumSlots() const;


  unsigned getSlotIndex(unsigned Slot) const;


  AttributeSet getSlotAttributes(unsigned Slot) const;

  void dump() const;
};




template<> struct DenseMapInfo<AttributeSet> {
  static inline AttributeSet getEmptyKey() {
    uintptr_t Val = static_cast<uintptr_t>(-1);
    Val <<= PointerLikeTypeTraits<void*>::NumLowBitsAvailable;
    return AttributeSet(reinterpret_cast<AttributeSetImpl*>(Val));
  }
  static inline AttributeSet getTombstoneKey() {
    uintptr_t Val = static_cast<uintptr_t>(-2);
    Val <<= PointerLikeTypeTraits<void*>::NumLowBitsAvailable;
    return AttributeSet(reinterpret_cast<AttributeSetImpl*>(Val));
  }
  static unsigned getHashValue(AttributeSet AS) {
    return (unsigned((uintptr_t)AS.pImpl) >> 4) ^
           (unsigned((uintptr_t)AS.pImpl) >> 9);
  }
  static bool isEqual(AttributeSet LHS, AttributeSet RHS) { return LHS == RHS; }
};







class AttrBuilder {
  std::bitset<Attribute::EndAttrKinds> Attrs;
  std::map<std::string, std::string> TargetDepAttrs;
  uint64_t Alignment;
  uint64_t StackAlignment;
public:
  AttrBuilder() : Attrs(0), Alignment(0), StackAlignment(0) {}
  explicit AttrBuilder(uint64_t Val)
    : Attrs(0), Alignment(0), StackAlignment(0) {
    addRawValue(Val);
  }
  AttrBuilder(const Attribute &A) : Attrs(0), Alignment(0), StackAlignment(0) {
    addAttribute(A);
  }
  AttrBuilder(AttributeSet AS, unsigned Idx);
  AttrBuilder(const AttrBuilder &B)
    : Attrs(B.Attrs),
      TargetDepAttrs(B.TargetDepAttrs.begin(), B.TargetDepAttrs.end()),
      Alignment(B.Alignment), StackAlignment(B.StackAlignment) {}

  void clear();


  AttrBuilder &addAttribute(Attribute::AttrKind Val);


  AttrBuilder &addAttribute(Attribute A);


  AttrBuilder &addAttribute(StringRef A, StringRef V = StringRef());


  AttrBuilder &removeAttribute(Attribute::AttrKind Val);


  AttrBuilder &removeAttributes(AttributeSet A, uint64_t Index);


  AttrBuilder &removeAttribute(StringRef A);


  AttrBuilder &merge(const AttrBuilder &B);


  bool contains(Attribute::AttrKind A) const {
    ((void)(((unsigned)A < Attribute::EndAttrKinds && "Attribute out of range!") || (__assert_fail("(unsigned)A < Attribute::EndAttrKinds && \"Attribute out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Attributes.h", 435, __func__),0)));
    return Attrs[A];
  }



  bool contains(StringRef A) const;


  bool hasAttributes() const;



  bool hasAttributes(AttributeSet A, uint64_t Index) const;


  bool hasAlignmentAttr() const;


  uint64_t getAlignment() const { return Alignment; }


  uint64_t getStackAlignment() const { return StackAlignment; }



  AttrBuilder &addAlignmentAttr(unsigned Align);



  AttrBuilder &addStackAlignmentAttr(unsigned Align);



  bool empty() const { return Attrs.none(); }


  typedef std::pair<std::string, std::string> td_type;
  typedef std::map<std::string, std::string>::iterator td_iterator;
  typedef std::map<std::string, std::string>::const_iterator td_const_iterator;

  td_iterator td_begin() { return TargetDepAttrs.begin(); }
  td_iterator td_end() { return TargetDepAttrs.end(); }

  td_const_iterator td_begin() const { return TargetDepAttrs.begin(); }
  td_const_iterator td_end() const { return TargetDepAttrs.end(); }

  bool td_empty() const { return TargetDepAttrs.empty(); }

  bool operator==(const AttrBuilder &B);
  bool operator!=(const AttrBuilder &B) {
    return !(*this == B);
  }




  AttrBuilder &addRawValue(uint64_t Val);
};

namespace AttributeFuncs {


AttributeSet typeIncompatible(Type *Ty, uint64_t Index);

}

}
# 31 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CallSite.h" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/CallingConv.h" 1
# 17 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/CallingConv.h"
namespace llvm {




namespace CallingConv {



  enum ID {




    C = 0,







    Fast = 8,





    Cold = 9,


    GHC = 10,



    HiPE = 11,


    WebKit_JS = 12,



    AnyReg = 13,



    FirstTargetCC = 64,





    X86_StdCall = 64,




    X86_FastCall = 65,



    ARM_APCS = 66,



    ARM_AAPCS = 67,


    ARM_AAPCS_VFP = 68,


    MSP430_INTR = 69,




    X86_ThisCall = 70,



    PTX_Kernel = 71,



    PTX_Device = 72,
# 111 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/CallingConv.h"
    SPIR_FUNC = 75,







    SPIR_KERNEL = 76,


    Intel_OCL_BI = 77,



    X86_64_SysV = 78,





    X86_64_Win64 = 79
  };
}

}
# 32 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CallSite.h" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h" 1
# 23 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/DerivedTypes.h" 1
# 21 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/DerivedTypes.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Type.h" 1
# 18 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Type.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APFloat.h" 1
# 20 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APFloat.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h" 1
# 22 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h"
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 1 3
# 21 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/assert.h" 1 3
# 12 "/mnt/home/ec2-user/build/emscripten/system/include/libc/assert.h" 3
extern "C" {



__attribute__((__noreturn__))

void __assert_fail (const char *, const char *, int, const char *);


}
# 22 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 2 3
# 25 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 3
# 23 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h" 2




namespace llvm {
class Deserializer;
class FoldingSetNodeID;
class Serializer;
class StringRef;
class hash_code;
class raw_ostream;

template <typename T> class SmallVectorImpl;



typedef uint64_t integerPart;

const unsigned int host_char_bit = 8;
const unsigned int integerPartWidth =
    host_char_bit * static_cast<unsigned int>(sizeof(integerPart));
# 75 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h"
class APInt {
  unsigned BitWidth;



  union {
    uint64_t VAL;
    uint64_t *pVal;
  };


  enum {

    APINT_BITS_PER_WORD =
        static_cast<unsigned int>(sizeof(uint64_t)) * 8,

    APINT_WORD_SIZE = static_cast<unsigned int>(sizeof(uint64_t))
  };





  APInt(uint64_t *val, unsigned bits) : BitWidth(bits), pVal(val) {}




  bool isSingleWord() const { return BitWidth <= APINT_BITS_PER_WORD; }




  static unsigned whichWord(unsigned bitPosition) {
    return bitPosition / APINT_BITS_PER_WORD;
  }





  static unsigned whichBit(unsigned bitPosition) {
    return bitPosition % APINT_BITS_PER_WORD;
  }







  static uint64_t maskBit(unsigned bitPosition) {
    return 1ULL << whichBit(bitPosition);
  }







  APInt &clearUnusedBits() {

    unsigned wordBits = BitWidth % APINT_BITS_PER_WORD;
    if (wordBits == 0)



      return *this;


    uint64_t mask = ~uint64_t(0ULL) >> (APINT_BITS_PER_WORD - wordBits);
    if (isSingleWord())
      VAL &= mask;
    else
      pVal[getNumWords() - 1] &= mask;
    return *this;
  }



  uint64_t getWord(unsigned bitPosition) const {
    return isSingleWord() ? VAL : pVal[whichWord(bitPosition)];
  }
# 172 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h"
  void fromString(unsigned numBits, StringRef str, uint8_t radix);







  static void divide(const APInt LHS, unsigned lhsWords, const APInt &RHS,
                     unsigned rhsWords, APInt *Quotient, APInt *Remainder);


  void initSlowCase(unsigned numBits, uint64_t val, bool isSigned);


  void initFromArray(ArrayRef<uint64_t> array);


  void initSlowCase(const APInt &that);


  APInt shlSlowCase(unsigned shiftAmt) const;


  APInt AndSlowCase(const APInt &RHS) const;


  APInt OrSlowCase(const APInt &RHS) const;


  APInt XorSlowCase(const APInt &RHS) const;


  APInt &AssignSlowCase(const APInt &RHS);


  bool EqualSlowCase(const APInt &RHS) const;


  bool EqualSlowCase(uint64_t Val) const;


  unsigned countLeadingZerosSlowCase() const;


  unsigned countTrailingOnesSlowCase() const;


  unsigned countPopulationSlowCase() const;

public:
# 236 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h"
  APInt(unsigned numBits, uint64_t val, bool isSigned = false)
      : BitWidth(numBits), VAL(0) {
    ((void)((BitWidth && "bitwidth too small") || (__assert_fail("BitWidth && \"bitwidth too small\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h", 238, __func__),0)));
    if (isSingleWord())
      VAL = val;
    else
      initSlowCase(numBits, val, isSigned);
    clearUnusedBits();
  }
# 253 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h"
  APInt(unsigned numBits, ArrayRef<uint64_t> bigVal);
# 262 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h"
  APInt(unsigned numBits, unsigned numWords, const uint64_t bigVal[]);
# 275 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h"
  APInt(unsigned numBits, StringRef str, uint8_t radix);



  APInt(const APInt &that) : BitWidth(that.BitWidth), VAL(0) {
    ((void)((BitWidth && "bitwidth too small") || (__assert_fail("BitWidth && \"bitwidth too small\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h", 280, __func__),0)));
    if (isSingleWord())
      VAL = that.VAL;
    else
      initSlowCase(that);
  }
# 295 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h"
  ~APInt() {
    if (needsCleanup())
      delete[] pVal;
  }





  explicit APInt() : BitWidth(1) {}


  bool needsCleanup() const { return !isSingleWord(); }



  void Profile(FoldingSetNodeID &id) const;
# 322 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h"
  bool isNegative() const { return (*this)[BitWidth - 1]; }




  bool isNonNegative() const { return !isNegative(); }







  bool isStrictlyPositive() const { return isNonNegative() && !!*this; }




  bool isAllOnesValue() const {
    if (isSingleWord())
      return VAL == ~integerPart(0) >> (APINT_BITS_PER_WORD - BitWidth);
    return countPopulationSlowCase() == BitWidth;
  }





  bool isMaxValue() const { return isAllOnesValue(); }





  bool isMaxSignedValue() const {
    return BitWidth == 1 ? VAL == 0
                         : !isNegative() && countPopulation() == BitWidth - 1;
  }





  bool isMinValue() const { return !*this; }





  bool isMinSignedValue() const {
    return BitWidth == 1 ? VAL == 1 : isNegative() && isPowerOf2();
  }


  bool isIntN(unsigned N) const {
    ((void)((N && "N == 0 ???") || (__assert_fail("N && \"N == 0 ???\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h", 377, __func__),0)));
    return getActiveBits() <= N;
  }


  bool isSignedIntN(unsigned N) const {
    ((void)((N && "N == 0 ???") || (__assert_fail("N && \"N == 0 ???\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h", 383, __func__),0)));
    return getMinSignedBits() <= N;
  }




  bool isPowerOf2() const {
    if (isSingleWord())
      return isPowerOf2_64(VAL);
    return countPopulationSlowCase() == 1;
  }




  bool isSignBit() const { return isMinSignedValue(); }




  bool getBoolValue() const { return !!*this; }



  uint64_t getLimitedValue(uint64_t Limit = ~0ULL) const {
    return (getActiveBits() > 64 || getZExtValue() > Limit) ? Limit
                                                            : getZExtValue();
  }






  static APInt getMaxValue(unsigned numBits) {
    return getAllOnesValue(numBits);
  }


  static APInt getSignedMaxValue(unsigned numBits) {
    APInt API = getAllOnesValue(numBits);
    API.clearBit(numBits - 1);
    return API;
  }


  static APInt getMinValue(unsigned numBits) { return APInt(numBits, 0); }


  static APInt getSignedMinValue(unsigned numBits) {
    APInt API(numBits, 0);
    API.setBit(numBits - 1);
    return API;
  }





  static APInt getSignBit(unsigned BitWidth) {
    return getSignedMinValue(BitWidth);
  }




  static APInt getAllOnesValue(unsigned numBits) {
    return APInt(numBits, (0xffffffffffffffff), true);
  }




  static APInt getNullValue(unsigned numBits) { return APInt(numBits, 0); }







  APInt getHiBits(unsigned numBits) const;







  APInt getLoBits(unsigned numBits) const;


  static APInt getOneBitSet(unsigned numBits, unsigned BitNo) {
    APInt Res(numBits, 0);
    Res.setBit(BitNo);
    return Res;
  }
# 495 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h"
  static APInt getBitsSet(unsigned numBits, unsigned loBit, unsigned hiBit) {
    ((void)((hiBit <= numBits && "hiBit out of range") || (__assert_fail("hiBit <= numBits && \"hiBit out of range\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h", 496, __func__),0)));
    ((void)((loBit < numBits && "loBit out of range") || (__assert_fail("loBit < numBits && \"loBit out of range\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h", 497, __func__),0)));
    if (hiBit < loBit)
      return getLowBitsSet(numBits, hiBit) |
             getHighBitsSet(numBits, numBits - loBit);
    return getLowBitsSet(numBits, hiBit - loBit).shl(loBit);
  }







  static APInt getHighBitsSet(unsigned numBits, unsigned hiBitsSet) {
    ((void)((hiBitsSet <= numBits && "Too many bits to set!") || (__assert_fail("hiBitsSet <= numBits && \"Too many bits to set!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h", 511, __func__),0)));

    if (hiBitsSet == 0)
      return APInt(numBits, 0);
    unsigned shiftAmt = numBits - hiBitsSet;

    if (numBits <= APINT_BITS_PER_WORD)
      return APInt(numBits, ~0ULL << shiftAmt);
    return getAllOnesValue(numBits).shl(shiftAmt);
  }







  static APInt getLowBitsSet(unsigned numBits, unsigned loBitsSet) {
    ((void)((loBitsSet <= numBits && "Too many bits to set!") || (__assert_fail("loBitsSet <= numBits && \"Too many bits to set!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h", 529, __func__),0)));

    if (loBitsSet == 0)
      return APInt(numBits, 0);
    if (loBitsSet == APINT_BITS_PER_WORD)
      return APInt(numBits, (0xffffffffffffffff));

    if (loBitsSet <= APINT_BITS_PER_WORD)
      return APInt(numBits, (0xffffffffffffffff) >> (APINT_BITS_PER_WORD - loBitsSet));
    return getAllOnesValue(numBits).lshr(numBits - loBitsSet);
  }


  static APInt getSplat(unsigned NewLen, const APInt &V) {
    ((void)((NewLen >= V.getBitWidth() && "Can't splat to smaller bit width!") || (__assert_fail("NewLen >= V.getBitWidth() && \"Can't splat to smaller bit width!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h", 543, __func__),0)));

    APInt Val = V.zextOrSelf(NewLen);
    for (unsigned I = V.getBitWidth(); I < NewLen; I <<= 1)
      Val |= Val << I;

    return Val;
  }



  static bool isSameValue(const APInt &I1, const APInt &I2) {
    if (I1.getBitWidth() == I2.getBitWidth())
      return I1 == I2;

    if (I1.getBitWidth() > I2.getBitWidth())
      return I1 == I2.zext(I1.getBitWidth());

    return I1.zext(I2.getBitWidth()) == I2;
  }


  friend hash_code hash_value(const APInt &Arg);




  const uint64_t *getRawData() const {
    if (isSingleWord())
      return &VAL;
    return &pVal[0];
  }
# 583 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h"
  const APInt operator++(int) {
    APInt API(*this);
    ++(*this);
    return API;
  }




  APInt &operator++();




  const APInt operator--(int) {
    APInt API(*this);
    --(*this);
    return API;
  }




  APInt &operator--();






  APInt operator~() const {
    APInt Result(*this);
    Result.flipAllBits();
    return Result;
  }






  APInt operator-() const { return APInt(BitWidth, 0) - (*this); }






  bool operator!() const {
    if (isSingleWord())
      return !VAL;

    for (unsigned i = 0; i != getNumWords(); ++i)
      if (pVal[i])
        return false;
    return true;
  }
# 648 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h"
  APInt &operator=(const APInt &RHS) {

    if (isSingleWord() && RHS.isSingleWord()) {
      VAL = RHS.VAL;
      BitWidth = RHS.BitWidth;
      return clearUnusedBits();
    }

    return AssignSlowCase(RHS);
  }
# 681 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h"
  APInt &operator=(uint64_t RHS);







  APInt &operator&=(const APInt &RHS);







  APInt &operator|=(const APInt &RHS);






  APInt &operator|=(uint64_t RHS) {
    if (isSingleWord()) {
      VAL |= RHS;
      clearUnusedBits();
    } else {
      pVal[0] |= RHS;
    }
    return *this;
  }







  APInt &operator^=(const APInt &RHS);






  APInt &operator*=(const APInt &RHS);






  APInt &operator+=(const APInt &RHS);






  APInt &operator-=(const APInt &RHS);






  APInt &operator<<=(unsigned shiftAmt) {
    *this = shl(shiftAmt);
    return *this;
  }
# 762 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h"
  APInt operator&(const APInt &RHS) const {
    ((void)((BitWidth == RHS.BitWidth && "Bit widths must be the same") || (__assert_fail("BitWidth == RHS.BitWidth && \"Bit widths must be the same\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h", 763, __func__),0)));
    if (isSingleWord())
      return APInt(getBitWidth(), VAL & RHS.VAL);
    return AndSlowCase(RHS);
  }
  APInt __attribute__((__warn_unused_result__)) And(const APInt &RHS) const {
    return this->operator&(RHS);
  }






  APInt operator|(const APInt &RHS) const {
    ((void)((BitWidth == RHS.BitWidth && "Bit widths must be the same") || (__assert_fail("BitWidth == RHS.BitWidth && \"Bit widths must be the same\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h", 778, __func__),0)));
    if (isSingleWord())
      return APInt(getBitWidth(), VAL | RHS.VAL);
    return OrSlowCase(RHS);
  }







  APInt __attribute__((__warn_unused_result__)) Or(const APInt &RHS) const {
    return this->operator|(RHS);
  }






  APInt operator^(const APInt &RHS) const {
    ((void)((BitWidth == RHS.BitWidth && "Bit widths must be the same") || (__assert_fail("BitWidth == RHS.BitWidth && \"Bit widths must be the same\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h", 800, __func__),0)));
    if (isSingleWord())
      return APInt(BitWidth, VAL ^ RHS.VAL);
    return XorSlowCase(RHS);
  }







  APInt __attribute__((__warn_unused_result__)) Xor(const APInt &RHS) const {
    return this->operator^(RHS);
  }




  APInt operator*(const APInt &RHS) const;




  APInt operator+(const APInt &RHS) const;
  APInt operator+(uint64_t RHS) const { return (*this) + APInt(BitWidth, RHS); }




  APInt operator-(const APInt &RHS) const;
  APInt operator-(uint64_t RHS) const { return (*this) - APInt(BitWidth, RHS); }




  APInt operator<<(unsigned Bits) const { return shl(Bits); }




  APInt operator<<(const APInt &Bits) const { return shl(Bits); }




  APInt __attribute__((__warn_unused_result__)) ashr(unsigned shiftAmt) const;




  APInt __attribute__((__warn_unused_result__)) lshr(unsigned shiftAmt) const;




  APInt __attribute__((__warn_unused_result__)) shl(unsigned shiftAmt) const {
    ((void)((shiftAmt <= BitWidth && "Invalid shift amount") || (__assert_fail("shiftAmt <= BitWidth && \"Invalid shift amount\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h", 857, __func__),0)));
    if (isSingleWord()) {
      if (shiftAmt >= BitWidth)
        return APInt(BitWidth, 0);
      return APInt(BitWidth, VAL << shiftAmt);
    }
    return shlSlowCase(shiftAmt);
  }


  APInt __attribute__((__warn_unused_result__)) rotl(unsigned rotateAmt) const;


  APInt __attribute__((__warn_unused_result__)) rotr(unsigned rotateAmt) const;




  APInt __attribute__((__warn_unused_result__)) ashr(const APInt &shiftAmt) const;




  APInt __attribute__((__warn_unused_result__)) lshr(const APInt &shiftAmt) const;




  APInt __attribute__((__warn_unused_result__)) shl(const APInt &shiftAmt) const;


  APInt __attribute__((__warn_unused_result__)) rotl(const APInt &rotateAmt) const;


  APInt __attribute__((__warn_unused_result__)) rotr(const APInt &rotateAmt) const;







  APInt __attribute__((__warn_unused_result__)) udiv(const APInt &RHS) const;




  APInt __attribute__((__warn_unused_result__)) sdiv(const APInt &RHS) const;
# 915 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h"
  APInt __attribute__((__warn_unused_result__)) urem(const APInt &RHS) const;




  APInt __attribute__((__warn_unused_result__)) srem(const APInt &RHS) const;
# 929 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h"
  static void udivrem(const APInt &LHS, const APInt &RHS, APInt &Quotient,
                      APInt &Remainder);

  static void sdivrem(const APInt &LHS, const APInt &RHS, APInt &Quotient,
                      APInt &Remainder);


  APInt sadd_ov(const APInt &RHS, bool &Overflow) const;
  APInt uadd_ov(const APInt &RHS, bool &Overflow) const;
  APInt ssub_ov(const APInt &RHS, bool &Overflow) const;
  APInt usub_ov(const APInt &RHS, bool &Overflow) const;
  APInt sdiv_ov(const APInt &RHS, bool &Overflow) const;
  APInt smul_ov(const APInt &RHS, bool &Overflow) const;
  APInt umul_ov(const APInt &RHS, bool &Overflow) const;
  APInt sshl_ov(unsigned Amt, bool &Overflow) const;




  bool operator[](unsigned bitPosition) const {
    ((void)((bitPosition < getBitWidth() && "Bit position out of bounds!") || (__assert_fail("bitPosition < getBitWidth() && \"Bit position out of bounds!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h", 949, __func__),0)));
    return (maskBit(bitPosition) &
            (isSingleWord() ? VAL : pVal[whichWord(bitPosition)])) !=
           0;
  }
# 963 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h"
  bool operator==(const APInt &RHS) const {
    ((void)((BitWidth == RHS.BitWidth && "Comparison requires equal bit widths") || (__assert_fail("BitWidth == RHS.BitWidth && \"Comparison requires equal bit widths\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h", 964, __func__),0)));
    if (isSingleWord())
      return VAL == RHS.VAL;
    return EqualSlowCase(RHS);
  }







  bool operator==(uint64_t Val) const {
    if (isSingleWord())
      return VAL == Val;
    return EqualSlowCase(Val);
  }







  bool eq(const APInt &RHS) const { return (*this) == RHS; }







  bool operator!=(const APInt &RHS) const { return !((*this) == RHS); }







  bool operator!=(uint64_t Val) const { return !((*this) == Val); }







  bool ne(const APInt &RHS) const { return !((*this) == RHS); }







  bool ult(const APInt &RHS) const;







  bool ult(uint64_t RHS) const { return ult(APInt(getBitWidth(), RHS)); }







  bool slt(const APInt &RHS) const;







  bool slt(uint64_t RHS) const { return slt(APInt(getBitWidth(), RHS)); }







  bool ule(const APInt &RHS) const { return ult(RHS) || eq(RHS); }







  bool ule(uint64_t RHS) const { return ule(APInt(getBitWidth(), RHS)); }







  bool sle(const APInt &RHS) const { return slt(RHS) || eq(RHS); }







  bool sle(uint64_t RHS) const { return sle(APInt(getBitWidth(), RHS)); }







  bool ugt(const APInt &RHS) const { return !ult(RHS) && !eq(RHS); }







  bool ugt(uint64_t RHS) const { return ugt(APInt(getBitWidth(), RHS)); }







  bool sgt(const APInt &RHS) const { return !slt(RHS) && !eq(RHS); }







  bool sgt(uint64_t RHS) const { return sgt(APInt(getBitWidth(), RHS)); }







  bool uge(const APInt &RHS) const { return !ult(RHS); }







  bool uge(uint64_t RHS) const { return uge(APInt(getBitWidth(), RHS)); }







  bool sge(const APInt &RHS) const { return !slt(RHS); }







  bool sge(uint64_t RHS) const { return sge(APInt(getBitWidth(), RHS)); }



  bool intersects(const APInt &RHS) const { return (*this & RHS) != 0; }
# 1154 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h"
  APInt __attribute__((__warn_unused_result__)) trunc(unsigned width) const;







  APInt __attribute__((__warn_unused_result__)) sext(unsigned width) const;






  APInt __attribute__((__warn_unused_result__)) zext(unsigned width) const;





  APInt __attribute__((__warn_unused_result__)) sextOrTrunc(unsigned width) const;





  APInt __attribute__((__warn_unused_result__)) zextOrTrunc(unsigned width) const;





  APInt __attribute__((__warn_unused_result__)) sextOrSelf(unsigned width) const;





  APInt __attribute__((__warn_unused_result__)) zextOrSelf(unsigned width) const;






  void setAllBits() {
    if (isSingleWord())
      VAL = (0xffffffffffffffff);
    else {

      for (unsigned i = 0; i < getNumWords(); ++i)
        pVal[i] = (0xffffffffffffffff);
    }

    clearUnusedBits();
  }




  void setBit(unsigned bitPosition);


  void clearAllBits() {
    if (isSingleWord())
      VAL = 0;
    else
      memset(pVal, 0, getNumWords() * APINT_WORD_SIZE);
  }




  void clearBit(unsigned bitPosition);


  void flipAllBits() {
    if (isSingleWord())
      VAL ^= (0xffffffffffffffff);
    else {
      for (unsigned i = 0; i < getNumWords(); ++i)
        pVal[i] ^= (0xffffffffffffffff);
    }
    clearUnusedBits();
  }





  void flipBit(unsigned bitPosition);






  unsigned getBitWidth() const { return BitWidth; }






  unsigned getNumWords() const { return getNumWords(BitWidth); }







  static unsigned getNumWords(unsigned BitWidth) {
    return (BitWidth + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD;
  }






  unsigned getActiveBits() const { return BitWidth - countLeadingZeros(); }





  unsigned getActiveWords() const {
    unsigned numActiveBits = getActiveBits();
    return numActiveBits ? whichWord(numActiveBits - 1) + 1 : 1;
  }
# 1295 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h"
  unsigned getMinSignedBits() const {
    if (isNegative())
      return BitWidth - countLeadingOnes() + 1;
    return getActiveBits() + 1;
  }






  uint64_t getZExtValue() const {
    if (isSingleWord())
      return VAL;
    ((void)((getActiveBits() <= 64 && "Too many bits for uint64_t") || (__assert_fail("getActiveBits() <= 64 && \"Too many bits for uint64_t\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h", 1309, __func__),0)));
    return pVal[0];
  }






  int64_t getSExtValue() const {
    if (isSingleWord())
      return int64_t(VAL << (APINT_BITS_PER_WORD - BitWidth)) >>
             (APINT_BITS_PER_WORD - BitWidth);
    ((void)((getMinSignedBits() <= 64 && "Too many bits for int64_t") || (__assert_fail("getMinSignedBits() <= 64 && \"Too many bits for int64_t\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h", 1322, __func__),0)));
    return int64_t(pVal[0]);
  }





  static unsigned getBitsNeeded(StringRef str, uint8_t radix);
# 1340 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h"
  unsigned countLeadingZeros() const {
    if (isSingleWord()) {
      unsigned unusedBits = APINT_BITS_PER_WORD - BitWidth;
      return llvm::countLeadingZeros(VAL) - unusedBits;
    }
    return countLeadingZerosSlowCase();
  }
# 1356 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h"
  unsigned countLeadingOnes() const;



  unsigned getNumSignBits() const {
    return isNegative() ? countLeadingOnes() : countLeadingZeros();
  }
# 1372 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h"
  unsigned countTrailingZeros() const;
# 1382 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h"
  unsigned countTrailingOnes() const {
    if (isSingleWord())
      return CountTrailingOnes_64(VAL);
    return countTrailingOnesSlowCase();
  }







  unsigned countPopulation() const {
    if (isSingleWord())
      return CountPopulation_64(VAL);
    return countPopulationSlowCase();
  }




  void print(raw_ostream &OS, bool isSigned) const;



  void toString(SmallVectorImpl<char> &Str, unsigned Radix, bool Signed,
                bool formatAsCLiteral = false) const;



  void toStringUnsigned(SmallVectorImpl<char> &Str, unsigned Radix = 10) const {
    toString(Str, Radix, false, false);
  }



  void toStringSigned(SmallVectorImpl<char> &Str, unsigned Radix = 10) const {
    toString(Str, Radix, true, false);
  }






  std::string toString(unsigned Radix, bool Signed) const;


  APInt __attribute__((__warn_unused_result__)) byteSwap() const;


  double roundToDouble(bool isSigned) const;


  double roundToDouble() const { return roundToDouble(false); }


  double signedRoundToDouble() const { return roundToDouble(true); }






  double bitsToDouble() const {
    union {
      uint64_t I;
      double D;
    } T;
    T.I = (isSingleWord() ? VAL : pVal[0]);
    return T.D;
  }






  float bitsToFloat() const {
    union {
      unsigned I;
      float F;
    } T;
    T.I = unsigned((isSingleWord() ? VAL : pVal[0]));
    return T.F;
  }





  static APInt __attribute__((__warn_unused_result__)) doubleToBits(double V) {
    union {
      uint64_t I;
      double D;
    } T;
    T.D = V;
    return APInt(sizeof T * 8, T.I);
  }





  static APInt __attribute__((__warn_unused_result__)) floatToBits(float V) {
    union {
      unsigned I;
      float F;
    } T;
    T.F = V;
    return APInt(sizeof T * 8, T.I);
  }






  unsigned logBase2() const { return BitWidth - 1 - countLeadingZeros(); }


  unsigned ceilLogBase2() const {
    return BitWidth - (*this - 1).countLeadingZeros();
  }



  int32_t exactLogBase2() const {
    if (!isPowerOf2())
      return -1;
    return logBase2();
  }


  APInt __attribute__((__warn_unused_result__)) sqrt() const;




  APInt __attribute__((__warn_unused_result__)) abs() const {
    if (isNegative())
      return -(*this);
    return *this;
  }


  APInt multiplicativeInverse(const APInt &modulo) const;






  struct ms;
  ms magic() const;


  struct mu;
  mu magicu(unsigned LeadingZeros = 0) const;
# 1554 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h"
  static void tcSet(integerPart *, integerPart, unsigned int);


  static void tcAssign(integerPart *, const integerPart *, unsigned int);


  static bool tcIsZero(const integerPart *, unsigned int);


  static int tcExtractBit(const integerPart *, unsigned int bit);





  static void tcExtract(integerPart *, unsigned int dstCount,
                        const integerPart *, unsigned int srcBits,
                        unsigned int srcLSB);


  static void tcSetBit(integerPart *, unsigned int bit);


  static void tcClearBit(integerPart *, unsigned int bit);



  static unsigned int tcLSB(const integerPart *, unsigned int);
  static unsigned int tcMSB(const integerPart *parts, unsigned int n);


  static void tcNegate(integerPart *, unsigned int);


  static integerPart tcAdd(integerPart *, const integerPart *,
                           integerPart carry, unsigned);


  static integerPart tcSubtract(integerPart *, const integerPart *,
                                integerPart carry, unsigned);
# 1605 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h"
  static int tcMultiplyPart(integerPart *dst, const integerPart *src,
                            integerPart multiplier, integerPart carry,
                            unsigned int srcParts, unsigned int dstParts,
                            bool add);





  static int tcMultiply(integerPart *, const integerPart *, const integerPart *,
                        unsigned);




  static unsigned int tcFullMultiply(integerPart *, const integerPart *,
                                     const integerPart *, unsigned, unsigned);
# 1632 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APInt.h"
  static int tcDivide(integerPart *lhs, const integerPart *rhs,
                      integerPart *remainder, integerPart *scratch,
                      unsigned int parts);



  static void tcShiftLeft(integerPart *, unsigned int parts,
                          unsigned int count);



  static void tcShiftRight(integerPart *, unsigned int parts,
                           unsigned int count);


  static void tcAnd(integerPart *, const integerPart *, unsigned int);
  static void tcOr(integerPart *, const integerPart *, unsigned int);
  static void tcXor(integerPart *, const integerPart *, unsigned int);
  static void tcComplement(integerPart *, unsigned int);


  static int tcCompare(const integerPart *, const integerPart *, unsigned int);


  static integerPart tcIncrement(integerPart *, unsigned int);


  static integerPart tcDecrement(integerPart *, unsigned int);


  static void tcSetLeastSignificantBits(integerPart *, unsigned int,
                                        unsigned int bits);


  void dump() const;


};


struct APInt::ms {
  APInt m;
  unsigned s;
};


struct APInt::mu {
  APInt m;
  bool a;
  unsigned s;
};

inline bool operator==(uint64_t V1, const APInt &V2) { return V2 == V1; }

inline bool operator!=(uint64_t V1, const APInt &V2) { return V2 != V1; }

inline raw_ostream &operator<<(raw_ostream &OS, const APInt &I) {
  I.print(OS, true);
  return OS;
}

namespace APIntOps {


inline APInt smin(const APInt &A, const APInt &B) { return A.slt(B) ? A : B; }


inline APInt smax(const APInt &A, const APInt &B) { return A.sgt(B) ? A : B; }


inline APInt umin(const APInt &A, const APInt &B) { return A.ult(B) ? A : B; }


inline APInt umax(const APInt &A, const APInt &B) { return A.ugt(B) ? A : B; }


inline bool isIntN(unsigned N, const APInt &APIVal) { return APIVal.isIntN(N); }


inline bool isSignedIntN(unsigned N, const APInt &APIVal) {
  return APIVal.isSignedIntN(N);
}



inline bool isMask(unsigned numBits, const APInt &APIVal) {
  return numBits <= APIVal.getBitWidth() &&
         APIVal == APInt::getLowBitsSet(APIVal.getBitWidth(), numBits);
}



inline bool isShiftedMask(unsigned numBits, const APInt &APIVal) {
  return isMask(numBits, (APIVal - APInt(numBits, 1)) | APIVal);
}


inline APInt byteSwap(const APInt &APIVal) { return APIVal.byteSwap(); }


inline unsigned logBase2(const APInt &APIVal) { return APIVal.logBase2(); }







APInt GreatestCommonDivisor(const APInt &Val1, const APInt &Val2);




inline double RoundAPIntToDouble(const APInt &APIVal) {
  return APIVal.roundToDouble();
}




inline double RoundSignedAPIntToDouble(const APInt &APIVal) {
  return APIVal.signedRoundToDouble();
}


inline float RoundAPIntToFloat(const APInt &APIVal) {
  return float(RoundAPIntToDouble(APIVal));
}




inline float RoundSignedAPIntToFloat(const APInt &APIVal) {
  return float(APIVal.signedRoundToDouble());
}




APInt RoundDoubleToAPInt(double Double, unsigned width);




inline APInt RoundFloatToAPInt(float Float, unsigned width) {
  return RoundDoubleToAPInt(double(Float), width);
}




inline APInt ashr(const APInt &LHS, unsigned shiftAmt) {
  return LHS.ashr(shiftAmt);
}




inline APInt lshr(const APInt &LHS, unsigned shiftAmt) {
  return LHS.lshr(shiftAmt);
}




inline APInt shl(const APInt &LHS, unsigned shiftAmt) {
  return LHS.shl(shiftAmt);
}




inline APInt sdiv(const APInt &LHS, const APInt &RHS) { return LHS.sdiv(RHS); }




inline APInt udiv(const APInt &LHS, const APInt &RHS) { return LHS.udiv(RHS); }




inline APInt srem(const APInt &LHS, const APInt &RHS) { return LHS.srem(RHS); }




inline APInt urem(const APInt &LHS, const APInt &RHS) { return LHS.urem(RHS); }




inline APInt mul(const APInt &LHS, const APInt &RHS) { return LHS * RHS; }




inline APInt add(const APInt &LHS, const APInt &RHS) { return LHS + RHS; }




inline APInt sub(const APInt &LHS, const APInt &RHS) { return LHS - RHS; }





inline APInt And(const APInt &LHS, const APInt &RHS) { return LHS & RHS; }




inline APInt Or(const APInt &LHS, const APInt &RHS) { return LHS | RHS; }




inline APInt Xor(const APInt &LHS, const APInt &RHS) { return LHS ^ RHS; }




inline APInt Not(const APInt &APIVal) { return ~APIVal; }

}



hash_code hash_value(const APInt &Arg);
}
# 21 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APFloat.h" 2

namespace llvm {

struct fltSemantics;
class APSInt;
class StringRef;





enum lostFraction {
  lfExactlyZero,
  lfLessThanHalf,
  lfExactlyHalf,
  lfMoreThanHalf
};
# 122 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APFloat.h"
class APFloat {
public:


  typedef signed short ExponentType;




  static const fltSemantics IEEEhalf;
  static const fltSemantics IEEEsingle;
  static const fltSemantics IEEEdouble;
  static const fltSemantics IEEEquad;
  static const fltSemantics PPCDoubleDouble;
  static const fltSemantics x87DoubleExtended;



  static const fltSemantics Bogus;



  static unsigned int semanticsPrecision(const fltSemantics &);


  enum cmpResult {
    cmpLessThan,
    cmpEqual,
    cmpGreaterThan,
    cmpUnordered
  };


  enum roundingMode {
    rmNearestTiesToEven,
    rmTowardPositive,
    rmTowardNegative,
    rmTowardZero,
    rmNearestTiesToAway
  };




  enum opStatus {
    opOK = 0x00,
    opInvalidOp = 0x01,
    opDivByZero = 0x02,
    opOverflow = 0x04,
    opUnderflow = 0x08,
    opInexact = 0x10
  };


  enum fltCategory {
    fcInfinity,
    fcNaN,
    fcNormal,
    fcZero
  };


  enum uninitializedTag {
    uninitialized
  };




  APFloat(const fltSemantics &);
  APFloat(const fltSemantics &, StringRef);
  APFloat(const fltSemantics &, integerPart);
  APFloat(const fltSemantics &, uninitializedTag);
  APFloat(const fltSemantics &, const APInt &);
  explicit APFloat(double d);
  explicit APFloat(float f);
  APFloat(const APFloat &);
  ~APFloat();




  bool needsCleanup() const { return partCount() > 1; }







  static APFloat getZero(const fltSemantics &Sem, bool Negative = false) {
    APFloat Val(Sem, uninitialized);
    Val.makeZero(Negative);
    return Val;
  }




  static APFloat getInf(const fltSemantics &Sem, bool Negative = false) {
    APFloat Val(Sem, uninitialized);
    Val.makeInf(Negative);
    return Val;
  }






  static APFloat getNaN(const fltSemantics &Sem, bool Negative = false,
                        unsigned type = 0) {
    if (type) {
      APInt fill(64, type);
      return getQNaN(Sem, Negative, &fill);
    } else {
      return getQNaN(Sem, Negative, 0);
    }
  }


  static APFloat getQNaN(const fltSemantics &Sem, bool Negative = false,
                         const APInt *payload = 0) {
    return makeNaN(Sem, false, Negative, payload);
  }


  static APFloat getSNaN(const fltSemantics &Sem, bool Negative = false,
                         const APInt *payload = 0) {
    return makeNaN(Sem, true, Negative, payload);
  }




  static APFloat getLargest(const fltSemantics &Sem, bool Negative = false);





  static APFloat getSmallest(const fltSemantics &Sem, bool Negative = false);





  static APFloat getSmallestNormalized(const fltSemantics &Sem,
                                       bool Negative = false);





  static APFloat getAllOnesValue(unsigned BitWidth, bool isIEEE = false);





  void Profile(FoldingSetNodeID &NID) const;


  void Emit(Serializer &S) const;


  static APFloat ReadVal(Deserializer &D);




  opStatus add(const APFloat &, roundingMode);
  opStatus subtract(const APFloat &, roundingMode);
  opStatus multiply(const APFloat &, roundingMode);
  opStatus divide(const APFloat &, roundingMode);

  opStatus remainder(const APFloat &);

  opStatus mod(const APFloat &, roundingMode);
  opStatus fusedMultiplyAdd(const APFloat &, const APFloat &, roundingMode);
  opStatus roundToIntegral(roundingMode);

  opStatus next(bool nextDown);






  void changeSign();
  void clearSign();
  void copySign(const APFloat &);






  opStatus convert(const fltSemantics &, roundingMode, bool *);
  opStatus convertToInteger(integerPart *, unsigned int, bool, roundingMode,
                            bool *) const;
  opStatus convertToInteger(APSInt &, roundingMode, bool *) const;
  opStatus convertFromAPInt(const APInt &, bool, roundingMode);
  opStatus convertFromSignExtendedInteger(const integerPart *, unsigned int,
                                          bool, roundingMode);
  opStatus convertFromZeroExtendedInteger(const integerPart *, unsigned int,
                                          bool, roundingMode);
  opStatus convertFromString(StringRef, roundingMode);
  APInt bitcastToAPInt() const;
  double convertToDouble() const;
  float convertToFloat() const;






  bool operator==(const APFloat &) const ;



  cmpResult compare(const APFloat &) const;


  bool bitwiseIsEqual(const APFloat &) const;




  unsigned int convertToHexString(char *dst, unsigned int hexDigits,
                                  bool upperCase, roundingMode) const;
# 361 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APFloat.h"
  bool isNegative() const { return sign; }





  bool isNormal() const { return !isDenormal() && isFiniteNonZero(); }





  bool isFinite() const { return !isNaN() && !isInfinity(); }


  bool isZero() const { return category == fcZero; }



  bool isDenormal() const;


  bool isInfinity() const { return category == fcInfinity; }


  bool isNaN() const { return category == fcNaN; }


  bool isSignaling() const;






  fltCategory getCategory() const { return category; }
  const fltSemantics &getSemantics() const { return *semantics; }
  bool isNonZero() const { return category != fcZero; }
  bool isFiniteNonZero() const { return isFinite() && !isZero(); }
  bool isPosZero() const { return isZero() && !isNegative(); }
  bool isNegZero() const { return isZero() && isNegative(); }



  bool isSmallest() const;



  bool isLargest() const;



  APFloat &operator=(const APFloat &);
# 424 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APFloat.h"
  friend hash_code hash_value(const APFloat &Arg);
# 446 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/APFloat.h"
  void toString(SmallVectorImpl<char> &Str, unsigned FormatPrecision = 0,
                unsigned FormatMaxPadding = 3) const;



  bool getExactInverse(APFloat *inv) const;

private:




  integerPart *significandParts();
  const integerPart *significandParts() const;
  unsigned int partCount() const;






  integerPart addSignificand(const APFloat &);
  integerPart subtractSignificand(const APFloat &, integerPart);
  lostFraction addOrSubtractSignificand(const APFloat &, bool subtract);
  lostFraction multiplySignificand(const APFloat &, const APFloat *);
  lostFraction divideSignificand(const APFloat &);
  void incrementSignificand();
  void initialize(const fltSemantics *);
  void shiftSignificandLeft(unsigned int);
  lostFraction shiftSignificandRight(unsigned int);
  unsigned int significandLSB() const;
  unsigned int significandMSB() const;
  void zeroSignificand();

  bool isSignificandAllOnes() const;

  bool isSignificandAllZeros() const;






  opStatus addOrSubtractSpecials(const APFloat &, bool subtract);
  opStatus divideSpecials(const APFloat &);
  opStatus multiplySpecials(const APFloat &);
  opStatus modSpecials(const APFloat &);






  void makeLargest(bool Neg = false);
  void makeSmallest(bool Neg = false);
  void makeNaN(bool SNaN = false, bool Neg = false, const APInt *fill = 0);
  static APFloat makeNaN(const fltSemantics &Sem, bool SNaN, bool Negative,
                         const APInt *fill);
  void makeInf(bool Neg = false);
  void makeZero(bool Neg = false);






  bool convertFromStringSpecials(StringRef str);
  opStatus normalize(roundingMode, lostFraction);
  opStatus addOrSubtract(const APFloat &, roundingMode, bool subtract);
  cmpResult compareAbsoluteValue(const APFloat &) const;
  opStatus handleOverflow(roundingMode);
  bool roundAwayFromZero(roundingMode, lostFraction, unsigned int) const;
  opStatus convertToSignExtendedInteger(integerPart *, unsigned int, bool,
                                        roundingMode, bool *) const;
  opStatus convertFromUnsignedParts(const integerPart *, unsigned int,
                                    roundingMode);
  opStatus convertFromHexadecimalString(StringRef, roundingMode);
  opStatus convertFromDecimalString(StringRef, roundingMode);
  char *convertNormalToHexString(char *, unsigned int, bool,
                                 roundingMode) const;
  opStatus roundSignificandWithExponent(const integerPart *, unsigned int, int,
                                        roundingMode);



  APInt convertHalfAPFloatToAPInt() const;
  APInt convertFloatAPFloatToAPInt() const;
  APInt convertDoubleAPFloatToAPInt() const;
  APInt convertQuadrupleAPFloatToAPInt() const;
  APInt convertF80LongDoubleAPFloatToAPInt() const;
  APInt convertPPCDoubleDoubleAPFloatToAPInt() const;
  void initFromAPInt(const fltSemantics *Sem, const APInt &api);
  void initFromHalfAPInt(const APInt &api);
  void initFromFloatAPInt(const APInt &api);
  void initFromDoubleAPInt(const APInt &api);
  void initFromQuadrupleAPInt(const APInt &api);
  void initFromF80LongDoubleAPInt(const APInt &api);
  void initFromPPCDoubleDoubleAPInt(const APInt &api);

  void assign(const APFloat &);
  void copySignificand(const APFloat &);
  void freeSignificand();


  const fltSemantics *semantics;




  union Significand {
    integerPart part;
    integerPart *parts;
  } significand;


  ExponentType exponent;





  fltCategory category : 3;


  unsigned int sign : 1;
};





hash_code hash_value(const APFloat &Arg);
}
# 19 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Type.h" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/Casting.h" 1
# 19 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/Casting.h"
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 1 3
# 21 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/assert.h" 1 3
# 12 "/mnt/home/ec2-user/build/emscripten/system/include/libc/assert.h" 3
extern "C" {



__attribute__((__noreturn__))

void __assert_fail (const char *, const char *, int, const char *);


}
# 22 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 2 3
# 25 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 3
# 20 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/Casting.h" 2

namespace llvm {
# 31 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/Casting.h"
template<typename From> struct simplify_type {
  typedef From SimpleType;


  static SimpleType &getSimplifiedValue(From &Val) { return Val; }
};

template<typename From> struct simplify_type<const From> {
  typedef typename simplify_type<From>::SimpleType NonConstSimpleType;
  typedef typename add_const_past_pointer<NonConstSimpleType>::type
    SimpleType;
  typedef typename add_lvalue_reference_if_not_pointer<SimpleType>::type
    RetType;
  static RetType getSimplifiedValue(const From& Val) {
    return simplify_type<From>::getSimplifiedValue(const_cast<From&>(Val));
  }
};




template <typename To, typename From, typename Enabler = void>
struct isa_impl {
  static inline bool doit(const From &Val) {
    return To::classof(&Val);
  }
};


template <typename To, typename From>
struct isa_impl<To, From,
                typename enable_if<
                  llvm::is_base_of<To, From>
                >::type
               > {
  static inline bool doit(const From &) { return true; }
};

template <typename To, typename From> struct isa_impl_cl {
  static inline bool doit(const From &Val) {
    return isa_impl<To, From>::doit(Val);
  }
};

template <typename To, typename From> struct isa_impl_cl<To, const From> {
  static inline bool doit(const From &Val) {
    return isa_impl<To, From>::doit(Val);
  }
};

template <typename To, typename From> struct isa_impl_cl<To, From*> {
  static inline bool doit(const From *Val) {
    ((void)((Val && "isa<> used on a null pointer") || (__assert_fail("Val && \"isa<> used on a null pointer\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/Casting.h", 83, __func__),0)));
    return isa_impl<To, From>::doit(*Val);
  }
};

template <typename To, typename From> struct isa_impl_cl<To, From*const> {
  static inline bool doit(const From *Val) {
    ((void)((Val && "isa<> used on a null pointer") || (__assert_fail("Val && \"isa<> used on a null pointer\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/Casting.h", 90, __func__),0)));
    return isa_impl<To, From>::doit(*Val);
  }
};

template <typename To, typename From> struct isa_impl_cl<To, const From*> {
  static inline bool doit(const From *Val) {
    ((void)((Val && "isa<> used on a null pointer") || (__assert_fail("Val && \"isa<> used on a null pointer\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/Casting.h", 97, __func__),0)));
    return isa_impl<To, From>::doit(*Val);
  }
};

template <typename To, typename From> struct isa_impl_cl<To, const From*const> {
  static inline bool doit(const From *Val) {
    ((void)((Val && "isa<> used on a null pointer") || (__assert_fail("Val && \"isa<> used on a null pointer\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/Casting.h", 104, __func__),0)));
    return isa_impl<To, From>::doit(*Val);
  }
};

template<typename To, typename From, typename SimpleFrom>
struct isa_impl_wrap {


  static bool doit(const From &Val) {
    return isa_impl_wrap<To, SimpleFrom,
      typename simplify_type<SimpleFrom>::SimpleType>::doit(
                          simplify_type<const From>::getSimplifiedValue(Val));
  }
};

template<typename To, typename FromTy>
struct isa_impl_wrap<To, FromTy, FromTy> {

  static bool doit(const FromTy &Val) {
    return isa_impl_cl<To,FromTy>::doit(Val);
  }
};






template <class X, class Y>
inline bool isa(const Y &Val) {
  return isa_impl_wrap<X, const Y,
                       typename simplify_type<const Y>::SimpleType>::doit(Val);
}





template<class To, class From> struct cast_retty;




template<class To, class From> struct cast_retty_impl {
  typedef To& ret_type;
};
template<class To, class From> struct cast_retty_impl<To, const From> {
  typedef const To &ret_type;
};

template<class To, class From> struct cast_retty_impl<To, From*> {
  typedef To* ret_type;
};

template<class To, class From> struct cast_retty_impl<To, const From*> {
  typedef const To* ret_type;
};

template<class To, class From> struct cast_retty_impl<To, const From*const> {
  typedef const To* ret_type;
};


template<class To, class From, class SimpleFrom>
struct cast_retty_wrap {



  typedef typename cast_retty<To, SimpleFrom>::ret_type ret_type;
};

template<class To, class FromTy>
struct cast_retty_wrap<To, FromTy, FromTy> {

  typedef typename cast_retty_impl<To,FromTy>::ret_type ret_type;
};

template<class To, class From>
struct cast_retty {
  typedef typename cast_retty_wrap<To, From,
                   typename simplify_type<From>::SimpleType>::ret_type ret_type;
};




template<class To, class From, class SimpleFrom> struct cast_convert_val {

  static typename cast_retty<To, From>::ret_type doit(From &Val) {
    return cast_convert_val<To, SimpleFrom,
      typename simplify_type<SimpleFrom>::SimpleType>::doit(
                          simplify_type<From>::getSimplifiedValue(Val));
  }
};

template<class To, class FromTy> struct cast_convert_val<To,FromTy,FromTy> {

  static typename cast_retty<To, FromTy>::ret_type doit(const FromTy &Val) {
    typename cast_retty<To, FromTy>::ret_type Res2
     = (typename cast_retty<To, FromTy>::ret_type)const_cast<FromTy&>(Val);
    return Res2;
  }
};

template <class X> struct is_simple_type {
  static const bool value =
      is_same<X, typename simplify_type<X>::SimpleType>::value;
};
# 221 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/Casting.h"
template <class X, class Y>
inline typename enable_if_c<!is_simple_type<Y>::value,
                            typename cast_retty<X, const Y>::ret_type>::type
cast(const Y &Val) {
  ((void)((isa<X>(Val) && "cast<Ty>() argument of incompatible type!") || (__assert_fail("isa<X>(Val) && \"cast<Ty>() argument of incompatible type!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/Casting.h", 225, __func__),0)));
  return cast_convert_val<
      X, const Y, typename simplify_type<const Y>::SimpleType>::doit(Val);
}

template <class X, class Y>
inline typename cast_retty<X, Y>::ret_type cast(Y &Val) {
  ((void)((isa<X>(Val) && "cast<Ty>() argument of incompatible type!") || (__assert_fail("isa<X>(Val) && \"cast<Ty>() argument of incompatible type!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/Casting.h", 232, __func__),0)));
  return cast_convert_val<X, Y,
                          typename simplify_type<Y>::SimpleType>::doit(Val);
}

template <class X, class Y>
inline typename cast_retty<X, Y *>::ret_type cast(Y *Val) {
  ((void)((isa<X>(Val) && "cast<Ty>() argument of incompatible type!") || (__assert_fail("isa<X>(Val) && \"cast<Ty>() argument of incompatible type!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/Casting.h", 239, __func__),0)));
  return cast_convert_val<X, Y*,
                          typename simplify_type<Y*>::SimpleType>::doit(Val);
}




template <class X, class Y>
inline typename cast_retty<X, Y*>::ret_type cast_or_null(Y *Val) {
  if (Val == 0) return 0;
  ((void)((isa<X>(Val) && "cast_or_null<Ty>() argument of incompatible type!") || (__assert_fail("isa<X>(Val) && \"cast_or_null<Ty>() argument of incompatible type!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/Casting.h", 250, __func__),0)));
  return cast<X>(Val);
}
# 263 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/Casting.h"
template <class X, class Y>
inline typename enable_if_c<!is_simple_type<Y>::value,
                            typename cast_retty<X, const Y>::ret_type>::type
dyn_cast(const Y &Val) {
  return isa<X>(Val) ? cast<X>(Val) : 0;
}

template <class X, class Y>
inline typename cast_retty<X, Y>::ret_type dyn_cast(Y &Val) {
  return isa<X>(Val) ? cast<X>(Val) : 0;
}

template <class X, class Y>
inline typename cast_retty<X, Y *>::ret_type dyn_cast(Y *Val) {
  return isa<X>(Val) ? cast<X>(Val) : 0;
}




template <class X, class Y>
inline typename cast_retty<X, Y*>::ret_type dyn_cast_or_null(Y *Val) {
  return (Val && isa<X>(Val)) ? cast<X>(Val) : 0;
}

}
# 20 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Type.h" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CBindingWrapping.h" 1
# 21 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Type.h" 2

# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/ErrorHandling.h" 1
# 22 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/ErrorHandling.h"
namespace llvm {
  class Twine;


  typedef void (*fatal_error_handler_t)(void *user_data,
                                        const std::string& reason,
                                        bool gen_crash_diag);
# 49 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/ErrorHandling.h"
  void install_fatal_error_handler(fatal_error_handler_t handler,
                                   void *user_data = 0);




  void remove_fatal_error_handler();




  struct ScopedFatalErrorHandler {
    explicit ScopedFatalErrorHandler(fatal_error_handler_t handler,
                                     void *user_data = 0) {
      install_fatal_error_handler(handler, user_data);
    }

    ~ScopedFatalErrorHandler() { remove_fatal_error_handler(); }
  };
# 77 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/ErrorHandling.h"
  __attribute__((noreturn)) void report_fatal_error(const char *reason,
                                                  bool gen_crash_diag = true);
  __attribute__((noreturn)) void report_fatal_error(const std::string &reason,
                                                  bool gen_crash_diag = true);
  __attribute__((noreturn)) void report_fatal_error(StringRef reason,
                                                  bool gen_crash_diag = true);
  __attribute__((noreturn)) void report_fatal_error(const Twine &reason,
                                                  bool gen_crash_diag = true);




  __attribute__((noreturn)) void llvm_unreachable_internal(const char *msg=0,
                                                         const char *file=0,
                                                         unsigned line=0);
}
# 23 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Type.h" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h" 1
# 21 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
extern "C" {
# 65 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
typedef int LLVMBool;






typedef struct LLVMOpaqueContext *LLVMContextRef;







typedef struct LLVMOpaqueModule *LLVMModuleRef;






typedef struct LLVMOpaqueType *LLVMTypeRef;






typedef struct LLVMOpaqueValue *LLVMValueRef;






typedef struct LLVMOpaqueBasicBlock *LLVMBasicBlockRef;






typedef struct LLVMOpaqueBuilder *LLVMBuilderRef;






typedef struct LLVMOpaqueModuleProvider *LLVMModuleProviderRef;






typedef struct LLVMOpaqueMemoryBuffer *LLVMMemoryBufferRef;


typedef struct LLVMOpaquePassManager *LLVMPassManagerRef;


typedef struct LLVMOpaquePassRegistry *LLVMPassRegistryRef;





typedef struct LLVMOpaqueUse *LLVMUseRef;

typedef enum {
    LLVMZExtAttribute = 1<<0,
    LLVMSExtAttribute = 1<<1,
    LLVMNoReturnAttribute = 1<<2,
    LLVMInRegAttribute = 1<<3,
    LLVMStructRetAttribute = 1<<4,
    LLVMNoUnwindAttribute = 1<<5,
    LLVMNoAliasAttribute = 1<<6,
    LLVMByValAttribute = 1<<7,
    LLVMNestAttribute = 1<<8,
    LLVMReadNoneAttribute = 1<<9,
    LLVMReadOnlyAttribute = 1<<10,
    LLVMNoInlineAttribute = 1<<11,
    LLVMAlwaysInlineAttribute = 1<<12,
    LLVMOptimizeForSizeAttribute = 1<<13,
    LLVMStackProtectAttribute = 1<<14,
    LLVMStackProtectReqAttribute = 1<<15,
    LLVMAlignment = 31<<16,
    LLVMNoCaptureAttribute = 1<<21,
    LLVMNoRedZoneAttribute = 1<<22,
    LLVMNoImplicitFloatAttribute = 1<<23,
    LLVMNakedAttribute = 1<<24,
    LLVMInlineHintAttribute = 1<<25,
    LLVMStackAlignment = 7<<26,
    LLVMReturnsTwice = 1 << 29,
    LLVMUWTable = 1 << 30,
    LLVMNonLazyBind = 1 << 31
# 172 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
} LLVMAttribute;

typedef enum {

  LLVMRet = 1,
  LLVMBr = 2,
  LLVMSwitch = 3,
  LLVMIndirectBr = 4,
  LLVMInvoke = 5,

  LLVMUnreachable = 7,


  LLVMAdd = 8,
  LLVMFAdd = 9,
  LLVMSub = 10,
  LLVMFSub = 11,
  LLVMMul = 12,
  LLVMFMul = 13,
  LLVMUDiv = 14,
  LLVMSDiv = 15,
  LLVMFDiv = 16,
  LLVMURem = 17,
  LLVMSRem = 18,
  LLVMFRem = 19,


  LLVMShl = 20,
  LLVMLShr = 21,
  LLVMAShr = 22,
  LLVMAnd = 23,
  LLVMOr = 24,
  LLVMXor = 25,


  LLVMAlloca = 26,
  LLVMLoad = 27,
  LLVMStore = 28,
  LLVMGetElementPtr = 29,


  LLVMTrunc = 30,
  LLVMZExt = 31,
  LLVMSExt = 32,
  LLVMFPToUI = 33,
  LLVMFPToSI = 34,
  LLVMUIToFP = 35,
  LLVMSIToFP = 36,
  LLVMFPTrunc = 37,
  LLVMFPExt = 38,
  LLVMPtrToInt = 39,
  LLVMIntToPtr = 40,
  LLVMBitCast = 41,
  LLVMAddrSpaceCast = 60,


  LLVMICmp = 42,
  LLVMFCmp = 43,
  LLVMPHI = 44,
  LLVMCall = 45,
  LLVMSelect = 46,
  LLVMUserOp1 = 47,
  LLVMUserOp2 = 48,
  LLVMVAArg = 49,
  LLVMExtractElement = 50,
  LLVMInsertElement = 51,
  LLVMShuffleVector = 52,
  LLVMExtractValue = 53,
  LLVMInsertValue = 54,


  LLVMFence = 55,
  LLVMAtomicCmpXchg = 56,
  LLVMAtomicRMW = 57,


  LLVMResume = 58,
  LLVMLandingPad = 59

} LLVMOpcode;

typedef enum {
  LLVMVoidTypeKind,
  LLVMHalfTypeKind,
  LLVMFloatTypeKind,
  LLVMDoubleTypeKind,
  LLVMX86_FP80TypeKind,
  LLVMFP128TypeKind,
  LLVMPPC_FP128TypeKind,
  LLVMLabelTypeKind,
  LLVMIntegerTypeKind,
  LLVMFunctionTypeKind,
  LLVMStructTypeKind,
  LLVMArrayTypeKind,
  LLVMPointerTypeKind,
  LLVMVectorTypeKind,
  LLVMMetadataTypeKind,
  LLVMX86_MMXTypeKind
} LLVMTypeKind;

typedef enum {
  LLVMExternalLinkage,
  LLVMAvailableExternallyLinkage,
  LLVMLinkOnceAnyLinkage,
  LLVMLinkOnceODRLinkage,

  LLVMLinkOnceODRAutoHideLinkage,
  LLVMWeakAnyLinkage,
  LLVMWeakODRLinkage,

  LLVMAppendingLinkage,
  LLVMInternalLinkage,

  LLVMPrivateLinkage,
  LLVMDLLImportLinkage,
  LLVMDLLExportLinkage,
  LLVMExternalWeakLinkage,
  LLVMGhostLinkage,
  LLVMCommonLinkage,
  LLVMLinkerPrivateLinkage,
  LLVMLinkerPrivateWeakLinkage
} LLVMLinkage;

typedef enum {
  LLVMDefaultVisibility,
  LLVMHiddenVisibility,
  LLVMProtectedVisibility
} LLVMVisibility;

typedef enum {
  LLVMCCallConv = 0,
  LLVMFastCallConv = 8,
  LLVMColdCallConv = 9,
  LLVMWebKitJSCallConv = 12,
  LLVMAnyRegCallConv = 13,
  LLVMX86StdcallCallConv = 64,
  LLVMX86FastcallCallConv = 65
} LLVMCallConv;

typedef enum {
  LLVMIntEQ = 32,
  LLVMIntNE,
  LLVMIntUGT,
  LLVMIntUGE,
  LLVMIntULT,
  LLVMIntULE,
  LLVMIntSGT,
  LLVMIntSGE,
  LLVMIntSLT,
  LLVMIntSLE
} LLVMIntPredicate;

typedef enum {
  LLVMRealPredicateFalse,
  LLVMRealOEQ,
  LLVMRealOGT,
  LLVMRealOGE,
  LLVMRealOLT,
  LLVMRealOLE,
  LLVMRealONE,
  LLVMRealORD,
  LLVMRealUNO,
  LLVMRealUEQ,
  LLVMRealUGT,
  LLVMRealUGE,
  LLVMRealULT,
  LLVMRealULE,
  LLVMRealUNE,
  LLVMRealPredicateTrue
} LLVMRealPredicate;

typedef enum {
  LLVMLandingPadCatch,
  LLVMLandingPadFilter
} LLVMLandingPadClauseTy;

typedef enum {
  LLVMNotThreadLocal = 0,
  LLVMGeneralDynamicTLSModel,
  LLVMLocalDynamicTLSModel,
  LLVMInitialExecTLSModel,
  LLVMLocalExecTLSModel
} LLVMThreadLocalMode;

typedef enum {
  LLVMAtomicOrderingNotAtomic = 0,
  LLVMAtomicOrderingUnordered = 1,

  LLVMAtomicOrderingMonotonic = 2,


  LLVMAtomicOrderingAcquire = 4,


  LLVMAtomicOrderingRelease = 5,


  LLVMAtomicOrderingAcquireRelease = 6,



  LLVMAtomicOrderingSequentiallyConsistent = 7







} LLVMAtomicOrdering;

typedef enum {
    LLVMAtomicRMWBinOpXchg,
    LLVMAtomicRMWBinOpAdd,
    LLVMAtomicRMWBinOpSub,
    LLVMAtomicRMWBinOpAnd,
    LLVMAtomicRMWBinOpNand,
    LLVMAtomicRMWBinOpOr,
    LLVMAtomicRMWBinOpXor,
    LLVMAtomicRMWBinOpMax,


    LLVMAtomicRMWBinOpMin,


    LLVMAtomicRMWBinOpUMax,


    LLVMAtomicRMWBinOpUMin


} LLVMAtomicRMWBinOp;





void LLVMInitializeCore(LLVMPassRegistryRef R);




void LLVMShutdown(void);




char *LLVMCreateMessage(const char *Message);
void LLVMDisposeMessage(char *Message);

typedef void (*LLVMFatalErrorHandler)(const char *Reason);
# 431 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
void LLVMInstallFatalErrorHandler(LLVMFatalErrorHandler Handler);





void LLVMResetFatalErrorHandler(void);






void LLVMEnablePrettyStackTrace(void);
# 464 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMContextRef LLVMContextCreate(void);




LLVMContextRef LLVMGetGlobalContext(void);







void LLVMContextDispose(LLVMContextRef C);

unsigned LLVMGetMDKindIDInContext(LLVMContextRef C, const char* Name,
                                  unsigned SLen);
unsigned LLVMGetMDKindID(const char* Name, unsigned SLen);
# 506 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMModuleRef LLVMModuleCreateWithName(const char *ModuleID);







LLVMModuleRef LLVMModuleCreateWithNameInContext(const char *ModuleID,
                                                LLVMContextRef C);







void LLVMDisposeModule(LLVMModuleRef M);






const char *LLVMGetDataLayout(LLVMModuleRef M);






void LLVMSetDataLayout(LLVMModuleRef M, const char *Triple);






const char *LLVMGetTarget(LLVMModuleRef M);






void LLVMSetTarget(LLVMModuleRef M, const char *Triple);






void LLVMDumpModule(LLVMModuleRef M);







LLVMBool LLVMPrintModuleToFile(LLVMModuleRef M, const char *Filename,
                               char **ErrorMessage);







char *LLVMPrintModuleToString(LLVMModuleRef M);






void LLVMSetModuleInlineAsm(LLVMModuleRef M, const char *Asm);






LLVMContextRef LLVMGetModuleContext(LLVMModuleRef M);




LLVMTypeRef LLVMGetTypeByName(LLVMModuleRef M, const char *Name);






unsigned LLVMGetNamedMetadataNumOperands(LLVMModuleRef M, const char* name);
# 614 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
void LLVMGetNamedMetadataOperands(LLVMModuleRef M, const char* name, LLVMValueRef *Dest);







void LLVMAddNamedMetadataOperand(LLVMModuleRef M, const char* name,
                                 LLVMValueRef Val);






LLVMValueRef LLVMAddFunction(LLVMModuleRef M, const char *Name,
                             LLVMTypeRef FunctionTy);
# 640 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMValueRef LLVMGetNamedFunction(LLVMModuleRef M, const char *Name);






LLVMValueRef LLVMGetFirstFunction(LLVMModuleRef M);






LLVMValueRef LLVMGetLastFunction(LLVMModuleRef M);







LLVMValueRef LLVMGetNextFunction(LLVMValueRef Fn);







LLVMValueRef LLVMGetPreviousFunction(LLVMValueRef Fn);
# 710 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMTypeKind LLVMGetTypeKind(LLVMTypeRef Ty);
# 719 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMBool LLVMTypeIsSized(LLVMTypeRef Ty);






LLVMContextRef LLVMGetTypeContext(LLVMTypeRef Ty);






void LLVMDumpType(LLVMTypeRef Val);







char *LLVMPrintTypeToString(LLVMTypeRef Val);
# 754 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMTypeRef LLVMInt1TypeInContext(LLVMContextRef C);
LLVMTypeRef LLVMInt8TypeInContext(LLVMContextRef C);
LLVMTypeRef LLVMInt16TypeInContext(LLVMContextRef C);
LLVMTypeRef LLVMInt32TypeInContext(LLVMContextRef C);
LLVMTypeRef LLVMInt64TypeInContext(LLVMContextRef C);
LLVMTypeRef LLVMIntTypeInContext(LLVMContextRef C, unsigned NumBits);





LLVMTypeRef LLVMInt1Type(void);
LLVMTypeRef LLVMInt8Type(void);
LLVMTypeRef LLVMInt16Type(void);
LLVMTypeRef LLVMInt32Type(void);
LLVMTypeRef LLVMInt64Type(void);
LLVMTypeRef LLVMIntType(unsigned NumBits);
unsigned LLVMGetIntTypeWidth(LLVMTypeRef IntegerTy);
# 786 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMTypeRef LLVMHalfTypeInContext(LLVMContextRef C);




LLVMTypeRef LLVMFloatTypeInContext(LLVMContextRef C);




LLVMTypeRef LLVMDoubleTypeInContext(LLVMContextRef C);




LLVMTypeRef LLVMX86FP80TypeInContext(LLVMContextRef C);





LLVMTypeRef LLVMFP128TypeInContext(LLVMContextRef C);




LLVMTypeRef LLVMPPCFP128TypeInContext(LLVMContextRef C);






LLVMTypeRef LLVMHalfType(void);
LLVMTypeRef LLVMFloatType(void);
LLVMTypeRef LLVMDoubleType(void);
LLVMTypeRef LLVMX86FP80Type(void);
LLVMTypeRef LLVMFP128Type(void);
LLVMTypeRef LLVMPPCFP128Type(void);
# 842 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMTypeRef LLVMFunctionType(LLVMTypeRef ReturnType,
                             LLVMTypeRef *ParamTypes, unsigned ParamCount,
                             LLVMBool IsVarArg);




LLVMBool LLVMIsFunctionVarArg(LLVMTypeRef FunctionTy);




LLVMTypeRef LLVMGetReturnType(LLVMTypeRef FunctionTy);




unsigned LLVMCountParamTypes(LLVMTypeRef FunctionTy);
# 872 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
void LLVMGetParamTypes(LLVMTypeRef FunctionTy, LLVMTypeRef *Dest);
# 896 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMTypeRef LLVMStructTypeInContext(LLVMContextRef C, LLVMTypeRef *ElementTypes,
                                    unsigned ElementCount, LLVMBool Packed);






LLVMTypeRef LLVMStructType(LLVMTypeRef *ElementTypes, unsigned ElementCount,
                           LLVMBool Packed);






LLVMTypeRef LLVMStructCreateNamed(LLVMContextRef C, const char *Name);






const char *LLVMGetStructName(LLVMTypeRef Ty);






void LLVMStructSetBody(LLVMTypeRef StructTy, LLVMTypeRef *ElementTypes,
                       unsigned ElementCount, LLVMBool Packed);






unsigned LLVMCountStructElementTypes(LLVMTypeRef StructTy);
# 946 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
void LLVMGetStructElementTypes(LLVMTypeRef StructTy, LLVMTypeRef *Dest);






LLVMBool LLVMIsPackedStruct(LLVMTypeRef StructTy);






LLVMBool LLVMIsOpaqueStruct(LLVMTypeRef StructTy);
# 983 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMTypeRef LLVMGetElementType(LLVMTypeRef Ty);
# 993 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMTypeRef LLVMArrayType(LLVMTypeRef ElementType, unsigned ElementCount);
# 1002 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
unsigned LLVMGetArrayLength(LLVMTypeRef ArrayTy);
# 1012 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMTypeRef LLVMPointerType(LLVMTypeRef ElementType, unsigned AddressSpace);
# 1021 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
unsigned LLVMGetPointerAddressSpace(LLVMTypeRef PointerTy);
# 1032 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMTypeRef LLVMVectorType(LLVMTypeRef ElementType, unsigned ElementCount);
# 1041 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
unsigned LLVMGetVectorSize(LLVMTypeRef VectorTy);
# 1056 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMTypeRef LLVMVoidTypeInContext(LLVMContextRef C);




LLVMTypeRef LLVMLabelTypeInContext(LLVMContextRef C);




LLVMTypeRef LLVMX86MMXTypeInContext(LLVMContextRef C);





LLVMTypeRef LLVMVoidType(void);
LLVMTypeRef LLVMLabelType(void);
LLVMTypeRef LLVMX86MMXType(void);
# 1195 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMTypeRef LLVMTypeOf(LLVMValueRef Val);






const char *LLVMGetValueName(LLVMValueRef Val);






void LLVMSetValueName(LLVMValueRef Val, const char *Name);






void LLVMDumpValue(LLVMValueRef Val);







char *LLVMPrintValueToString(LLVMValueRef Val);






void LLVMReplaceAllUsesWith(LLVMValueRef OldVal, LLVMValueRef NewVal);




LLVMBool LLVMIsConstant(LLVMValueRef Val);




LLVMBool LLVMIsUndef(LLVMValueRef Val);
# 1256 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMValueRef LLVMIsAArgument(LLVMValueRef Val); LLVMValueRef LLVMIsABasicBlock(LLVMValueRef Val); LLVMValueRef LLVMIsAInlineAsm(LLVMValueRef Val); LLVMValueRef LLVMIsAMDNode(LLVMValueRef Val); LLVMValueRef LLVMIsAMDString(LLVMValueRef Val); LLVMValueRef LLVMIsAUser(LLVMValueRef Val); LLVMValueRef LLVMIsAConstant(LLVMValueRef Val); LLVMValueRef LLVMIsABlockAddress(LLVMValueRef Val); LLVMValueRef LLVMIsAConstantAggregateZero(LLVMValueRef Val); LLVMValueRef LLVMIsAConstantArray(LLVMValueRef Val); LLVMValueRef LLVMIsAConstantDataSequential(LLVMValueRef Val); LLVMValueRef LLVMIsAConstantDataArray(LLVMValueRef Val); LLVMValueRef LLVMIsAConstantDataVector(LLVMValueRef Val); LLVMValueRef LLVMIsAConstantExpr(LLVMValueRef Val); LLVMValueRef LLVMIsAConstantFP(LLVMValueRef Val); LLVMValueRef LLVMIsAConstantInt(LLVMValueRef Val); LLVMValueRef LLVMIsAConstantPointerNull(LLVMValueRef Val); LLVMValueRef LLVMIsAConstantStruct(LLVMValueRef Val); LLVMValueRef LLVMIsAConstantVector(LLVMValueRef Val); LLVMValueRef LLVMIsAGlobalValue(LLVMValueRef Val); LLVMValueRef LLVMIsAFunction(LLVMValueRef Val); LLVMValueRef LLVMIsAGlobalAlias(LLVMValueRef Val); LLVMValueRef LLVMIsAGlobalVariable(LLVMValueRef Val); LLVMValueRef LLVMIsAUndefValue(LLVMValueRef Val); LLVMValueRef LLVMIsAInstruction(LLVMValueRef Val); LLVMValueRef LLVMIsABinaryOperator(LLVMValueRef Val); LLVMValueRef LLVMIsACallInst(LLVMValueRef Val); LLVMValueRef LLVMIsAIntrinsicInst(LLVMValueRef Val); LLVMValueRef LLVMIsADbgInfoIntrinsic(LLVMValueRef Val); LLVMValueRef LLVMIsADbgDeclareInst(LLVMValueRef Val); LLVMValueRef LLVMIsAMemIntrinsic(LLVMValueRef Val); LLVMValueRef LLVMIsAMemCpyInst(LLVMValueRef Val); LLVMValueRef LLVMIsAMemMoveInst(LLVMValueRef Val); LLVMValueRef LLVMIsAMemSetInst(LLVMValueRef Val); LLVMValueRef LLVMIsACmpInst(LLVMValueRef Val); LLVMValueRef LLVMIsAFCmpInst(LLVMValueRef Val); LLVMValueRef LLVMIsAICmpInst(LLVMValueRef Val); LLVMValueRef LLVMIsAExtractElementInst(LLVMValueRef Val); LLVMValueRef LLVMIsAGetElementPtrInst(LLVMValueRef Val); LLVMValueRef LLVMIsAInsertElementInst(LLVMValueRef Val); LLVMValueRef LLVMIsAInsertValueInst(LLVMValueRef Val); LLVMValueRef LLVMIsALandingPadInst(LLVMValueRef Val); LLVMValueRef LLVMIsAPHINode(LLVMValueRef Val); LLVMValueRef LLVMIsASelectInst(LLVMValueRef Val); LLVMValueRef LLVMIsAShuffleVectorInst(LLVMValueRef Val); LLVMValueRef LLVMIsAStoreInst(LLVMValueRef Val); LLVMValueRef LLVMIsATerminatorInst(LLVMValueRef Val); LLVMValueRef LLVMIsABranchInst(LLVMValueRef Val); LLVMValueRef LLVMIsAIndirectBrInst(LLVMValueRef Val); LLVMValueRef LLVMIsAInvokeInst(LLVMValueRef Val); LLVMValueRef LLVMIsAReturnInst(LLVMValueRef Val); LLVMValueRef LLVMIsASwitchInst(LLVMValueRef Val); LLVMValueRef LLVMIsAUnreachableInst(LLVMValueRef Val); LLVMValueRef LLVMIsAResumeInst(LLVMValueRef Val); LLVMValueRef LLVMIsAUnaryInstruction(LLVMValueRef Val); LLVMValueRef LLVMIsAAllocaInst(LLVMValueRef Val); LLVMValueRef LLVMIsACastInst(LLVMValueRef Val); LLVMValueRef LLVMIsAAddrSpaceCastInst(LLVMValueRef Val); LLVMValueRef LLVMIsABitCastInst(LLVMValueRef Val); LLVMValueRef LLVMIsAFPExtInst(LLVMValueRef Val); LLVMValueRef LLVMIsAFPToSIInst(LLVMValueRef Val); LLVMValueRef LLVMIsAFPToUIInst(LLVMValueRef Val); LLVMValueRef LLVMIsAFPTruncInst(LLVMValueRef Val); LLVMValueRef LLVMIsAIntToPtrInst(LLVMValueRef Val); LLVMValueRef LLVMIsAPtrToIntInst(LLVMValueRef Val); LLVMValueRef LLVMIsASExtInst(LLVMValueRef Val); LLVMValueRef LLVMIsASIToFPInst(LLVMValueRef Val); LLVMValueRef LLVMIsATruncInst(LLVMValueRef Val); LLVMValueRef LLVMIsAUIToFPInst(LLVMValueRef Val); LLVMValueRef LLVMIsAZExtInst(LLVMValueRef Val); LLVMValueRef LLVMIsAExtractValueInst(LLVMValueRef Val); LLVMValueRef LLVMIsALoadInst(LLVMValueRef Val); LLVMValueRef LLVMIsAVAArgInst(LLVMValueRef Val);
# 1285 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMUseRef LLVMGetFirstUse(LLVMValueRef Val);







LLVMUseRef LLVMGetNextUse(LLVMUseRef U);
# 1302 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMValueRef LLVMGetUser(LLVMUseRef U);






LLVMValueRef LLVMGetUsedValue(LLVMUseRef U);
# 1330 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMValueRef LLVMGetOperand(LLVMValueRef Val, unsigned Index);






void LLVMSetOperand(LLVMValueRef User, unsigned Index, LLVMValueRef Val);






int LLVMGetNumOperands(LLVMValueRef Val);
# 1367 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMValueRef LLVMConstNull(LLVMTypeRef Ty);
# 1377 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMValueRef LLVMConstAllOnes(LLVMTypeRef Ty);






LLVMValueRef LLVMGetUndef(LLVMTypeRef Ty);






LLVMBool LLVMIsNull(LLVMValueRef Val);





LLVMValueRef LLVMConstPointerNull(LLVMTypeRef Ty);
# 1426 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMValueRef LLVMConstInt(LLVMTypeRef IntTy, unsigned long long N,
                          LLVMBool SignExtend);






LLVMValueRef LLVMConstIntOfArbitraryPrecision(LLVMTypeRef IntTy,
                                              unsigned NumWords,
                                              const uint64_t Words[]);
# 1447 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMValueRef LLVMConstIntOfString(LLVMTypeRef IntTy, const char *Text,
                                  uint8_t Radix);







LLVMValueRef LLVMConstIntOfStringAndSize(LLVMTypeRef IntTy, const char *Text,
                                         unsigned SLen, uint8_t Radix);




LLVMValueRef LLVMConstReal(LLVMTypeRef RealTy, double N);







LLVMValueRef LLVMConstRealOfString(LLVMTypeRef RealTy, const char *Text);




LLVMValueRef LLVMConstRealOfStringAndSize(LLVMTypeRef RealTy, const char *Text,
                                          unsigned SLen);






unsigned long long LLVMConstIntGetZExtValue(LLVMValueRef ConstantVal);






long long LLVMConstIntGetSExtValue(LLVMValueRef ConstantVal);
# 1509 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMValueRef LLVMConstStringInContext(LLVMContextRef C, const char *Str,
                                      unsigned Length, LLVMBool DontNullTerminate);
# 1521 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMValueRef LLVMConstString(const char *Str, unsigned Length,
                             LLVMBool DontNullTerminate);






LLVMValueRef LLVMConstStructInContext(LLVMContextRef C,
                                      LLVMValueRef *ConstantVals,
                                      unsigned Count, LLVMBool Packed);
# 1541 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMValueRef LLVMConstStruct(LLVMValueRef *ConstantVals, unsigned Count,
                             LLVMBool Packed);






LLVMValueRef LLVMConstArray(LLVMTypeRef ElementTy,
                            LLVMValueRef *ConstantVals, unsigned Length);






LLVMValueRef LLVMConstNamedStruct(LLVMTypeRef StructTy,
                                  LLVMValueRef *ConstantVals,
                                  unsigned Count);






LLVMValueRef LLVMConstVector(LLVMValueRef *ScalarConstantVals, unsigned Size);
# 1581 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMOpcode LLVMGetConstOpcode(LLVMValueRef ConstantVal);
LLVMValueRef LLVMAlignOf(LLVMTypeRef Ty);
LLVMValueRef LLVMSizeOf(LLVMTypeRef Ty);
LLVMValueRef LLVMConstNeg(LLVMValueRef ConstantVal);
LLVMValueRef LLVMConstNSWNeg(LLVMValueRef ConstantVal);
LLVMValueRef LLVMConstNUWNeg(LLVMValueRef ConstantVal);
LLVMValueRef LLVMConstFNeg(LLVMValueRef ConstantVal);
LLVMValueRef LLVMConstNot(LLVMValueRef ConstantVal);
LLVMValueRef LLVMConstAdd(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
LLVMValueRef LLVMConstNSWAdd(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
LLVMValueRef LLVMConstNUWAdd(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
LLVMValueRef LLVMConstFAdd(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
LLVMValueRef LLVMConstSub(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
LLVMValueRef LLVMConstNSWSub(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
LLVMValueRef LLVMConstNUWSub(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
LLVMValueRef LLVMConstFSub(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
LLVMValueRef LLVMConstMul(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
LLVMValueRef LLVMConstNSWMul(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
LLVMValueRef LLVMConstNUWMul(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
LLVMValueRef LLVMConstFMul(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
LLVMValueRef LLVMConstUDiv(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
LLVMValueRef LLVMConstSDiv(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
LLVMValueRef LLVMConstExactSDiv(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
LLVMValueRef LLVMConstFDiv(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
LLVMValueRef LLVMConstURem(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
LLVMValueRef LLVMConstSRem(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
LLVMValueRef LLVMConstFRem(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
LLVMValueRef LLVMConstAnd(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
LLVMValueRef LLVMConstOr(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
LLVMValueRef LLVMConstXor(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
LLVMValueRef LLVMConstICmp(LLVMIntPredicate Predicate,
                           LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
LLVMValueRef LLVMConstFCmp(LLVMRealPredicate Predicate,
                           LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
LLVMValueRef LLVMConstShl(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
LLVMValueRef LLVMConstLShr(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
LLVMValueRef LLVMConstAShr(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
LLVMValueRef LLVMConstGEP(LLVMValueRef ConstantVal,
                          LLVMValueRef *ConstantIndices, unsigned NumIndices);
LLVMValueRef LLVMConstInBoundsGEP(LLVMValueRef ConstantVal,
                                  LLVMValueRef *ConstantIndices,
                                  unsigned NumIndices);
LLVMValueRef LLVMConstTrunc(LLVMValueRef ConstantVal, LLVMTypeRef ToType);
LLVMValueRef LLVMConstSExt(LLVMValueRef ConstantVal, LLVMTypeRef ToType);
LLVMValueRef LLVMConstZExt(LLVMValueRef ConstantVal, LLVMTypeRef ToType);
LLVMValueRef LLVMConstFPTrunc(LLVMValueRef ConstantVal, LLVMTypeRef ToType);
LLVMValueRef LLVMConstFPExt(LLVMValueRef ConstantVal, LLVMTypeRef ToType);
LLVMValueRef LLVMConstUIToFP(LLVMValueRef ConstantVal, LLVMTypeRef ToType);
LLVMValueRef LLVMConstSIToFP(LLVMValueRef ConstantVal, LLVMTypeRef ToType);
LLVMValueRef LLVMConstFPToUI(LLVMValueRef ConstantVal, LLVMTypeRef ToType);
LLVMValueRef LLVMConstFPToSI(LLVMValueRef ConstantVal, LLVMTypeRef ToType);
LLVMValueRef LLVMConstPtrToInt(LLVMValueRef ConstantVal, LLVMTypeRef ToType);
LLVMValueRef LLVMConstIntToPtr(LLVMValueRef ConstantVal, LLVMTypeRef ToType);
LLVMValueRef LLVMConstBitCast(LLVMValueRef ConstantVal, LLVMTypeRef ToType);
LLVMValueRef LLVMConstAddrSpaceCast(LLVMValueRef ConstantVal, LLVMTypeRef ToType);
LLVMValueRef LLVMConstZExtOrBitCast(LLVMValueRef ConstantVal,
                                    LLVMTypeRef ToType);
LLVMValueRef LLVMConstSExtOrBitCast(LLVMValueRef ConstantVal,
                                    LLVMTypeRef ToType);
LLVMValueRef LLVMConstTruncOrBitCast(LLVMValueRef ConstantVal,
                                     LLVMTypeRef ToType);
LLVMValueRef LLVMConstPointerCast(LLVMValueRef ConstantVal,
                                  LLVMTypeRef ToType);
LLVMValueRef LLVMConstIntCast(LLVMValueRef ConstantVal, LLVMTypeRef ToType,
                              LLVMBool isSigned);
LLVMValueRef LLVMConstFPCast(LLVMValueRef ConstantVal, LLVMTypeRef ToType);
LLVMValueRef LLVMConstSelect(LLVMValueRef ConstantCondition,
                             LLVMValueRef ConstantIfTrue,
                             LLVMValueRef ConstantIfFalse);
LLVMValueRef LLVMConstExtractElement(LLVMValueRef VectorConstant,
                                     LLVMValueRef IndexConstant);
LLVMValueRef LLVMConstInsertElement(LLVMValueRef VectorConstant,
                                    LLVMValueRef ElementValueConstant,
                                    LLVMValueRef IndexConstant);
LLVMValueRef LLVMConstShuffleVector(LLVMValueRef VectorAConstant,
                                    LLVMValueRef VectorBConstant,
                                    LLVMValueRef MaskConstant);
LLVMValueRef LLVMConstExtractValue(LLVMValueRef AggConstant, unsigned *IdxList,
                                   unsigned NumIdx);
LLVMValueRef LLVMConstInsertValue(LLVMValueRef AggConstant,
                                  LLVMValueRef ElementValueConstant,
                                  unsigned *IdxList, unsigned NumIdx);
LLVMValueRef LLVMConstInlineAsm(LLVMTypeRef Ty,
                                const char *AsmString, const char *Constraints,
                                LLVMBool HasSideEffects, LLVMBool IsAlignStack);
LLVMValueRef LLVMBlockAddress(LLVMValueRef F, LLVMBasicBlockRef BB);
# 1683 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMModuleRef LLVMGetGlobalParent(LLVMValueRef Global);
LLVMBool LLVMIsDeclaration(LLVMValueRef Global);
LLVMLinkage LLVMGetLinkage(LLVMValueRef Global);
void LLVMSetLinkage(LLVMValueRef Global, LLVMLinkage Linkage);
const char *LLVMGetSection(LLVMValueRef Global);
void LLVMSetSection(LLVMValueRef Global, const char *Section);
LLVMVisibility LLVMGetVisibility(LLVMValueRef Global);
void LLVMSetVisibility(LLVMValueRef Global, LLVMVisibility Viz);
# 1705 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
unsigned LLVMGetAlignment(LLVMValueRef V);







void LLVMSetAlignment(LLVMValueRef V, unsigned Bytes);
# 1728 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMValueRef LLVMAddGlobal(LLVMModuleRef M, LLVMTypeRef Ty, const char *Name);
LLVMValueRef LLVMAddGlobalInAddressSpace(LLVMModuleRef M, LLVMTypeRef Ty,
                                         const char *Name,
                                         unsigned AddressSpace);
LLVMValueRef LLVMGetNamedGlobal(LLVMModuleRef M, const char *Name);
LLVMValueRef LLVMGetFirstGlobal(LLVMModuleRef M);
LLVMValueRef LLVMGetLastGlobal(LLVMModuleRef M);
LLVMValueRef LLVMGetNextGlobal(LLVMValueRef GlobalVar);
LLVMValueRef LLVMGetPreviousGlobal(LLVMValueRef GlobalVar);
void LLVMDeleteGlobal(LLVMValueRef GlobalVar);
LLVMValueRef LLVMGetInitializer(LLVMValueRef GlobalVar);
void LLVMSetInitializer(LLVMValueRef GlobalVar, LLVMValueRef ConstantVal);
LLVMBool LLVMIsThreadLocal(LLVMValueRef GlobalVar);
void LLVMSetThreadLocal(LLVMValueRef GlobalVar, LLVMBool IsThreadLocal);
LLVMBool LLVMIsGlobalConstant(LLVMValueRef GlobalVar);
void LLVMSetGlobalConstant(LLVMValueRef GlobalVar, LLVMBool IsConstant);
LLVMThreadLocalMode LLVMGetThreadLocalMode(LLVMValueRef GlobalVar);
void LLVMSetThreadLocalMode(LLVMValueRef GlobalVar, LLVMThreadLocalMode Mode);
LLVMBool LLVMIsExternallyInitialized(LLVMValueRef GlobalVar);
void LLVMSetExternallyInitialized(LLVMValueRef GlobalVar, LLVMBool IsExtInit);
# 1762 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMValueRef LLVMAddAlias(LLVMModuleRef M, LLVMTypeRef Ty, LLVMValueRef Aliasee,
                          const char *Name);
# 1785 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
void LLVMDeleteFunction(LLVMValueRef Fn);






unsigned LLVMGetIntrinsicID(LLVMValueRef Fn);
# 1801 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
unsigned LLVMGetFunctionCallConv(LLVMValueRef Fn);
# 1811 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
void LLVMSetFunctionCallConv(LLVMValueRef Fn, unsigned CC);







const char *LLVMGetGC(LLVMValueRef Fn);






void LLVMSetGC(LLVMValueRef Fn, const char *Name);






void LLVMAddFunctionAttr(LLVMValueRef Fn, LLVMAttribute PA);





void LLVMAddTargetDependentFunctionAttr(LLVMValueRef Fn, const char *A,
                                        const char *V);






LLVMAttribute LLVMGetFunctionAttr(LLVMValueRef Fn);




void LLVMRemoveFunctionAttr(LLVMValueRef Fn, LLVMAttribute PA);
# 1870 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
unsigned LLVMCountParams(LLVMValueRef Fn);
# 1883 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
void LLVMGetParams(LLVMValueRef Fn, LLVMValueRef *Params);
# 1892 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMValueRef LLVMGetParam(LLVMValueRef Fn, unsigned Index);
# 1903 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMValueRef LLVMGetParamParent(LLVMValueRef Inst);






LLVMValueRef LLVMGetFirstParam(LLVMValueRef Fn);






LLVMValueRef LLVMGetLastParam(LLVMValueRef Fn);
# 1926 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMValueRef LLVMGetNextParam(LLVMValueRef Arg);






LLVMValueRef LLVMGetPreviousParam(LLVMValueRef Arg);






void LLVMAddAttribute(LLVMValueRef Arg, LLVMAttribute PA);






void LLVMRemoveAttribute(LLVMValueRef Arg, LLVMAttribute PA);




LLVMAttribute LLVMGetAttribute(LLVMValueRef Arg);







void LLVMSetParamAlignment(LLVMValueRef Arg, unsigned align);
# 1993 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMValueRef LLVMMDStringInContext(LLVMContextRef C, const char *Str,
                                   unsigned SLen);




LLVMValueRef LLVMMDString(const char *Str, unsigned SLen);






LLVMValueRef LLVMMDNodeInContext(LLVMContextRef C, LLVMValueRef *Vals,
                                 unsigned Count);




LLVMValueRef LLVMMDNode(LLVMValueRef *Vals, unsigned Count);
# 2021 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
const char *LLVMGetMDString(LLVMValueRef V, unsigned* Len);







unsigned LLVMGetMDNodeNumOperands(LLVMValueRef V);
# 2042 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
void LLVMGetMDNodeOperands(LLVMValueRef V, LLVMValueRef *Dest);
# 2068 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMValueRef LLVMBasicBlockAsValue(LLVMBasicBlockRef BB);




LLVMBool LLVMValueIsBasicBlock(LLVMValueRef Val);




LLVMBasicBlockRef LLVMValueAsBasicBlock(LLVMValueRef Val);






LLVMValueRef LLVMGetBasicBlockParent(LLVMBasicBlockRef BB);
# 2097 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMValueRef LLVMGetBasicBlockTerminator(LLVMBasicBlockRef BB);






unsigned LLVMCountBasicBlocks(LLVMValueRef Fn);
# 2114 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
void LLVMGetBasicBlocks(LLVMValueRef Fn, LLVMBasicBlockRef *BasicBlocks);
# 2124 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMBasicBlockRef LLVMGetFirstBasicBlock(LLVMValueRef Fn);






LLVMBasicBlockRef LLVMGetLastBasicBlock(LLVMValueRef Fn);




LLVMBasicBlockRef LLVMGetNextBasicBlock(LLVMBasicBlockRef BB);




LLVMBasicBlockRef LLVMGetPreviousBasicBlock(LLVMBasicBlockRef BB);







LLVMBasicBlockRef LLVMGetEntryBasicBlock(LLVMValueRef Fn);






LLVMBasicBlockRef LLVMAppendBasicBlockInContext(LLVMContextRef C,
                                                LLVMValueRef Fn,
                                                const char *Name);







LLVMBasicBlockRef LLVMAppendBasicBlock(LLVMValueRef Fn, const char *Name);
# 2176 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMBasicBlockRef LLVMInsertBasicBlockInContext(LLVMContextRef C,
                                                LLVMBasicBlockRef BB,
                                                const char *Name);






LLVMBasicBlockRef LLVMInsertBasicBlock(LLVMBasicBlockRef InsertBeforeBB,
                                       const char *Name);
# 2196 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
void LLVMDeleteBasicBlock(LLVMBasicBlockRef BB);
# 2206 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
void LLVMRemoveBasicBlockFromParent(LLVMBasicBlockRef BB);






void LLVMMoveBasicBlockBefore(LLVMBasicBlockRef BB, LLVMBasicBlockRef MovePos);






void LLVMMoveBasicBlockAfter(LLVMBasicBlockRef BB, LLVMBasicBlockRef MovePos);







LLVMValueRef LLVMGetFirstInstruction(LLVMBasicBlockRef BB);






LLVMValueRef LLVMGetLastInstruction(LLVMBasicBlockRef BB);
# 2261 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
int LLVMHasMetadata(LLVMValueRef Val);




LLVMValueRef LLVMGetMetadata(LLVMValueRef Val, unsigned KindID);




void LLVMSetMetadata(LLVMValueRef Val, unsigned KindID, LLVMValueRef Node);






LLVMBasicBlockRef LLVMGetInstructionParent(LLVMValueRef Inst);
# 2288 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMValueRef LLVMGetNextInstruction(LLVMValueRef Inst);







LLVMValueRef LLVMGetPreviousInstruction(LLVMValueRef Inst);
# 2306 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
void LLVMInstructionEraseFromParent(LLVMValueRef Inst);






LLVMOpcode LLVMGetInstructionOpcode(LLVMValueRef Inst);
# 2323 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMIntPredicate LLVMGetICmpPredicate(LLVMValueRef Inst);
# 2344 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
void LLVMSetInstructionCallConv(LLVMValueRef Instr, unsigned CC);
# 2354 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
unsigned LLVMGetInstructionCallConv(LLVMValueRef Instr);


void LLVMAddInstrAttribute(LLVMValueRef Instr, unsigned index, LLVMAttribute);
void LLVMRemoveInstrAttribute(LLVMValueRef Instr, unsigned index,
                              LLVMAttribute);
void LLVMSetInstrParamAlignment(LLVMValueRef Instr, unsigned index,
                                unsigned align);
# 2370 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMBool LLVMIsTailCall(LLVMValueRef CallInst);
# 2379 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
void LLVMSetTailCall(LLVMValueRef CallInst, LLVMBool IsTailCall);
# 2392 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMBasicBlockRef LLVMGetSwitchDefaultDest(LLVMValueRef SwitchInstr);
# 2406 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
void LLVMAddIncoming(LLVMValueRef PhiNode, LLVMValueRef *IncomingValues,
                     LLVMBasicBlockRef *IncomingBlocks, unsigned Count);




unsigned LLVMCountIncoming(LLVMValueRef PhiNode);




LLVMValueRef LLVMGetIncomingValue(LLVMValueRef PhiNode, unsigned Index);




LLVMBasicBlockRef LLVMGetIncomingBlock(LLVMValueRef PhiNode, unsigned Index);
# 2445 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMBuilderRef LLVMCreateBuilderInContext(LLVMContextRef C);
LLVMBuilderRef LLVMCreateBuilder(void);
void LLVMPositionBuilder(LLVMBuilderRef Builder, LLVMBasicBlockRef Block,
                         LLVMValueRef Instr);
void LLVMPositionBuilderBefore(LLVMBuilderRef Builder, LLVMValueRef Instr);
void LLVMPositionBuilderAtEnd(LLVMBuilderRef Builder, LLVMBasicBlockRef Block);
LLVMBasicBlockRef LLVMGetInsertBlock(LLVMBuilderRef Builder);
void LLVMClearInsertionPosition(LLVMBuilderRef Builder);
void LLVMInsertIntoBuilder(LLVMBuilderRef Builder, LLVMValueRef Instr);
void LLVMInsertIntoBuilderWithName(LLVMBuilderRef Builder, LLVMValueRef Instr,
                                   const char *Name);
void LLVMDisposeBuilder(LLVMBuilderRef Builder);


void LLVMSetCurrentDebugLocation(LLVMBuilderRef Builder, LLVMValueRef L);
LLVMValueRef LLVMGetCurrentDebugLocation(LLVMBuilderRef Builder);
void LLVMSetInstDebugLocation(LLVMBuilderRef Builder, LLVMValueRef Inst);


LLVMValueRef LLVMBuildRetVoid(LLVMBuilderRef);
LLVMValueRef LLVMBuildRet(LLVMBuilderRef, LLVMValueRef V);
LLVMValueRef LLVMBuildAggregateRet(LLVMBuilderRef, LLVMValueRef *RetVals,
                                   unsigned N);
LLVMValueRef LLVMBuildBr(LLVMBuilderRef, LLVMBasicBlockRef Dest);
LLVMValueRef LLVMBuildCondBr(LLVMBuilderRef, LLVMValueRef If,
                             LLVMBasicBlockRef Then, LLVMBasicBlockRef Else);
LLVMValueRef LLVMBuildSwitch(LLVMBuilderRef, LLVMValueRef V,
                             LLVMBasicBlockRef Else, unsigned NumCases);
LLVMValueRef LLVMBuildIndirectBr(LLVMBuilderRef B, LLVMValueRef Addr,
                                 unsigned NumDests);
LLVMValueRef LLVMBuildInvoke(LLVMBuilderRef, LLVMValueRef Fn,
                             LLVMValueRef *Args, unsigned NumArgs,
                             LLVMBasicBlockRef Then, LLVMBasicBlockRef Catch,
                             const char *Name);
LLVMValueRef LLVMBuildLandingPad(LLVMBuilderRef B, LLVMTypeRef Ty,
                                 LLVMValueRef PersFn, unsigned NumClauses,
                                 const char *Name);
LLVMValueRef LLVMBuildResume(LLVMBuilderRef B, LLVMValueRef Exn);
LLVMValueRef LLVMBuildUnreachable(LLVMBuilderRef);


void LLVMAddCase(LLVMValueRef Switch, LLVMValueRef OnVal,
                 LLVMBasicBlockRef Dest);


void LLVMAddDestination(LLVMValueRef IndirectBr, LLVMBasicBlockRef Dest);


void LLVMAddClause(LLVMValueRef LandingPad, LLVMValueRef ClauseVal);


void LLVMSetCleanup(LLVMValueRef LandingPad, LLVMBool Val);


LLVMValueRef LLVMBuildAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                          const char *Name);
LLVMValueRef LLVMBuildNSWAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                             const char *Name);
LLVMValueRef LLVMBuildNUWAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                             const char *Name);
LLVMValueRef LLVMBuildFAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                           const char *Name);
LLVMValueRef LLVMBuildSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                          const char *Name);
LLVMValueRef LLVMBuildNSWSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                             const char *Name);
LLVMValueRef LLVMBuildNUWSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                             const char *Name);
LLVMValueRef LLVMBuildFSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                           const char *Name);
LLVMValueRef LLVMBuildMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                          const char *Name);
LLVMValueRef LLVMBuildNSWMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                             const char *Name);
LLVMValueRef LLVMBuildNUWMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                             const char *Name);
LLVMValueRef LLVMBuildFMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                           const char *Name);
LLVMValueRef LLVMBuildUDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                           const char *Name);
LLVMValueRef LLVMBuildSDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                           const char *Name);
LLVMValueRef LLVMBuildExactSDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                                const char *Name);
LLVMValueRef LLVMBuildFDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                           const char *Name);
LLVMValueRef LLVMBuildURem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                           const char *Name);
LLVMValueRef LLVMBuildSRem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                           const char *Name);
LLVMValueRef LLVMBuildFRem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                           const char *Name);
LLVMValueRef LLVMBuildShl(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                           const char *Name);
LLVMValueRef LLVMBuildLShr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                           const char *Name);
LLVMValueRef LLVMBuildAShr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                           const char *Name);
LLVMValueRef LLVMBuildAnd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                          const char *Name);
LLVMValueRef LLVMBuildOr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                          const char *Name);
LLVMValueRef LLVMBuildXor(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS,
                          const char *Name);
LLVMValueRef LLVMBuildBinOp(LLVMBuilderRef B, LLVMOpcode Op,
                            LLVMValueRef LHS, LLVMValueRef RHS,
                            const char *Name);
LLVMValueRef LLVMBuildNeg(LLVMBuilderRef, LLVMValueRef V, const char *Name);
LLVMValueRef LLVMBuildNSWNeg(LLVMBuilderRef B, LLVMValueRef V,
                             const char *Name);
LLVMValueRef LLVMBuildNUWNeg(LLVMBuilderRef B, LLVMValueRef V,
                             const char *Name);
LLVMValueRef LLVMBuildFNeg(LLVMBuilderRef, LLVMValueRef V, const char *Name);
LLVMValueRef LLVMBuildNot(LLVMBuilderRef, LLVMValueRef V, const char *Name);


LLVMValueRef LLVMBuildMalloc(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name);
LLVMValueRef LLVMBuildArrayMalloc(LLVMBuilderRef, LLVMTypeRef Ty,
                                  LLVMValueRef Val, const char *Name);
LLVMValueRef LLVMBuildAlloca(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name);
LLVMValueRef LLVMBuildArrayAlloca(LLVMBuilderRef, LLVMTypeRef Ty,
                                  LLVMValueRef Val, const char *Name);
LLVMValueRef LLVMBuildFree(LLVMBuilderRef, LLVMValueRef PointerVal);
LLVMValueRef LLVMBuildLoad(LLVMBuilderRef, LLVMValueRef PointerVal,
                           const char *Name);
LLVMValueRef LLVMBuildStore(LLVMBuilderRef, LLVMValueRef Val, LLVMValueRef Ptr);
LLVMValueRef LLVMBuildGEP(LLVMBuilderRef B, LLVMValueRef Pointer,
                          LLVMValueRef *Indices, unsigned NumIndices,
                          const char *Name);
LLVMValueRef LLVMBuildInBoundsGEP(LLVMBuilderRef B, LLVMValueRef Pointer,
                                  LLVMValueRef *Indices, unsigned NumIndices,
                                  const char *Name);
LLVMValueRef LLVMBuildStructGEP(LLVMBuilderRef B, LLVMValueRef Pointer,
                                unsigned Idx, const char *Name);
LLVMValueRef LLVMBuildGlobalString(LLVMBuilderRef B, const char *Str,
                                   const char *Name);
LLVMValueRef LLVMBuildGlobalStringPtr(LLVMBuilderRef B, const char *Str,
                                      const char *Name);
LLVMBool LLVMGetVolatile(LLVMValueRef MemoryAccessInst);
void LLVMSetVolatile(LLVMValueRef MemoryAccessInst, LLVMBool IsVolatile);


LLVMValueRef LLVMBuildTrunc(LLVMBuilderRef, LLVMValueRef Val,
                            LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildZExt(LLVMBuilderRef, LLVMValueRef Val,
                           LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildSExt(LLVMBuilderRef, LLVMValueRef Val,
                           LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildFPToUI(LLVMBuilderRef, LLVMValueRef Val,
                             LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildFPToSI(LLVMBuilderRef, LLVMValueRef Val,
                             LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildUIToFP(LLVMBuilderRef, LLVMValueRef Val,
                             LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildSIToFP(LLVMBuilderRef, LLVMValueRef Val,
                             LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildFPTrunc(LLVMBuilderRef, LLVMValueRef Val,
                              LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildFPExt(LLVMBuilderRef, LLVMValueRef Val,
                            LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildPtrToInt(LLVMBuilderRef, LLVMValueRef Val,
                               LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildIntToPtr(LLVMBuilderRef, LLVMValueRef Val,
                               LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildBitCast(LLVMBuilderRef, LLVMValueRef Val,
                              LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildAddrSpaceCast(LLVMBuilderRef, LLVMValueRef Val,
                                    LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildZExtOrBitCast(LLVMBuilderRef, LLVMValueRef Val,
                                    LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildSExtOrBitCast(LLVMBuilderRef, LLVMValueRef Val,
                                    LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildTruncOrBitCast(LLVMBuilderRef, LLVMValueRef Val,
                                     LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildCast(LLVMBuilderRef B, LLVMOpcode Op, LLVMValueRef Val,
                           LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildPointerCast(LLVMBuilderRef, LLVMValueRef Val,
                                  LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildIntCast(LLVMBuilderRef, LLVMValueRef Val,
                              LLVMTypeRef DestTy, const char *Name);
LLVMValueRef LLVMBuildFPCast(LLVMBuilderRef, LLVMValueRef Val,
                             LLVMTypeRef DestTy, const char *Name);


LLVMValueRef LLVMBuildICmp(LLVMBuilderRef, LLVMIntPredicate Op,
                           LLVMValueRef LHS, LLVMValueRef RHS,
                           const char *Name);
LLVMValueRef LLVMBuildFCmp(LLVMBuilderRef, LLVMRealPredicate Op,
                           LLVMValueRef LHS, LLVMValueRef RHS,
                           const char *Name);


LLVMValueRef LLVMBuildPhi(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name);
LLVMValueRef LLVMBuildCall(LLVMBuilderRef, LLVMValueRef Fn,
                           LLVMValueRef *Args, unsigned NumArgs,
                           const char *Name);
LLVMValueRef LLVMBuildSelect(LLVMBuilderRef, LLVMValueRef If,
                             LLVMValueRef Then, LLVMValueRef Else,
                             const char *Name);
LLVMValueRef LLVMBuildVAArg(LLVMBuilderRef, LLVMValueRef List, LLVMTypeRef Ty,
                            const char *Name);
LLVMValueRef LLVMBuildExtractElement(LLVMBuilderRef, LLVMValueRef VecVal,
                                     LLVMValueRef Index, const char *Name);
LLVMValueRef LLVMBuildInsertElement(LLVMBuilderRef, LLVMValueRef VecVal,
                                    LLVMValueRef EltVal, LLVMValueRef Index,
                                    const char *Name);
LLVMValueRef LLVMBuildShuffleVector(LLVMBuilderRef, LLVMValueRef V1,
                                    LLVMValueRef V2, LLVMValueRef Mask,
                                    const char *Name);
LLVMValueRef LLVMBuildExtractValue(LLVMBuilderRef, LLVMValueRef AggVal,
                                   unsigned Index, const char *Name);
LLVMValueRef LLVMBuildInsertValue(LLVMBuilderRef, LLVMValueRef AggVal,
                                  LLVMValueRef EltVal, unsigned Index,
                                  const char *Name);

LLVMValueRef LLVMBuildIsNull(LLVMBuilderRef, LLVMValueRef Val,
                             const char *Name);
LLVMValueRef LLVMBuildIsNotNull(LLVMBuilderRef, LLVMValueRef Val,
                                const char *Name);
LLVMValueRef LLVMBuildPtrDiff(LLVMBuilderRef, LLVMValueRef LHS,
                              LLVMValueRef RHS, const char *Name);
LLVMValueRef LLVMBuildAtomicRMW(LLVMBuilderRef B,LLVMAtomicRMWBinOp op,
                                LLVMValueRef PTR, LLVMValueRef Val,
                                LLVMAtomicOrdering ordering,
                                LLVMBool singleThread);
# 2685 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMModuleProviderRef
LLVMCreateModuleProviderForExistingModule(LLVMModuleRef M);




void LLVMDisposeModuleProvider(LLVMModuleProviderRef M);
# 2703 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMBool LLVMCreateMemoryBufferWithContentsOfFile(const char *Path,
                                                  LLVMMemoryBufferRef *OutMemBuf,
                                                  char **OutMessage);
LLVMBool LLVMCreateMemoryBufferWithSTDIN(LLVMMemoryBufferRef *OutMemBuf,
                                         char **OutMessage);
LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRange(const char *InputData,
                                                          size_t InputDataLength,
                                                          const char *BufferName,
                                                          LLVMBool RequiresNullTerminator);
LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRangeCopy(const char *InputData,
                                                              size_t InputDataLength,
                                                              const char *BufferName);
const char *LLVMGetBufferStart(LLVMMemoryBufferRef MemBuf);
size_t LLVMGetBufferSize(LLVMMemoryBufferRef MemBuf);
void LLVMDisposeMemoryBuffer(LLVMMemoryBufferRef MemBuf);
# 2731 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMPassRegistryRef LLVMGetGlobalPassRegistry(void);
# 2746 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMPassManagerRef LLVMCreatePassManager(void);





LLVMPassManagerRef LLVMCreateFunctionPassManagerForModule(LLVMModuleRef M);


LLVMPassManagerRef LLVMCreateFunctionPassManager(LLVMModuleProviderRef MP);





LLVMBool LLVMRunPassManager(LLVMPassManagerRef PM, LLVMModuleRef M);




LLVMBool LLVMInitializeFunctionPassManager(LLVMPassManagerRef FPM);





LLVMBool LLVMRunFunctionPassManager(LLVMPassManagerRef FPM, LLVMValueRef F);




LLVMBool LLVMFinalizeFunctionPassManager(LLVMPassManagerRef FPM);




void LLVMDisposePassManager(LLVMPassManagerRef PM);
# 2801 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
LLVMBool LLVMStartMultithreaded(void);




void LLVMStopMultithreaded(void);



LLVMBool LLVMIsMultithreaded(void);
# 2825 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm-c/Core.h"
}
# 24 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Type.h" 2

namespace llvm {

class PointerType;
class IntegerType;
class raw_ostream;
class Module;
class LLVMContext;
class LLVMContextImpl;
class StringRef;
template<class GraphType> struct GraphTraits;
# 44 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Type.h"
class Type {
public:







  enum TypeID {

    VoidTyID = 0,
    HalfTyID,
    FloatTyID,
    DoubleTyID,
    X86_FP80TyID,
    FP128TyID,
    PPC_FP128TyID,
    LabelTyID,
    MetadataTyID,
    X86_MMXTyID,



    IntegerTyID,
    FunctionTyID,
    StructTyID,
    ArrayTyID,
    PointerTyID,
    VectorTyID,

    NumTypeIDs,
    LastPrimitiveTyID = X86_MMXTyID,
    FirstDerivedTyID = IntegerTyID
  };

private:

  LLVMContext &Context;





  uint32_t IDAndSubclassData;

protected:
  friend class LLVMContextImpl;
  explicit Type(LLVMContext &C, TypeID tid)
    : Context(C), IDAndSubclassData(0),
      NumContainedTys(0), ContainedTys(0) {
    setTypeID(tid);
  }
  ~Type() {}

  void setTypeID(TypeID ID) {
    IDAndSubclassData = (ID & 0xFF) | (IDAndSubclassData & 0xFFFFFF00);
    ((void)((getTypeID() == ID && "TypeID data too large for field") || (__assert_fail("getTypeID() == ID && \"TypeID data too large for field\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Type.h", 101, __func__),0)));
  }

  unsigned getSubclassData() const { return IDAndSubclassData >> 8; }

  void setSubclassData(unsigned val) {
    IDAndSubclassData = (IDAndSubclassData & 0xFF) | (val << 8);

    ((void)((getSubclassData() == val && "Subclass data too large for field") || (__assert_fail("getSubclassData() == val && \"Subclass data too large for field\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Type.h", 109, __func__),0)));
  }



  unsigned NumContainedTys;






  Type * const *ContainedTys;

public:
  void print(raw_ostream &O) const;
  void dump() const;


  LLVMContext &getContext() const { return Context; }
# 137 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Type.h"
  TypeID getTypeID() const { return (TypeID)(IDAndSubclassData & 0xFF); }


  bool isVoidTy() const { return getTypeID() == VoidTyID; }


  bool isHalfTy() const { return getTypeID() == HalfTyID; }


  bool isFloatTy() const { return getTypeID() == FloatTyID; }


  bool isDoubleTy() const { return getTypeID() == DoubleTyID; }


  bool isX86_FP80Ty() const { return getTypeID() == X86_FP80TyID; }


  bool isFP128Ty() const { return getTypeID() == FP128TyID; }


  bool isPPC_FP128Ty() const { return getTypeID() == PPC_FP128TyID; }



  bool isFloatingPointTy() const {
    return getTypeID() == HalfTyID || getTypeID() == FloatTyID ||
           getTypeID() == DoubleTyID ||
           getTypeID() == X86_FP80TyID || getTypeID() == FP128TyID ||
           getTypeID() == PPC_FP128TyID;
  }

  const fltSemantics &getFltSemantics() const {
    switch (getTypeID()) {
    case HalfTyID: return APFloat::IEEEhalf;
    case FloatTyID: return APFloat::IEEEsingle;
    case DoubleTyID: return APFloat::IEEEdouble;
    case X86_FP80TyID: return APFloat::x87DoubleExtended;
    case FP128TyID: return APFloat::IEEEquad;
    case PPC_FP128TyID: return APFloat::PPCDoubleDouble;
    default: ::llvm::llvm_unreachable_internal("Invalid floating type", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Type.h", 177);
    }
  }


  bool isX86_MMXTy() const { return getTypeID() == X86_MMXTyID; }



  bool isFPOrFPVectorTy() const { return getScalarType()->isFloatingPointTy(); }


  bool isLabelTy() const { return getTypeID() == LabelTyID; }


  bool isMetadataTy() const { return getTypeID() == MetadataTyID; }



  bool isIntegerTy() const { return getTypeID() == IntegerTyID; }


  bool isIntegerTy(unsigned Bitwidth) const;




  bool isIntOrIntVectorTy() const { return getScalarType()->isIntegerTy(); }



  bool isFunctionTy() const { return getTypeID() == FunctionTyID; }



  bool isStructTy() const { return getTypeID() == StructTyID; }



  bool isArrayTy() const { return getTypeID() == ArrayTyID; }



  bool isPointerTy() const { return getTypeID() == PointerTyID; }




  bool isPtrOrPtrVectorTy() const { return getScalarType()->isPointerTy(); }



  bool isVectorTy() const { return getTypeID() == VectorTyID; }






  bool canLosslesslyBitCastTo(Type *Ty) const;



  bool isEmptyTy() const;




  bool isPrimitiveType() const { return getTypeID() <= LastPrimitiveTyID; }
  bool isDerivedType() const { return getTypeID() >= FirstDerivedTyID; }




  bool isFirstClassType() const {
    return getTypeID() != FunctionTyID && getTypeID() != VoidTyID;
  }





  bool isSingleValueType() const {
    return (getTypeID() != VoidTyID && isPrimitiveType()) ||
            getTypeID() == IntegerTyID || getTypeID() == PointerTyID ||
            getTypeID() == VectorTyID;
  }






  bool isAggregateType() const {
    return getTypeID() == StructTyID || getTypeID() == ArrayTyID;
  }





  bool isSized() const {

    if (getTypeID() == IntegerTyID || isFloatingPointTy() ||
        getTypeID() == PointerTyID ||
        getTypeID() == X86_MMXTyID)
      return true;


    if (getTypeID() != StructTyID && getTypeID() != ArrayTyID &&
        getTypeID() != VectorTyID)
      return false;

    return isSizedDerivedType();
  }
# 303 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Type.h"
  unsigned getPrimitiveSizeInBits() const;




  unsigned getScalarSizeInBits();




  int getFPMantissaWidth() const;



  const Type *getScalarType() const;
  Type *getScalarType();




  typedef Type * const *subtype_iterator;
  subtype_iterator subtype_begin() const { return ContainedTys; }
  subtype_iterator subtype_end() const { return &ContainedTys[NumContainedTys];}

  typedef std::reverse_iterator<subtype_iterator> subtype_reverse_iterator;
  subtype_reverse_iterator subtype_rbegin() const {
    return subtype_reverse_iterator(subtype_end());
  }
  subtype_reverse_iterator subtype_rend() const {
    return subtype_reverse_iterator(subtype_begin());
  }





  Type *getContainedType(unsigned i) const {
    ((void)((i < NumContainedTys && "Index out of range!") || (__assert_fail("i < NumContainedTys && \"Index out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Type.h", 340, __func__),0)));
    return ContainedTys[i];
  }



  unsigned getNumContainedTypes() const { return NumContainedTys; }
# 355 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Type.h"
  unsigned getIntegerBitWidth() const;

  Type *getFunctionParamType(unsigned i) const;
  unsigned getFunctionNumParams() const;
  bool isFunctionVarArg() const;

  StringRef getStructName() const;
  unsigned getStructNumElements() const;
  Type *getStructElementType(unsigned N) const;

  Type *getSequentialElementType() const;

  uint64_t getArrayNumElements() const;
  Type *getArrayElementType() const { return getSequentialElementType(); }

  unsigned getVectorNumElements() const;
  Type *getVectorElementType() const { return getSequentialElementType(); }

  Type *getPointerElementType() const { return getSequentialElementType(); }


  unsigned getPointerAddressSpace() const;







  static Type *getPrimitiveType(LLVMContext &C, TypeID IDNumber);




  static Type *getVoidTy(LLVMContext &C);
  static Type *getLabelTy(LLVMContext &C);
  static Type *getHalfTy(LLVMContext &C);
  static Type *getFloatTy(LLVMContext &C);
  static Type *getDoubleTy(LLVMContext &C);
  static Type *getMetadataTy(LLVMContext &C);
  static Type *getX86_FP80Ty(LLVMContext &C);
  static Type *getFP128Ty(LLVMContext &C);
  static Type *getPPC_FP128Ty(LLVMContext &C);
  static Type *getX86_MMXTy(LLVMContext &C);
  static IntegerType *getIntNTy(LLVMContext &C, unsigned N);
  static IntegerType *getInt1Ty(LLVMContext &C);
  static IntegerType *getInt8Ty(LLVMContext &C);
  static IntegerType *getInt16Ty(LLVMContext &C);
  static IntegerType *getInt32Ty(LLVMContext &C);
  static IntegerType *getInt64Ty(LLVMContext &C);





  static PointerType *getHalfPtrTy(LLVMContext &C, unsigned AS = 0);
  static PointerType *getFloatPtrTy(LLVMContext &C, unsigned AS = 0);
  static PointerType *getDoublePtrTy(LLVMContext &C, unsigned AS = 0);
  static PointerType *getX86_FP80PtrTy(LLVMContext &C, unsigned AS = 0);
  static PointerType *getFP128PtrTy(LLVMContext &C, unsigned AS = 0);
  static PointerType *getPPC_FP128PtrTy(LLVMContext &C, unsigned AS = 0);
  static PointerType *getX86_MMXPtrTy(LLVMContext &C, unsigned AS = 0);
  static PointerType *getIntNPtrTy(LLVMContext &C, unsigned N, unsigned AS = 0);
  static PointerType *getInt1PtrTy(LLVMContext &C, unsigned AS = 0);
  static PointerType *getInt8PtrTy(LLVMContext &C, unsigned AS = 0);
  static PointerType *getInt16PtrTy(LLVMContext &C, unsigned AS = 0);
  static PointerType *getInt32PtrTy(LLVMContext &C, unsigned AS = 0);
  static PointerType *getInt64PtrTy(LLVMContext &C, unsigned AS = 0);



  PointerType *getPointerTo(unsigned AddrSpace = 0);

private:



  bool isSizedDerivedType() const;
};


static inline raw_ostream &operator<<(raw_ostream &OS, Type &T) {
  T.print(OS);
  return OS;
}


template <> struct isa_impl<PointerType, Type> {
  static inline bool doit(const Type &Ty) {
    return Ty.getTypeID() == Type::PointerTyID;
  }
};







template <> struct GraphTraits<Type*> {
  typedef Type NodeType;
  typedef Type::subtype_iterator ChildIteratorType;

  static inline NodeType *getEntryNode(Type *T) { return T; }
  static inline ChildIteratorType child_begin(NodeType *N) {
    return N->subtype_begin();
  }
  static inline ChildIteratorType child_end(NodeType *N) {
    return N->subtype_end();
  }
};

template <> struct GraphTraits<const Type*> {
  typedef const Type NodeType;
  typedef Type::subtype_iterator ChildIteratorType;

  static inline NodeType *getEntryNode(NodeType *T) { return T; }
  static inline ChildIteratorType child_begin(NodeType *N) {
    return N->subtype_begin();
  }
  static inline ChildIteratorType child_end(NodeType *N) {
    return N->subtype_end();
  }
};


inline Type *unwrap(LLVMTypeRef P) { return reinterpret_cast<Type*>(P); } inline LLVMTypeRef wrap(const Type *P) { return reinterpret_cast<LLVMTypeRef>(const_cast<Type*>(P)); } template<typename T> inline T *unwrap(LLVMTypeRef P) { return cast<T>(unwrap(P)); }



inline Type **unwrap(LLVMTypeRef* Tys) {
  return reinterpret_cast<Type**>(Tys);
}

inline LLVMTypeRef *wrap(Type **Tys) {
  return reinterpret_cast<LLVMTypeRef*>(const_cast<Type**>(Tys));
}

}
# 22 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/DerivedTypes.h" 2



namespace llvm {

class Value;
class APInt;
class LLVMContext;
template<typename T> class ArrayRef;
class StringRef;





class IntegerType : public Type {
  friend class LLVMContextImpl;

protected:
  explicit IntegerType(LLVMContext &C, unsigned NumBits) : Type(C, IntegerTyID){
    setSubclassData(NumBits);
  }
public:

  enum {
    MIN_INT_BITS = 1,
    MAX_INT_BITS = (1<<23)-1


  };






  static IntegerType *get(LLVMContext &C, unsigned NumBits);


  unsigned getBitWidth() const { return getSubclassData(); }




  uint64_t getBitMask() const {
    return ~uint64_t(0UL) >> (64-getBitWidth());
  }



  uint64_t getSignBit() const {
    return 1ULL << (getBitWidth()-1);
  }




  APInt getMask() const;





  bool isPowerOf2ByteWidth() const;


  static inline bool classof(const Type *T) {
    return T->getTypeID() == IntegerTyID;
  }
};




class FunctionType : public Type {
  FunctionType(const FunctionType &) ;
  const FunctionType &operator=(const FunctionType &) ;
  FunctionType(Type *Result, ArrayRef<Type*> Params, bool IsVarArgs);

public:



  static FunctionType *get(Type *Result,
                           ArrayRef<Type*> Params, bool isVarArg);



  static FunctionType *get(Type *Result, bool isVarArg);



  static bool isValidReturnType(Type *RetTy);



  static bool isValidArgumentType(Type *ArgTy);

  bool isVarArg() const { return getSubclassData()!=0; }
  Type *getReturnType() const { return ContainedTys[0]; }

  typedef Type::subtype_iterator param_iterator;
  param_iterator param_begin() const { return ContainedTys + 1; }
  param_iterator param_end() const { return &ContainedTys[NumContainedTys]; }


  Type *getParamType(unsigned i) const { return ContainedTys[i+1]; }




  unsigned getNumParams() const { return NumContainedTys - 1; }


  static inline bool classof(const Type *T) {
    return T->getTypeID() == FunctionTyID;
  }
};




class CompositeType : public Type {
protected:
  explicit CompositeType(LLVMContext &C, TypeID tid) : Type(C, tid) { }
public:




  Type *getTypeAtIndex(const Value *V);
  Type *getTypeAtIndex(unsigned Idx);
  bool indexValid(const Value *V) const;
  bool indexValid(unsigned Idx) const;


  static inline bool classof(const Type *T) {
    return T->getTypeID() == ArrayTyID ||
           T->getTypeID() == StructTyID ||
           T->getTypeID() == PointerTyID ||
           T->getTypeID() == VectorTyID;
  }
};
# 187 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/DerivedTypes.h"
class StructType : public CompositeType {
  StructType(const StructType &) ;
  const StructType &operator=(const StructType &) ;
  StructType(LLVMContext &C)
    : CompositeType(C, StructTyID), SymbolTableEntry(0) {}
  enum {

    SCDB_HasBody = 1,
    SCDB_Packed = 2,
    SCDB_IsLiteral = 4,
    SCDB_IsSized = 8
  };






  void *SymbolTableEntry;
public:
  ~StructType() {
    delete [] ContainedTys;
  }


  static StructType *create(LLVMContext &Context, StringRef Name);
  static StructType *create(LLVMContext &Context);

  static StructType *create(ArrayRef<Type*> Elements,
                            StringRef Name,
                            bool isPacked = false);
  static StructType *create(ArrayRef<Type*> Elements);
  static StructType *create(LLVMContext &Context,
                            ArrayRef<Type*> Elements,
                            StringRef Name,
                            bool isPacked = false);
  static StructType *create(LLVMContext &Context, ArrayRef<Type*> Elements);
  static StructType *create(StringRef Name, Type *elt1, ...) __attribute__((sentinel));



  static StructType *get(LLVMContext &Context, ArrayRef<Type*> Elements,
                         bool isPacked = false);



  static StructType *get(LLVMContext &Context, bool isPacked = false);





  static StructType *get(Type *elt1, ...) __attribute__((sentinel));

  bool isPacked() const { return (getSubclassData() & SCDB_Packed) != 0; }



  bool isLiteral() const { return (getSubclassData() & SCDB_IsLiteral) != 0; }



  bool isOpaque() const { return (getSubclassData() & SCDB_HasBody) == 0; }


  bool isSized() const;


  bool hasName() const { return SymbolTableEntry != 0; }




  StringRef getName() const;




  void setName(StringRef Name);


  void setBody(ArrayRef<Type*> Elements, bool isPacked = false);
  void setBody(Type *elt1, ...) __attribute__((sentinel));



  static bool isValidElementType(Type *ElemTy);



  typedef Type::subtype_iterator element_iterator;
  element_iterator element_begin() const { return ContainedTys; }
  element_iterator element_end() const { return &ContainedTys[NumContainedTys];}



  bool isLayoutIdentical(StructType *Other) const;


  unsigned getNumElements() const { return NumContainedTys; }
  Type *getElementType(unsigned N) const {
    ((void)((N < NumContainedTys && "Element number out of range!") || (__assert_fail("N < NumContainedTys && \"Element number out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/DerivedTypes.h", 288, __func__),0)));
    return ContainedTys[N];
  }


  static inline bool classof(const Type *T) {
    return T->getTypeID() == StructTyID;
  }
};
# 306 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/DerivedTypes.h"
class SequentialType : public CompositeType {
  Type *ContainedType;
  SequentialType(const SequentialType &) ;
  const SequentialType &operator=(const SequentialType &) ;

protected:
  SequentialType(TypeID TID, Type *ElType)
    : CompositeType(ElType->getContext(), TID), ContainedType(ElType) {
    ContainedTys = &ContainedType;
    NumContainedTys = 1;
  }

public:
  Type *getElementType() const { return ContainedTys[0]; }


  static inline bool classof(const Type *T) {
    return T->getTypeID() == ArrayTyID ||
           T->getTypeID() == PointerTyID ||
           T->getTypeID() == VectorTyID;
  }
};




class ArrayType : public SequentialType {
  uint64_t NumElements;

  ArrayType(const ArrayType &) ;
  const ArrayType &operator=(const ArrayType &) ;
  ArrayType(Type *ElType, uint64_t NumEl);
public:



  static ArrayType *get(Type *ElementType, uint64_t NumElements);



  static bool isValidElementType(Type *ElemTy);

  uint64_t getNumElements() const { return NumElements; }


  static inline bool classof(const Type *T) {
    return T->getTypeID() == ArrayTyID;
  }
};



class VectorType : public SequentialType {
  unsigned NumElements;

  VectorType(const VectorType &) ;
  const VectorType &operator=(const VectorType &) ;
  VectorType(Type *ElType, unsigned NumEl);
public:



  static VectorType *get(Type *ElementType, unsigned NumElements);





  static VectorType *getInteger(VectorType *VTy) {
    unsigned EltBits = VTy->getElementType()->getPrimitiveSizeInBits();
    ((void)((EltBits && "Element size must be of a non-zero size") || (__assert_fail("EltBits && \"Element size must be of a non-zero size\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/DerivedTypes.h", 376, __func__),0)));
    Type *EltTy = IntegerType::get(VTy->getContext(), EltBits);
    return VectorType::get(EltTy, VTy->getNumElements());
  }





  static VectorType *getExtendedElementVectorType(VectorType *VTy) {
    unsigned EltBits = VTy->getElementType()->getPrimitiveSizeInBits();
    Type *EltTy = IntegerType::get(VTy->getContext(), EltBits * 2);
    return VectorType::get(EltTy, VTy->getNumElements());
  }





  static VectorType *getTruncatedElementVectorType(VectorType *VTy) {
    unsigned EltBits = VTy->getElementType()->getPrimitiveSizeInBits();
    ((void)(((EltBits & 1) == 0 && "Cannot truncate vector element with odd bit-width") || (__assert_fail("(EltBits & 1) == 0 && \"Cannot truncate vector element with odd bit-width\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/DerivedTypes.h", 398, __func__),0)));

    Type *EltTy = IntegerType::get(VTy->getContext(), EltBits / 2);
    return VectorType::get(EltTy, VTy->getNumElements());
  }



  static bool isValidElementType(Type *ElemTy);


  unsigned getNumElements() const { return NumElements; }



  unsigned getBitWidth() const {
    return NumElements * getElementType()->getPrimitiveSizeInBits();
  }


  static inline bool classof(const Type *T) {
    return T->getTypeID() == VectorTyID;
  }
};




class PointerType : public SequentialType {
  PointerType(const PointerType &) ;
  const PointerType &operator=(const PointerType &) ;
  explicit PointerType(Type *ElType, unsigned AddrSpace);
public:


  static PointerType *get(Type *ElementType, unsigned AddressSpace);



  static PointerType *getUnqual(Type *ElementType) {
    return PointerType::get(ElementType, 0);
  }



  static bool isValidElementType(Type *ElemTy);


  inline unsigned getAddressSpace() const { return getSubclassData(); }


  static inline bool classof(const Type *T) {
    return T->getTypeID() == PointerTyID;
  }
};

}
# 24 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/InstrTypes.h" 1
# 19 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/InstrTypes.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/Twine.h" 1
# 16 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/Twine.h"
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 1 3
# 21 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/assert.h" 1 3
# 12 "/mnt/home/ec2-user/build/emscripten/system/include/libc/assert.h" 3
extern "C" {



__attribute__((__noreturn__))

void __assert_fail (const char *, const char *, int, const char *);


}
# 22 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 2 3
# 25 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 3
# 17 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/Twine.h" 2


namespace llvm {
  template <typename T>
  class SmallVectorImpl;
  class StringRef;
  class raw_ostream;
# 81 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/Twine.h"
  class Twine {

    enum NodeKind {


      NullKind,


      EmptyKind,


      TwineKind,


      CStringKind,


      StdStringKind,


      StringRefKind,


      CharKind,



      DecUIKind,



      DecIKind,



      DecULKind,


      DecLKind,



      DecULLKind,


      DecLLKind,



      UHexKind
    };

    union Child
    {
      const Twine *twine;
      const char *cString;
      const std::string *stdString;
      const StringRef *stringRef;
      char character;
      unsigned int decUI;
      int decI;
      const unsigned long *decUL;
      const long *decL;
      const unsigned long long *decULL;
      const long long *decLL;
      const uint64_t *uHex;
    };

  private:


    Child LHS;


    Child RHS;



    unsigned char LHSKind;

    unsigned char RHSKind;

  private:

    explicit Twine(NodeKind Kind)
      : LHSKind(Kind), RHSKind(EmptyKind) {
      ((void)((isNullary() && "Invalid kind!") || (__assert_fail("isNullary() && \"Invalid kind!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/Twine.h", 167, __func__),0)));
    }


    explicit Twine(const Twine &_LHS, const Twine &_RHS)
      : LHSKind(TwineKind), RHSKind(TwineKind) {
      LHS.twine = &_LHS;
      RHS.twine = &_RHS;
      ((void)((isValid() && "Invalid twine!") || (__assert_fail("isValid() && \"Invalid twine!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/Twine.h", 175, __func__),0)));
    }


    explicit Twine(Child _LHS, NodeKind _LHSKind,
                   Child _RHS, NodeKind _RHSKind)
      : LHS(_LHS), RHS(_RHS), LHSKind(_LHSKind), RHSKind(_RHSKind) {
      ((void)((isValid() && "Invalid twine!") || (__assert_fail("isValid() && \"Invalid twine!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/Twine.h", 182, __func__),0)));
    }


    bool isNull() const {
      return getLHSKind() == NullKind;
    }


    bool isEmpty() const {
      return getLHSKind() == EmptyKind;
    }


    bool isNullary() const {
      return isNull() || isEmpty();
    }


    bool isUnary() const {
      return getRHSKind() == EmptyKind && !isNullary();
    }


    bool isBinary() const {
      return getLHSKind() != NullKind && getRHSKind() != EmptyKind;
    }



    bool isValid() const {

      if (isNullary() && getRHSKind() != EmptyKind)
        return false;


      if (getRHSKind() == NullKind)
        return false;


      if (getRHSKind() != EmptyKind && getLHSKind() == EmptyKind)
        return false;


      if (getLHSKind() == TwineKind &&
          !LHS.twine->isBinary())
        return false;
      if (getRHSKind() == TwineKind &&
          !RHS.twine->isBinary())
        return false;

      return true;
    }


    NodeKind getLHSKind() const { return (NodeKind) LHSKind; }


    NodeKind getRHSKind() const { return (NodeKind) RHSKind; }


    void printOneChild(raw_ostream &OS, Child Ptr, NodeKind Kind) const;


    void printOneChildRepr(raw_ostream &OS, Child Ptr,
                           NodeKind Kind) const;

  public:




                 Twine() : LHSKind(EmptyKind), RHSKind(EmptyKind) {
      ((void)((isValid() && "Invalid twine!") || (__assert_fail("isValid() && \"Invalid twine!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/Twine.h", 255, __func__),0)));
    }






                 Twine(const char *Str)
      : RHSKind(EmptyKind) {
      if (Str[0] != '\0') {
        LHS.cString = Str;
        LHSKind = CStringKind;
      } else
        LHSKind = EmptyKind;

      ((void)((isValid() && "Invalid twine!") || (__assert_fail("isValid() && \"Invalid twine!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/Twine.h", 271, __func__),0)));
    }


                 Twine(const std::string &Str)
      : LHSKind(StdStringKind), RHSKind(EmptyKind) {
      LHS.stdString = &Str;
      ((void)((isValid() && "Invalid twine!") || (__assert_fail("isValid() && \"Invalid twine!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/Twine.h", 278, __func__),0)));
    }


                 Twine(const StringRef &Str)
      : LHSKind(StringRefKind), RHSKind(EmptyKind) {
      LHS.stringRef = &Str;
      ((void)((isValid() && "Invalid twine!") || (__assert_fail("isValid() && \"Invalid twine!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/Twine.h", 285, __func__),0)));
    }


    explicit Twine(char Val)
      : LHSKind(CharKind), RHSKind(EmptyKind) {
      LHS.character = Val;
    }


    explicit Twine(signed char Val)
      : LHSKind(CharKind), RHSKind(EmptyKind) {
      LHS.character = static_cast<char>(Val);
    }


    explicit Twine(unsigned char Val)
      : LHSKind(CharKind), RHSKind(EmptyKind) {
      LHS.character = static_cast<char>(Val);
    }


    explicit Twine(unsigned Val)
      : LHSKind(DecUIKind), RHSKind(EmptyKind) {
      LHS.decUI = Val;
    }


    explicit Twine(int Val)
      : LHSKind(DecIKind), RHSKind(EmptyKind) {
      LHS.decI = Val;
    }


    explicit Twine(const unsigned long &Val)
      : LHSKind(DecULKind), RHSKind(EmptyKind) {
      LHS.decUL = &Val;
    }


    explicit Twine(const long &Val)
      : LHSKind(DecLKind), RHSKind(EmptyKind) {
      LHS.decL = &Val;
    }


    explicit Twine(const unsigned long long &Val)
      : LHSKind(DecULLKind), RHSKind(EmptyKind) {
      LHS.decULL = &Val;
    }


    explicit Twine(const long long &Val)
      : LHSKind(DecLLKind), RHSKind(EmptyKind) {
      LHS.decLL = &Val;
    }







                 Twine(const char *_LHS, const StringRef &_RHS)
      : LHSKind(CStringKind), RHSKind(StringRefKind) {
      LHS.cString = _LHS;
      RHS.stringRef = &_RHS;
      ((void)((isValid() && "Invalid twine!") || (__assert_fail("isValid() && \"Invalid twine!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/Twine.h", 352, __func__),0)));
    }


                 Twine(const StringRef &_LHS, const char *_RHS)
      : LHSKind(StringRefKind), RHSKind(CStringKind) {
      LHS.stringRef = &_LHS;
      RHS.cString = _RHS;
      ((void)((isValid() && "Invalid twine!") || (__assert_fail("isValid() && \"Invalid twine!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/Twine.h", 360, __func__),0)));
    }



    static Twine createNull() {
      return Twine(NullKind);
    }






    static Twine utohexstr(const uint64_t &Val) {
      Child LHS, RHS;
      LHS.uHex = &Val;
      RHS.twine = 0;
      return Twine(LHS, UHexKind, RHS, EmptyKind);
    }







    bool isTriviallyEmpty() const {
      return isNullary();
    }



    bool isSingleStringRef() const {
      if (getRHSKind() != EmptyKind) return false;

      switch (getLHSKind()) {
      case EmptyKind:
      case CStringKind:
      case StdStringKind:
      case StringRefKind:
        return true;
      default:
        return false;
      }
    }





    Twine concat(const Twine &Suffix) const;






    std::string str() const;



    void toVector(SmallVectorImpl<char> &Out) const;



    StringRef getSingleStringRef() const {
      ((void)((isSingleStringRef() &&"This cannot be had as a single stringref!") || (__assert_fail("isSingleStringRef() &&\"This cannot be had as a single stringref!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/Twine.h", 427, __func__),0)));
      switch (getLHSKind()) {
      default: ::llvm::llvm_unreachable_internal("Out of sync with isSingleStringRef", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/Twine.h", 429);
      case EmptyKind: return StringRef();
      case CStringKind: return StringRef(LHS.cString);
      case StdStringKind: return StringRef(*LHS.stdString);
      case StringRefKind: return *LHS.stringRef;
      }
    }




    StringRef toStringRef(SmallVectorImpl<char> &Out) const;







    StringRef toNullTerminatedStringRef(SmallVectorImpl<char> &Out) const;



    void print(raw_ostream &OS) const;


    void dump() const;


    void printRepr(raw_ostream &OS) const;


    void dumpRepr() const;


  };




  inline Twine Twine::concat(const Twine &Suffix) const {

    if (isNull() || Suffix.isNull())
      return Twine(NullKind);


    if (isEmpty())
      return Suffix;
    if (Suffix.isEmpty())
      return *this;



    Child NewLHS, NewRHS;
    NewLHS.twine = this;
    NewRHS.twine = &Suffix;
    NodeKind NewLHSKind = TwineKind, NewRHSKind = TwineKind;
    if (isUnary()) {
      NewLHS = LHS;
      NewLHSKind = getLHSKind();
    }
    if (Suffix.isUnary()) {
      NewRHS = Suffix.LHS;
      NewRHSKind = Suffix.getLHSKind();
    }

    return Twine(NewLHS, NewLHSKind, NewRHS, NewRHSKind);
  }

  inline Twine operator+(const Twine &LHS, const Twine &RHS) {
    return LHS.concat(RHS);
  }




  inline Twine operator+(const char *LHS, const StringRef &RHS) {
    return Twine(LHS, RHS);
  }




  inline Twine operator+(const StringRef &LHS, const char *RHS) {
    return Twine(LHS, RHS);
  }

  inline raw_ostream &operator<<(raw_ostream &OS, const Twine &RHS) {
    RHS.print(OS);
    return OS;
  }


}
# 20 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/InstrTypes.h" 2

# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.h" 1
# 18 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ilist_node.h" 1
# 18 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ilist_node.h"
namespace llvm {

template<typename NodeTy>
struct ilist_traits;



template<typename NodeTy>
class ilist_half_node {
  friend struct ilist_traits<NodeTy>;
  NodeTy *Prev;
protected:
  NodeTy *getPrev() { return Prev; }
  const NodeTy *getPrev() const { return Prev; }
  void setPrev(NodeTy *P) { Prev = P; }
  ilist_half_node() : Prev(0) {}
};

template<typename NodeTy>
struct ilist_nextprev_traits;




template<typename NodeTy>
class ilist_node : private ilist_half_node<NodeTy> {
  friend struct ilist_nextprev_traits<NodeTy>;
  friend struct ilist_traits<NodeTy>;
  NodeTy *Next;
  NodeTy *getNext() { return Next; }
  const NodeTy *getNext() const { return Next; }
  void setNext(NodeTy *N) { Next = N; }
protected:
  ilist_node() : Next(0) {}

public:




  NodeTy *getPrevNode() {
    NodeTy *Prev = this->getPrev();


    if (!Prev->getNext())
      return 0;

    return Prev;
  }


  const NodeTy *getPrevNode() const {
    const NodeTy *Prev = this->getPrev();


    if (!Prev->getNext())
      return 0;

    return Prev;
  }


  NodeTy *getNextNode() {
    NodeTy *Next = getNext();


    if (!Next->getNext())
      return 0;

    return Next;
  }


  const NodeTy *getNextNode() const {
    const NodeTy *Next = getNext();


    if (!Next->getNext())
      return 0;

    return Next;
  }


};

}
# 19 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.h" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/User.h" 1
# 22 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/User.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Value.h" 1
# 17 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Value.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Use.h" 1
# 35 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Use.h"
namespace llvm {

class Value;
class User;
class Use;
template<typename>
struct simplify_type;


template<>
class PointerLikeTypeTraits<Use**> {
public:
  static inline void *getAsVoidPointer(Use** P) { return P; }
  static inline Use **getFromVoidPointer(void *P) {
    return static_cast<Use**>(P);
  }
  enum { NumLowBitsAvailable = 2 };
};







class Use {
public:


  void swap(Use &RHS);



  typedef PointerIntPair<User*, 1, unsigned> UserRef;

private:
  Use(const Use &U) ;


  ~Use() {
    if (Val) removeFromList();
  }

  enum PrevPtrTag { zeroDigitTag
                  , oneDigitTag
                  , stopTag
                  , fullStopTag };


  Use(PrevPtrTag tag) : Val(0) {
    Prev.setInt(tag);
  }

public:

  operator Value*() const { return Val; }



  Value *get() const { return Val; }



  User *getUser() const;

  inline void set(Value *Val);

  Value *operator=(Value *RHS) {
    set(RHS);
    return RHS;
  }
  const Use &operator=(const Use &RHS) {
    set(RHS.Val);
    return *this;
  }

        Value *operator->() { return Val; }
  const Value *operator->() const { return Val; }

  Use *getNext() const { return Next; }




  static Use *initTags(Use *Start, Use *Stop);



  static void zap(Use *Start, const Use *Stop, bool del = false);

private:
  const Use* getImpliedUser() const;

  Value *Val;
  Use *Next;
  PointerIntPair<Use**, 2, PrevPtrTag> Prev;

  void setPrev(Use **NewPrev) {
    Prev.setPointer(NewPrev);
  }
  void addToList(Use **List) {
    Next = *List;
    if (Next) Next->setPrev(&Next);
    setPrev(List);
    *List = this;
  }
  void removeFromList() {
    Use **StrippedPrev = Prev.getPointer();
    *StrippedPrev = Next;
    if (Next) Next->setPrev(StrippedPrev);
  }

  friend class Value;
};



template<> struct simplify_type<Use> {
  typedef Value* SimpleType;
  static SimpleType getSimplifiedValue(Use &Val) {
    return Val.get();
  }
};
template<> struct simplify_type<const Use> {
  typedef Value* SimpleType;
  static SimpleType getSimplifiedValue(const Use &Val) {
    return Val.get();
  }
};



template<typename UserTy>
class value_use_iterator : public std::iterator<std::forward_iterator_tag,
                                                UserTy*, ptrdiff_t> {
  typedef std::iterator<std::forward_iterator_tag, UserTy*, ptrdiff_t> super;
  typedef value_use_iterator<UserTy> _Self;

  Use *U;
  explicit value_use_iterator(Use *u) : U(u) {}
  friend class Value;
public:
  typedef typename super::reference reference;
  typedef typename super::pointer pointer;

  value_use_iterator() {}

  bool operator==(const _Self &x) const {
    return U == x.U;
  }
  bool operator!=(const _Self &x) const {
    return !operator==(x);
  }


  bool atEnd() const { return U == 0; }


  _Self &operator++() {
    ((void)((U && "Cannot increment end iterator!") || (__assert_fail("U && \"Cannot increment end iterator!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Use.h", 194, __func__),0)));
    U = U->getNext();
    return *this;
  }
  _Self operator++(int) {
    _Self tmp = *this; ++*this; return tmp;
  }


  UserTy *operator*() const {
    ((void)((U && "Cannot dereference end iterator!") || (__assert_fail("U && \"Cannot dereference end iterator!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Use.h", 204, __func__),0)));
    return U->getUser();
  }

  UserTy *operator->() const { return operator*(); }

  Use &getUse() const { return *U; }




  unsigned getOperandNo() const;
};


inline Use *unwrap(LLVMUseRef P) { return reinterpret_cast<Use*>(P); } inline LLVMUseRef wrap(const Use *P) { return reinterpret_cast<LLVMUseRef>(const_cast<Use*>(P)); }

}
# 18 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Value.h" 2





namespace llvm {

class APInt;
class Argument;
class AssemblyAnnotationWriter;
class BasicBlock;
class Constant;
class DataLayout;
class Function;
class GlobalAlias;
class GlobalValue;
class GlobalVariable;
class InlineAsm;
class Instruction;
class LLVMContext;
class MDNode;
class StringRef;
class Twine;
class Type;
class ValueHandleBase;
class ValueSymbolTable;
class raw_ostream;

template<typename ValueTy> class StringMapEntry;
typedef StringMapEntry<Value*> ValueName;
# 66 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Value.h"
class Value {
  const unsigned char SubclassID;
  unsigned char HasValueHandle : 1;
protected:




  unsigned char SubclassOptionalData : 7;

private:



  unsigned short SubclassData;

  Type *VTy;
  Use *UseList;

  friend class ValueSymbolTable;
  friend class ValueHandleBase;
  ValueName *Name;

  void operator=(const Value &) ;
  Value(const Value &) ;

protected:


  virtual void printCustom(raw_ostream &O) const;

  Value(Type *Ty, unsigned scid);
public:
  virtual ~Value();



  void dump() const;



  void print(raw_ostream &O, AssemblyAnnotationWriter *AAW = 0) const;



  Type *getType() const { return VTy; }


  LLVMContext &getContext() const;


  bool hasName() const { return Name != 0 && SubclassID != MDStringVal; }
  ValueName *getValueName() const { return Name; }
  void setValueName(ValueName *VN) { Name = VN; }




  StringRef getName() const;





  void setName(const Twine &Name);




  void takeName(Value *V);





  void replaceAllUsesWith(Value *V);




  typedef value_use_iterator<User> use_iterator;
  typedef value_use_iterator<const User> const_use_iterator;

  bool use_empty() const { return UseList == 0; }
  use_iterator use_begin() { return use_iterator(UseList); }
  const_use_iterator use_begin() const { return const_use_iterator(UseList); }
  use_iterator use_end() { return use_iterator(0); }
  const_use_iterator use_end() const { return const_use_iterator(0); }
  User *use_back() { return *use_begin(); }
  const User *use_back() const { return *use_begin(); }





  bool hasOneUse() const {
    const_use_iterator I = use_begin(), E = use_end();
    if (I == E) return false;
    return ++I == E;
  }



  bool hasNUses(unsigned N) const;




  bool hasNUsesOrMore(unsigned N) const;

  bool isUsedInBasicBlock(const BasicBlock *BB) const;




  unsigned getNumUses() const;



  void addUse(Use &U) { U.addToList(&UseList); }





  enum ValueTy {
    ArgumentVal,
    BasicBlockVal,
    FunctionVal,
    GlobalAliasVal,
    GlobalVariableVal,
    UndefValueVal,
    BlockAddressVal,
    ConstantExprVal,
    ConstantAggregateZeroVal,
    ConstantDataArrayVal,
    ConstantDataVectorVal,
    ConstantIntVal,
    ConstantFPVal,
    ConstantArrayVal,
    ConstantStructVal,
    ConstantVectorVal,
    ConstantPointerNullVal,
    MDNodeVal,
    MDStringVal,
    InlineAsmVal,
    PseudoSourceValueVal,
    FixedStackPseudoSourceValueVal,

    InstructionVal,




    ConstantFirstVal = FunctionVal,
    ConstantLastVal = ConstantPointerNullVal
  };
# 233 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Value.h"
  unsigned getValueID() const {
    return SubclassID;
  }




  unsigned getRawSubclassOptionalData() const {
    return SubclassOptionalData;
  }



  void clearSubclassOptionalData() {
    SubclassOptionalData = 0;
  }



  bool hasSameSubclassOptionalData(const Value *V) const {
    return SubclassOptionalData == V->SubclassOptionalData;
  }



  void intersectOptionalDataWith(const Value *V) {
    SubclassOptionalData &= V->SubclassOptionalData;
  }



  bool hasValueHandle() const { return HasValueHandle; }





  Value *stripPointerCasts();
  const Value *stripPointerCasts() const {
    return const_cast<Value*>(this)->stripPointerCasts();
  }





  Value *stripPointerCastsNoFollowAliases();
  const Value *stripPointerCastsNoFollowAliases() const {
    return const_cast<Value*>(this)->stripPointerCastsNoFollowAliases();
  }





  Value *stripInBoundsConstantOffsets();
  const Value *stripInBoundsConstantOffsets() const {
    return const_cast<Value*>(this)->stripInBoundsConstantOffsets();
  }
# 301 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Value.h"
  Value *stripAndAccumulateInBoundsConstantOffsets(const DataLayout &DL,
                                                   APInt &Offset);
  const Value *stripAndAccumulateInBoundsConstantOffsets(const DataLayout &DL,
                                                         APInt &Offset) const {
    return const_cast<Value *>(this)
        ->stripAndAccumulateInBoundsConstantOffsets(DL, Offset);
  }





  Value *stripInBoundsOffsets();
  const Value *stripInBoundsOffsets() const {
    return const_cast<Value*>(this)->stripInBoundsOffsets();
  }



  bool isDereferenceablePointer() const;





  Value *DoPHITranslation(const BasicBlock *CurBB, const BasicBlock *PredBB);

  const Value *DoPHITranslation(const BasicBlock *CurBB,
                                const BasicBlock *PredBB) const{
    return const_cast<Value*>(this)->DoPHITranslation(CurBB, PredBB);
  }



  static const unsigned MaximumAlignment = 1u << 29;






  void mutateType(Type *Ty) {
    VTy = Ty;
  }

protected:
  unsigned short getSubclassDataFromValue() const { return SubclassData; }
  void setValueSubclassData(unsigned short D) { SubclassData = D; }
};

inline raw_ostream &operator<<(raw_ostream &OS, const Value &V) {
  V.print(OS);
  return OS;
}

void Use::set(Value *V) {
  if (Val) removeFromList();
  Val = V;
  if (V) V->addUse(*this);
}





template <> struct isa_impl<Constant, Value> {
  static inline bool doit(const Value &Val) {
    return Val.getValueID() >= Value::ConstantFirstVal &&
      Val.getValueID() <= Value::ConstantLastVal;
  }
};

template <> struct isa_impl<Argument, Value> {
  static inline bool doit (const Value &Val) {
    return Val.getValueID() == Value::ArgumentVal;
  }
};

template <> struct isa_impl<InlineAsm, Value> {
  static inline bool doit(const Value &Val) {
    return Val.getValueID() == Value::InlineAsmVal;
  }
};

template <> struct isa_impl<Instruction, Value> {
  static inline bool doit(const Value &Val) {
    return Val.getValueID() >= Value::InstructionVal;
  }
};

template <> struct isa_impl<BasicBlock, Value> {
  static inline bool doit(const Value &Val) {
    return Val.getValueID() == Value::BasicBlockVal;
  }
};

template <> struct isa_impl<Function, Value> {
  static inline bool doit(const Value &Val) {
    return Val.getValueID() == Value::FunctionVal;
  }
};

template <> struct isa_impl<GlobalVariable, Value> {
  static inline bool doit(const Value &Val) {
    return Val.getValueID() == Value::GlobalVariableVal;
  }
};

template <> struct isa_impl<GlobalAlias, Value> {
  static inline bool doit(const Value &Val) {
    return Val.getValueID() == Value::GlobalAliasVal;
  }
};

template <> struct isa_impl<GlobalValue, Value> {
  static inline bool doit(const Value &Val) {
    return isa<GlobalVariable>(Val) || isa<Function>(Val) ||
      isa<GlobalAlias>(Val);
  }
};

template <> struct isa_impl<MDNode, Value> {
  static inline bool doit(const Value &Val) {
    return Val.getValueID() == Value::MDNodeVal;
  }
};


template<>
class PointerLikeTypeTraits<Value*> {
  typedef Value* PT;
public:
  static inline void *getAsVoidPointer(PT P) { return P; }
  static inline PT getFromVoidPointer(void *P) {
    return static_cast<PT>(P);
  }
  enum { NumLowBitsAvailable = 2 };
};


inline Value *unwrap(LLVMValueRef P) { return reinterpret_cast<Value*>(P); } inline LLVMValueRef wrap(const Value *P) { return reinterpret_cast<LLVMValueRef>(const_cast<Value*>(P)); } template<typename T> inline T *unwrap(LLVMValueRef P) { return cast<T>(unwrap(P)); }



inline Value **unwrap(LLVMValueRef *Vals) {
  return reinterpret_cast<Value**>(Vals);
}

template<typename T>
inline T **unwrap(LLVMValueRef *Vals, unsigned Length) {




  (void)Length;
  return reinterpret_cast<T**>(Vals);
}

inline LLVMValueRef *wrap(const Value **Vals) {
  return reinterpret_cast<LLVMValueRef*>(const_cast<Value**>(Vals));
}

}
# 23 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/User.h" 2


namespace llvm {




template <class>
struct OperandTraits;

class User : public Value {
  User(const User &) ;
  void *operator new(size_t) ;
  template <unsigned>
  friend struct HungoffOperandTraits;
  virtual void anchor();
protected:





  Use *OperandList;



  unsigned NumOperands;

  void *operator new(size_t s, unsigned Us);
  User(Type *ty, unsigned vty, Use *OpList, unsigned NumOps)
    : Value(ty, vty), OperandList(OpList), NumOperands(NumOps) {}
  Use *allocHungoffUses(unsigned) const;
  void dropHungoffUses() {
    Use::zap(OperandList, OperandList + NumOperands, true);
    OperandList = 0;

    NumOperands = 0;
  }
public:
  ~User() {
    Use::zap(OperandList, OperandList + NumOperands);
  }

  void operator delete(void *Usr);

  void operator delete(void*, unsigned) {
    ::llvm::llvm_unreachable_internal("Constructor throws?", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/User.h", 69);
  }

  void operator delete(void*, unsigned, bool) {
    ::llvm::llvm_unreachable_internal("Constructor throws?", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/User.h", 73);
  }
protected:
  template <int Idx, typename U> static Use &OpFrom(const U *that) {
    return Idx < 0
      ? OperandTraits<U>::op_end(const_cast<U*>(that))[Idx]
      : OperandTraits<U>::op_begin(const_cast<U*>(that))[Idx];
  }
  template <int Idx> Use &Op() {
    return OpFrom<Idx>(this);
  }
  template <int Idx> const Use &Op() const {
    return OpFrom<Idx>(this);
  }
public:
  Value *getOperand(unsigned i) const {
    ((void)((i < NumOperands && "getOperand() out of range!") || (__assert_fail("i < NumOperands && \"getOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/User.h", 89, __func__),0)));
    return OperandList[i];
  }
  void setOperand(unsigned i, Value *Val) {
    ((void)((i < NumOperands && "setOperand() out of range!") || (__assert_fail("i < NumOperands && \"setOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/User.h", 93, __func__),0)));
    ((void)(((!isa<Constant>((const Value*)this) || isa<GlobalValue>((const Value*)this)) && "Cannot mutate a constant with setOperand!") || (__assert_fail("(!isa<Constant>((const Value*)this) || isa<GlobalValue>((const Value*)this)) && \"Cannot mutate a constant with setOperand!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/User.h", 96, __func__),0)));


    OperandList[i] = Val;
  }
  const Use &getOperandUse(unsigned i) const {
    ((void)((i < NumOperands && "getOperandUse() out of range!") || (__assert_fail("i < NumOperands && \"getOperandUse() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/User.h", 100, __func__),0)));
    return OperandList[i];
  }
  Use &getOperandUse(unsigned i) {
    ((void)((i < NumOperands && "getOperandUse() out of range!") || (__assert_fail("i < NumOperands && \"getOperandUse() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/User.h", 104, __func__),0)));
    return OperandList[i];
  }

  unsigned getNumOperands() const { return NumOperands; }




  typedef Use* op_iterator;
  typedef const Use* const_op_iterator;

  inline op_iterator op_begin() { return OperandList; }
  inline const_op_iterator op_begin() const { return OperandList; }
  inline op_iterator op_end() { return OperandList+NumOperands; }
  inline const_op_iterator op_end() const { return OperandList+NumOperands; }



  class value_op_iterator : public std::iterator<std::forward_iterator_tag,
                                                 Value*> {
    op_iterator OI;
  public:
    explicit value_op_iterator(Use *U) : OI(U) {}

    bool operator==(const value_op_iterator &x) const {
      return OI == x.OI;
    }
    bool operator!=(const value_op_iterator &x) const {
      return !operator==(x);
    }


    value_op_iterator &operator++() {
      ++OI;
      return *this;
    }
    value_op_iterator operator++(int) {
      value_op_iterator tmp = *this; ++*this; return tmp;
    }


    Value *operator*() const {
      return *OI;
    }

    Value *operator->() const { return operator*(); }
  };

  inline value_op_iterator value_op_begin() {
    return value_op_iterator(op_begin());
  }
  inline value_op_iterator value_op_end() {
    return value_op_iterator(op_end());
  }
# 168 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/User.h"
  void dropAllReferences() {
    for (op_iterator i = op_begin(), e = op_end(); i != e; ++i)
      i->set(0);
  }




  void replaceUsesOfWith(Value *From, Value *To);


  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) || isa<Constant>(V);
  }
};

template<> struct simplify_type<User::op_iterator> {
  typedef Value* SimpleType;
  static SimpleType getSimplifiedValue(User::op_iterator &Val) {
    return Val->get();
  }
};
template<> struct simplify_type<User::const_op_iterator> {
  typedef Value* SimpleType;
  static SimpleType getSimplifiedValue(User::const_op_iterator &Val) {
    return Val->get();
  }
};


template<typename UserTy>
unsigned value_use_iterator<UserTy>::getOperandNo() const {
  return U - U->getUser()->op_begin();
}

}
# 20 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.h" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/DebugLoc.h" 1
# 20 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/DebugLoc.h"
namespace llvm {
  template <typename T> struct DenseMapInfo;
  class MDNode;
  class LLVMContext;




  class DebugLoc {
    friend struct DenseMapInfo<DebugLoc>;



    static DebugLoc getEmptyKey() {
      DebugLoc DL;
      DL.LineCol = 1;
      return DL;
    }



    static DebugLoc getTombstoneKey() {
      DebugLoc DL;
      DL.LineCol = 2;
      return DL;
    }




    uint32_t LineCol;



    int ScopeIdx;
  public:
    DebugLoc() : LineCol(0), ScopeIdx(0) {}



    static DebugLoc get(unsigned Line, unsigned Col,
                        MDNode *Scope, MDNode *InlinedAt = 0);


    static DebugLoc getFromDILocation(MDNode *N);


    static DebugLoc getFromDILexicalBlock(MDNode *N);


    bool isUnknown() const { return ScopeIdx == 0; }

    unsigned getLine() const {
      return (LineCol << 8) >> 8;
    }

    unsigned getCol() const {
      return LineCol >> 24;
    }



    MDNode *getScope(const LLVMContext &Ctx) const;



    MDNode *getInlinedAt(const LLVMContext &Ctx) const;


    void getScopeAndInlinedAt(MDNode *&Scope, MDNode *&IA,
                              const LLVMContext &Ctx) const;




    MDNode *getAsMDNode(const LLVMContext &Ctx) const;

    bool operator==(const DebugLoc &DL) const {
      return LineCol == DL.LineCol && ScopeIdx == DL.ScopeIdx;
    }
    bool operator!=(const DebugLoc &DL) const { return !(*this == DL); }

    void dump(const LLVMContext &Ctx) const;
  };

  template <>
  struct DenseMapInfo<DebugLoc> {
    static DebugLoc getEmptyKey() { return DebugLoc::getEmptyKey(); }
    static DebugLoc getTombstoneKey() { return DebugLoc::getTombstoneKey(); }
    static unsigned getHashValue(const DebugLoc &Key);
    static bool isEqual(DebugLoc LHS, DebugLoc RHS) { return LHS == RHS; }
  };
}
# 21 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.h" 2

namespace llvm {

class FastMathFlags;
class LLVMContext;
class MDNode;

template<typename ValueSubClass, typename ItemParentClass>
  class SymbolTableListTraits;

class Instruction : public User, public ilist_node<Instruction> {
  void operator=(const Instruction &) ;
  Instruction(const Instruction &) ;

  BasicBlock *Parent;
  DebugLoc DbgLoc;

  enum {


    HasMetadataBit = 1 << 15
  };
public:

  ~Instruction();



  Instruction *use_back() { return cast<Instruction>(*use_begin());}
  const Instruction *use_back() const { return cast<Instruction>(*use_begin());}

  inline const BasicBlock *getParent() const { return Parent; }
  inline BasicBlock *getParent() { return Parent; }




  void removeFromParent();




  void eraseFromParent();



  void insertBefore(Instruction *InsertPos);



  void insertAfter(Instruction *InsertPos);




  void moveBefore(Instruction *MovePos);






  unsigned getOpcode() const { return getValueID() - InstructionVal; }

  const char *getOpcodeName() const { return getOpcodeName(getOpcode()); }
  bool isTerminator() const { return isTerminator(getOpcode()); }
  bool isBinaryOp() const { return isBinaryOp(getOpcode()); }
  bool isShift() { return isShift(getOpcode()); }
  bool isCast() const { return isCast(getOpcode()); }

  static const char* getOpcodeName(unsigned OpCode);

  static inline bool isTerminator(unsigned OpCode) {
    return OpCode >= TermOpsBegin && OpCode < TermOpsEnd;
  }

  static inline bool isBinaryOp(unsigned Opcode) {
    return Opcode >= BinaryOpsBegin && Opcode < BinaryOpsEnd;
  }


  static inline bool isShift(unsigned Opcode) {
    return Opcode >= Shl && Opcode <= AShr;
  }



  inline bool isLogicalShift() const {
    return getOpcode() == Shl || getOpcode() == LShr;
  }


  inline bool isArithmeticShift() const {
    return getOpcode() == AShr;
  }


  static inline bool isCast(unsigned OpCode) {
    return OpCode >= CastOpsBegin && OpCode < CastOpsEnd;
  }







  bool hasMetadata() const {
    return !DbgLoc.isUnknown() || hasMetadataHashEntry();
  }



  bool hasMetadataOtherThanDebugLoc() const {
    return hasMetadataHashEntry();
  }



  MDNode *getMetadata(unsigned KindID) const {
    if (!hasMetadata()) return 0;
    return getMetadataImpl(KindID);
  }



  MDNode *getMetadata(StringRef Kind) const {
    if (!hasMetadata()) return 0;
    return getMetadataImpl(Kind);
  }




  void getAllMetadata(SmallVectorImpl<std::pair<unsigned, MDNode*> > &MDs)const{
    if (hasMetadata())
      getAllMetadataImpl(MDs);
  }



  void getAllMetadataOtherThanDebugLoc(SmallVectorImpl<std::pair<unsigned,
                                       MDNode*> > &MDs) const {
    if (hasMetadataOtherThanDebugLoc())
      getAllMetadataOtherThanDebugLocImpl(MDs);
  }




  void setMetadata(unsigned KindID, MDNode *Node);
  void setMetadata(StringRef Kind, MDNode *Node);


  void setDebugLoc(const DebugLoc &Loc) { DbgLoc = Loc; }


  const DebugLoc &getDebugLoc() const { return DbgLoc; }




  void setHasUnsafeAlgebra(bool B);




  void setHasNoNaNs(bool B);




  void setHasNoInfs(bool B);




  void setHasNoSignedZeros(bool B);




  void setHasAllowReciprocal(bool B);




  void setFastMathFlags(FastMathFlags FMF);


  bool hasUnsafeAlgebra() const;


  bool hasNoNaNs() const;


  bool hasNoInfs() const;


  bool hasNoSignedZeros() const;


  bool hasAllowReciprocal() const;




  FastMathFlags getFastMathFlags() const;


  void copyFastMathFlags(const Instruction *I);

private:


  bool hasMetadataHashEntry() const {
    return (getSubclassDataFromValue() & HasMetadataBit) != 0;
  }


  MDNode *getMetadataImpl(unsigned KindID) const;
  MDNode *getMetadataImpl(StringRef Kind) const;
  void getAllMetadataImpl(SmallVectorImpl<std::pair<unsigned,MDNode*> > &)const;
  void getAllMetadataOtherThanDebugLocImpl(SmallVectorImpl<std::pair<unsigned,
                                           MDNode*> > &) const;
  void clearMetadataHashEntries();
public:
# 259 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.h"
  bool isAssociative() const;
  static bool isAssociative(unsigned op);
# 269 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.h"
  bool isCommutative() const { return isCommutative(getOpcode()); }
  static bool isCommutative(unsigned op);







  bool isIdempotent() const { return isIdempotent(getOpcode()); }
  static bool isIdempotent(unsigned op);
# 290 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.h"
  bool isNilpotent() const { return isNilpotent(getOpcode()); }
  static bool isNilpotent(unsigned op);



  bool mayWriteToMemory() const;



  bool mayReadFromMemory() const;




  bool mayReadOrWriteMemory() const {
    return mayReadFromMemory() || mayWriteToMemory();
  }



  bool mayThrow() const;





  bool mayReturn() const;







  bool mayHaveSideEffects() const {
    return mayWriteToMemory() || mayThrow() || !mayReturn();
  }






  Instruction *clone() const;




  bool isIdenticalTo(const Instruction *I) const;




  bool isIdenticalToWhenDefined(const Instruction *I) const;



  enum OperationEquivalenceFlags {

    CompareIgnoringAlignment = 1<<0,


    CompareUsingScalarTypes = 1<<1
  };
# 363 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.h"
  bool isSameOperationAs(const Instruction *I, unsigned flags = 0) const;





  bool isUsedOutsideOfBlock(const BasicBlock *BB) const;



  static inline bool classof(const Value *V) {
    return V->getValueID() >= Value::InstructionVal;
  }




  enum TermOps {




# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.def" 1
# 96 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.def"
 TermOpsBegin = 1,
Ret = 1,
Br = 2,
Switch = 3,
IndirectBr = 4,
Invoke = 5,
Resume = 6,
Unreachable = 7,
  TermOpsEnd = 7 +1
# 385 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.h" 2
 };

  enum BinaryOps {




# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.def" 1
# 107 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.def"
 BinaryOpsBegin = 8,
Add = 8,
FAdd = 9,
Sub = 10,
FSub = 11,
Mul = 12,
FMul = 13,
UDiv = 14,
SDiv = 15,
FDiv = 16,
URem = 17,
SRem = 18,
FRem = 19,


Shl = 20,
LShr = 21,
AShr = 22,
And = 23,
Or = 24,
Xor = 25,
  BinaryOpsEnd = 25 +1
# 392 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.h" 2
 };

  enum MemoryOps {




# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.def" 1
# 131 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.def"
 MemoryOpsBegin = 26,
Alloca = 26,
Load = 27,
Store = 28,
GetElementPtr = 29,
Fence = 30,
AtomicCmpXchg = 31,
AtomicRMW = 32,
  MemoryOpsEnd = 32 +1
# 399 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.h" 2
 };

  enum CastOps {




# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.def" 1
# 144 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.def"
 CastOpsBegin = 33,
Trunc = 33,
ZExt = 34,
SExt = 35,
FPToUI = 36,
FPToSI = 37,
UIToFP = 38,
SIToFP = 39,
FPTrunc = 40,
FPExt = 41,
PtrToInt = 42,
IntToPtr = 43,
BitCast = 44,
AddrSpaceCast = 45,
  CastOpsEnd = 45 +1
# 406 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.h" 2
 };

  enum OtherOps {




# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.def" 1
# 161 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.def"
 OtherOpsBegin = 46,
ICmp = 46,
FCmp = 47,
PHI = 48,
Call = 49,
Select = 50,
UserOp1 = 51,
UserOp2 = 52,
VAArg = 53,
ExtractElement = 54,
InsertElement = 55,
ShuffleVector = 56,
ExtractValue = 57,
InsertValue = 58,
LandingPad = 59,
  OtherOpsEnd = 59 +1
# 413 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.h" 2
 };
private:


  void setValueSubclassData(unsigned short D) {
    Value::setValueSubclassData(D);
  }
  unsigned short getSubclassDataFromValue() const {
    return Value::getSubclassDataFromValue();
  }

  void setHasMetadataHashEntry(bool V) {
    setValueSubclassData((getSubclassDataFromValue() & ~HasMetadataBit) |
                         (V ? HasMetadataBit : 0));
  }

  friend class SymbolTableListTraits<Instruction, BasicBlock>;
  void setParent(BasicBlock *P);
protected:




  void setInstructionSubclassData(unsigned short D) {
    ((void)(((D & HasMetadataBit) == 0 && "Out of range value put into field") || (__assert_fail("(D & HasMetadataBit) == 0 && \"Out of range value put into field\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.h", 437, __func__),0)));
    setValueSubclassData((getSubclassDataFromValue() & HasMetadataBit) | D);
  }

  unsigned getSubclassDataFromInstruction() const {
    return getSubclassDataFromValue() & ~HasMetadataBit;
  }

  Instruction(Type *Ty, unsigned iType, Use *Ops, unsigned NumOps,
              Instruction *InsertBefore = 0);
  Instruction(Type *Ty, unsigned iType, Use *Ops, unsigned NumOps,
              BasicBlock *InsertAtEnd);
  virtual Instruction *clone_impl() const = 0;

};


template<>
class PointerLikeTypeTraits<Instruction*> {
  typedef Instruction* PT;
public:
  static inline void *getAsVoidPointer(PT P) { return P; }
  static inline PT getFromVoidPointer(void *P) {
    return static_cast<PT>(P);
  }
  enum { NumLowBitsAvailable = 2 };
};

}
# 22 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/InstrTypes.h" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/OperandTraits.h" 1
# 20 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/OperandTraits.h"
namespace llvm {
# 30 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/OperandTraits.h"
template <typename SubClass, unsigned ARITY>
struct FixedNumOperandTraits {
  static Use *op_begin(SubClass* U) {
    return reinterpret_cast<Use*>(U) - ARITY;
  }
  static Use *op_end(SubClass* U) {
    return reinterpret_cast<Use*>(U);
  }
  static unsigned operands(const User*) {
    return ARITY;
  }
};
# 50 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/OperandTraits.h"
template <typename SubClass, unsigned ARITY = 1>
struct OptionalOperandTraits : public FixedNumOperandTraits<SubClass, ARITY> {
  static unsigned operands(const User *U) {
    return U->getNumOperands();
  }
};
# 65 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/OperandTraits.h"
template <typename SubClass, unsigned MINARITY = 0>
struct VariadicOperandTraits {
  static Use *op_begin(SubClass* U) {
    return reinterpret_cast<Use*>(U) - static_cast<User*>(U)->getNumOperands();
  }
  static Use *op_end(SubClass* U) {
    return reinterpret_cast<Use*>(U);
  }
  static unsigned operands(const User *U) {
    return U->getNumOperands();
  }
};
# 92 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/OperandTraits.h"
template <unsigned MINARITY = 1>
struct HungoffOperandTraits {
  static Use *op_begin(User* U) {
    return U->OperandList;
  }
  static Use *op_end(User* U) {
    return U->OperandList + U->getNumOperands();
  }
  static unsigned operands(const User *U) {
    return U->getNumOperands();
  }
};
# 158 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/OperandTraits.h"
}
# 23 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/InstrTypes.h" 2

namespace llvm {

class LLVMContext;
# 35 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/InstrTypes.h"
class TerminatorInst : public Instruction {
protected:
  TerminatorInst(Type *Ty, Instruction::TermOps iType,
                 Use *Ops, unsigned NumOps,
                 Instruction *InsertBefore = 0)
    : Instruction(Ty, iType, Ops, NumOps, InsertBefore) {}

  TerminatorInst(Type *Ty, Instruction::TermOps iType,
                 Use *Ops, unsigned NumOps, BasicBlock *InsertAtEnd)
    : Instruction(Ty, iType, Ops, NumOps, InsertAtEnd) {}


  ~TerminatorInst();



  virtual BasicBlock *getSuccessorV(unsigned idx) const = 0;
  virtual unsigned getNumSuccessorsV() const = 0;
  virtual void setSuccessorV(unsigned idx, BasicBlock *B) = 0;
  virtual TerminatorInst *clone_impl() const = 0;
public:



  unsigned getNumSuccessors() const {
    return getNumSuccessorsV();
  }



  BasicBlock *getSuccessor(unsigned idx) const {
    return getSuccessorV(idx);
  }



  void setSuccessor(unsigned idx, BasicBlock *B) {
    setSuccessorV(idx, B);
  }


  static inline bool classof(const Instruction *I) {
    return I->isTerminator();
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};






class UnaryInstruction : public Instruction {
  void *operator new(size_t, unsigned) ;

protected:
  UnaryInstruction(Type *Ty, unsigned iType, Value *V,
                   Instruction *IB = 0)
    : Instruction(Ty, iType, &Op<0>(), 1, IB) {
    Op<0>() = V;
  }
  UnaryInstruction(Type *Ty, unsigned iType, Value *V, BasicBlock *IAE)
    : Instruction(Ty, iType, &Op<0>(), 1, IAE) {
    Op<0>() = V;
  }
public:

  void *operator new(size_t s) {
    return User::operator new(s, 1);
  }


  ~UnaryInstruction();


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::Alloca ||
           I->getOpcode() == Instruction::Load ||
           I->getOpcode() == Instruction::VAArg ||
           I->getOpcode() == Instruction::ExtractValue ||
           (I->getOpcode() >= CastOpsBegin && I->getOpcode() < CastOpsEnd);
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};

template <>
struct OperandTraits<UnaryInstruction> :
  public FixedNumOperandTraits<UnaryInstruction, 1> {
};

UnaryInstruction::op_iterator UnaryInstruction::op_begin() { return OperandTraits<UnaryInstruction>::op_begin(this); } UnaryInstruction::const_op_iterator UnaryInstruction::op_begin() const { return OperandTraits<UnaryInstruction>::op_begin(const_cast<UnaryInstruction*>(this)); } UnaryInstruction::op_iterator UnaryInstruction::op_end() { return OperandTraits<UnaryInstruction>::op_end(this); } UnaryInstruction::const_op_iterator UnaryInstruction::op_end() const { return OperandTraits<UnaryInstruction>::op_end(const_cast<UnaryInstruction*>(this)); } Value *UnaryInstruction::getOperand(unsigned i_nocapture) const { ((void)((i_nocapture < OperandTraits<UnaryInstruction>::operands(this) && "getOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<UnaryInstruction>::operands(this) && \"getOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/InstrTypes.h", 132, __func__),0))); return cast_or_null<Value>( OperandTraits<UnaryInstruction>::op_begin(const_cast<UnaryInstruction*>(this))[i_nocapture].get()); } void UnaryInstruction::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((void)((i_nocapture < OperandTraits<UnaryInstruction>::operands(this) && "setOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<UnaryInstruction>::operands(this) && \"setOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/InstrTypes.h", 132, __func__),0))); OperandTraits<UnaryInstruction>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned UnaryInstruction::getNumOperands() const { return OperandTraits<UnaryInstruction>::operands(this); } template <int Idx_nocapture> Use &UnaryInstruction::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &UnaryInstruction::Op() const { return this->OpFrom<Idx_nocapture>(this); }





class BinaryOperator : public Instruction {
  void *operator new(size_t, unsigned) ;
protected:
  void init(BinaryOps iType);
  BinaryOperator(BinaryOps iType, Value *S1, Value *S2, Type *Ty,
                 const Twine &Name, Instruction *InsertBefore);
  BinaryOperator(BinaryOps iType, Value *S1, Value *S2, Type *Ty,
                 const Twine &Name, BasicBlock *InsertAtEnd);
  virtual BinaryOperator *clone_impl() const ;
public:

  void *operator new(size_t s) {
    return User::operator new(s, 2);
  }


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;






  static BinaryOperator *Create(BinaryOps Op, Value *S1, Value *S2,
                                const Twine &Name = Twine(),
                                Instruction *InsertBefore = 0);





  static BinaryOperator *Create(BinaryOps Op, Value *S1, Value *S2,
                                const Twine &Name, BasicBlock *InsertAtEnd);
# 180 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/InstrTypes.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.def" 1
# 108 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.def"
static BinaryOperator *CreateAdd(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::Add, V1, V2, Name); }
static BinaryOperator *CreateFAdd(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::FAdd, V1, V2, Name); }
static BinaryOperator *CreateSub(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::Sub, V1, V2, Name); }
static BinaryOperator *CreateFSub(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::FSub, V1, V2, Name); }
static BinaryOperator *CreateMul(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::Mul, V1, V2, Name); }
static BinaryOperator *CreateFMul(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::FMul, V1, V2, Name); }
static BinaryOperator *CreateUDiv(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::UDiv, V1, V2, Name); }
static BinaryOperator *CreateSDiv(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::SDiv, V1, V2, Name); }
static BinaryOperator *CreateFDiv(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::FDiv, V1, V2, Name); }
static BinaryOperator *CreateURem(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::URem, V1, V2, Name); }
static BinaryOperator *CreateSRem(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::SRem, V1, V2, Name); }
static BinaryOperator *CreateFRem(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::FRem, V1, V2, Name); }


static BinaryOperator *CreateShl(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::Shl, V1, V2, Name); }
static BinaryOperator *CreateLShr(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::LShr, V1, V2, Name); }
static BinaryOperator *CreateAShr(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::AShr, V1, V2, Name); }
static BinaryOperator *CreateAnd(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::And, V1, V2, Name); }
static BinaryOperator *CreateOr(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::Or, V1, V2, Name); }
static BinaryOperator *CreateXor(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::Xor, V1, V2, Name); }
# 181 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/InstrTypes.h" 2





# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.def" 1
# 108 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.def"
static BinaryOperator *CreateAdd(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::Add, V1, V2, Name, BB); }
static BinaryOperator *CreateFAdd(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::FAdd, V1, V2, Name, BB); }
static BinaryOperator *CreateSub(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::Sub, V1, V2, Name, BB); }
static BinaryOperator *CreateFSub(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::FSub, V1, V2, Name, BB); }
static BinaryOperator *CreateMul(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::Mul, V1, V2, Name, BB); }
static BinaryOperator *CreateFMul(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::FMul, V1, V2, Name, BB); }
static BinaryOperator *CreateUDiv(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::UDiv, V1, V2, Name, BB); }
static BinaryOperator *CreateSDiv(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::SDiv, V1, V2, Name, BB); }
static BinaryOperator *CreateFDiv(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::FDiv, V1, V2, Name, BB); }
static BinaryOperator *CreateURem(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::URem, V1, V2, Name, BB); }
static BinaryOperator *CreateSRem(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::SRem, V1, V2, Name, BB); }
static BinaryOperator *CreateFRem(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::FRem, V1, V2, Name, BB); }


static BinaryOperator *CreateShl(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::Shl, V1, V2, Name, BB); }
static BinaryOperator *CreateLShr(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::LShr, V1, V2, Name, BB); }
static BinaryOperator *CreateAShr(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::AShr, V1, V2, Name, BB); }
static BinaryOperator *CreateAnd(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::And, V1, V2, Name, BB); }
static BinaryOperator *CreateOr(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::Or, V1, V2, Name, BB); }
static BinaryOperator *CreateXor(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::Xor, V1, V2, Name, BB); }
# 187 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/InstrTypes.h" 2





# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.def" 1
# 108 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instruction.def"
static BinaryOperator *CreateAdd(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::Add, V1, V2, Name, I); }
static BinaryOperator *CreateFAdd(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::FAdd, V1, V2, Name, I); }
static BinaryOperator *CreateSub(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::Sub, V1, V2, Name, I); }
static BinaryOperator *CreateFSub(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::FSub, V1, V2, Name, I); }
static BinaryOperator *CreateMul(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::Mul, V1, V2, Name, I); }
static BinaryOperator *CreateFMul(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::FMul, V1, V2, Name, I); }
static BinaryOperator *CreateUDiv(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::UDiv, V1, V2, Name, I); }
static BinaryOperator *CreateSDiv(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::SDiv, V1, V2, Name, I); }
static BinaryOperator *CreateFDiv(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::FDiv, V1, V2, Name, I); }
static BinaryOperator *CreateURem(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::URem, V1, V2, Name, I); }
static BinaryOperator *CreateSRem(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::SRem, V1, V2, Name, I); }
static BinaryOperator *CreateFRem(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::FRem, V1, V2, Name, I); }


static BinaryOperator *CreateShl(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::Shl, V1, V2, Name, I); }
static BinaryOperator *CreateLShr(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::LShr, V1, V2, Name, I); }
static BinaryOperator *CreateAShr(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::AShr, V1, V2, Name, I); }
static BinaryOperator *CreateAnd(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::And, V1, V2, Name, I); }
static BinaryOperator *CreateOr(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::Or, V1, V2, Name, I); }
static BinaryOperator *CreateXor(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::Xor, V1, V2, Name, I); }
# 193 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/InstrTypes.h" 2

  static BinaryOperator *CreateNSW(BinaryOps Opc, Value *V1, Value *V2,
                                   const Twine &Name = "") {
    BinaryOperator *BO = Create(Opc, V1, V2, Name);
    BO->setHasNoSignedWrap(true);
    return BO;
  }
  static BinaryOperator *CreateNSW(BinaryOps Opc, Value *V1, Value *V2,
                                   const Twine &Name, BasicBlock *BB) {
    BinaryOperator *BO = Create(Opc, V1, V2, Name, BB);
    BO->setHasNoSignedWrap(true);
    return BO;
  }
  static BinaryOperator *CreateNSW(BinaryOps Opc, Value *V1, Value *V2,
                                   const Twine &Name, Instruction *I) {
    BinaryOperator *BO = Create(Opc, V1, V2, Name, I);
    BO->setHasNoSignedWrap(true);
    return BO;
  }

  static BinaryOperator *CreateNUW(BinaryOps Opc, Value *V1, Value *V2,
                                   const Twine &Name = "") {
    BinaryOperator *BO = Create(Opc, V1, V2, Name);
    BO->setHasNoUnsignedWrap(true);
    return BO;
  }
  static BinaryOperator *CreateNUW(BinaryOps Opc, Value *V1, Value *V2,
                                   const Twine &Name, BasicBlock *BB) {
    BinaryOperator *BO = Create(Opc, V1, V2, Name, BB);
    BO->setHasNoUnsignedWrap(true);
    return BO;
  }
  static BinaryOperator *CreateNUW(BinaryOps Opc, Value *V1, Value *V2,
                                   const Twine &Name, Instruction *I) {
    BinaryOperator *BO = Create(Opc, V1, V2, Name, I);
    BO->setHasNoUnsignedWrap(true);
    return BO;
  }

  static BinaryOperator *CreateExact(BinaryOps Opc, Value *V1, Value *V2,
                                     const Twine &Name = "") {
    BinaryOperator *BO = Create(Opc, V1, V2, Name);
    BO->setIsExact(true);
    return BO;
  }
  static BinaryOperator *CreateExact(BinaryOps Opc, Value *V1, Value *V2,
                                     const Twine &Name, BasicBlock *BB) {
    BinaryOperator *BO = Create(Opc, V1, V2, Name, BB);
    BO->setIsExact(true);
    return BO;
  }
  static BinaryOperator *CreateExact(BinaryOps Opc, Value *V1, Value *V2,
                                     const Twine &Name, Instruction *I) {
    BinaryOperator *BO = Create(Opc, V1, V2, Name, I);
    BO->setIsExact(true);
    return BO;
  }
# 265 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/InstrTypes.h"
  static BinaryOperator *CreateNSWAdd (Value *V1, Value *V2, const Twine &Name = "") { return CreateNSW(Instruction::Add, V1, V2, Name); } static BinaryOperator *CreateNSWAdd (Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return CreateNSW(Instruction::Add, V1, V2, Name, BB); } static BinaryOperator *CreateNSWAdd (Value *V1, Value *V2, const Twine &Name, Instruction *I) { return CreateNSW(Instruction::Add, V1, V2, Name, I); }
  static BinaryOperator *CreateNUWAdd (Value *V1, Value *V2, const Twine &Name = "") { return CreateNUW(Instruction::Add, V1, V2, Name); } static BinaryOperator *CreateNUWAdd (Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return CreateNUW(Instruction::Add, V1, V2, Name, BB); } static BinaryOperator *CreateNUWAdd (Value *V1, Value *V2, const Twine &Name, Instruction *I) { return CreateNUW(Instruction::Add, V1, V2, Name, I); }
  static BinaryOperator *CreateNSWSub (Value *V1, Value *V2, const Twine &Name = "") { return CreateNSW(Instruction::Sub, V1, V2, Name); } static BinaryOperator *CreateNSWSub (Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return CreateNSW(Instruction::Sub, V1, V2, Name, BB); } static BinaryOperator *CreateNSWSub (Value *V1, Value *V2, const Twine &Name, Instruction *I) { return CreateNSW(Instruction::Sub, V1, V2, Name, I); }
  static BinaryOperator *CreateNUWSub (Value *V1, Value *V2, const Twine &Name = "") { return CreateNUW(Instruction::Sub, V1, V2, Name); } static BinaryOperator *CreateNUWSub (Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return CreateNUW(Instruction::Sub, V1, V2, Name, BB); } static BinaryOperator *CreateNUWSub (Value *V1, Value *V2, const Twine &Name, Instruction *I) { return CreateNUW(Instruction::Sub, V1, V2, Name, I); }
  static BinaryOperator *CreateNSWMul (Value *V1, Value *V2, const Twine &Name = "") { return CreateNSW(Instruction::Mul, V1, V2, Name); } static BinaryOperator *CreateNSWMul (Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return CreateNSW(Instruction::Mul, V1, V2, Name, BB); } static BinaryOperator *CreateNSWMul (Value *V1, Value *V2, const Twine &Name, Instruction *I) { return CreateNSW(Instruction::Mul, V1, V2, Name, I); }
  static BinaryOperator *CreateNUWMul (Value *V1, Value *V2, const Twine &Name = "") { return CreateNUW(Instruction::Mul, V1, V2, Name); } static BinaryOperator *CreateNUWMul (Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return CreateNUW(Instruction::Mul, V1, V2, Name, BB); } static BinaryOperator *CreateNUWMul (Value *V1, Value *V2, const Twine &Name, Instruction *I) { return CreateNUW(Instruction::Mul, V1, V2, Name, I); }
  static BinaryOperator *CreateNSWShl (Value *V1, Value *V2, const Twine &Name = "") { return CreateNSW(Instruction::Shl, V1, V2, Name); } static BinaryOperator *CreateNSWShl (Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return CreateNSW(Instruction::Shl, V1, V2, Name, BB); } static BinaryOperator *CreateNSWShl (Value *V1, Value *V2, const Twine &Name, Instruction *I) { return CreateNSW(Instruction::Shl, V1, V2, Name, I); }
  static BinaryOperator *CreateNUWShl (Value *V1, Value *V2, const Twine &Name = "") { return CreateNUW(Instruction::Shl, V1, V2, Name); } static BinaryOperator *CreateNUWShl (Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return CreateNUW(Instruction::Shl, V1, V2, Name, BB); } static BinaryOperator *CreateNUWShl (Value *V1, Value *V2, const Twine &Name, Instruction *I) { return CreateNUW(Instruction::Shl, V1, V2, Name, I); }

  static BinaryOperator *CreateExactSDiv (Value *V1, Value *V2, const Twine &Name = "") { return CreateExact(Instruction::SDiv, V1, V2, Name); } static BinaryOperator *CreateExactSDiv (Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return CreateExact(Instruction::SDiv, V1, V2, Name, BB); } static BinaryOperator *CreateExactSDiv (Value *V1, Value *V2, const Twine &Name, Instruction *I) { return CreateExact(Instruction::SDiv, V1, V2, Name, I); }
  static BinaryOperator *CreateExactUDiv (Value *V1, Value *V2, const Twine &Name = "") { return CreateExact(Instruction::UDiv, V1, V2, Name); } static BinaryOperator *CreateExactUDiv (Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return CreateExact(Instruction::UDiv, V1, V2, Name, BB); } static BinaryOperator *CreateExactUDiv (Value *V1, Value *V2, const Twine &Name, Instruction *I) { return CreateExact(Instruction::UDiv, V1, V2, Name, I); }
  static BinaryOperator *CreateExactAShr (Value *V1, Value *V2, const Twine &Name = "") { return CreateExact(Instruction::AShr, V1, V2, Name); } static BinaryOperator *CreateExactAShr (Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return CreateExact(Instruction::AShr, V1, V2, Name, BB); } static BinaryOperator *CreateExactAShr (Value *V1, Value *V2, const Twine &Name, Instruction *I) { return CreateExact(Instruction::AShr, V1, V2, Name, I); }
  static BinaryOperator *CreateExactLShr (Value *V1, Value *V2, const Twine &Name = "") { return CreateExact(Instruction::LShr, V1, V2, Name); } static BinaryOperator *CreateExactLShr (Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return CreateExact(Instruction::LShr, V1, V2, Name, BB); } static BinaryOperator *CreateExactLShr (Value *V1, Value *V2, const Twine &Name, Instruction *I) { return CreateExact(Instruction::LShr, V1, V2, Name, I); }
# 287 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/InstrTypes.h"
  static BinaryOperator *CreateNeg(Value *Op, const Twine &Name = "",
                                   Instruction *InsertBefore = 0);
  static BinaryOperator *CreateNeg(Value *Op, const Twine &Name,
                                   BasicBlock *InsertAtEnd);
  static BinaryOperator *CreateNSWNeg(Value *Op, const Twine &Name = "",
                                      Instruction *InsertBefore = 0);
  static BinaryOperator *CreateNSWNeg(Value *Op, const Twine &Name,
                                      BasicBlock *InsertAtEnd);
  static BinaryOperator *CreateNUWNeg(Value *Op, const Twine &Name = "",
                                      Instruction *InsertBefore = 0);
  static BinaryOperator *CreateNUWNeg(Value *Op, const Twine &Name,
                                      BasicBlock *InsertAtEnd);
  static BinaryOperator *CreateFNeg(Value *Op, const Twine &Name = "",
                                    Instruction *InsertBefore = 0);
  static BinaryOperator *CreateFNeg(Value *Op, const Twine &Name,
                                    BasicBlock *InsertAtEnd);
  static BinaryOperator *CreateNot(Value *Op, const Twine &Name = "",
                                   Instruction *InsertBefore = 0);
  static BinaryOperator *CreateNot(Value *Op, const Twine &Name,
                                   BasicBlock *InsertAtEnd);




  static bool isNeg(const Value *V);
  static bool isFNeg(const Value *V, bool IgnoreZeroSign=false);
  static bool isNot(const Value *V);





  static const Value *getNegArgument(const Value *BinOp);
  static Value *getNegArgument( Value *BinOp);
  static const Value *getFNegArgument(const Value *BinOp);
  static Value *getFNegArgument( Value *BinOp);
  static const Value *getNotArgument(const Value *BinOp);
  static Value *getNotArgument( Value *BinOp);

  BinaryOps getOpcode() const {
    return static_cast<BinaryOps>(Instruction::getOpcode());
  }






  bool swapOperands();




  void setHasNoUnsignedWrap(bool b = true);




  void setHasNoSignedWrap(bool b = true);




  void setIsExact(bool b = true);


  bool hasNoUnsignedWrap() const;


  bool hasNoSignedWrap() const;


  bool isExact() const;


  static inline bool classof(const Instruction *I) {
    return I->isBinaryOp();
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};

template <>
struct OperandTraits<BinaryOperator> :
  public FixedNumOperandTraits<BinaryOperator, 2> {
};

BinaryOperator::op_iterator BinaryOperator::op_begin() { return OperandTraits<BinaryOperator>::op_begin(this); } BinaryOperator::const_op_iterator BinaryOperator::op_begin() const { return OperandTraits<BinaryOperator>::op_begin(const_cast<BinaryOperator*>(this)); } BinaryOperator::op_iterator BinaryOperator::op_end() { return OperandTraits<BinaryOperator>::op_end(this); } BinaryOperator::const_op_iterator BinaryOperator::op_end() const { return OperandTraits<BinaryOperator>::op_end(const_cast<BinaryOperator*>(this)); } Value *BinaryOperator::getOperand(unsigned i_nocapture) const { ((void)((i_nocapture < OperandTraits<BinaryOperator>::operands(this) && "getOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<BinaryOperator>::operands(this) && \"getOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/InstrTypes.h", 375, __func__),0))); return cast_or_null<Value>( OperandTraits<BinaryOperator>::op_begin(const_cast<BinaryOperator*>(this))[i_nocapture].get()); } void BinaryOperator::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((void)((i_nocapture < OperandTraits<BinaryOperator>::operands(this) && "setOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<BinaryOperator>::operands(this) && \"setOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/InstrTypes.h", 375, __func__),0))); OperandTraits<BinaryOperator>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned BinaryOperator::getNumOperands() const { return OperandTraits<BinaryOperator>::operands(this); } template <int Idx_nocapture> Use &BinaryOperator::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &BinaryOperator::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 387 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/InstrTypes.h"
class CastInst : public UnaryInstruction {
  virtual void anchor() ;
protected:

  CastInst(Type *Ty, unsigned iType, Value *S,
           const Twine &NameStr = "", Instruction *InsertBefore = 0)
    : UnaryInstruction(Ty, iType, S, InsertBefore) {
    setName(NameStr);
  }

  CastInst(Type *Ty, unsigned iType, Value *S,
           const Twine &NameStr, BasicBlock *InsertAtEnd)
    : UnaryInstruction(Ty, iType, S, InsertAtEnd) {
    setName(NameStr);
  }
public:






  static CastInst *Create(
    Instruction::CastOps,
    Value *S,
    Type *Ty,
    const Twine &Name = "",
    Instruction *InsertBefore = 0
  );






  static CastInst *Create(
    Instruction::CastOps,
    Value *S,
    Type *Ty,
    const Twine &Name,
    BasicBlock *InsertAtEnd
  );


  static CastInst *CreateZExtOrBitCast(
    Value *S,
    Type *Ty,
    const Twine &Name = "",
    Instruction *InsertBefore = 0
  );


  static CastInst *CreateZExtOrBitCast(
    Value *S,
    Type *Ty,
    const Twine &Name,
    BasicBlock *InsertAtEnd
  );


  static CastInst *CreateSExtOrBitCast(
    Value *S,
    Type *Ty,
    const Twine &Name = "",
    Instruction *InsertBefore = 0
  );


  static CastInst *CreateSExtOrBitCast(
    Value *S,
    Type *Ty,
    const Twine &Name,
    BasicBlock *InsertAtEnd
  );


  static CastInst *CreatePointerCast(
    Value *S,
    Type *Ty,
    const Twine &Name,
    BasicBlock *InsertAtEnd
  );


  static CastInst *CreatePointerCast(
    Value *S,
    Type *Ty,
    const Twine &Name = "",
    Instruction *InsertBefore = 0
  );


  static CastInst *CreateIntegerCast(
    Value *S,
    Type *Ty,
    bool isSigned,
    const Twine &Name = "",
    Instruction *InsertBefore = 0
  );


  static CastInst *CreateIntegerCast(
    Value *S,
    Type *Ty,
    bool isSigned,
    const Twine &Name,
    BasicBlock *InsertAtEnd
  );


  static CastInst *CreateFPCast(
    Value *S,
    Type *Ty,
    const Twine &Name = "",
    Instruction *InsertBefore = 0
  );


  static CastInst *CreateFPCast(
    Value *S,
    Type *Ty,
    const Twine &Name,
    BasicBlock *InsertAtEnd
  );


  static CastInst *CreateTruncOrBitCast(
    Value *S,
    Type *Ty,
    const Twine &Name = "",
    Instruction *InsertBefore = 0
  );


  static CastInst *CreateTruncOrBitCast(
    Value *S,
    Type *Ty,
    const Twine &Name,
    BasicBlock *InsertAtEnd
  );


  static bool isCastable(
    Type *SrcTy,
    Type *DestTy
  );


  static bool isBitCastable(
    Type *SrcTy,
    Type *DestTy
  );




  static Instruction::CastOps getCastOpcode(
    const Value *Val,
    bool SrcIsSigned,
    Type *Ty,
    bool DstIsSigned
  );






  bool isIntegerCast() const;






  bool isLosslessCast() const;
# 573 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/InstrTypes.h"
  static bool isNoopCast(
    Instruction::CastOps Opcode,
    Type *SrcTy,
    Type *DstTy,
    Type *IntPtrTy
  );


  bool isNoopCast(
    Type *IntPtrTy
  ) const;







  static unsigned isEliminableCastPair(
    Instruction::CastOps firstOpcode,
    Instruction::CastOps secondOpcode,
    Type *SrcTy,
    Type *MidTy,
    Type *DstTy,
    Type *SrcIntPtrTy,
    Type *MidIntPtrTy,
    Type *DstIntPtrTy
  );


  Instruction::CastOps getOpcode() const {
    return Instruction::CastOps(Instruction::getOpcode());
  }


  Type* getSrcTy() const { return getOperand(0)->getType(); }

  Type* getDestTy() const { return getType(); }





  static bool castIsValid(Instruction::CastOps op, Value *S, Type *DstTy);


  static inline bool classof(const Instruction *I) {
    return I->isCast();
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};







class CmpInst : public Instruction {
  void *operator new(size_t, unsigned) ;
  CmpInst() ;
protected:
  CmpInst(Type *ty, Instruction::OtherOps op, unsigned short pred,
          Value *LHS, Value *RHS, const Twine &Name = "",
          Instruction *InsertBefore = 0);

  CmpInst(Type *ty, Instruction::OtherOps op, unsigned short pred,
          Value *LHS, Value *RHS, const Twine &Name,
          BasicBlock *InsertAtEnd);

  virtual void anchor() ;
public:




  enum Predicate {

    FCMP_FALSE = 0,
    FCMP_OEQ = 1,
    FCMP_OGT = 2,
    FCMP_OGE = 3,
    FCMP_OLT = 4,
    FCMP_OLE = 5,
    FCMP_ONE = 6,
    FCMP_ORD = 7,
    FCMP_UNO = 8,
    FCMP_UEQ = 9,
    FCMP_UGT = 10,
    FCMP_UGE = 11,
    FCMP_ULT = 12,
    FCMP_ULE = 13,
    FCMP_UNE = 14,
    FCMP_TRUE = 15,
    FIRST_FCMP_PREDICATE = FCMP_FALSE,
    LAST_FCMP_PREDICATE = FCMP_TRUE,
    BAD_FCMP_PREDICATE = FCMP_TRUE + 1,
    ICMP_EQ = 32,
    ICMP_NE = 33,
    ICMP_UGT = 34,
    ICMP_UGE = 35,
    ICMP_ULT = 36,
    ICMP_ULE = 37,
    ICMP_SGT = 38,
    ICMP_SGE = 39,
    ICMP_SLT = 40,
    ICMP_SLE = 41,
    FIRST_ICMP_PREDICATE = ICMP_EQ,
    LAST_ICMP_PREDICATE = ICMP_SLE,
    BAD_ICMP_PREDICATE = ICMP_SLE + 1
  };


  void *operator new(size_t s) {
    return User::operator new(s, 2);
  }





  static CmpInst *Create(OtherOps Op,
                         unsigned short predicate, Value *S1,
                         Value *S2, const Twine &Name = "",
                         Instruction *InsertBefore = 0);





  static CmpInst *Create(OtherOps Op, unsigned short predicate, Value *S1,
                         Value *S2, const Twine &Name, BasicBlock *InsertAtEnd);


  OtherOps getOpcode() const {
    return static_cast<OtherOps>(Instruction::getOpcode());
  }


  Predicate getPredicate() const {
    return Predicate(getSubclassDataFromInstruction());
  }


  void setPredicate(Predicate P) { setInstructionSubclassData(P); }

  static bool isFPPredicate(Predicate P) {
    return P >= FIRST_FCMP_PREDICATE && P <= LAST_FCMP_PREDICATE;
  }

  static bool isIntPredicate(Predicate P) {
    return P >= FIRST_ICMP_PREDICATE && P <= LAST_ICMP_PREDICATE;
  }

  bool isFPPredicate() const { return isFPPredicate(getPredicate()); }
  bool isIntPredicate() const { return isIntPredicate(getPredicate()); }






  Predicate getInversePredicate() const {
    return getInversePredicate(getPredicate());
  }





  static Predicate getInversePredicate(Predicate pred);







  Predicate getSwappedPredicate() const {
    return getSwappedPredicate(getPredicate());
  }




  static Predicate getSwappedPredicate(Predicate pred);


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;




  void swapOperands();



  bool isCommutative() const;



  bool isEquality() const;



  bool isSigned() const {
    return isSigned(getPredicate());
  }



  bool isUnsigned() const {
    return isUnsigned(getPredicate());
  }



  bool isTrueWhenEqual() const {
    return isTrueWhenEqual(getPredicate());
  }



  bool isFalseWhenEqual() const {
    return isFalseWhenEqual(getPredicate());
  }



  static bool isUnsigned(unsigned short predicate);



  static bool isSigned(unsigned short predicate);


  static bool isOrdered(unsigned short predicate);


  static bool isUnordered(unsigned short predicate);


  static bool isTrueWhenEqual(unsigned short predicate);


  static bool isFalseWhenEqual(unsigned short predicate);


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::ICmp ||
           I->getOpcode() == Instruction::FCmp;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }


  static Type* makeCmpResultType(Type* opnd_type) {
    if (VectorType* vt = dyn_cast<VectorType>(opnd_type)) {
      return VectorType::get(Type::getInt1Ty(opnd_type->getContext()),
                             vt->getNumElements());
    }
    return Type::getInt1Ty(opnd_type->getContext());
  }
private:


  void setValueSubclassData(unsigned short D) {
    Value::setValueSubclassData(D);
  }
};



template <>
struct OperandTraits<CmpInst> : public FixedNumOperandTraits<CmpInst, 2> {
};

CmpInst::op_iterator CmpInst::op_begin() { return OperandTraits<CmpInst>::op_begin(this); } CmpInst::const_op_iterator CmpInst::op_begin() const { return OperandTraits<CmpInst>::op_begin(const_cast<CmpInst*>(this)); } CmpInst::op_iterator CmpInst::op_end() { return OperandTraits<CmpInst>::op_end(this); } CmpInst::const_op_iterator CmpInst::op_end() const { return OperandTraits<CmpInst>::op_end(const_cast<CmpInst*>(this)); } Value *CmpInst::getOperand(unsigned i_nocapture) const { ((void)((i_nocapture < OperandTraits<CmpInst>::operands(this) && "getOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<CmpInst>::operands(this) && \"getOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/InstrTypes.h", 853, __func__),0))); return cast_or_null<Value>( OperandTraits<CmpInst>::op_begin(const_cast<CmpInst*>(this))[i_nocapture].get()); } void CmpInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((void)((i_nocapture < OperandTraits<CmpInst>::operands(this) && "setOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<CmpInst>::operands(this) && \"setOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/InstrTypes.h", 853, __func__),0))); OperandTraits<CmpInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned CmpInst::getNumOperands() const { return OperandTraits<CmpInst>::operands(this); } template <int Idx_nocapture> Use &CmpInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &CmpInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }

}
# 25 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h" 2



namespace llvm {

class APInt;
class ConstantInt;
class ConstantRange;
class DataLayout;
class LLVMContext;

enum AtomicOrdering {
  NotAtomic = 0,
  Unordered = 1,
  Monotonic = 2,

  Acquire = 4,
  Release = 5,
  AcquireRelease = 6,
  SequentiallyConsistent = 7
};

enum SynchronizationScope {
  SingleThread = 0,
  CrossThread = 1
};







class AllocaInst : public UnaryInstruction {
protected:
  virtual AllocaInst *clone_impl() const;
public:
  explicit AllocaInst(Type *Ty, Value *ArraySize = 0,
                      const Twine &Name = "", Instruction *InsertBefore = 0);
  AllocaInst(Type *Ty, Value *ArraySize,
             const Twine &Name, BasicBlock *InsertAtEnd);

  AllocaInst(Type *Ty, const Twine &Name, Instruction *InsertBefore = 0);
  AllocaInst(Type *Ty, const Twine &Name, BasicBlock *InsertAtEnd);

  AllocaInst(Type *Ty, Value *ArraySize, unsigned Align,
             const Twine &Name = "", Instruction *InsertBefore = 0);
  AllocaInst(Type *Ty, Value *ArraySize, unsigned Align,
             const Twine &Name, BasicBlock *InsertAtEnd);


  virtual ~AllocaInst();




  bool isArrayAllocation() const;




  const Value *getArraySize() const { return getOperand(0); }
  Value *getArraySize() { return getOperand(0); }



  PointerType *getType() const {
    return cast<PointerType>(Instruction::getType());
  }




  Type *getAllocatedType() const;




  unsigned getAlignment() const {
    return (1u << getSubclassDataFromInstruction()) >> 1;
  }
  void setAlignment(unsigned Align);




  bool isStaticAlloca() const;


  static inline bool classof(const Instruction *I) {
    return (I->getOpcode() == Instruction::Alloca);
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
private:


  void setInstructionSubclassData(unsigned short D) {
    Instruction::setInstructionSubclassData(D);
  }
};
# 136 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h"
class LoadInst : public UnaryInstruction {
  void AssertOK();
protected:
  virtual LoadInst *clone_impl() const;
public:
  LoadInst(Value *Ptr, const Twine &NameStr, Instruction *InsertBefore);
  LoadInst(Value *Ptr, const Twine &NameStr, BasicBlock *InsertAtEnd);
  LoadInst(Value *Ptr, const Twine &NameStr, bool isVolatile = false,
           Instruction *InsertBefore = 0);
  LoadInst(Value *Ptr, const Twine &NameStr, bool isVolatile,
           BasicBlock *InsertAtEnd);
  LoadInst(Value *Ptr, const Twine &NameStr, bool isVolatile,
           unsigned Align, Instruction *InsertBefore = 0);
  LoadInst(Value *Ptr, const Twine &NameStr, bool isVolatile,
           unsigned Align, BasicBlock *InsertAtEnd);
  LoadInst(Value *Ptr, const Twine &NameStr, bool isVolatile,
           unsigned Align, AtomicOrdering Order,
           SynchronizationScope SynchScope = CrossThread,
           Instruction *InsertBefore = 0);
  LoadInst(Value *Ptr, const Twine &NameStr, bool isVolatile,
           unsigned Align, AtomicOrdering Order,
           SynchronizationScope SynchScope,
           BasicBlock *InsertAtEnd);

  LoadInst(Value *Ptr, const char *NameStr, Instruction *InsertBefore);
  LoadInst(Value *Ptr, const char *NameStr, BasicBlock *InsertAtEnd);
  explicit LoadInst(Value *Ptr, const char *NameStr = 0,
                    bool isVolatile = false, Instruction *InsertBefore = 0);
  LoadInst(Value *Ptr, const char *NameStr, bool isVolatile,
           BasicBlock *InsertAtEnd);




  bool isVolatile() const { return getSubclassDataFromInstruction() & 1; }



  void setVolatile(bool V) {
    setInstructionSubclassData((getSubclassDataFromInstruction() & ~1) |
                               (V ? 1 : 0));
  }



  unsigned getAlignment() const {
    return (1 << ((getSubclassDataFromInstruction() >> 1) & 31)) >> 1;
  }

  void setAlignment(unsigned Align);


  AtomicOrdering getOrdering() const {
    return AtomicOrdering((getSubclassDataFromInstruction() >> 7) & 7);
  }



  void setOrdering(AtomicOrdering Ordering) {
    setInstructionSubclassData((getSubclassDataFromInstruction() & ~(7 << 7)) |
                               (Ordering << 7));
  }

  SynchronizationScope getSynchScope() const {
    return SynchronizationScope((getSubclassDataFromInstruction() >> 6) & 1);
  }




  void setSynchScope(SynchronizationScope xthread) {
    setInstructionSubclassData((getSubclassDataFromInstruction() & ~(1 << 6)) |
                               (xthread << 6));
  }

  bool isAtomic() const { return getOrdering() != NotAtomic; }
  void setAtomic(AtomicOrdering Ordering,
                 SynchronizationScope SynchScope = CrossThread) {
    setOrdering(Ordering);
    setSynchScope(SynchScope);
  }

  bool isSimple() const { return !isAtomic() && !isVolatile(); }
  bool isUnordered() const {
    return getOrdering() <= Unordered && !isVolatile();
  }

  Value *getPointerOperand() { return getOperand(0); }
  const Value *getPointerOperand() const { return getOperand(0); }
  static unsigned getPointerOperandIndex() { return 0U; }


  unsigned getPointerAddressSpace() const {
    return getPointerOperand()->getType()->getPointerAddressSpace();
  }



  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::Load;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
private:


  void setInstructionSubclassData(unsigned short D) {
    Instruction::setInstructionSubclassData(D);
  }
};
# 255 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h"
class StoreInst : public Instruction {
  void *operator new(size_t, unsigned) ;
  void AssertOK();
protected:
  virtual StoreInst *clone_impl() const;
public:

  void *operator new(size_t s) {
    return User::operator new(s, 2);
  }
  StoreInst(Value *Val, Value *Ptr, Instruction *InsertBefore);
  StoreInst(Value *Val, Value *Ptr, BasicBlock *InsertAtEnd);
  StoreInst(Value *Val, Value *Ptr, bool isVolatile = false,
            Instruction *InsertBefore = 0);
  StoreInst(Value *Val, Value *Ptr, bool isVolatile, BasicBlock *InsertAtEnd);
  StoreInst(Value *Val, Value *Ptr, bool isVolatile,
            unsigned Align, Instruction *InsertBefore = 0);
  StoreInst(Value *Val, Value *Ptr, bool isVolatile,
            unsigned Align, BasicBlock *InsertAtEnd);
  StoreInst(Value *Val, Value *Ptr, bool isVolatile,
            unsigned Align, AtomicOrdering Order,
            SynchronizationScope SynchScope = CrossThread,
            Instruction *InsertBefore = 0);
  StoreInst(Value *Val, Value *Ptr, bool isVolatile,
            unsigned Align, AtomicOrdering Order,
            SynchronizationScope SynchScope,
            BasicBlock *InsertAtEnd);





  bool isVolatile() const { return getSubclassDataFromInstruction() & 1; }



  void setVolatile(bool V) {
    setInstructionSubclassData((getSubclassDataFromInstruction() & ~1) |
                               (V ? 1 : 0));
  }


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;



  unsigned getAlignment() const {
    return (1 << ((getSubclassDataFromInstruction() >> 1) & 31)) >> 1;
  }

  void setAlignment(unsigned Align);


  AtomicOrdering getOrdering() const {
    return AtomicOrdering((getSubclassDataFromInstruction() >> 7) & 7);
  }



  void setOrdering(AtomicOrdering Ordering) {
    setInstructionSubclassData((getSubclassDataFromInstruction() & ~(7 << 7)) |
                               (Ordering << 7));
  }

  SynchronizationScope getSynchScope() const {
    return SynchronizationScope((getSubclassDataFromInstruction() >> 6) & 1);
  }




  void setSynchScope(SynchronizationScope xthread) {
    setInstructionSubclassData((getSubclassDataFromInstruction() & ~(1 << 6)) |
                               (xthread << 6));
  }

  bool isAtomic() const { return getOrdering() != NotAtomic; }
  void setAtomic(AtomicOrdering Ordering,
                 SynchronizationScope SynchScope = CrossThread) {
    setOrdering(Ordering);
    setSynchScope(SynchScope);
  }

  bool isSimple() const { return !isAtomic() && !isVolatile(); }
  bool isUnordered() const {
    return getOrdering() <= Unordered && !isVolatile();
  }

  Value *getValueOperand() { return getOperand(0); }
  const Value *getValueOperand() const { return getOperand(0); }

  Value *getPointerOperand() { return getOperand(1); }
  const Value *getPointerOperand() const { return getOperand(1); }
  static unsigned getPointerOperandIndex() { return 1U; }


  unsigned getPointerAddressSpace() const {
    return getPointerOperand()->getType()->getPointerAddressSpace();
  }


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::Store;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
private:


  void setInstructionSubclassData(unsigned short D) {
    Instruction::setInstructionSubclassData(D);
  }
};

template <>
struct OperandTraits<StoreInst> : public FixedNumOperandTraits<StoreInst, 2> {
};

StoreInst::op_iterator StoreInst::op_begin() { return OperandTraits<StoreInst>::op_begin(this); } StoreInst::const_op_iterator StoreInst::op_begin() const { return OperandTraits<StoreInst>::op_begin(const_cast<StoreInst*>(this)); } StoreInst::op_iterator StoreInst::op_end() { return OperandTraits<StoreInst>::op_end(this); } StoreInst::const_op_iterator StoreInst::op_end() const { return OperandTraits<StoreInst>::op_end(const_cast<StoreInst*>(this)); } Value *StoreInst::getOperand(unsigned i_nocapture) const { ((void)((i_nocapture < OperandTraits<StoreInst>::operands(this) && "getOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<StoreInst>::operands(this) && \"getOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 374, __func__),0))); return cast_or_null<Value>( OperandTraits<StoreInst>::op_begin(const_cast<StoreInst*>(this))[i_nocapture].get()); } void StoreInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((void)((i_nocapture < OperandTraits<StoreInst>::operands(this) && "setOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<StoreInst>::operands(this) && \"setOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 374, __func__),0))); OperandTraits<StoreInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned StoreInst::getNumOperands() const { return OperandTraits<StoreInst>::operands(this); } template <int Idx_nocapture> Use &StoreInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &StoreInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }







class FenceInst : public Instruction {
  void *operator new(size_t, unsigned) ;
  void Init(AtomicOrdering Ordering, SynchronizationScope SynchScope);
protected:
  virtual FenceInst *clone_impl() const;
public:

  void *operator new(size_t s) {
    return User::operator new(s, 0);
  }



  FenceInst(LLVMContext &C, AtomicOrdering Ordering,
            SynchronizationScope SynchScope = CrossThread,
            Instruction *InsertBefore = 0);
  FenceInst(LLVMContext &C, AtomicOrdering Ordering,
            SynchronizationScope SynchScope,
            BasicBlock *InsertAtEnd);


  AtomicOrdering getOrdering() const {
    return AtomicOrdering(getSubclassDataFromInstruction() >> 1);
  }



  void setOrdering(AtomicOrdering Ordering) {
    setInstructionSubclassData((getSubclassDataFromInstruction() & 1) |
                               (Ordering << 1));
  }

  SynchronizationScope getSynchScope() const {
    return SynchronizationScope(getSubclassDataFromInstruction() & 1);
  }




  void setSynchScope(SynchronizationScope xthread) {
    setInstructionSubclassData((getSubclassDataFromInstruction() & ~1) |
                               xthread);
  }


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::Fence;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
private:


  void setInstructionSubclassData(unsigned short D) {
    Instruction::setInstructionSubclassData(D);
  }
};
# 449 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h"
class AtomicCmpXchgInst : public Instruction {
  void *operator new(size_t, unsigned) ;
  void Init(Value *Ptr, Value *Cmp, Value *NewVal,
            AtomicOrdering Ordering, SynchronizationScope SynchScope);
protected:
  virtual AtomicCmpXchgInst *clone_impl() const;
public:

  void *operator new(size_t s) {
    return User::operator new(s, 3);
  }
  AtomicCmpXchgInst(Value *Ptr, Value *Cmp, Value *NewVal,
                    AtomicOrdering Ordering, SynchronizationScope SynchScope,
                    Instruction *InsertBefore = 0);
  AtomicCmpXchgInst(Value *Ptr, Value *Cmp, Value *NewVal,
                    AtomicOrdering Ordering, SynchronizationScope SynchScope,
                    BasicBlock *InsertAtEnd);




  bool isVolatile() const {
    return getSubclassDataFromInstruction() & 1;
  }



  void setVolatile(bool V) {
     setInstructionSubclassData((getSubclassDataFromInstruction() & ~1) |
                                (unsigned)V);
  }


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;


  void setOrdering(AtomicOrdering Ordering) {
    ((void)((Ordering != NotAtomic && "CmpXchg instructions can only be atomic.") || (__assert_fail("Ordering != NotAtomic && \"CmpXchg instructions can only be atomic.\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 487, __func__),0)));

    setInstructionSubclassData((getSubclassDataFromInstruction() & 3) |
                               (Ordering << 2));
  }




  void setSynchScope(SynchronizationScope SynchScope) {
    setInstructionSubclassData((getSubclassDataFromInstruction() & ~2) |
                               (SynchScope << 1));
  }


  AtomicOrdering getOrdering() const {
    return AtomicOrdering(getSubclassDataFromInstruction() >> 2);
  }



  SynchronizationScope getSynchScope() const {
    return SynchronizationScope((getSubclassDataFromInstruction() & 2) >> 1);
  }

  Value *getPointerOperand() { return getOperand(0); }
  const Value *getPointerOperand() const { return getOperand(0); }
  static unsigned getPointerOperandIndex() { return 0U; }

  Value *getCompareOperand() { return getOperand(1); }
  const Value *getCompareOperand() const { return getOperand(1); }

  Value *getNewValOperand() { return getOperand(2); }
  const Value *getNewValOperand() const { return getOperand(2); }


  unsigned getPointerAddressSpace() const {
    return getPointerOperand()->getType()->getPointerAddressSpace();
  }


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::AtomicCmpXchg;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
private:


  void setInstructionSubclassData(unsigned short D) {
    Instruction::setInstructionSubclassData(D);
  }
};

template <>
struct OperandTraits<AtomicCmpXchgInst> :
    public FixedNumOperandTraits<AtomicCmpXchgInst, 3> {
};

AtomicCmpXchgInst::op_iterator AtomicCmpXchgInst::op_begin() { return OperandTraits<AtomicCmpXchgInst>::op_begin(this); } AtomicCmpXchgInst::const_op_iterator AtomicCmpXchgInst::op_begin() const { return OperandTraits<AtomicCmpXchgInst>::op_begin(const_cast<AtomicCmpXchgInst*>(this)); } AtomicCmpXchgInst::op_iterator AtomicCmpXchgInst::op_end() { return OperandTraits<AtomicCmpXchgInst>::op_end(this); } AtomicCmpXchgInst::const_op_iterator AtomicCmpXchgInst::op_end() const { return OperandTraits<AtomicCmpXchgInst>::op_end(const_cast<AtomicCmpXchgInst*>(this)); } Value *AtomicCmpXchgInst::getOperand(unsigned i_nocapture) const { ((void)((i_nocapture < OperandTraits<AtomicCmpXchgInst>::operands(this) && "getOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<AtomicCmpXchgInst>::operands(this) && \"getOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 546, __func__),0))); return cast_or_null<Value>( OperandTraits<AtomicCmpXchgInst>::op_begin(const_cast<AtomicCmpXchgInst*>(this))[i_nocapture].get()); } void AtomicCmpXchgInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((void)((i_nocapture < OperandTraits<AtomicCmpXchgInst>::operands(this) && "setOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<AtomicCmpXchgInst>::operands(this) && \"setOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 546, __func__),0))); OperandTraits<AtomicCmpXchgInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned AtomicCmpXchgInst::getNumOperands() const { return OperandTraits<AtomicCmpXchgInst>::operands(this); } template <int Idx_nocapture> Use &AtomicCmpXchgInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &AtomicCmpXchgInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 556 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h"
class AtomicRMWInst : public Instruction {
  void *operator new(size_t, unsigned) ;
protected:
  virtual AtomicRMWInst *clone_impl() const;
public:




  enum BinOp {

    Xchg,

    Add,

    Sub,

    And,

    Nand,

    Or,

    Xor,

    Max,

    Min,

    UMax,

    UMin,

    FIRST_BINOP = Xchg,
    LAST_BINOP = UMin,
    BAD_BINOP
  };


  void *operator new(size_t s) {
    return User::operator new(s, 2);
  }
  AtomicRMWInst(BinOp Operation, Value *Ptr, Value *Val,
                AtomicOrdering Ordering, SynchronizationScope SynchScope,
                Instruction *InsertBefore = 0);
  AtomicRMWInst(BinOp Operation, Value *Ptr, Value *Val,
                AtomicOrdering Ordering, SynchronizationScope SynchScope,
                BasicBlock *InsertAtEnd);

  BinOp getOperation() const {
    return static_cast<BinOp>(getSubclassDataFromInstruction() >> 5);
  }

  void setOperation(BinOp Operation) {
    unsigned short SubclassData = getSubclassDataFromInstruction();
    setInstructionSubclassData((SubclassData & 31) |
                               (Operation << 5));
  }



  bool isVolatile() const {
    return getSubclassDataFromInstruction() & 1;
  }



  void setVolatile(bool V) {
     setInstructionSubclassData((getSubclassDataFromInstruction() & ~1) |
                                (unsigned)V);
  }


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;


  void setOrdering(AtomicOrdering Ordering) {
    ((void)((Ordering != NotAtomic && "atomicrmw instructions can only be atomic.") || (__assert_fail("Ordering != NotAtomic && \"atomicrmw instructions can only be atomic.\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 634, __func__),0)));

    setInstructionSubclassData((getSubclassDataFromInstruction() & ~(7 << 2)) |
                               (Ordering << 2));
  }




  void setSynchScope(SynchronizationScope SynchScope) {
    setInstructionSubclassData((getSubclassDataFromInstruction() & ~2) |
                               (SynchScope << 1));
  }


  AtomicOrdering getOrdering() const {
    return AtomicOrdering((getSubclassDataFromInstruction() >> 2) & 7);
  }



  SynchronizationScope getSynchScope() const {
    return SynchronizationScope((getSubclassDataFromInstruction() & 2) >> 1);
  }

  Value *getPointerOperand() { return getOperand(0); }
  const Value *getPointerOperand() const { return getOperand(0); }
  static unsigned getPointerOperandIndex() { return 0U; }

  Value *getValOperand() { return getOperand(1); }
  const Value *getValOperand() const { return getOperand(1); }


  unsigned getPointerAddressSpace() const {
    return getPointerOperand()->getType()->getPointerAddressSpace();
  }


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::AtomicRMW;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
private:
  void Init(BinOp Operation, Value *Ptr, Value *Val,
            AtomicOrdering Ordering, SynchronizationScope SynchScope);


  void setInstructionSubclassData(unsigned short D) {
    Instruction::setInstructionSubclassData(D);
  }
};

template <>
struct OperandTraits<AtomicRMWInst>
    : public FixedNumOperandTraits<AtomicRMWInst,2> {
};

AtomicRMWInst::op_iterator AtomicRMWInst::op_begin() { return OperandTraits<AtomicRMWInst>::op_begin(this); } AtomicRMWInst::const_op_iterator AtomicRMWInst::op_begin() const { return OperandTraits<AtomicRMWInst>::op_begin(const_cast<AtomicRMWInst*>(this)); } AtomicRMWInst::op_iterator AtomicRMWInst::op_end() { return OperandTraits<AtomicRMWInst>::op_end(this); } AtomicRMWInst::const_op_iterator AtomicRMWInst::op_end() const { return OperandTraits<AtomicRMWInst>::op_end(const_cast<AtomicRMWInst*>(this)); } Value *AtomicRMWInst::getOperand(unsigned i_nocapture) const { ((void)((i_nocapture < OperandTraits<AtomicRMWInst>::operands(this) && "getOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<AtomicRMWInst>::operands(this) && \"getOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 692, __func__),0))); return cast_or_null<Value>( OperandTraits<AtomicRMWInst>::op_begin(const_cast<AtomicRMWInst*>(this))[i_nocapture].get()); } void AtomicRMWInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((void)((i_nocapture < OperandTraits<AtomicRMWInst>::operands(this) && "setOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<AtomicRMWInst>::operands(this) && \"setOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 692, __func__),0))); OperandTraits<AtomicRMWInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned AtomicRMWInst::getNumOperands() const { return OperandTraits<AtomicRMWInst>::operands(this); } template <int Idx_nocapture> Use &AtomicRMWInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &AtomicRMWInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 701 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h"
inline Type *checkGEPType(Type *Ty) {
  ((void)((Ty && "Invalid GetElementPtrInst indices for type!") || (__assert_fail("Ty && \"Invalid GetElementPtrInst indices for type!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 702, __func__),0)));
  return Ty;
}




class GetElementPtrInst : public Instruction {
  GetElementPtrInst(const GetElementPtrInst &GEPI);
  void init(Value *Ptr, ArrayRef<Value *> IdxList, const Twine &NameStr);





  inline GetElementPtrInst(Value *Ptr, ArrayRef<Value *> IdxList,
                           unsigned Values, const Twine &NameStr,
                           Instruction *InsertBefore);
  inline GetElementPtrInst(Value *Ptr, ArrayRef<Value *> IdxList,
                           unsigned Values, const Twine &NameStr,
                           BasicBlock *InsertAtEnd);
protected:
  virtual GetElementPtrInst *clone_impl() const;
public:
  static GetElementPtrInst *Create(Value *Ptr, ArrayRef<Value *> IdxList,
                                   const Twine &NameStr = "",
                                   Instruction *InsertBefore = 0) {
    unsigned Values = 1 + unsigned(IdxList.size());
    return new(Values)
      GetElementPtrInst(Ptr, IdxList, Values, NameStr, InsertBefore);
  }
  static GetElementPtrInst *Create(Value *Ptr, ArrayRef<Value *> IdxList,
                                   const Twine &NameStr,
                                   BasicBlock *InsertAtEnd) {
    unsigned Values = 1 + unsigned(IdxList.size());
    return new(Values)
      GetElementPtrInst(Ptr, IdxList, Values, NameStr, InsertAtEnd);
  }



  static GetElementPtrInst *CreateInBounds(Value *Ptr,
                                           ArrayRef<Value *> IdxList,
                                           const Twine &NameStr = "",
                                           Instruction *InsertBefore = 0) {
    GetElementPtrInst *GEP = Create(Ptr, IdxList, NameStr, InsertBefore);
    GEP->setIsInBounds(true);
    return GEP;
  }
  static GetElementPtrInst *CreateInBounds(Value *Ptr,
                                           ArrayRef<Value *> IdxList,
                                           const Twine &NameStr,
                                           BasicBlock *InsertAtEnd) {
    GetElementPtrInst *GEP = Create(Ptr, IdxList, NameStr, InsertAtEnd);
    GEP->setIsInBounds(true);
    return GEP;
  }


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;


  SequentialType *getType() const {
    return cast<SequentialType>(Instruction::getType());
  }


  unsigned getAddressSpace() const {


    return getPointerAddressSpace();
  }







  static Type *getIndexedType(Type *Ptr, ArrayRef<Value *> IdxList);
  static Type *getIndexedType(Type *Ptr, ArrayRef<Constant *> IdxList);
  static Type *getIndexedType(Type *Ptr, ArrayRef<uint64_t> IdxList);

  inline op_iterator idx_begin() { return op_begin()+1; }
  inline const_op_iterator idx_begin() const { return op_begin()+1; }
  inline op_iterator idx_end() { return op_end(); }
  inline const_op_iterator idx_end() const { return op_end(); }

  Value *getPointerOperand() {
    return getOperand(0);
  }
  const Value *getPointerOperand() const {
    return getOperand(0);
  }
  static unsigned getPointerOperandIndex() {
    return 0U;
  }



  Type *getPointerOperandType() const {
    return getPointerOperand()->getType();
  }


  unsigned getPointerAddressSpace() const {
    return getPointerOperandType()->getPointerAddressSpace();
  }



  static Type *getGEPReturnType(Value *Ptr, ArrayRef<Value *> IdxList) {
    Type *PtrTy = PointerType::get(checkGEPType(
                                   getIndexedType(Ptr->getType(), IdxList)),
                                   Ptr->getType()->getPointerAddressSpace());

    if (Ptr->getType()->isVectorTy()) {
      unsigned NumElem = cast<VectorType>(Ptr->getType())->getNumElements();
      return VectorType::get(PtrTy, NumElem);
    }


    return PtrTy;
  }

  unsigned getNumIndices() const {
    return getNumOperands() - 1;
  }

  bool hasIndices() const {
    return getNumOperands() > 1;
  }




  bool hasAllZeroIndices() const;




  bool hasAllConstantIndices() const;



  void setIsInBounds(bool b = true);


  bool isInBounds() const;
# 860 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h"
  bool accumulateConstantOffset(const DataLayout &DL, APInt &Offset) const;


  static inline bool classof(const Instruction *I) {
    return (I->getOpcode() == Instruction::GetElementPtr);
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};

template <>
struct OperandTraits<GetElementPtrInst> :
  public VariadicOperandTraits<GetElementPtrInst, 1> {
};

GetElementPtrInst::GetElementPtrInst(Value *Ptr,
                                     ArrayRef<Value *> IdxList,
                                     unsigned Values,
                                     const Twine &NameStr,
                                     Instruction *InsertBefore)
  : Instruction(getGEPReturnType(Ptr, IdxList),
                GetElementPtr,
                OperandTraits<GetElementPtrInst>::op_end(this) - Values,
                Values, InsertBefore) {
  init(Ptr, IdxList, NameStr);
}
GetElementPtrInst::GetElementPtrInst(Value *Ptr,
                                     ArrayRef<Value *> IdxList,
                                     unsigned Values,
                                     const Twine &NameStr,
                                     BasicBlock *InsertAtEnd)
  : Instruction(getGEPReturnType(Ptr, IdxList),
                GetElementPtr,
                OperandTraits<GetElementPtrInst>::op_end(this) - Values,
                Values, InsertAtEnd) {
  init(Ptr, IdxList, NameStr);
}


GetElementPtrInst::op_iterator GetElementPtrInst::op_begin() { return OperandTraits<GetElementPtrInst>::op_begin(this); } GetElementPtrInst::const_op_iterator GetElementPtrInst::op_begin() const { return OperandTraits<GetElementPtrInst>::op_begin(const_cast<GetElementPtrInst*>(this)); } GetElementPtrInst::op_iterator GetElementPtrInst::op_end() { return OperandTraits<GetElementPtrInst>::op_end(this); } GetElementPtrInst::const_op_iterator GetElementPtrInst::op_end() const { return OperandTraits<GetElementPtrInst>::op_end(const_cast<GetElementPtrInst*>(this)); } Value *GetElementPtrInst::getOperand(unsigned i_nocapture) const { ((void)((i_nocapture < OperandTraits<GetElementPtrInst>::operands(this) && "getOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<GetElementPtrInst>::operands(this) && \"getOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 900, __func__),0))); return cast_or_null<Value>( OperandTraits<GetElementPtrInst>::op_begin(const_cast<GetElementPtrInst*>(this))[i_nocapture].get()); } void GetElementPtrInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((void)((i_nocapture < OperandTraits<GetElementPtrInst>::operands(this) && "setOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<GetElementPtrInst>::operands(this) && \"setOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 900, __func__),0))); OperandTraits<GetElementPtrInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned GetElementPtrInst::getNumOperands() const { return OperandTraits<GetElementPtrInst>::operands(this); } template <int Idx_nocapture> Use &GetElementPtrInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &GetElementPtrInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 911 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h"
class ICmpInst: public CmpInst {
  void AssertOK() {
    ((void)((getPredicate() >= CmpInst::FIRST_ICMP_PREDICATE && getPredicate() <= CmpInst::LAST_ICMP_PREDICATE && "Invalid ICmp predicate value") || (__assert_fail("getPredicate() >= CmpInst::FIRST_ICMP_PREDICATE && getPredicate() <= CmpInst::LAST_ICMP_PREDICATE && \"Invalid ICmp predicate value\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 915, __func__),0)));


    ((void)((getOperand(0)->getType() == getOperand(1)->getType() && "Both operands to ICmp instruction are not of the same type!") || (__assert_fail("getOperand(0)->getType() == getOperand(1)->getType() && \"Both operands to ICmp instruction are not of the same type!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 917, __func__),0)));


    ((void)(((getOperand(0)->getType()->isIntOrIntVectorTy() || getOperand(0)->getType()->isPtrOrPtrVectorTy()) && "Invalid operand types for ICmp instruction") || (__assert_fail("(getOperand(0)->getType()->isIntOrIntVectorTy() || getOperand(0)->getType()->isPtrOrPtrVectorTy()) && \"Invalid operand types for ICmp instruction\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 921, __func__),0)));


  }

protected:

  virtual ICmpInst *clone_impl() const;
public:

  ICmpInst(
    Instruction *InsertBefore,
    Predicate pred,
    Value *LHS,
    Value *RHS,
    const Twine &NameStr = ""
  ) : CmpInst(makeCmpResultType(LHS->getType()),
              Instruction::ICmp, pred, LHS, RHS, NameStr,
              InsertBefore) {

  AssertOK();

  }


  ICmpInst(
    BasicBlock &InsertAtEnd,
    Predicate pred,
    Value *LHS,
    Value *RHS,
    const Twine &NameStr = ""
  ) : CmpInst(makeCmpResultType(LHS->getType()),
              Instruction::ICmp, pred, LHS, RHS, NameStr,
              &InsertAtEnd) {

  AssertOK();

  }


  ICmpInst(
    Predicate pred,
    Value *LHS,
    Value *RHS,
    const Twine &NameStr = ""
  ) : CmpInst(makeCmpResultType(LHS->getType()),
              Instruction::ICmp, pred, LHS, RHS, NameStr) {

  AssertOK();

  }





  Predicate getSignedPredicate() const {
    return getSignedPredicate(getPredicate());
  }



  static Predicate getSignedPredicate(Predicate pred);





  Predicate getUnsignedPredicate() const {
    return getUnsignedPredicate(getPredicate());
  }



  static Predicate getUnsignedPredicate(Predicate pred);



  static bool isEquality(Predicate P) {
    return P == ICMP_EQ || P == ICMP_NE;
  }



  bool isEquality() const {
    return isEquality(getPredicate());
  }



  bool isCommutative() const { return isEquality(); }



  bool isRelational() const {
    return !isEquality();
  }



  static bool isRelational(Predicate P) {
    return !isEquality(P);
  }



  static ConstantRange makeConstantRange(Predicate pred, const APInt &C);






  void swapOperands() {
    setPredicate(getSwappedPredicate());
    Op<0>().swap(Op<1>());
  }


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::ICmp;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }

};
# 1055 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h"
class FCmpInst: public CmpInst {
protected:

  virtual FCmpInst *clone_impl() const;
public:

  FCmpInst(
    Instruction *InsertBefore,
    Predicate pred,
    Value *LHS,
    Value *RHS,
    const Twine &NameStr = ""
  ) : CmpInst(makeCmpResultType(LHS->getType()),
              Instruction::FCmp, pred, LHS, RHS, NameStr,
              InsertBefore) {
    ((void)((pred <= FCmpInst::LAST_FCMP_PREDICATE && "Invalid FCmp predicate value") || (__assert_fail("pred <= FCmpInst::LAST_FCMP_PREDICATE && \"Invalid FCmp predicate value\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 1071, __func__),0)));

    ((void)((getOperand(0)->getType() == getOperand(1)->getType() && "Both operands to FCmp instruction are not of the same type!") || (__assert_fail("getOperand(0)->getType() == getOperand(1)->getType() && \"Both operands to FCmp instruction are not of the same type!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 1073, __func__),0)));


    ((void)((getOperand(0)->getType()->isFPOrFPVectorTy() && "Invalid operand types for FCmp instruction") || (__assert_fail("getOperand(0)->getType()->isFPOrFPVectorTy() && \"Invalid operand types for FCmp instruction\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 1076, __func__),0)));

  }


  FCmpInst(
    BasicBlock &InsertAtEnd,
    Predicate pred,
    Value *LHS,
    Value *RHS,
    const Twine &NameStr = ""
  ) : CmpInst(makeCmpResultType(LHS->getType()),
              Instruction::FCmp, pred, LHS, RHS, NameStr,
              &InsertAtEnd) {
    ((void)((pred <= FCmpInst::LAST_FCMP_PREDICATE && "Invalid FCmp predicate value") || (__assert_fail("pred <= FCmpInst::LAST_FCMP_PREDICATE && \"Invalid FCmp predicate value\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 1090, __func__),0)));

    ((void)((getOperand(0)->getType() == getOperand(1)->getType() && "Both operands to FCmp instruction are not of the same type!") || (__assert_fail("getOperand(0)->getType() == getOperand(1)->getType() && \"Both operands to FCmp instruction are not of the same type!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 1092, __func__),0)));


    ((void)((getOperand(0)->getType()->isFPOrFPVectorTy() && "Invalid operand types for FCmp instruction") || (__assert_fail("getOperand(0)->getType()->isFPOrFPVectorTy() && \"Invalid operand types for FCmp instruction\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 1095, __func__),0)));

  }


  FCmpInst(
    Predicate pred,
    Value *LHS,
    Value *RHS,
    const Twine &NameStr = ""
  ) : CmpInst(makeCmpResultType(LHS->getType()),
              Instruction::FCmp, pred, LHS, RHS, NameStr) {
    ((void)((pred <= FCmpInst::LAST_FCMP_PREDICATE && "Invalid FCmp predicate value") || (__assert_fail("pred <= FCmpInst::LAST_FCMP_PREDICATE && \"Invalid FCmp predicate value\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 1107, __func__),0)));

    ((void)((getOperand(0)->getType() == getOperand(1)->getType() && "Both operands to FCmp instruction are not of the same type!") || (__assert_fail("getOperand(0)->getType() == getOperand(1)->getType() && \"Both operands to FCmp instruction are not of the same type!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 1109, __func__),0)));


    ((void)((getOperand(0)->getType()->isFPOrFPVectorTy() && "Invalid operand types for FCmp instruction") || (__assert_fail("getOperand(0)->getType()->isFPOrFPVectorTy() && \"Invalid operand types for FCmp instruction\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 1112, __func__),0)));

  }



  bool isEquality() const {
    return getPredicate() == FCMP_OEQ || getPredicate() == FCMP_ONE ||
           getPredicate() == FCMP_UEQ || getPredicate() == FCMP_UNE;
  }



  bool isCommutative() const {
    return isEquality() ||
           getPredicate() == FCMP_FALSE ||
           getPredicate() == FCMP_TRUE ||
           getPredicate() == FCMP_ORD ||
           getPredicate() == FCMP_UNO;
  }



  bool isRelational() const { return !isEquality(); }






  void swapOperands() {
    setPredicate(getSwappedPredicate());
    Op<0>().swap(Op<1>());
  }


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::FCmp;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};







class CallInst : public Instruction {
  AttributeSet AttributeList;
  CallInst(const CallInst &CI);
  void init(Value *Func, ArrayRef<Value *> Args, const Twine &NameStr);
  void init(Value *Func, const Twine &NameStr);



  inline CallInst(Value *Func, ArrayRef<Value *> Args,
                  const Twine &NameStr, Instruction *InsertBefore);



  inline CallInst(Value *Func, ArrayRef<Value *> Args,
                  const Twine &NameStr, BasicBlock *InsertAtEnd);

  CallInst(Value *F, Value *Actual, const Twine &NameStr,
           Instruction *InsertBefore);
  CallInst(Value *F, Value *Actual, const Twine &NameStr,
           BasicBlock *InsertAtEnd);
  explicit CallInst(Value *F, const Twine &NameStr,
                    Instruction *InsertBefore);
  CallInst(Value *F, const Twine &NameStr, BasicBlock *InsertAtEnd);
protected:
  virtual CallInst *clone_impl() const;
public:
  static CallInst *Create(Value *Func,
                          ArrayRef<Value *> Args,
                          const Twine &NameStr = "",
                          Instruction *InsertBefore = 0) {
    return new(unsigned(Args.size() + 1))
      CallInst(Func, Args, NameStr, InsertBefore);
  }
  static CallInst *Create(Value *Func,
                          ArrayRef<Value *> Args,
                          const Twine &NameStr, BasicBlock *InsertAtEnd) {
    return new(unsigned(Args.size() + 1))
      CallInst(Func, Args, NameStr, InsertAtEnd);
  }
  static CallInst *Create(Value *F, const Twine &NameStr = "",
                          Instruction *InsertBefore = 0) {
    return new(1) CallInst(F, NameStr, InsertBefore);
  }
  static CallInst *Create(Value *F, const Twine &NameStr,
                          BasicBlock *InsertAtEnd) {
    return new(1) CallInst(F, NameStr, InsertAtEnd);
  }






  static Instruction *CreateMalloc(Instruction *InsertBefore,
                                   Type *IntPtrTy, Type *AllocTy,
                                   Value *AllocSize, Value *ArraySize = 0,
                                   Function* MallocF = 0,
                                   const Twine &Name = "");
  static Instruction *CreateMalloc(BasicBlock *InsertAtEnd,
                                   Type *IntPtrTy, Type *AllocTy,
                                   Value *AllocSize, Value *ArraySize = 0,
                                   Function* MallocF = 0,
                                   const Twine &Name = "");

  static Instruction* CreateFree(Value* Source, Instruction *InsertBefore);
  static Instruction* CreateFree(Value* Source, BasicBlock *InsertAtEnd);

  ~CallInst();

  bool isTailCall() const { return getSubclassDataFromInstruction() & 1; }
  void setTailCall(bool isTC = true) {
    setInstructionSubclassData((getSubclassDataFromInstruction() & ~1) |
                               unsigned(isTC));
  }


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;



  unsigned getNumArgOperands() const { return getNumOperands() - 1; }



  Value *getArgOperand(unsigned i) const { return getOperand(i); }
  void setArgOperand(unsigned i, Value *v) { setOperand(i, v); }



  CallingConv::ID getCallingConv() const {
    return static_cast<CallingConv::ID>(getSubclassDataFromInstruction() >> 1);
  }
  void setCallingConv(CallingConv::ID CC) {
    setInstructionSubclassData((getSubclassDataFromInstruction() & 1) |
                               (static_cast<unsigned>(CC) << 1));
  }



  const AttributeSet &getAttributes() const { return AttributeList; }



  void setAttributes(const AttributeSet &Attrs) { AttributeList = Attrs; }


  void addAttribute(unsigned i, Attribute::AttrKind attr);


  void removeAttribute(unsigned i, Attribute attr);


  bool hasFnAttr(Attribute::AttrKind A) const {
    ((void)((A != Attribute::NoBuiltin && "Use CallInst::isNoBuiltin() to check for Attribute::NoBuiltin") || (__assert_fail("A != Attribute::NoBuiltin && \"Use CallInst::isNoBuiltin() to check for Attribute::NoBuiltin\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 1275, __func__),0)));

    return hasFnAttrImpl(A);
  }


  bool paramHasAttr(unsigned i, Attribute::AttrKind A) const;


  unsigned getParamAlignment(unsigned i) const {
    return AttributeList.getParamAlignment(i);
  }



  bool isNoBuiltin() const {
    return hasFnAttrImpl(Attribute::NoBuiltin) &&
      !hasFnAttrImpl(Attribute::Builtin);
  }


  bool isNoInline() const { return hasFnAttr(Attribute::NoInline); }
  void setIsNoInline() {
    addAttribute(AttributeSet::FunctionIndex, Attribute::NoInline);
  }


  bool canReturnTwice() const {
    return hasFnAttr(Attribute::ReturnsTwice);
  }
  void setCanReturnTwice() {
    addAttribute(AttributeSet::FunctionIndex, Attribute::ReturnsTwice);
  }


  bool doesNotAccessMemory() const {
    return hasFnAttr(Attribute::ReadNone);
  }
  void setDoesNotAccessMemory() {
    addAttribute(AttributeSet::FunctionIndex, Attribute::ReadNone);
  }


  bool onlyReadsMemory() const {
    return doesNotAccessMemory() || hasFnAttr(Attribute::ReadOnly);
  }
  void setOnlyReadsMemory() {
    addAttribute(AttributeSet::FunctionIndex, Attribute::ReadOnly);
  }


  bool doesNotReturn() const { return hasFnAttr(Attribute::NoReturn); }
  void setDoesNotReturn() {
    addAttribute(AttributeSet::FunctionIndex, Attribute::NoReturn);
  }


  bool doesNotThrow() const { return hasFnAttr(Attribute::NoUnwind); }
  void setDoesNotThrow() {
    addAttribute(AttributeSet::FunctionIndex, Attribute::NoUnwind);
  }


  bool cannotDuplicate() const {return hasFnAttr(Attribute::NoDuplicate); }
  void setCannotDuplicate() {
    addAttribute(AttributeSet::FunctionIndex, Attribute::NoDuplicate);
  }



  bool hasStructRetAttr() const {

    return paramHasAttr(1, Attribute::StructRet);
  }


  bool hasByValArgument() const {
    return AttributeList.hasAttrSomewhere(Attribute::ByVal);
  }




  Function *getCalledFunction() const {
    return dyn_cast<Function>(Op<-1>());
  }



  const Value *getCalledValue() const { return Op<-1>(); }
        Value *getCalledValue() { return Op<-1>(); }


  void setCalledFunction(Value* Fn) {
    Op<-1>() = Fn;
  }


  bool isInlineAsm() const {
    return isa<InlineAsm>(Op<-1>());
  }


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::Call;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
private:

  bool hasFnAttrImpl(Attribute::AttrKind A) const;



  void setInstructionSubclassData(unsigned short D) {
    Instruction::setInstructionSubclassData(D);
  }
};

template <>
struct OperandTraits<CallInst> : public VariadicOperandTraits<CallInst, 1> {
};

CallInst::CallInst(Value *Func, ArrayRef<Value *> Args,
                   const Twine &NameStr, BasicBlock *InsertAtEnd)
  : Instruction(cast<FunctionType>(cast<PointerType>(Func->getType())
                                   ->getElementType())->getReturnType(),
                Instruction::Call,
                OperandTraits<CallInst>::op_end(this) - (Args.size() + 1),
                unsigned(Args.size() + 1), InsertAtEnd) {
  init(Func, Args, NameStr);
}

CallInst::CallInst(Value *Func, ArrayRef<Value *> Args,
                   const Twine &NameStr, Instruction *InsertBefore)
  : Instruction(cast<FunctionType>(cast<PointerType>(Func->getType())
                                   ->getElementType())->getReturnType(),
                Instruction::Call,
                OperandTraits<CallInst>::op_end(this) - (Args.size() + 1),
                unsigned(Args.size() + 1), InsertBefore) {
  init(Func, Args, NameStr);
}





CallInst::op_iterator CallInst::op_begin() { return OperandTraits<CallInst>::op_begin(this); } CallInst::const_op_iterator CallInst::op_begin() const { return OperandTraits<CallInst>::op_begin(const_cast<CallInst*>(this)); } CallInst::op_iterator CallInst::op_end() { return OperandTraits<CallInst>::op_end(this); } CallInst::const_op_iterator CallInst::op_end() const { return OperandTraits<CallInst>::op_end(const_cast<CallInst*>(this)); } Value *CallInst::getOperand(unsigned i_nocapture) const { ((void)((i_nocapture < OperandTraits<CallInst>::operands(this) && "getOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<CallInst>::operands(this) && \"getOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 1422, __func__),0))); return cast_or_null<Value>( OperandTraits<CallInst>::op_begin(const_cast<CallInst*>(this))[i_nocapture].get()); } void CallInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((void)((i_nocapture < OperandTraits<CallInst>::operands(this) && "setOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<CallInst>::operands(this) && \"setOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 1422, __func__),0))); OperandTraits<CallInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned CallInst::getNumOperands() const { return OperandTraits<CallInst>::operands(this); } template <int Idx_nocapture> Use &CallInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &CallInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }







class SelectInst : public Instruction {
  void init(Value *C, Value *S1, Value *S2) {
    ((void)((!areInvalidOperands(C, S1, S2) && "Invalid operands for select") || (__assert_fail("!areInvalidOperands(C, S1, S2) && \"Invalid operands for select\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 1432, __func__),0)));
    Op<0>() = C;
    Op<1>() = S1;
    Op<2>() = S2;
  }

  SelectInst(Value *C, Value *S1, Value *S2, const Twine &NameStr,
             Instruction *InsertBefore)
    : Instruction(S1->getType(), Instruction::Select,
                  &Op<0>(), 3, InsertBefore) {
    init(C, S1, S2);
    setName(NameStr);
  }
  SelectInst(Value *C, Value *S1, Value *S2, const Twine &NameStr,
             BasicBlock *InsertAtEnd)
    : Instruction(S1->getType(), Instruction::Select,
                  &Op<0>(), 3, InsertAtEnd) {
    init(C, S1, S2);
    setName(NameStr);
  }
protected:
  virtual SelectInst *clone_impl() const;
public:
  static SelectInst *Create(Value *C, Value *S1, Value *S2,
                            const Twine &NameStr = "",
                            Instruction *InsertBefore = 0) {
    return new(3) SelectInst(C, S1, S2, NameStr, InsertBefore);
  }
  static SelectInst *Create(Value *C, Value *S1, Value *S2,
                            const Twine &NameStr,
                            BasicBlock *InsertAtEnd) {
    return new(3) SelectInst(C, S1, S2, NameStr, InsertAtEnd);
  }

  const Value *getCondition() const { return Op<0>(); }
  const Value *getTrueValue() const { return Op<1>(); }
  const Value *getFalseValue() const { return Op<2>(); }
  Value *getCondition() { return Op<0>(); }
  Value *getTrueValue() { return Op<1>(); }
  Value *getFalseValue() { return Op<2>(); }



  static const char *areInvalidOperands(Value *Cond, Value *True, Value *False);


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;

  OtherOps getOpcode() const {
    return static_cast<OtherOps>(Instruction::getOpcode());
  }


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::Select;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};

template <>
struct OperandTraits<SelectInst> : public FixedNumOperandTraits<SelectInst, 3> {
};

SelectInst::op_iterator SelectInst::op_begin() { return OperandTraits<SelectInst>::op_begin(this); } SelectInst::const_op_iterator SelectInst::op_begin() const { return OperandTraits<SelectInst>::op_begin(const_cast<SelectInst*>(this)); } SelectInst::op_iterator SelectInst::op_end() { return OperandTraits<SelectInst>::op_end(this); } SelectInst::const_op_iterator SelectInst::op_end() const { return OperandTraits<SelectInst>::op_end(const_cast<SelectInst*>(this)); } Value *SelectInst::getOperand(unsigned i_nocapture) const { ((void)((i_nocapture < OperandTraits<SelectInst>::operands(this) && "getOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<SelectInst>::operands(this) && \"getOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 1497, __func__),0))); return cast_or_null<Value>( OperandTraits<SelectInst>::op_begin(const_cast<SelectInst*>(this))[i_nocapture].get()); } void SelectInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((void)((i_nocapture < OperandTraits<SelectInst>::operands(this) && "setOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<SelectInst>::operands(this) && \"setOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 1497, __func__),0))); OperandTraits<SelectInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned SelectInst::getNumOperands() const { return OperandTraits<SelectInst>::operands(this); } template <int Idx_nocapture> Use &SelectInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &SelectInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 1506 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h"
class VAArgInst : public UnaryInstruction {
protected:
  virtual VAArgInst *clone_impl() const;

public:
  VAArgInst(Value *List, Type *Ty, const Twine &NameStr = "",
             Instruction *InsertBefore = 0)
    : UnaryInstruction(Ty, VAArg, List, InsertBefore) {
    setName(NameStr);
  }
  VAArgInst(Value *List, Type *Ty, const Twine &NameStr,
            BasicBlock *InsertAtEnd)
    : UnaryInstruction(Ty, VAArg, List, InsertAtEnd) {
    setName(NameStr);
  }

  Value *getPointerOperand() { return getOperand(0); }
  const Value *getPointerOperand() const { return getOperand(0); }
  static unsigned getPointerOperandIndex() { return 0U; }


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == VAArg;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};
# 1542 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h"
class ExtractElementInst : public Instruction {
  ExtractElementInst(Value *Vec, Value *Idx, const Twine &NameStr = "",
                     Instruction *InsertBefore = 0);
  ExtractElementInst(Value *Vec, Value *Idx, const Twine &NameStr,
                     BasicBlock *InsertAtEnd);
protected:
  virtual ExtractElementInst *clone_impl() const;

public:
  static ExtractElementInst *Create(Value *Vec, Value *Idx,
                                   const Twine &NameStr = "",
                                   Instruction *InsertBefore = 0) {
    return new(2) ExtractElementInst(Vec, Idx, NameStr, InsertBefore);
  }
  static ExtractElementInst *Create(Value *Vec, Value *Idx,
                                   const Twine &NameStr,
                                   BasicBlock *InsertAtEnd) {
    return new(2) ExtractElementInst(Vec, Idx, NameStr, InsertAtEnd);
  }



  static bool isValidOperands(const Value *Vec, const Value *Idx);

  Value *getVectorOperand() { return Op<0>(); }
  Value *getIndexOperand() { return Op<1>(); }
  const Value *getVectorOperand() const { return Op<0>(); }
  const Value *getIndexOperand() const { return Op<1>(); }

  VectorType *getVectorOperandType() const {
    return cast<VectorType>(getVectorOperand()->getType());
  }



  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::ExtractElement;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};

template <>
struct OperandTraits<ExtractElementInst> :
  public FixedNumOperandTraits<ExtractElementInst, 2> {
};

ExtractElementInst::op_iterator ExtractElementInst::op_begin() { return OperandTraits<ExtractElementInst>::op_begin(this); } ExtractElementInst::const_op_iterator ExtractElementInst::op_begin() const { return OperandTraits<ExtractElementInst>::op_begin(const_cast<ExtractElementInst*>(this)); } ExtractElementInst::op_iterator ExtractElementInst::op_end() { return OperandTraits<ExtractElementInst>::op_end(this); } ExtractElementInst::const_op_iterator ExtractElementInst::op_end() const { return OperandTraits<ExtractElementInst>::op_end(const_cast<ExtractElementInst*>(this)); } Value *ExtractElementInst::getOperand(unsigned i_nocapture) const { ((void)((i_nocapture < OperandTraits<ExtractElementInst>::operands(this) && "getOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<ExtractElementInst>::operands(this) && \"getOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 1593, __func__),0))); return cast_or_null<Value>( OperandTraits<ExtractElementInst>::op_begin(const_cast<ExtractElementInst*>(this))[i_nocapture].get()); } void ExtractElementInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((void)((i_nocapture < OperandTraits<ExtractElementInst>::operands(this) && "setOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<ExtractElementInst>::operands(this) && \"setOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 1593, __func__),0))); OperandTraits<ExtractElementInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned ExtractElementInst::getNumOperands() const { return OperandTraits<ExtractElementInst>::operands(this); } template <int Idx_nocapture> Use &ExtractElementInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &ExtractElementInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 1602 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h"
class InsertElementInst : public Instruction {
  InsertElementInst(Value *Vec, Value *NewElt, Value *Idx,
                    const Twine &NameStr = "",
                    Instruction *InsertBefore = 0);
  InsertElementInst(Value *Vec, Value *NewElt, Value *Idx,
                    const Twine &NameStr, BasicBlock *InsertAtEnd);
protected:
  virtual InsertElementInst *clone_impl() const;

public:
  static InsertElementInst *Create(Value *Vec, Value *NewElt, Value *Idx,
                                   const Twine &NameStr = "",
                                   Instruction *InsertBefore = 0) {
    return new(3) InsertElementInst(Vec, NewElt, Idx, NameStr, InsertBefore);
  }
  static InsertElementInst *Create(Value *Vec, Value *NewElt, Value *Idx,
                                   const Twine &NameStr,
                                   BasicBlock *InsertAtEnd) {
    return new(3) InsertElementInst(Vec, NewElt, Idx, NameStr, InsertAtEnd);
  }



  static bool isValidOperands(const Value *Vec, const Value *NewElt,
                              const Value *Idx);



  VectorType *getType() const {
    return cast<VectorType>(Instruction::getType());
  }


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::InsertElement;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};

template <>
struct OperandTraits<InsertElementInst> :
  public FixedNumOperandTraits<InsertElementInst, 3> {
};

InsertElementInst::op_iterator InsertElementInst::op_begin() { return OperandTraits<InsertElementInst>::op_begin(this); } InsertElementInst::const_op_iterator InsertElementInst::op_begin() const { return OperandTraits<InsertElementInst>::op_begin(const_cast<InsertElementInst*>(this)); } InsertElementInst::op_iterator InsertElementInst::op_end() { return OperandTraits<InsertElementInst>::op_end(this); } InsertElementInst::const_op_iterator InsertElementInst::op_end() const { return OperandTraits<InsertElementInst>::op_end(const_cast<InsertElementInst*>(this)); } Value *InsertElementInst::getOperand(unsigned i_nocapture) const { ((void)((i_nocapture < OperandTraits<InsertElementInst>::operands(this) && "getOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<InsertElementInst>::operands(this) && \"getOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 1651, __func__),0))); return cast_or_null<Value>( OperandTraits<InsertElementInst>::op_begin(const_cast<InsertElementInst*>(this))[i_nocapture].get()); } void InsertElementInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((void)((i_nocapture < OperandTraits<InsertElementInst>::operands(this) && "setOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<InsertElementInst>::operands(this) && \"setOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 1651, __func__),0))); OperandTraits<InsertElementInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned InsertElementInst::getNumOperands() const { return OperandTraits<InsertElementInst>::operands(this); } template <int Idx_nocapture> Use &InsertElementInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &InsertElementInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 1660 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h"
class ShuffleVectorInst : public Instruction {
protected:
  virtual ShuffleVectorInst *clone_impl() const;

public:

  void *operator new(size_t s) {
    return User::operator new(s, 3);
  }
  ShuffleVectorInst(Value *V1, Value *V2, Value *Mask,
                    const Twine &NameStr = "",
                    Instruction *InsertBefor = 0);
  ShuffleVectorInst(Value *V1, Value *V2, Value *Mask,
                    const Twine &NameStr, BasicBlock *InsertAtEnd);



  static bool isValidOperands(const Value *V1, const Value *V2,
                              const Value *Mask);



  VectorType *getType() const {
    return cast<VectorType>(Instruction::getType());
  }


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;

  Constant *getMask() const {
    return cast<Constant>(getOperand(2));
  }




  static int getMaskValue(Constant *Mask, unsigned i);

  int getMaskValue(unsigned i) const {
    return getMaskValue(getMask(), i);
  }



  static void getShuffleMask(Constant *Mask, SmallVectorImpl<int> &Result);

  void getShuffleMask(SmallVectorImpl<int> &Result) const {
    return getShuffleMask(getMask(), Result);
  }

  SmallVector<int, 16> getShuffleMask() const {
    SmallVector<int, 16> Mask;
    getShuffleMask(Mask);
    return Mask;
  }



  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::ShuffleVector;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};

template <>
struct OperandTraits<ShuffleVectorInst> :
  public FixedNumOperandTraits<ShuffleVectorInst, 3> {
};

ShuffleVectorInst::op_iterator ShuffleVectorInst::op_begin() { return OperandTraits<ShuffleVectorInst>::op_begin(this); } ShuffleVectorInst::const_op_iterator ShuffleVectorInst::op_begin() const { return OperandTraits<ShuffleVectorInst>::op_begin(const_cast<ShuffleVectorInst*>(this)); } ShuffleVectorInst::op_iterator ShuffleVectorInst::op_end() { return OperandTraits<ShuffleVectorInst>::op_end(this); } ShuffleVectorInst::const_op_iterator ShuffleVectorInst::op_end() const { return OperandTraits<ShuffleVectorInst>::op_end(const_cast<ShuffleVectorInst*>(this)); } Value *ShuffleVectorInst::getOperand(unsigned i_nocapture) const { ((void)((i_nocapture < OperandTraits<ShuffleVectorInst>::operands(this) && "getOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<ShuffleVectorInst>::operands(this) && \"getOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 1731, __func__),0))); return cast_or_null<Value>( OperandTraits<ShuffleVectorInst>::op_begin(const_cast<ShuffleVectorInst*>(this))[i_nocapture].get()); } void ShuffleVectorInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((void)((i_nocapture < OperandTraits<ShuffleVectorInst>::operands(this) && "setOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<ShuffleVectorInst>::operands(this) && \"setOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 1731, __func__),0))); OperandTraits<ShuffleVectorInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned ShuffleVectorInst::getNumOperands() const { return OperandTraits<ShuffleVectorInst>::operands(this); } template <int Idx_nocapture> Use &ShuffleVectorInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &ShuffleVectorInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 1740 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h"
class ExtractValueInst : public UnaryInstruction {
  SmallVector<unsigned, 4> Indices;

  ExtractValueInst(const ExtractValueInst &EVI);
  void init(ArrayRef<unsigned> Idxs, const Twine &NameStr);





  inline ExtractValueInst(Value *Agg,
                          ArrayRef<unsigned> Idxs,
                          const Twine &NameStr,
                          Instruction *InsertBefore);
  inline ExtractValueInst(Value *Agg,
                          ArrayRef<unsigned> Idxs,
                          const Twine &NameStr, BasicBlock *InsertAtEnd);


  void *operator new(size_t s) {
    return User::operator new(s, 1);
  }
protected:
  virtual ExtractValueInst *clone_impl() const;

public:
  static ExtractValueInst *Create(Value *Agg,
                                  ArrayRef<unsigned> Idxs,
                                  const Twine &NameStr = "",
                                  Instruction *InsertBefore = 0) {
    return new
      ExtractValueInst(Agg, Idxs, NameStr, InsertBefore);
  }
  static ExtractValueInst *Create(Value *Agg,
                                  ArrayRef<unsigned> Idxs,
                                  const Twine &NameStr,
                                  BasicBlock *InsertAtEnd) {
    return new ExtractValueInst(Agg, Idxs, NameStr, InsertAtEnd);
  }





  static Type *getIndexedType(Type *Agg, ArrayRef<unsigned> Idxs);

  typedef const unsigned* idx_iterator;
  inline idx_iterator idx_begin() const { return Indices.begin(); }
  inline idx_iterator idx_end() const { return Indices.end(); }

  Value *getAggregateOperand() {
    return getOperand(0);
  }
  const Value *getAggregateOperand() const {
    return getOperand(0);
  }
  static unsigned getAggregateOperandIndex() {
    return 0U;
  }

  ArrayRef<unsigned> getIndices() const {
    return Indices;
  }

  unsigned getNumIndices() const {
    return (unsigned)Indices.size();
  }

  bool hasIndices() const {
    return true;
  }


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::ExtractValue;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};

ExtractValueInst::ExtractValueInst(Value *Agg,
                                   ArrayRef<unsigned> Idxs,
                                   const Twine &NameStr,
                                   Instruction *InsertBefore)
  : UnaryInstruction(checkGEPType(getIndexedType(Agg->getType(), Idxs)),
                     ExtractValue, Agg, InsertBefore) {
  init(Idxs, NameStr);
}
ExtractValueInst::ExtractValueInst(Value *Agg,
                                   ArrayRef<unsigned> Idxs,
                                   const Twine &NameStr,
                                   BasicBlock *InsertAtEnd)
  : UnaryInstruction(checkGEPType(getIndexedType(Agg->getType(), Idxs)),
                     ExtractValue, Agg, InsertAtEnd) {
  init(Idxs, NameStr);
}
# 1846 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h"
class InsertValueInst : public Instruction {
  SmallVector<unsigned, 4> Indices;

  void *operator new(size_t, unsigned) ;
  InsertValueInst(const InsertValueInst &IVI);
  void init(Value *Agg, Value *Val, ArrayRef<unsigned> Idxs,
            const Twine &NameStr);





  inline InsertValueInst(Value *Agg, Value *Val,
                         ArrayRef<unsigned> Idxs,
                         const Twine &NameStr,
                         Instruction *InsertBefore);
  inline InsertValueInst(Value *Agg, Value *Val,
                         ArrayRef<unsigned> Idxs,
                         const Twine &NameStr, BasicBlock *InsertAtEnd);



  InsertValueInst(Value *Agg, Value *Val,
                  unsigned Idx, const Twine &NameStr = "",
                  Instruction *InsertBefore = 0);
  InsertValueInst(Value *Agg, Value *Val, unsigned Idx,
                  const Twine &NameStr, BasicBlock *InsertAtEnd);
protected:
  virtual InsertValueInst *clone_impl() const;
public:

  void *operator new(size_t s) {
    return User::operator new(s, 2);
  }

  static InsertValueInst *Create(Value *Agg, Value *Val,
                                 ArrayRef<unsigned> Idxs,
                                 const Twine &NameStr = "",
                                 Instruction *InsertBefore = 0) {
    return new InsertValueInst(Agg, Val, Idxs, NameStr, InsertBefore);
  }
  static InsertValueInst *Create(Value *Agg, Value *Val,
                                 ArrayRef<unsigned> Idxs,
                                 const Twine &NameStr,
                                 BasicBlock *InsertAtEnd) {
    return new InsertValueInst(Agg, Val, Idxs, NameStr, InsertAtEnd);
  }


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;

  typedef const unsigned* idx_iterator;
  inline idx_iterator idx_begin() const { return Indices.begin(); }
  inline idx_iterator idx_end() const { return Indices.end(); }

  Value *getAggregateOperand() {
    return getOperand(0);
  }
  const Value *getAggregateOperand() const {
    return getOperand(0);
  }
  static unsigned getAggregateOperandIndex() {
    return 0U;
  }

  Value *getInsertedValueOperand() {
    return getOperand(1);
  }
  const Value *getInsertedValueOperand() const {
    return getOperand(1);
  }
  static unsigned getInsertedValueOperandIndex() {
    return 1U;
  }

  ArrayRef<unsigned> getIndices() const {
    return Indices;
  }

  unsigned getNumIndices() const {
    return (unsigned)Indices.size();
  }

  bool hasIndices() const {
    return true;
  }


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::InsertValue;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};

template <>
struct OperandTraits<InsertValueInst> :
  public FixedNumOperandTraits<InsertValueInst, 2> {
};

InsertValueInst::InsertValueInst(Value *Agg,
                                 Value *Val,
                                 ArrayRef<unsigned> Idxs,
                                 const Twine &NameStr,
                                 Instruction *InsertBefore)
  : Instruction(Agg->getType(), InsertValue,
                OperandTraits<InsertValueInst>::op_begin(this),
                2, InsertBefore) {
  init(Agg, Val, Idxs, NameStr);
}
InsertValueInst::InsertValueInst(Value *Agg,
                                 Value *Val,
                                 ArrayRef<unsigned> Idxs,
                                 const Twine &NameStr,
                                 BasicBlock *InsertAtEnd)
  : Instruction(Agg->getType(), InsertValue,
                OperandTraits<InsertValueInst>::op_begin(this),
                2, InsertAtEnd) {
  init(Agg, Val, Idxs, NameStr);
}

InsertValueInst::op_iterator InsertValueInst::op_begin() { return OperandTraits<InsertValueInst>::op_begin(this); } InsertValueInst::const_op_iterator InsertValueInst::op_begin() const { return OperandTraits<InsertValueInst>::op_begin(const_cast<InsertValueInst*>(this)); } InsertValueInst::op_iterator InsertValueInst::op_end() { return OperandTraits<InsertValueInst>::op_end(this); } InsertValueInst::const_op_iterator InsertValueInst::op_end() const { return OperandTraits<InsertValueInst>::op_end(const_cast<InsertValueInst*>(this)); } Value *InsertValueInst::getOperand(unsigned i_nocapture) const { ((void)((i_nocapture < OperandTraits<InsertValueInst>::operands(this) && "getOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<InsertValueInst>::operands(this) && \"getOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 1968, __func__),0))); return cast_or_null<Value>( OperandTraits<InsertValueInst>::op_begin(const_cast<InsertValueInst*>(this))[i_nocapture].get()); } void InsertValueInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((void)((i_nocapture < OperandTraits<InsertValueInst>::operands(this) && "setOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<InsertValueInst>::operands(this) && \"setOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 1968, __func__),0))); OperandTraits<InsertValueInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned InsertValueInst::getNumOperands() const { return OperandTraits<InsertValueInst>::operands(this); } template <int Idx_nocapture> Use &InsertValueInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &InsertValueInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 1978 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h"
class PHINode : public Instruction {
  void *operator new(size_t, unsigned) ;


  unsigned ReservedSpace;
  PHINode(const PHINode &PN);

  void *operator new(size_t s) {
    return User::operator new(s, 0);
  }
  explicit PHINode(Type *Ty, unsigned NumReservedValues,
                   const Twine &NameStr = "", Instruction *InsertBefore = 0)
    : Instruction(Ty, Instruction::PHI, 0, 0, InsertBefore),
      ReservedSpace(NumReservedValues) {
    setName(NameStr);
    OperandList = allocHungoffUses(ReservedSpace);
  }

  PHINode(Type *Ty, unsigned NumReservedValues, const Twine &NameStr,
          BasicBlock *InsertAtEnd)
    : Instruction(Ty, Instruction::PHI, 0, 0, InsertAtEnd),
      ReservedSpace(NumReservedValues) {
    setName(NameStr);
    OperandList = allocHungoffUses(ReservedSpace);
  }
protected:



  Use *allocHungoffUses(unsigned) const;

  virtual PHINode *clone_impl() const;
public:


  static PHINode *Create(Type *Ty, unsigned NumReservedValues,
                         const Twine &NameStr = "",
                         Instruction *InsertBefore = 0) {
    return new PHINode(Ty, NumReservedValues, NameStr, InsertBefore);
  }
  static PHINode *Create(Type *Ty, unsigned NumReservedValues,
                         const Twine &NameStr, BasicBlock *InsertAtEnd) {
    return new PHINode(Ty, NumReservedValues, NameStr, InsertAtEnd);
  }
  ~PHINode();


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;




  typedef BasicBlock **block_iterator;
  typedef BasicBlock * const *const_block_iterator;

  block_iterator block_begin() {
    Use::UserRef *ref =
      reinterpret_cast<Use::UserRef*>(op_begin() + ReservedSpace);
    return reinterpret_cast<block_iterator>(ref + 1);
  }

  const_block_iterator block_begin() const {
    const Use::UserRef *ref =
      reinterpret_cast<const Use::UserRef*>(op_begin() + ReservedSpace);
    return reinterpret_cast<const_block_iterator>(ref + 1);
  }

  block_iterator block_end() {
    return block_begin() + getNumOperands();
  }

  const_block_iterator block_end() const {
    return block_begin() + getNumOperands();
  }



  unsigned getNumIncomingValues() const { return getNumOperands(); }



  Value *getIncomingValue(unsigned i) const {
    return getOperand(i);
  }
  void setIncomingValue(unsigned i, Value *V) {
    setOperand(i, V);
  }
  static unsigned getOperandNumForIncomingValue(unsigned i) {
    return i;
  }
  static unsigned getIncomingValueNumForOperand(unsigned i) {
    return i;
  }



  BasicBlock *getIncomingBlock(unsigned i) const {
    return block_begin()[i];
  }




  BasicBlock *getIncomingBlock(const Use &U) const {
    ((void)((this == U.getUser() && "Iterator doesn't point to PHI's Uses?") || (__assert_fail("this == U.getUser() && \"Iterator doesn't point to PHI's Uses?\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2082, __func__),0)));
    return getIncomingBlock(unsigned(&U - op_begin()));
  }




  template <typename U>
  BasicBlock *getIncomingBlock(value_use_iterator<U> I) const {
    return getIncomingBlock(I.getUse());
  }

  void setIncomingBlock(unsigned i, BasicBlock *BB) {
    block_begin()[i] = BB;
  }



  void addIncoming(Value *V, BasicBlock *BB) {
    ((void)((V && "PHI node got a null value!") || (__assert_fail("V && \"PHI node got a null value!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2101, __func__),0)));
    ((void)((BB && "PHI node got a null basic block!") || (__assert_fail("BB && \"PHI node got a null basic block!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2102, __func__),0)));
    ((void)((getType() == V->getType() && "All operands to PHI node must be the same type as the PHI node!") || (__assert_fail("getType() == V->getType() && \"All operands to PHI node must be the same type as the PHI node!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2104, __func__),0)));

    if (NumOperands == ReservedSpace)
      growOperands();

    ++NumOperands;
    setIncomingValue(NumOperands - 1, V);
    setIncomingBlock(NumOperands - 1, BB);
  }
# 2121 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h"
  Value *removeIncomingValue(unsigned Idx, bool DeletePHIIfEmpty = true);

  Value *removeIncomingValue(const BasicBlock *BB, bool DeletePHIIfEmpty=true) {
    int Idx = getBasicBlockIndex(BB);
    ((void)((Idx >= 0 && "Invalid basic block argument to remove!") || (__assert_fail("Idx >= 0 && \"Invalid basic block argument to remove!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2125, __func__),0)));
    return removeIncomingValue(Idx, DeletePHIIfEmpty);
  }




  int getBasicBlockIndex(const BasicBlock *BB) const {
    for (unsigned i = 0, e = getNumOperands(); i != e; ++i)
      if (block_begin()[i] == BB)
        return i;
    return -1;
  }

  Value *getIncomingValueForBlock(const BasicBlock *BB) const {
    int Idx = getBasicBlockIndex(BB);
    ((void)((Idx >= 0 && "Invalid basic block argument!") || (__assert_fail("Idx >= 0 && \"Invalid basic block argument!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2141, __func__),0)));
    return getIncomingValue(Idx);
  }



  Value *hasConstantValue() const;


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::PHI;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
 private:
  void growOperands();
};

template <>
struct OperandTraits<PHINode> : public HungoffOperandTraits<2> {
};

PHINode::op_iterator PHINode::op_begin() { return OperandTraits<PHINode>::op_begin(this); } PHINode::const_op_iterator PHINode::op_begin() const { return OperandTraits<PHINode>::op_begin(const_cast<PHINode*>(this)); } PHINode::op_iterator PHINode::op_end() { return OperandTraits<PHINode>::op_end(this); } PHINode::const_op_iterator PHINode::op_end() const { return OperandTraits<PHINode>::op_end(const_cast<PHINode*>(this)); } Value *PHINode::getOperand(unsigned i_nocapture) const { ((void)((i_nocapture < OperandTraits<PHINode>::operands(this) && "getOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<PHINode>::operands(this) && \"getOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2164, __func__),0))); return cast_or_null<Value>( OperandTraits<PHINode>::op_begin(const_cast<PHINode*>(this))[i_nocapture].get()); } void PHINode::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((void)((i_nocapture < OperandTraits<PHINode>::operands(this) && "setOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<PHINode>::operands(this) && \"setOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2164, __func__),0))); OperandTraits<PHINode>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned PHINode::getNumOperands() const { return OperandTraits<PHINode>::operands(this); } template <int Idx_nocapture> Use &PHINode::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &PHINode::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 2178 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h"
class LandingPadInst : public Instruction {


  unsigned ReservedSpace;
  LandingPadInst(const LandingPadInst &LP);
public:
  enum ClauseType { Catch, Filter };
private:
  void *operator new(size_t, unsigned) ;

  void *operator new(size_t s) {
    return User::operator new(s, 0);
  }
  void growOperands(unsigned Size);
  void init(Value *PersFn, unsigned NumReservedValues, const Twine &NameStr);

  explicit LandingPadInst(Type *RetTy, Value *PersonalityFn,
                          unsigned NumReservedValues, const Twine &NameStr,
                          Instruction *InsertBefore);
  explicit LandingPadInst(Type *RetTy, Value *PersonalityFn,
                          unsigned NumReservedValues, const Twine &NameStr,
                          BasicBlock *InsertAtEnd);
protected:
  virtual LandingPadInst *clone_impl() const;
public:


  static LandingPadInst *Create(Type *RetTy, Value *PersonalityFn,
                                unsigned NumReservedClauses,
                                const Twine &NameStr = "",
                                Instruction *InsertBefore = 0);
  static LandingPadInst *Create(Type *RetTy, Value *PersonalityFn,
                                unsigned NumReservedClauses,
                                const Twine &NameStr, BasicBlock *InsertAtEnd);
  ~LandingPadInst();


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;



  Value *getPersonalityFn() const { return getOperand(0); }




  bool isCleanup() const { return getSubclassDataFromInstruction() & 1; }


  void setCleanup(bool V) {
    setInstructionSubclassData((getSubclassDataFromInstruction() & ~1) |
                               (V ? 1 : 0));
  }


  void addClause(Value *ClauseVal);



  Value *getClause(unsigned Idx) const { return OperandList[Idx + 1]; }


  bool isCatch(unsigned Idx) const {
    return !isa<ArrayType>(OperandList[Idx + 1]->getType());
  }


  bool isFilter(unsigned Idx) const {
    return isa<ArrayType>(OperandList[Idx + 1]->getType());
  }


  unsigned getNumClauses() const { return getNumOperands() - 1; }



  void reserveClauses(unsigned Size) { growOperands(Size); }


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::LandingPad;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};

template <>
struct OperandTraits<LandingPadInst> : public HungoffOperandTraits<2> {
};

LandingPadInst::op_iterator LandingPadInst::op_begin() { return OperandTraits<LandingPadInst>::op_begin(this); } LandingPadInst::const_op_iterator LandingPadInst::op_begin() const { return OperandTraits<LandingPadInst>::op_begin(const_cast<LandingPadInst*>(this)); } LandingPadInst::op_iterator LandingPadInst::op_end() { return OperandTraits<LandingPadInst>::op_end(this); } LandingPadInst::const_op_iterator LandingPadInst::op_end() const { return OperandTraits<LandingPadInst>::op_end(const_cast<LandingPadInst*>(this)); } Value *LandingPadInst::getOperand(unsigned i_nocapture) const { ((void)((i_nocapture < OperandTraits<LandingPadInst>::operands(this) && "getOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<LandingPadInst>::operands(this) && \"getOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2269, __func__),0))); return cast_or_null<Value>( OperandTraits<LandingPadInst>::op_begin(const_cast<LandingPadInst*>(this))[i_nocapture].get()); } void LandingPadInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((void)((i_nocapture < OperandTraits<LandingPadInst>::operands(this) && "setOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<LandingPadInst>::operands(this) && \"setOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2269, __func__),0))); OperandTraits<LandingPadInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned LandingPadInst::getNumOperands() const { return OperandTraits<LandingPadInst>::operands(this); } template <int Idx_nocapture> Use &LandingPadInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &LandingPadInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 2279 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h"
class ReturnInst : public TerminatorInst {
  ReturnInst(const ReturnInst &RI);

private:
# 2294 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h"
  explicit ReturnInst(LLVMContext &C, Value *retVal = 0,
                      Instruction *InsertBefore = 0);
  ReturnInst(LLVMContext &C, Value *retVal, BasicBlock *InsertAtEnd);
  explicit ReturnInst(LLVMContext &C, BasicBlock *InsertAtEnd);
protected:
  virtual ReturnInst *clone_impl() const;
public:
  static ReturnInst* Create(LLVMContext &C, Value *retVal = 0,
                            Instruction *InsertBefore = 0) {
    return new(!!retVal) ReturnInst(C, retVal, InsertBefore);
  }
  static ReturnInst* Create(LLVMContext &C, Value *retVal,
                            BasicBlock *InsertAtEnd) {
    return new(!!retVal) ReturnInst(C, retVal, InsertAtEnd);
  }
  static ReturnInst* Create(LLVMContext &C, BasicBlock *InsertAtEnd) {
    return new(0) ReturnInst(C, InsertAtEnd);
  }
  virtual ~ReturnInst();


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;


  Value *getReturnValue() const {
    return getNumOperands() != 0 ? getOperand(0) : 0;
  }

  unsigned getNumSuccessors() const { return 0; }


  static inline bool classof(const Instruction *I) {
    return (I->getOpcode() == Instruction::Ret);
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
 private:
  virtual BasicBlock *getSuccessorV(unsigned idx) const;
  virtual unsigned getNumSuccessorsV() const;
  virtual void setSuccessorV(unsigned idx, BasicBlock *B);
};

template <>
struct OperandTraits<ReturnInst> : public VariadicOperandTraits<ReturnInst> {
};

ReturnInst::op_iterator ReturnInst::op_begin() { return OperandTraits<ReturnInst>::op_begin(this); } ReturnInst::const_op_iterator ReturnInst::op_begin() const { return OperandTraits<ReturnInst>::op_begin(const_cast<ReturnInst*>(this)); } ReturnInst::op_iterator ReturnInst::op_end() { return OperandTraits<ReturnInst>::op_end(this); } ReturnInst::const_op_iterator ReturnInst::op_end() const { return OperandTraits<ReturnInst>::op_end(const_cast<ReturnInst*>(this)); } Value *ReturnInst::getOperand(unsigned i_nocapture) const { ((void)((i_nocapture < OperandTraits<ReturnInst>::operands(this) && "getOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<ReturnInst>::operands(this) && \"getOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2341, __func__),0))); return cast_or_null<Value>( OperandTraits<ReturnInst>::op_begin(const_cast<ReturnInst*>(this))[i_nocapture].get()); } void ReturnInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((void)((i_nocapture < OperandTraits<ReturnInst>::operands(this) && "setOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<ReturnInst>::operands(this) && \"setOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2341, __func__),0))); OperandTraits<ReturnInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned ReturnInst::getNumOperands() const { return OperandTraits<ReturnInst>::operands(this); } template <int Idx_nocapture> Use &ReturnInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &ReturnInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 2350 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h"
class BranchInst : public TerminatorInst {




  BranchInst(const BranchInst &BI);
  void AssertOK();







  explicit BranchInst(BasicBlock *IfTrue, Instruction *InsertBefore = 0);
  BranchInst(BasicBlock *IfTrue, BasicBlock *IfFalse, Value *Cond,
             Instruction *InsertBefore = 0);
  BranchInst(BasicBlock *IfTrue, BasicBlock *InsertAtEnd);
  BranchInst(BasicBlock *IfTrue, BasicBlock *IfFalse, Value *Cond,
             BasicBlock *InsertAtEnd);
protected:
  virtual BranchInst *clone_impl() const;
public:
  static BranchInst *Create(BasicBlock *IfTrue, Instruction *InsertBefore = 0) {
    return new(1) BranchInst(IfTrue, InsertBefore);
  }
  static BranchInst *Create(BasicBlock *IfTrue, BasicBlock *IfFalse,
                            Value *Cond, Instruction *InsertBefore = 0) {
    return new(3) BranchInst(IfTrue, IfFalse, Cond, InsertBefore);
  }
  static BranchInst *Create(BasicBlock *IfTrue, BasicBlock *InsertAtEnd) {
    return new(1) BranchInst(IfTrue, InsertAtEnd);
  }
  static BranchInst *Create(BasicBlock *IfTrue, BasicBlock *IfFalse,
                            Value *Cond, BasicBlock *InsertAtEnd) {
    return new(3) BranchInst(IfTrue, IfFalse, Cond, InsertAtEnd);
  }


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;

  bool isUnconditional() const { return getNumOperands() == 1; }
  bool isConditional() const { return getNumOperands() == 3; }

  Value *getCondition() const {
    ((void)((isConditional() && "Cannot get condition of an uncond branch!") || (__assert_fail("isConditional() && \"Cannot get condition of an uncond branch!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2395, __func__),0)));
    return Op<-3>();
  }

  void setCondition(Value *V) {
    ((void)((isConditional() && "Cannot set condition of unconditional branch!") || (__assert_fail("isConditional() && \"Cannot set condition of unconditional branch!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2400, __func__),0)));
    Op<-3>() = V;
  }

  unsigned getNumSuccessors() const { return 1+isConditional(); }

  BasicBlock *getSuccessor(unsigned i) const {
    ((void)((i < getNumSuccessors() && "Successor # out of range for Branch!") || (__assert_fail("i < getNumSuccessors() && \"Successor # out of range for Branch!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2407, __func__),0)));
    return cast_or_null<BasicBlock>((&Op<-1>() - i)->get());
  }

  void setSuccessor(unsigned idx, BasicBlock *NewSucc) {
    ((void)((idx < getNumSuccessors() && "Successor # out of range for Branch!") || (__assert_fail("idx < getNumSuccessors() && \"Successor # out of range for Branch!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2412, __func__),0)));
    *(&Op<-1>() - idx) = (Value*)NewSucc;
  }






  void swapSuccessors();


  static inline bool classof(const Instruction *I) {
    return (I->getOpcode() == Instruction::Br);
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
private:
  virtual BasicBlock *getSuccessorV(unsigned idx) const;
  virtual unsigned getNumSuccessorsV() const;
  virtual void setSuccessorV(unsigned idx, BasicBlock *B);
};

template <>
struct OperandTraits<BranchInst> : public VariadicOperandTraits<BranchInst, 1> {
};

BranchInst::op_iterator BranchInst::op_begin() { return OperandTraits<BranchInst>::op_begin(this); } BranchInst::const_op_iterator BranchInst::op_begin() const { return OperandTraits<BranchInst>::op_begin(const_cast<BranchInst*>(this)); } BranchInst::op_iterator BranchInst::op_end() { return OperandTraits<BranchInst>::op_end(this); } BranchInst::const_op_iterator BranchInst::op_end() const { return OperandTraits<BranchInst>::op_end(const_cast<BranchInst*>(this)); } Value *BranchInst::getOperand(unsigned i_nocapture) const { ((void)((i_nocapture < OperandTraits<BranchInst>::operands(this) && "getOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<BranchInst>::operands(this) && \"getOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2440, __func__),0))); return cast_or_null<Value>( OperandTraits<BranchInst>::op_begin(const_cast<BranchInst*>(this))[i_nocapture].get()); } void BranchInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((void)((i_nocapture < OperandTraits<BranchInst>::operands(this) && "setOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<BranchInst>::operands(this) && \"setOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2440, __func__),0))); OperandTraits<BranchInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned BranchInst::getNumOperands() const { return OperandTraits<BranchInst>::operands(this); } template <int Idx_nocapture> Use &BranchInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &BranchInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 2449 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h"
class SwitchInst : public TerminatorInst {
  void *operator new(size_t, unsigned) ;
  unsigned ReservedSpace;




  SwitchInst(const SwitchInst &SI);
  void init(Value *Value, BasicBlock *Default, unsigned NumReserved);
  void growOperands();

  void *operator new(size_t s) {
    return User::operator new(s, 0);
  }




  SwitchInst(Value *Value, BasicBlock *Default, unsigned NumCases,
             Instruction *InsertBefore);





  SwitchInst(Value *Value, BasicBlock *Default, unsigned NumCases,
             BasicBlock *InsertAtEnd);
protected:
  virtual SwitchInst *clone_impl() const;
public:


  static const unsigned DefaultPseudoIndex = static_cast<unsigned>(~0L-1);

  template <class SwitchInstTy, class ConstantIntTy, class BasicBlockTy>
  class CaseIteratorT {
  protected:

    SwitchInstTy *SI;
    unsigned Index;

  public:

    typedef CaseIteratorT<SwitchInstTy, ConstantIntTy, BasicBlockTy> Self;



    CaseIteratorT(SwitchInstTy *SI, unsigned CaseNum) {
      this->SI = SI;
      Index = CaseNum;
    }



    static Self fromSuccessorIndex(SwitchInstTy *SI, unsigned SuccessorIndex) {
      ((void)((SuccessorIndex < SI->getNumSuccessors() && "Successor index # out of range!") || (__assert_fail("SuccessorIndex < SI->getNumSuccessors() && \"Successor index # out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2505, __func__),0)));

      return SuccessorIndex != 0 ?
             Self(SI, SuccessorIndex - 1) :
             Self(SI, DefaultPseudoIndex);
    }


    ConstantIntTy *getCaseValue() {
      ((void)((Index < SI->getNumCases() && "Index out the number of cases.") || (__assert_fail("Index < SI->getNumCases() && \"Index out the number of cases.\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2513, __func__),0)));
      return reinterpret_cast<ConstantIntTy*>(SI->getOperand(2 + Index*2));
    }


    BasicBlockTy *getCaseSuccessor() {
      ((void)(((Index < SI->getNumCases() || Index == DefaultPseudoIndex) && "Index out the number of cases.") || (__assert_fail("(Index < SI->getNumCases() || Index == DefaultPseudoIndex) && \"Index out the number of cases.\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2521, __func__),0)));


      return SI->getSuccessor(getSuccessorIndex());
    }


    unsigned getCaseIndex() const { return Index; }


    unsigned getSuccessorIndex() const {
      ((void)(((Index == DefaultPseudoIndex || Index < SI->getNumCases()) && "Index out the number of cases.") || (__assert_fail("(Index == DefaultPseudoIndex || Index < SI->getNumCases()) && \"Index out the number of cases.\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2531, __func__),0)));

      return Index != DefaultPseudoIndex ? Index + 1 : 0;
    }

    Self operator++() {


      ((void)((Index+1 <= SI->getNumCases() && "Index out the number of cases.") || (__assert_fail("Index+1 <= SI->getNumCases() && \"Index out the number of cases.\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2538, __func__),0)));
      ++Index;
      return *this;
    }
    Self operator++(int) {
      Self tmp = *this;
      ++(*this);
      return tmp;
    }
    Self operator--() {



      ((void)(((Index == 0 || Index-1 <= SI->getNumCases()) && "Index out the number of cases.") || (__assert_fail("(Index == 0 || Index-1 <= SI->getNumCases()) && \"Index out the number of cases.\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2552, __func__),0)));

      --Index;
      return *this;
    }
    Self operator--(int) {
      Self tmp = *this;
      --(*this);
      return tmp;
    }
    bool operator==(const Self& RHS) const {
      ((void)((RHS.SI == SI && "Incompatible operators.") || (__assert_fail("RHS.SI == SI && \"Incompatible operators.\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2562, __func__),0)));
      return RHS.Index == Index;
    }
    bool operator!=(const Self& RHS) const {
      ((void)((RHS.SI == SI && "Incompatible operators.") || (__assert_fail("RHS.SI == SI && \"Incompatible operators.\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2566, __func__),0)));
      return RHS.Index != Index;
    }
  };

  typedef CaseIteratorT<const SwitchInst, const ConstantInt, const BasicBlock>
    ConstCaseIt;

  class CaseIt : public CaseIteratorT<SwitchInst, ConstantInt, BasicBlock> {

    typedef CaseIteratorT<SwitchInst, ConstantInt, BasicBlock> ParentTy;

  public:

    CaseIt(const ParentTy& Src) : ParentTy(Src) {}
    CaseIt(SwitchInst *SI, unsigned CaseNum) : ParentTy(SI, CaseNum) {}


    void setValue(ConstantInt *V) {
      ((void)((Index < SI->getNumCases() && "Index out the number of cases.") || (__assert_fail("Index < SI->getNumCases() && \"Index out the number of cases.\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2585, __func__),0)));
      SI->setOperand(2 + Index*2, reinterpret_cast<Value*>(V));
    }


    void setSuccessor(BasicBlock *S) {
      SI->setSuccessor(getSuccessorIndex(), S);
    }
  };

  static SwitchInst *Create(Value *Value, BasicBlock *Default,
                            unsigned NumCases, Instruction *InsertBefore = 0) {
    return new SwitchInst(Value, Default, NumCases, InsertBefore);
  }
  static SwitchInst *Create(Value *Value, BasicBlock *Default,
                            unsigned NumCases, BasicBlock *InsertAtEnd) {
    return new SwitchInst(Value, Default, NumCases, InsertAtEnd);
  }

  ~SwitchInst();


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;


  Value *getCondition() const { return getOperand(0); }
  void setCondition(Value *V) { setOperand(0, V); }

  BasicBlock *getDefaultDest() const {
    return cast<BasicBlock>(getOperand(1));
  }

  void setDefaultDest(BasicBlock *DefaultCase) {
    setOperand(1, reinterpret_cast<Value*>(DefaultCase));
  }



  unsigned getNumCases() const {
    return getNumOperands()/2 - 1;
  }



  CaseIt case_begin() {
    return CaseIt(this, 0);
  }


  ConstCaseIt case_begin() const {
    return ConstCaseIt(this, 0);
  }



  CaseIt case_end() {
    return CaseIt(this, getNumCases());
  }


  ConstCaseIt case_end() const {
    return ConstCaseIt(this, getNumCases());
  }





  CaseIt case_default() {
    return CaseIt(this, DefaultPseudoIndex);
  }
  ConstCaseIt case_default() const {
    return ConstCaseIt(this, DefaultPseudoIndex);
  }





  CaseIt findCaseValue(const ConstantInt *C) {
    for (CaseIt i = case_begin(), e = case_end(); i != e; ++i)
      if (i.getCaseValue() == C)
        return i;
    return case_default();
  }
  ConstCaseIt findCaseValue(const ConstantInt *C) const {
    for (ConstCaseIt i = case_begin(), e = case_end(); i != e; ++i)
      if (i.getCaseValue() == C)
        return i;
    return case_default();
  }



  ConstantInt *findCaseDest(BasicBlock *BB) {
    if (BB == getDefaultDest()) return 0L;

    ConstantInt *CI = 0L;
    for (CaseIt i = case_begin(), e = case_end(); i != e; ++i) {
      if (i.getCaseSuccessor() == BB) {
        if (CI) return 0L;
        else CI = i.getCaseValue();
      }
    }
    return CI;
  }





  void addCase(ConstantInt *OnVal, BasicBlock *Dest);







  void removeCase(CaseIt i);

  unsigned getNumSuccessors() const { return getNumOperands()/2; }
  BasicBlock *getSuccessor(unsigned idx) const {
    ((void)((idx < getNumSuccessors() &&"Successor idx out of range for switch!") || (__assert_fail("idx < getNumSuccessors() &&\"Successor idx out of range for switch!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2708, __func__),0)));
    return cast<BasicBlock>(getOperand(idx*2+1));
  }
  void setSuccessor(unsigned idx, BasicBlock *NewSucc) {
    ((void)((idx < getNumSuccessors() && "Successor # out of range for switch!") || (__assert_fail("idx < getNumSuccessors() && \"Successor # out of range for switch!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2712, __func__),0)));
    setOperand(idx*2+1, (Value*)NewSucc);
  }


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::Switch;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
private:
  virtual BasicBlock *getSuccessorV(unsigned idx) const;
  virtual unsigned getNumSuccessorsV() const;
  virtual void setSuccessorV(unsigned idx, BasicBlock *B);
};

template <>
struct OperandTraits<SwitchInst> : public HungoffOperandTraits<2> {
};

SwitchInst::op_iterator SwitchInst::op_begin() { return OperandTraits<SwitchInst>::op_begin(this); } SwitchInst::const_op_iterator SwitchInst::op_begin() const { return OperandTraits<SwitchInst>::op_begin(const_cast<SwitchInst*>(this)); } SwitchInst::op_iterator SwitchInst::op_end() { return OperandTraits<SwitchInst>::op_end(this); } SwitchInst::const_op_iterator SwitchInst::op_end() const { return OperandTraits<SwitchInst>::op_end(const_cast<SwitchInst*>(this)); } Value *SwitchInst::getOperand(unsigned i_nocapture) const { ((void)((i_nocapture < OperandTraits<SwitchInst>::operands(this) && "getOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<SwitchInst>::operands(this) && \"getOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2733, __func__),0))); return cast_or_null<Value>( OperandTraits<SwitchInst>::op_begin(const_cast<SwitchInst*>(this))[i_nocapture].get()); } void SwitchInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((void)((i_nocapture < OperandTraits<SwitchInst>::operands(this) && "setOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<SwitchInst>::operands(this) && \"setOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2733, __func__),0))); OperandTraits<SwitchInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned SwitchInst::getNumOperands() const { return OperandTraits<SwitchInst>::operands(this); } template <int Idx_nocapture> Use &SwitchInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &SwitchInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 2743 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h"
class IndirectBrInst : public TerminatorInst {
  void *operator new(size_t, unsigned) ;
  unsigned ReservedSpace;




  IndirectBrInst(const IndirectBrInst &IBI);
  void init(Value *Address, unsigned NumDests);
  void growOperands();

  void *operator new(size_t s) {
    return User::operator new(s, 0);
  }




  IndirectBrInst(Value *Address, unsigned NumDests, Instruction *InsertBefore);





  IndirectBrInst(Value *Address, unsigned NumDests, BasicBlock *InsertAtEnd);
protected:
  virtual IndirectBrInst *clone_impl() const;
public:
  static IndirectBrInst *Create(Value *Address, unsigned NumDests,
                                Instruction *InsertBefore = 0) {
    return new IndirectBrInst(Address, NumDests, InsertBefore);
  }
  static IndirectBrInst *Create(Value *Address, unsigned NumDests,
                                BasicBlock *InsertAtEnd) {
    return new IndirectBrInst(Address, NumDests, InsertAtEnd);
  }
  ~IndirectBrInst();


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;


  Value *getAddress() { return getOperand(0); }
  const Value *getAddress() const { return getOperand(0); }
  void setAddress(Value *V) { setOperand(0, V); }




  unsigned getNumDestinations() const { return getNumOperands()-1; }


  BasicBlock *getDestination(unsigned i) { return getSuccessor(i); }
  const BasicBlock *getDestination(unsigned i) const { return getSuccessor(i); }



  void addDestination(BasicBlock *Dest);



  void removeDestination(unsigned i);

  unsigned getNumSuccessors() const { return getNumOperands()-1; }
  BasicBlock *getSuccessor(unsigned i) const {
    return cast<BasicBlock>(getOperand(i+1));
  }
  void setSuccessor(unsigned i, BasicBlock *NewSucc) {
    setOperand(i+1, (Value*)NewSucc);
  }


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::IndirectBr;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
private:
  virtual BasicBlock *getSuccessorV(unsigned idx) const;
  virtual unsigned getNumSuccessorsV() const;
  virtual void setSuccessorV(unsigned idx, BasicBlock *B);
};

template <>
struct OperandTraits<IndirectBrInst> : public HungoffOperandTraits<1> {
};

IndirectBrInst::op_iterator IndirectBrInst::op_begin() { return OperandTraits<IndirectBrInst>::op_begin(this); } IndirectBrInst::const_op_iterator IndirectBrInst::op_begin() const { return OperandTraits<IndirectBrInst>::op_begin(const_cast<IndirectBrInst*>(this)); } IndirectBrInst::op_iterator IndirectBrInst::op_end() { return OperandTraits<IndirectBrInst>::op_end(this); } IndirectBrInst::const_op_iterator IndirectBrInst::op_end() const { return OperandTraits<IndirectBrInst>::op_end(const_cast<IndirectBrInst*>(this)); } Value *IndirectBrInst::getOperand(unsigned i_nocapture) const { ((void)((i_nocapture < OperandTraits<IndirectBrInst>::operands(this) && "getOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<IndirectBrInst>::operands(this) && \"getOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2831, __func__),0))); return cast_or_null<Value>( OperandTraits<IndirectBrInst>::op_begin(const_cast<IndirectBrInst*>(this))[i_nocapture].get()); } void IndirectBrInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((void)((i_nocapture < OperandTraits<IndirectBrInst>::operands(this) && "setOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<IndirectBrInst>::operands(this) && \"setOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2831, __func__),0))); OperandTraits<IndirectBrInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned IndirectBrInst::getNumOperands() const { return OperandTraits<IndirectBrInst>::operands(this); } template <int Idx_nocapture> Use &IndirectBrInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &IndirectBrInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 2841 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h"
class InvokeInst : public TerminatorInst {
  AttributeSet AttributeList;
  InvokeInst(const InvokeInst &BI);
  void init(Value *Func, BasicBlock *IfNormal, BasicBlock *IfException,
            ArrayRef<Value *> Args, const Twine &NameStr);




  inline InvokeInst(Value *Func, BasicBlock *IfNormal, BasicBlock *IfException,
                    ArrayRef<Value *> Args, unsigned Values,
                    const Twine &NameStr, Instruction *InsertBefore);




  inline InvokeInst(Value *Func, BasicBlock *IfNormal, BasicBlock *IfException,
                    ArrayRef<Value *> Args, unsigned Values,
                    const Twine &NameStr, BasicBlock *InsertAtEnd);
protected:
  virtual InvokeInst *clone_impl() const;
public:
  static InvokeInst *Create(Value *Func,
                            BasicBlock *IfNormal, BasicBlock *IfException,
                            ArrayRef<Value *> Args, const Twine &NameStr = "",
                            Instruction *InsertBefore = 0) {
    unsigned Values = unsigned(Args.size()) + 3;
    return new(Values) InvokeInst(Func, IfNormal, IfException, Args,
                                  Values, NameStr, InsertBefore);
  }
  static InvokeInst *Create(Value *Func,
                            BasicBlock *IfNormal, BasicBlock *IfException,
                            ArrayRef<Value *> Args, const Twine &NameStr,
                            BasicBlock *InsertAtEnd) {
    unsigned Values = unsigned(Args.size()) + 3;
    return new(Values) InvokeInst(Func, IfNormal, IfException, Args,
                                  Values, NameStr, InsertAtEnd);
  }


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;



  unsigned getNumArgOperands() const { return getNumOperands() - 3; }



  Value *getArgOperand(unsigned i) const { return getOperand(i); }
  void setArgOperand(unsigned i, Value *v) { setOperand(i, v); }



  CallingConv::ID getCallingConv() const {
    return static_cast<CallingConv::ID>(getSubclassDataFromInstruction());
  }
  void setCallingConv(CallingConv::ID CC) {
    setInstructionSubclassData(static_cast<unsigned>(CC));
  }



  const AttributeSet &getAttributes() const { return AttributeList; }



  void setAttributes(const AttributeSet &Attrs) { AttributeList = Attrs; }


  void addAttribute(unsigned i, Attribute::AttrKind attr);


  void removeAttribute(unsigned i, Attribute attr);


  bool hasFnAttr(Attribute::AttrKind A) const {
    ((void)((A != Attribute::NoBuiltin && "Use CallInst::isNoBuiltin() to check for Attribute::NoBuiltin") || (__assert_fail("A != Attribute::NoBuiltin && \"Use CallInst::isNoBuiltin() to check for Attribute::NoBuiltin\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 2918, __func__),0)));

    return hasFnAttrImpl(A);
  }


  bool paramHasAttr(unsigned i, Attribute::AttrKind A) const;


  unsigned getParamAlignment(unsigned i) const {
    return AttributeList.getParamAlignment(i);
  }



  bool isNoBuiltin() const {


    return hasFnAttrImpl(Attribute::NoBuiltin) &&
      !hasFnAttrImpl(Attribute::Builtin);
  }


  bool isNoInline() const { return hasFnAttr(Attribute::NoInline); }
  void setIsNoInline() {
    addAttribute(AttributeSet::FunctionIndex, Attribute::NoInline);
  }


  bool doesNotAccessMemory() const {
    return hasFnAttr(Attribute::ReadNone);
  }
  void setDoesNotAccessMemory() {
    addAttribute(AttributeSet::FunctionIndex, Attribute::ReadNone);
  }


  bool onlyReadsMemory() const {
    return doesNotAccessMemory() || hasFnAttr(Attribute::ReadOnly);
  }
  void setOnlyReadsMemory() {
    addAttribute(AttributeSet::FunctionIndex, Attribute::ReadOnly);
  }


  bool doesNotReturn() const { return hasFnAttr(Attribute::NoReturn); }
  void setDoesNotReturn() {
    addAttribute(AttributeSet::FunctionIndex, Attribute::NoReturn);
  }


  bool doesNotThrow() const { return hasFnAttr(Attribute::NoUnwind); }
  void setDoesNotThrow() {
    addAttribute(AttributeSet::FunctionIndex, Attribute::NoUnwind);
  }



  bool hasStructRetAttr() const {

    return paramHasAttr(1, Attribute::StructRet);
  }


  bool hasByValArgument() const {
    return AttributeList.hasAttrSomewhere(Attribute::ByVal);
  }




  Function *getCalledFunction() const {
    return dyn_cast<Function>(Op<-3>());
  }



  const Value *getCalledValue() const { return Op<-3>(); }
        Value *getCalledValue() { return Op<-3>(); }


  void setCalledFunction(Value* Fn) {
    Op<-3>() = Fn;
  }


  BasicBlock *getNormalDest() const {
    return cast<BasicBlock>(Op<-2>());
  }
  BasicBlock *getUnwindDest() const {
    return cast<BasicBlock>(Op<-1>());
  }
  void setNormalDest(BasicBlock *B) {
    Op<-2>() = reinterpret_cast<Value*>(B);
  }
  void setUnwindDest(BasicBlock *B) {
    Op<-1>() = reinterpret_cast<Value*>(B);
  }



  LandingPadInst *getLandingPadInst() const;

  BasicBlock *getSuccessor(unsigned i) const {
    ((void)((i < 2 && "Successor # out of range for invoke!") || (__assert_fail("i < 2 && \"Successor # out of range for invoke!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 3021, __func__),0)));
    return i == 0 ? getNormalDest() : getUnwindDest();
  }

  void setSuccessor(unsigned idx, BasicBlock *NewSucc) {
    ((void)((idx < 2 && "Successor # out of range for invoke!") || (__assert_fail("idx < 2 && \"Successor # out of range for invoke!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 3026, __func__),0)));
    *(&Op<-2>() + idx) = reinterpret_cast<Value*>(NewSucc);
  }

  unsigned getNumSuccessors() const { return 2; }


  static inline bool classof(const Instruction *I) {
    return (I->getOpcode() == Instruction::Invoke);
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }

private:
  virtual BasicBlock *getSuccessorV(unsigned idx) const;
  virtual unsigned getNumSuccessorsV() const;
  virtual void setSuccessorV(unsigned idx, BasicBlock *B);

  bool hasFnAttrImpl(Attribute::AttrKind A) const;



  void setInstructionSubclassData(unsigned short D) {
    Instruction::setInstructionSubclassData(D);
  }
};

template <>
struct OperandTraits<InvokeInst> : public VariadicOperandTraits<InvokeInst, 3> {
};

InvokeInst::InvokeInst(Value *Func,
                       BasicBlock *IfNormal, BasicBlock *IfException,
                       ArrayRef<Value *> Args, unsigned Values,
                       const Twine &NameStr, Instruction *InsertBefore)
  : TerminatorInst(cast<FunctionType>(cast<PointerType>(Func->getType())
                                      ->getElementType())->getReturnType(),
                   Instruction::Invoke,
                   OperandTraits<InvokeInst>::op_end(this) - Values,
                   Values, InsertBefore) {
  init(Func, IfNormal, IfException, Args, NameStr);
}
InvokeInst::InvokeInst(Value *Func,
                       BasicBlock *IfNormal, BasicBlock *IfException,
                       ArrayRef<Value *> Args, unsigned Values,
                       const Twine &NameStr, BasicBlock *InsertAtEnd)
  : TerminatorInst(cast<FunctionType>(cast<PointerType>(Func->getType())
                                      ->getElementType())->getReturnType(),
                   Instruction::Invoke,
                   OperandTraits<InvokeInst>::op_end(this) - Values,
                   Values, InsertAtEnd) {
  init(Func, IfNormal, IfException, Args, NameStr);
}

InvokeInst::op_iterator InvokeInst::op_begin() { return OperandTraits<InvokeInst>::op_begin(this); } InvokeInst::const_op_iterator InvokeInst::op_begin() const { return OperandTraits<InvokeInst>::op_begin(const_cast<InvokeInst*>(this)); } InvokeInst::op_iterator InvokeInst::op_end() { return OperandTraits<InvokeInst>::op_end(this); } InvokeInst::const_op_iterator InvokeInst::op_end() const { return OperandTraits<InvokeInst>::op_end(const_cast<InvokeInst*>(this)); } Value *InvokeInst::getOperand(unsigned i_nocapture) const { ((void)((i_nocapture < OperandTraits<InvokeInst>::operands(this) && "getOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<InvokeInst>::operands(this) && \"getOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 3081, __func__),0))); return cast_or_null<Value>( OperandTraits<InvokeInst>::op_begin(const_cast<InvokeInst*>(this))[i_nocapture].get()); } void InvokeInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((void)((i_nocapture < OperandTraits<InvokeInst>::operands(this) && "setOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<InvokeInst>::operands(this) && \"setOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 3081, __func__),0))); OperandTraits<InvokeInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned InvokeInst::getNumOperands() const { return OperandTraits<InvokeInst>::operands(this); } template <int Idx_nocapture> Use &InvokeInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &InvokeInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 3090 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h"
class ResumeInst : public TerminatorInst {
  ResumeInst(const ResumeInst &RI);

  explicit ResumeInst(Value *Exn, Instruction *InsertBefore=0);
  ResumeInst(Value *Exn, BasicBlock *InsertAtEnd);
protected:
  virtual ResumeInst *clone_impl() const;
public:
  static ResumeInst *Create(Value *Exn, Instruction *InsertBefore = 0) {
    return new(1) ResumeInst(Exn, InsertBefore);
  }
  static ResumeInst *Create(Value *Exn, BasicBlock *InsertAtEnd) {
    return new(1) ResumeInst(Exn, InsertAtEnd);
  }


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;


  Value *getValue() const { return Op<0>(); }

  unsigned getNumSuccessors() const { return 0; }


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::Resume;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
private:
  virtual BasicBlock *getSuccessorV(unsigned idx) const;
  virtual unsigned getNumSuccessorsV() const;
  virtual void setSuccessorV(unsigned idx, BasicBlock *B);
};

template <>
struct OperandTraits<ResumeInst> :
    public FixedNumOperandTraits<ResumeInst, 1> {
};

ResumeInst::op_iterator ResumeInst::op_begin() { return OperandTraits<ResumeInst>::op_begin(this); } ResumeInst::const_op_iterator ResumeInst::op_begin() const { return OperandTraits<ResumeInst>::op_begin(const_cast<ResumeInst*>(this)); } ResumeInst::op_iterator ResumeInst::op_end() { return OperandTraits<ResumeInst>::op_end(this); } ResumeInst::const_op_iterator ResumeInst::op_end() const { return OperandTraits<ResumeInst>::op_end(const_cast<ResumeInst*>(this)); } Value *ResumeInst::getOperand(unsigned i_nocapture) const { ((void)((i_nocapture < OperandTraits<ResumeInst>::operands(this) && "getOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<ResumeInst>::operands(this) && \"getOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 3131, __func__),0))); return cast_or_null<Value>( OperandTraits<ResumeInst>::op_begin(const_cast<ResumeInst*>(this))[i_nocapture].get()); } void ResumeInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((void)((i_nocapture < OperandTraits<ResumeInst>::operands(this) && "setOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<ResumeInst>::operands(this) && \"setOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h", 3131, __func__),0))); OperandTraits<ResumeInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned ResumeInst::getNumOperands() const { return OperandTraits<ResumeInst>::operands(this); } template <int Idx_nocapture> Use &ResumeInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &ResumeInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 3142 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Instructions.h"
class UnreachableInst : public TerminatorInst {
  void *operator new(size_t, unsigned) ;
protected:
  virtual UnreachableInst *clone_impl() const;

public:

  void *operator new(size_t s) {
    return User::operator new(s, 0);
  }
  explicit UnreachableInst(LLVMContext &C, Instruction *InsertBefore = 0);
  explicit UnreachableInst(LLVMContext &C, BasicBlock *InsertAtEnd);

  unsigned getNumSuccessors() const { return 0; }


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::Unreachable;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
private:
  virtual BasicBlock *getSuccessorV(unsigned idx) const;
  virtual unsigned getNumSuccessorsV() const;
  virtual void setSuccessorV(unsigned idx, BasicBlock *B);
};






class TruncInst : public CastInst {
protected:

  virtual TruncInst *clone_impl() const;

public:

  TruncInst(
    Value *S,
    Type *Ty,
    const Twine &NameStr = "",
    Instruction *InsertBefore = 0
  );


  TruncInst(
    Value *S,
    Type *Ty,
    const Twine &NameStr,
    BasicBlock *InsertAtEnd
  );


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Trunc;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};






class ZExtInst : public CastInst {
protected:

  virtual ZExtInst *clone_impl() const;

public:

  ZExtInst(
    Value *S,
    Type *Ty,
    const Twine &NameStr = "",
    Instruction *InsertBefore = 0
  );


  ZExtInst(
    Value *S,
    Type *Ty,
    const Twine &NameStr,
    BasicBlock *InsertAtEnd
  );


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == ZExt;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};






class SExtInst : public CastInst {
protected:

  virtual SExtInst *clone_impl() const;

public:

  SExtInst(
    Value *S,
    Type *Ty,
    const Twine &NameStr = "",
    Instruction *InsertBefore = 0
  );


  SExtInst(
    Value *S,
    Type *Ty,
    const Twine &NameStr,
    BasicBlock *InsertAtEnd
  );


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == SExt;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};






class FPTruncInst : public CastInst {
protected:

  virtual FPTruncInst *clone_impl() const;

public:

  FPTruncInst(
    Value *S,
    Type *Ty,
    const Twine &NameStr = "",
    Instruction *InsertBefore = 0
  );


  FPTruncInst(
    Value *S,
    Type *Ty,
    const Twine &NameStr,
    BasicBlock *InsertAtEnd
  );


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == FPTrunc;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};






class FPExtInst : public CastInst {
protected:

  virtual FPExtInst *clone_impl() const;

public:

  FPExtInst(
    Value *S,
    Type *Ty,
    const Twine &NameStr = "",
    Instruction *InsertBefore = 0
  );


  FPExtInst(
    Value *S,
    Type *Ty,
    const Twine &NameStr,
    BasicBlock *InsertAtEnd
  );


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == FPExt;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};






class UIToFPInst : public CastInst {
protected:

  virtual UIToFPInst *clone_impl() const;

public:

  UIToFPInst(
    Value *S,
    Type *Ty,
    const Twine &NameStr = "",
    Instruction *InsertBefore = 0
  );


  UIToFPInst(
    Value *S,
    Type *Ty,
    const Twine &NameStr,
    BasicBlock *InsertAtEnd
  );


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == UIToFP;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};






class SIToFPInst : public CastInst {
protected:

  virtual SIToFPInst *clone_impl() const;

public:

  SIToFPInst(
    Value *S,
    Type *Ty,
    const Twine &NameStr = "",
    Instruction *InsertBefore = 0
  );


  SIToFPInst(
    Value *S,
    Type *Ty,
    const Twine &NameStr,
    BasicBlock *InsertAtEnd
  );


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == SIToFP;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};






class FPToUIInst : public CastInst {
protected:

  virtual FPToUIInst *clone_impl() const;

public:

  FPToUIInst(
    Value *S,
    Type *Ty,
    const Twine &NameStr = "",
    Instruction *InsertBefore = 0
  );


  FPToUIInst(
    Value *S,
    Type *Ty,
    const Twine &NameStr,
    BasicBlock *InsertAtEnd
  );


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == FPToUI;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};






class FPToSIInst : public CastInst {
protected:

  virtual FPToSIInst *clone_impl() const;

public:

  FPToSIInst(
    Value *S,
    Type *Ty,
    const Twine &NameStr = "",
    Instruction *InsertBefore = 0
  );


  FPToSIInst(
    Value *S,
    Type *Ty,
    const Twine &NameStr,
    BasicBlock *InsertAtEnd
  );


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == FPToSI;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};






class IntToPtrInst : public CastInst {
public:

  IntToPtrInst(
    Value *S,
    Type *Ty,
    const Twine &NameStr = "",
    Instruction *InsertBefore = 0
  );


  IntToPtrInst(
    Value *S,
    Type *Ty,
    const Twine &NameStr,
    BasicBlock *InsertAtEnd
  );


  virtual IntToPtrInst *clone_impl() const;


  unsigned getAddressSpace() const {
    return getType()->getPointerAddressSpace();
  }


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == IntToPtr;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};






class PtrToIntInst : public CastInst {
protected:

  virtual PtrToIntInst *clone_impl() const;

public:

  PtrToIntInst(
    Value *S,
    Type *Ty,
    const Twine &NameStr = "",
    Instruction *InsertBefore = 0
  );


  PtrToIntInst(
    Value *S,
    Type *Ty,
    const Twine &NameStr,
    BasicBlock *InsertAtEnd
  );


  Value *getPointerOperand() { return getOperand(0); }

  const Value *getPointerOperand() const { return getOperand(0); }

  static unsigned getPointerOperandIndex() { return 0U; }


  unsigned getPointerAddressSpace() const {
    return getPointerOperand()->getType()->getPointerAddressSpace();
  }


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == PtrToInt;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};






class BitCastInst : public CastInst {
protected:

  virtual BitCastInst *clone_impl() const;

public:

  BitCastInst(
    Value *S,
    Type *Ty,
    const Twine &NameStr = "",
    Instruction *InsertBefore = 0
  );


  BitCastInst(
    Value *S,
    Type *Ty,
    const Twine &NameStr,
    BasicBlock *InsertAtEnd
  );


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == BitCast;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};







class AddrSpaceCastInst : public CastInst {
protected:

  virtual AddrSpaceCastInst *clone_impl() const;

public:

  AddrSpaceCastInst(
    Value *S,
    Type *Ty,
    const Twine &NameStr = "",
    Instruction *InsertBefore = 0
  );


  AddrSpaceCastInst(
    Value *S,
    Type *Ty,
    const Twine &NameStr,
    BasicBlock *InsertAtEnd
  );


  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == AddrSpaceCast;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};

}
# 33 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CallSite.h" 2

namespace llvm {

class CallInst;
class InvokeInst;

template <typename FunTy = const Function,
          typename ValTy = const Value,
          typename UserTy = const User,
          typename InstrTy = const Instruction,
          typename CallTy = const CallInst,
          typename InvokeTy = const InvokeInst,
          typename IterTy = User::const_op_iterator>
class CallSiteBase {
protected:
  PointerIntPair<InstrTy*, 1, bool> I;
public:
  CallSiteBase() : I(0, false) {}
  CallSiteBase(CallTy *CI) : I(CI, true) { ((void)((CI) || (__assert_fail("CI", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CallSite.h", 51, __func__),0))); }
  CallSiteBase(InvokeTy *II) : I(II, false) { ((void)((II) || (__assert_fail("II", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CallSite.h", 52, __func__),0))); }
  CallSiteBase(ValTy *II) { *this = get(II); }
protected:





  static CallSiteBase get(ValTy *V) {
    if (InstrTy *II = dyn_cast<InstrTy>(V)) {
      if (II->getOpcode() == Instruction::Call)
        return CallSiteBase(static_cast<CallTy*>(II));
      else if (II->getOpcode() == Instruction::Invoke)
        return CallSiteBase(static_cast<InvokeTy*>(II));
    }
    return CallSiteBase();
  }
public:



  bool isCall() const { return I.getInt(); }



  bool isInvoke() const { return getInstruction() && !I.getInt(); }

  InstrTy *getInstruction() const { return I.getPointer(); }
  InstrTy *operator->() const { return I.getPointer(); }
                operator bool() const { return I.getPointer(); }



  ValTy *getCalledValue() const {
    ((void)((getInstruction() && "Not a call or invoke instruction!") || (__assert_fail("getInstruction() && \"Not a call or invoke instruction!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CallSite.h", 86, __func__),0)));
    return *getCallee();
  }




  FunTy *getCalledFunction() const {
    return dyn_cast<FunTy>(getCalledValue());
  }



  void setCalledFunction(Value *V) {
    ((void)((getInstruction() && "Not a call or invoke instruction!") || (__assert_fail("getInstruction() && \"Not a call or invoke instruction!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CallSite.h", 100, __func__),0)));
    *getCallee() = V;
  }




  bool isCallee(value_use_iterator<UserTy> UI) const {
    return getCallee() == &UI.getUse();
  }

  ValTy *getArgument(unsigned ArgNo) const {
    ((void)((arg_begin() + ArgNo < arg_end() && "Argument # out of range!") || (__assert_fail("arg_begin() + ArgNo < arg_end() && \"Argument # out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CallSite.h", 112, __func__),0)));
    return *(arg_begin() + ArgNo);
  }

  void setArgument(unsigned ArgNo, Value* newVal) {
    ((void)((getInstruction() && "Not a call or invoke instruction!") || (__assert_fail("getInstruction() && \"Not a call or invoke instruction!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CallSite.h", 117, __func__),0)));
    ((void)((arg_begin() + ArgNo < arg_end() && "Argument # out of range!") || (__assert_fail("arg_begin() + ArgNo < arg_end() && \"Argument # out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CallSite.h", 118, __func__),0)));
    getInstruction()->setOperand(ArgNo, newVal);
  }



  unsigned getArgumentNo(value_use_iterator<UserTy> I) const {
    ((void)((getInstruction() && "Not a call or invoke instruction!") || (__assert_fail("getInstruction() && \"Not a call or invoke instruction!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CallSite.h", 125, __func__),0)));
    ((void)((arg_begin() <= &I.getUse() && &I.getUse() < arg_end() && "Argument # out of range!") || (__assert_fail("arg_begin() <= &I.getUse() && &I.getUse() < arg_end() && \"Argument # out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CallSite.h", 127, __func__),0)));

    return &I.getUse() - arg_begin();
  }



  typedef IterTy arg_iterator;



  IterTy arg_begin() const {
    ((void)((getInstruction() && "Not a call or invoke instruction!") || (__assert_fail("getInstruction() && \"Not a call or invoke instruction!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CallSite.h", 138, __func__),0)));

    return (*this)->op_begin();
  }

  IterTy arg_end() const { return (*this)->op_end() - getArgumentEndOffset(); }
  bool arg_empty() const { return arg_end() == arg_begin(); }
  unsigned arg_size() const { return unsigned(arg_end() - arg_begin()); }



  Type *getType() const { return (*this)->getType(); }



  FunTy *getCaller() const { return (*this)->getParent()->getParent(); }
# 170 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CallSite.h"
  CallingConv::ID getCallingConv() const {
    InstrTy *II = getInstruction(); return isCall() ? cast<CallInst>(II)->getCallingConv() : cast<InvokeInst>(II)->getCallingConv();
  }
  void setCallingConv(CallingConv::ID CC) {
    InstrTy *II = getInstruction(); if (isCall()) cast<CallInst>(II)->setCallingConv(CC); else cast<InvokeInst>(II)->setCallingConv(CC);
  }



  const AttributeSet &getAttributes() const {
    InstrTy *II = getInstruction(); return isCall() ? cast<CallInst>(II)->getAttributes() : cast<InvokeInst>(II)->getAttributes();
  }
  void setAttributes(const AttributeSet &PAL) {
    InstrTy *II = getInstruction(); if (isCall()) cast<CallInst>(II)->setAttributes(PAL); else cast<InvokeInst>(II)->setAttributes(PAL);
  }


  bool hasFnAttr(Attribute::AttrKind A) const {
    InstrTy *II = getInstruction(); return isCall() ? cast<CallInst>(II)->hasFnAttr(A) : cast<InvokeInst>(II)->hasFnAttr(A);
  }


  bool paramHasAttr(unsigned i, Attribute::AttrKind A) const {
    InstrTy *II = getInstruction(); return isCall() ? cast<CallInst>(II)->paramHasAttr(i, A) : cast<InvokeInst>(II)->paramHasAttr(i, A);
  }


  uint16_t getParamAlignment(uint16_t i) const {
    InstrTy *II = getInstruction(); return isCall() ? cast<CallInst>(II)->getParamAlignment(i) : cast<InvokeInst>(II)->getParamAlignment(i);
  }



  bool isNoBuiltin() const {
    InstrTy *II = getInstruction(); return isCall() ? cast<CallInst>(II)->isNoBuiltin() : cast<InvokeInst>(II)->isNoBuiltin();
  }


  bool isNoInline() const {
    InstrTy *II = getInstruction(); return isCall() ? cast<CallInst>(II)->isNoInline() : cast<InvokeInst>(II)->isNoInline();
  }
  void setIsNoInline(bool Value = true) {
    InstrTy *II = getInstruction(); if (isCall()) cast<CallInst>(II)->setIsNoInline(Value); else cast<InvokeInst>(II)->setIsNoInline(Value);
  }


  bool doesNotAccessMemory() const {
    InstrTy *II = getInstruction(); return isCall() ? cast<CallInst>(II)->doesNotAccessMemory() : cast<InvokeInst>(II)->doesNotAccessMemory();
  }
  void setDoesNotAccessMemory() {
    InstrTy *II = getInstruction(); if (isCall()) cast<CallInst>(II)->setDoesNotAccessMemory(); else cast<InvokeInst>(II)->setDoesNotAccessMemory();
  }


  bool onlyReadsMemory() const {
    InstrTy *II = getInstruction(); return isCall() ? cast<CallInst>(II)->onlyReadsMemory() : cast<InvokeInst>(II)->onlyReadsMemory();
  }
  void setOnlyReadsMemory() {
    InstrTy *II = getInstruction(); if (isCall()) cast<CallInst>(II)->setOnlyReadsMemory(); else cast<InvokeInst>(II)->setOnlyReadsMemory();
  }


  bool doesNotReturn() const {
    InstrTy *II = getInstruction(); return isCall() ? cast<CallInst>(II)->doesNotReturn() : cast<InvokeInst>(II)->doesNotReturn();
  }
  void setDoesNotReturn() {
    InstrTy *II = getInstruction(); if (isCall()) cast<CallInst>(II)->setDoesNotReturn(); else cast<InvokeInst>(II)->setDoesNotReturn();
  }


  bool doesNotThrow() const {
    InstrTy *II = getInstruction(); return isCall() ? cast<CallInst>(II)->doesNotThrow() : cast<InvokeInst>(II)->doesNotThrow();
  }
  void setDoesNotThrow() {
    InstrTy *II = getInstruction(); if (isCall()) cast<CallInst>(II)->setDoesNotThrow(); else cast<InvokeInst>(II)->setDoesNotThrow();
  }





  bool doesNotCapture(unsigned ArgNo) const {
    return paramHasAttr(ArgNo + 1, Attribute::NoCapture);
  }


  bool isByValArgument(unsigned ArgNo) const {
    return paramHasAttr(ArgNo + 1, Attribute::ByVal);
  }

  bool doesNotAccessMemory(unsigned ArgNo) const {
    return paramHasAttr(ArgNo + 1, Attribute::ReadNone);
  }

  bool onlyReadsMemory(unsigned ArgNo) const {
    return paramHasAttr(ArgNo + 1, Attribute::ReadOnly) ||
           paramHasAttr(ArgNo + 1, Attribute::ReadNone);
  }



  bool hasArgument(const Value *Arg) const {
    for (arg_iterator AI = this->arg_begin(), E = this->arg_end(); AI != E;
         ++AI)
      if (AI->get() == Arg)
        return true;
    return false;
  }

private:
  unsigned getArgumentEndOffset() const {
    if (isCall())
      return 1;
    else
      return 3;
  }

  IterTy getCallee() const {
    if (isCall())
      return cast<CallInst>(getInstruction())->op_end() - 1;
    else
      return cast<InvokeInst>(getInstruction())->op_end() - 3;
  }
};

class CallSite : public CallSiteBase<Function, Value, User, Instruction,
                                     CallInst, InvokeInst, User::op_iterator> {
  typedef CallSiteBase<Function, Value, User, Instruction,
                       CallInst, InvokeInst, User::op_iterator> Base;
public:
  CallSite() {}
  CallSite(Base B) : Base(B) {}
  CallSite(Value* V) : Base(V) {}
  CallSite(CallInst *CI) : Base(CI) {}
  CallSite(InvokeInst *II) : Base(II) {}
  CallSite(Instruction *II) : Base(II) {}

  bool operator==(const CallSite &CS) const { return I == CS.I; }
  bool operator!=(const CallSite &CS) const { return I != CS.I; }
  bool operator<(const CallSite &CS) const {
    return getInstruction() < CS.getInstruction();
  }

private:
  User::op_iterator getCallee() const;
};


class ImmutableCallSite : public CallSiteBase<> {
  typedef CallSiteBase<> Base;
public:
  ImmutableCallSite(const Value* V) : Base(V) {}
  ImmutableCallSite(const CallInst *CI) : Base(CI) {}
  ImmutableCallSite(const InvokeInst *II) : Base(II) {}
  ImmutableCallSite(const Instruction *II) : Base(II) {}
  ImmutableCallSite(CallSite CS) : Base(CS.getInstruction()) {}
};

}
# 42 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/AliasAnalysis.h" 2

namespace llvm {

class LoadInst;
class StoreInst;
class VAArgInst;
class DataLayout;
class TargetLibraryInfo;
class Pass;
class AnalysisUsage;
class MemTransferInst;
class MemIntrinsic;
class DominatorTree;

class AliasAnalysis {
protected:
  const DataLayout *TD;
  const TargetLibraryInfo *TLI;

private:
  AliasAnalysis *AA;

protected:





  void InitializeAliasAnalysis(Pass *P);



  virtual void getAnalysisUsage(AnalysisUsage &AU) const;

public:
  static char ID;
  AliasAnalysis() : TD(0), TLI(0), AA(0) {}
  virtual ~AliasAnalysis();




  static uint64_t const UnknownSize = ~0ULL;




  const DataLayout *getDataLayout() const { return TD; }




  const TargetLibraryInfo *getTargetLibraryInfo() const { return TLI; }




  uint64_t getTypeStoreSize(Type *Ty);






  struct Location {

    const Value *Ptr;





    uint64_t Size;


    const MDNode *TBAATag;

    explicit Location(const Value *P = 0, uint64_t S = UnknownSize,
                      const MDNode *N = 0)
      : Ptr(P), Size(S), TBAATag(N) {}

    Location getWithNewPtr(const Value *NewPtr) const {
      Location Copy(*this);
      Copy.Ptr = NewPtr;
      return Copy;
    }

    Location getWithNewSize(uint64_t NewSize) const {
      Location Copy(*this);
      Copy.Size = NewSize;
      return Copy;
    }

    Location getWithoutTBAATag() const {
      Location Copy(*this);
      Copy.TBAATag = 0;
      return Copy;
    }
  };



  Location getLocation(const LoadInst *LI);
  Location getLocation(const StoreInst *SI);
  Location getLocation(const VAArgInst *VI);
  Location getLocation(const AtomicCmpXchgInst *CXI);
  Location getLocation(const AtomicRMWInst *RMWI);
  static Location getLocationForSource(const MemTransferInst *MTI);
  static Location getLocationForDest(const MemIntrinsic *MI);
# 161 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/AliasAnalysis.h"
  enum AliasResult {
    NoAlias = 0,
    MayAlias,
    PartialAlias,
    MustAlias
  };





  virtual AliasResult alias(const Location &LocA, const Location &LocB);


  AliasResult alias(const Value *V1, uint64_t V1Size,
                    const Value *V2, uint64_t V2Size) {
    return alias(Location(V1, V1Size), Location(V2, V2Size));
  }


  AliasResult alias(const Value *V1, const Value *V2) {
    return alias(V1, UnknownSize, V2, UnknownSize);
  }



  bool isNoAlias(const Location &LocA, const Location &LocB) {
    return alias(LocA, LocB) == NoAlias;
  }


  bool isNoAlias(const Value *V1, uint64_t V1Size,
                 const Value *V2, uint64_t V2Size) {
    return isNoAlias(Location(V1, V1Size), Location(V2, V2Size));
  }


  bool isNoAlias(const Value *V1, const Value *V2) {
    return isNoAlias(Location(V1), Location(V2));
  }


  bool isMustAlias(const Location &LocA, const Location &LocB) {
    return alias(LocA, LocB) == MustAlias;
  }


  bool isMustAlias(const Value *V1, const Value *V2) {
    return alias(V1, 1, V2, 1) == MustAlias;
  }





  virtual bool pointsToConstantMemory(const Location &Loc,
                                      bool OrLocal = false);


  bool pointsToConstantMemory(const Value *P, bool OrLocal = false) {
    return pointsToConstantMemory(Location(P), OrLocal);
  }
# 231 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/AliasAnalysis.h"
  enum ModRefResult { NoModRef = 0, Ref = 1, Mod = 2, ModRef = 3 };



  enum { Nowhere = 0, ArgumentPointees = 4, Anywhere = 8 | ArgumentPointees };





  enum ModRefBehavior {






    DoesNotAccessMemory = Nowhere | NoModRef,






    OnlyReadsArgumentPointees = ArgumentPointees | Ref,






    OnlyAccessesArgumentPointees = ArgumentPointees | ModRef,







    OnlyReadsMemory = Anywhere | Ref,



    UnknownModRefBehavior = Anywhere | ModRef
  };


  virtual ModRefBehavior getModRefBehavior(ImmutableCallSite CS);



  virtual ModRefBehavior getModRefBehavior(const Function *F);
# 295 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/AliasAnalysis.h"
  bool doesNotAccessMemory(ImmutableCallSite CS) {
    return getModRefBehavior(CS) == DoesNotAccessMemory;
  }




  bool doesNotAccessMemory(const Function *F) {
    return getModRefBehavior(F) == DoesNotAccessMemory;
  }
# 315 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/AliasAnalysis.h"
  bool onlyReadsMemory(ImmutableCallSite CS) {
    return onlyReadsMemory(getModRefBehavior(CS));
  }





  bool onlyReadsMemory(const Function *F) {
    return onlyReadsMemory(getModRefBehavior(F));
  }




  static bool onlyReadsMemory(ModRefBehavior MRB) {
    return !(MRB & Mod);
  }





  static bool onlyAccessesArgPointees(ModRefBehavior MRB) {
    return !(MRB & Anywhere & ~ArgumentPointees);
  }





  static bool doesAccessArgPointees(ModRefBehavior MRB) {
    return (MRB & ModRef) && (MRB & ArgumentPointees);
  }




  ModRefResult getModRefInfo(const Instruction *I,
                             const Location &Loc) {
    switch (I->getOpcode()) {
    case Instruction::VAArg: return getModRefInfo((const VAArgInst*)I, Loc);
    case Instruction::Load: return getModRefInfo((const LoadInst*)I, Loc);
    case Instruction::Store: return getModRefInfo((const StoreInst*)I, Loc);
    case Instruction::Fence: return getModRefInfo((const FenceInst*)I, Loc);
    case Instruction::AtomicCmpXchg:
      return getModRefInfo((const AtomicCmpXchgInst*)I, Loc);
    case Instruction::AtomicRMW:
      return getModRefInfo((const AtomicRMWInst*)I, Loc);
    case Instruction::Call: return getModRefInfo((const CallInst*)I, Loc);
    case Instruction::Invoke: return getModRefInfo((const InvokeInst*)I,Loc);
    default: return NoModRef;
    }
  }


  ModRefResult getModRefInfo(const Instruction *I,
                             const Value *P, uint64_t Size) {
    return getModRefInfo(I, Location(P, Size));
  }



  virtual ModRefResult getModRefInfo(ImmutableCallSite CS,
                                     const Location &Loc);


  ModRefResult getModRefInfo(ImmutableCallSite CS,
                             const Value *P, uint64_t Size) {
    return getModRefInfo(CS, Location(P, Size));
  }



  ModRefResult getModRefInfo(const CallInst *C, const Location &Loc) {
    return getModRefInfo(ImmutableCallSite(C), Loc);
  }


  ModRefResult getModRefInfo(const CallInst *C, const Value *P, uint64_t Size) {
    return getModRefInfo(C, Location(P, Size));
  }



  ModRefResult getModRefInfo(const InvokeInst *I,
                             const Location &Loc) {
    return getModRefInfo(ImmutableCallSite(I), Loc);
  }


  ModRefResult getModRefInfo(const InvokeInst *I,
                             const Value *P, uint64_t Size) {
    return getModRefInfo(I, Location(P, Size));
  }



  ModRefResult getModRefInfo(const LoadInst *L, const Location &Loc);


  ModRefResult getModRefInfo(const LoadInst *L, const Value *P, uint64_t Size) {
    return getModRefInfo(L, Location(P, Size));
  }



  ModRefResult getModRefInfo(const StoreInst *S, const Location &Loc);


  ModRefResult getModRefInfo(const StoreInst *S, const Value *P, uint64_t Size){
    return getModRefInfo(S, Location(P, Size));
  }



  ModRefResult getModRefInfo(const FenceInst *S, const Location &Loc) {


    return ModRef;
  }


  ModRefResult getModRefInfo(const FenceInst *S, const Value *P, uint64_t Size){
    return getModRefInfo(S, Location(P, Size));
  }



  ModRefResult getModRefInfo(const AtomicCmpXchgInst *CX, const Location &Loc);


  ModRefResult getModRefInfo(const AtomicCmpXchgInst *CX,
                             const Value *P, unsigned Size) {
    return getModRefInfo(CX, Location(P, Size));
  }



  ModRefResult getModRefInfo(const AtomicRMWInst *RMW, const Location &Loc);


  ModRefResult getModRefInfo(const AtomicRMWInst *RMW,
                             const Value *P, unsigned Size) {
    return getModRefInfo(RMW, Location(P, Size));
  }



  ModRefResult getModRefInfo(const VAArgInst* I, const Location &Loc);


  ModRefResult getModRefInfo(const VAArgInst* I, const Value* P, uint64_t Size){
    return getModRefInfo(I, Location(P, Size));
  }





  virtual ModRefResult getModRefInfo(ImmutableCallSite CS1,
                                     ImmutableCallSite CS2);



  ModRefResult callCapturesBefore(const Instruction *I,
                                  const AliasAnalysis::Location &MemLoc,
                                  DominatorTree *DT);


  ModRefResult callCapturesBefore(const Instruction *I, const Value *P,
                                  uint64_t Size, DominatorTree *DT) {
    return callCapturesBefore(I, Location(P, Size), DT);
  }







  bool canBasicBlockModify(const BasicBlock &BB, const Location &Loc);


  bool canBasicBlockModify(const BasicBlock &BB, const Value *P, uint64_t Size){
    return canBasicBlockModify(BB, Location(P, Size));
  }





  bool canInstructionRangeModify(const Instruction &I1, const Instruction &I2,
                                 const Location &Loc);


  bool canInstructionRangeModify(const Instruction &I1, const Instruction &I2,
                                 const Value *Ptr, uint64_t Size) {
    return canInstructionRangeModify(I1, I2, Location(Ptr, Size));
  }
# 527 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/AliasAnalysis.h"
  virtual void deleteValue(Value *V);







  virtual void copyValue(Value *From, Value *To);
# 546 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/AliasAnalysis.h"
  virtual void addEscapingUse(Use &U);




  void replaceWithNewValue(Value *Old, Value *New) {
    copyValue(Old, New);
    deleteValue(Old);
  }
};


template<>
struct DenseMapInfo<AliasAnalysis::Location> {
  static inline AliasAnalysis::Location getEmptyKey() {
    return
      AliasAnalysis::Location(DenseMapInfo<const Value *>::getEmptyKey(),
                              0, 0);
  }
  static inline AliasAnalysis::Location getTombstoneKey() {
    return
      AliasAnalysis::Location(DenseMapInfo<const Value *>::getTombstoneKey(),
                              0, 0);
  }
  static unsigned getHashValue(const AliasAnalysis::Location &Val) {
    return DenseMapInfo<const Value *>::getHashValue(Val.Ptr) ^
           DenseMapInfo<uint64_t>::getHashValue(Val.Size) ^
           DenseMapInfo<const MDNode *>::getHashValue(Val.TBAATag);
  }
  static bool isEqual(const AliasAnalysis::Location &LHS,
                      const AliasAnalysis::Location &RHS) {
    return LHS.Ptr == RHS.Ptr &&
           LHS.Size == RHS.Size &&
           LHS.TBAATag == RHS.TBAATag;
  }
};



bool isNoAliasCall(const Value *V);



bool isNoAliasArgument(const Value *V);
# 598 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/AliasAnalysis.h"
bool isIdentifiedObject(const Value *V);

}
# 28 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/lib/Analysis/AliasAnalysis.cpp" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/CaptureTracking.h" 1
# 17 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/CaptureTracking.h"
namespace llvm {

  class Value;
  class Use;
# 29 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/CaptureTracking.h"
  bool PointerMayBeCaptured(const Value *V,
                            bool ReturnCaptures,
                            bool StoreCaptures);




  struct CaptureTracker {
    virtual ~CaptureTracker();



    virtual void tooManyUses() = 0;






    virtual bool shouldExplore(Use *U);




    virtual bool captured(Use *U) = 0;
  };




  void PointerMayBeCaptured(const Value *V, CaptureTracker *Tracker);
}
# 29 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/lib/Analysis/AliasAnalysis.cpp" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/CFG.h" 1
# 18 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/CFG.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/BasicBlock.h" 1
# 18 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/BasicBlock.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ilist.h" 1
# 43 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ilist.h"
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 1 3
# 21 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/assert.h" 1 3
# 12 "/mnt/home/ec2-user/build/emscripten/system/include/libc/assert.h" 3
extern "C" {



__attribute__((__noreturn__))

void __assert_fail (const char *, const char *, int, const char *);


}
# 22 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 2 3
# 25 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 3
# 44 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ilist.h" 2



namespace llvm {

template<typename NodeTy, typename Traits> class iplist;
template<typename NodeTy> class ilist_iterator;




template<typename NodeTy>
struct ilist_nextprev_traits {
  static NodeTy *getPrev(NodeTy *N) { return N->getPrev(); }
  static NodeTy *getNext(NodeTy *N) { return N->getNext(); }
  static const NodeTy *getPrev(const NodeTy *N) { return N->getPrev(); }
  static const NodeTy *getNext(const NodeTy *N) { return N->getNext(); }

  static void setPrev(NodeTy *N, NodeTy *Prev) { N->setPrev(Prev); }
  static void setNext(NodeTy *N, NodeTy *Next) { N->setNext(Next); }
};

template<typename NodeTy>
struct ilist_traits;







template<typename NodeTy>
struct ilist_sentinel_traits {

  static NodeTy *createSentinel() { return new NodeTy(); }


  static void destroySentinel(NodeTy *N) { delete N; }




  static NodeTy *provideInitialHead() { return 0; }




  static NodeTy *ensureHead(NodeTy *&Head) {
    if (!Head) {
      Head = ilist_traits<NodeTy>::createSentinel();
      ilist_traits<NodeTy>::noteHead(Head, Head);
      ilist_traits<NodeTy>::setNext(Head, 0);
      return Head;
    }
    return ilist_traits<NodeTy>::getPrev(Head);
  }


  static void noteHead(NodeTy *NewHead, NodeTy *Sentinel) {
    ilist_traits<NodeTy>::setPrev(NewHead, Sentinel);
  }
};




template<typename NodeTy>
struct ilist_node_traits {
  static NodeTy *createNode(const NodeTy &V) { return new NodeTy(V); }
  static void deleteNode(NodeTy *V) { delete V; }

  void addNodeToList(NodeTy *) {}
  void removeNodeFromList(NodeTy *) {}
  void transferNodesFromList(ilist_node_traits & ,
                             ilist_iterator<NodeTy> ,
                             ilist_iterator<NodeTy> ) {}
};





template<typename NodeTy>
struct ilist_default_traits : public ilist_nextprev_traits<NodeTy>,
                              public ilist_sentinel_traits<NodeTy>,
                              public ilist_node_traits<NodeTy> {
};



template<typename NodeTy>
struct ilist_traits : public ilist_default_traits<NodeTy> {};


template<typename Ty>
struct ilist_traits<const Ty> : public ilist_traits<Ty> {};




template<typename NodeTy>
class ilist_iterator
  : public std::iterator<std::bidirectional_iterator_tag, NodeTy, ptrdiff_t> {

public:
  typedef ilist_traits<NodeTy> Traits;
  typedef std::iterator<std::bidirectional_iterator_tag,
                        NodeTy, ptrdiff_t> super;

  typedef typename super::value_type value_type;
  typedef typename super::difference_type difference_type;
  typedef typename super::pointer pointer;
  typedef typename super::reference reference;
private:
  pointer NodePtr;





  void operator[](difference_type) const;
  void operator+(difference_type) const;
  void operator-(difference_type) const;
  void operator+=(difference_type) const;
  void operator-=(difference_type) const;
  template<class T> void operator<(T) const;
  template<class T> void operator<=(T) const;
  template<class T> void operator>(T) const;
  template<class T> void operator>=(T) const;
  template<class T> void operator-(T) const;
public:

  ilist_iterator(pointer NP) : NodePtr(NP) {}
  ilist_iterator(reference NR) : NodePtr(&NR) {}
  ilist_iterator() : NodePtr(0) {}



  template<class node_ty>
  ilist_iterator(const ilist_iterator<node_ty> &RHS)
    : NodePtr(RHS.getNodePtrUnchecked()) {}



  template<class node_ty>
  const ilist_iterator &operator=(const ilist_iterator<node_ty> &RHS) {
    NodePtr = RHS.getNodePtrUnchecked();
    return *this;
  }


  operator pointer() const {
    return NodePtr;
  }

  reference operator*() const {
    return *NodePtr;
  }
  pointer operator->() const { return &operator*(); }


  bool operator==(const ilist_iterator &RHS) const {
    return NodePtr == RHS.NodePtr;
  }
  bool operator!=(const ilist_iterator &RHS) const {
    return NodePtr != RHS.NodePtr;
  }


  ilist_iterator &operator--() {
    NodePtr = Traits::getPrev(NodePtr);
    ((void)((NodePtr && "--'d off the beginning of an ilist!") || (__assert_fail("NodePtr && \"--'d off the beginning of an ilist!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ilist.h", 215, __func__),0)));
    return *this;
  }
  ilist_iterator &operator++() {
    NodePtr = Traits::getNext(NodePtr);
    return *this;
  }
  ilist_iterator operator--(int) {
    ilist_iterator tmp = *this;
    --*this;
    return tmp;
  }
  ilist_iterator operator++(int) {
    ilist_iterator tmp = *this;
    ++*this;
    return tmp;
  }


  pointer getNodePtrUnchecked() const { return NodePtr; }
};



template<typename T>
void operator-(int, ilist_iterator<T>) ;
template<typename T>
void operator-(ilist_iterator<T>,int) ;

template<typename T>
void operator+(int, ilist_iterator<T>) ;
template<typename T>
void operator+(ilist_iterator<T>,int) ;



template<typename T>
bool operator!=(const T* LHS, const ilist_iterator<const T> &RHS) {
  return LHS != RHS.getNodePtrUnchecked();
}
template<typename T>
bool operator==(const T* LHS, const ilist_iterator<const T> &RHS) {
  return LHS == RHS.getNodePtrUnchecked();
}
template<typename T>
bool operator!=(T* LHS, const ilist_iterator<T> &RHS) {
  return LHS != RHS.getNodePtrUnchecked();
}
template<typename T>
bool operator==(T* LHS, const ilist_iterator<T> &RHS) {
  return LHS == RHS.getNodePtrUnchecked();
}





template<typename From> struct simplify_type;

template<typename NodeTy> struct simplify_type<ilist_iterator<NodeTy> > {
  typedef NodeTy* SimpleType;

  static SimpleType getSimplifiedValue(ilist_iterator<NodeTy> &Node) {
    return &*Node;
  }
};
template<typename NodeTy> struct simplify_type<const ilist_iterator<NodeTy> > {
  typedef NodeTy* SimpleType;

  static SimpleType getSimplifiedValue(const ilist_iterator<NodeTy> &Node) {
    return &*Node;
  }
};
# 312 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ilist.h"
template<typename NodeTy, typename Traits=ilist_traits<NodeTy> >
class iplist : public Traits {
  mutable NodeTy *Head;





  NodeTy *getTail() { return this->ensureHead(Head); }
  const NodeTy *getTail() const { return this->ensureHead(Head); }
  void setTail(NodeTy *N) const { this->noteHead(Head, N); }



  void CreateLazySentinel() const {
    this->ensureHead(Head);
  }

  static bool op_less(NodeTy &L, NodeTy &R) { return L < R; }
  static bool op_equal(NodeTy &L, NodeTy &R) { return L == R; }



  iplist(const iplist &) ;
  void operator=(const iplist &) ;

public:
  typedef NodeTy *pointer;
  typedef const NodeTy *const_pointer;
  typedef NodeTy &reference;
  typedef const NodeTy &const_reference;
  typedef NodeTy value_type;
  typedef ilist_iterator<NodeTy> iterator;
  typedef ilist_iterator<const NodeTy> const_iterator;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;

  iplist() : Head(this->provideInitialHead()) {}
  ~iplist() {
    if (!Head) return;
    clear();
    Traits::destroySentinel(getTail());
  }


  iterator begin() {
    CreateLazySentinel();
    return iterator(Head);
  }
  const_iterator begin() const {
    CreateLazySentinel();
    return const_iterator(Head);
  }
  iterator end() {
    CreateLazySentinel();
    return iterator(getTail());
  }
  const_iterator end() const {
    CreateLazySentinel();
    return const_iterator(getTail());
  }


  reverse_iterator rbegin() { return reverse_iterator(end()); }
  const_reverse_iterator rbegin() const{ return const_reverse_iterator(end()); }
  reverse_iterator rend() { return reverse_iterator(begin()); }
  const_reverse_iterator rend() const { return const_reverse_iterator(begin());}



  size_type max_size() const { return size_type(-1); }
  bool __attribute__((__warn_unused_result__)) empty() const {
    return Head == 0 || Head == getTail();
  }


  reference front() {
    ((void)((!empty() && "Called front() on empty list!") || (__assert_fail("!empty() && \"Called front() on empty list!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ilist.h", 391, __func__),0)));
    return *Head;
  }
  const_reference front() const {
    ((void)((!empty() && "Called front() on empty list!") || (__assert_fail("!empty() && \"Called front() on empty list!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ilist.h", 395, __func__),0)));
    return *Head;
  }
  reference back() {
    ((void)((!empty() && "Called back() on empty list!") || (__assert_fail("!empty() && \"Called back() on empty list!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ilist.h", 399, __func__),0)));
    return *this->getPrev(getTail());
  }
  const_reference back() const {
    ((void)((!empty() && "Called back() on empty list!") || (__assert_fail("!empty() && \"Called back() on empty list!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ilist.h", 403, __func__),0)));
    return *this->getPrev(getTail());
  }

  void swap(iplist &RHS) {
    ((void)((0 && "Swap does not use list traits callback correctly yet!") || (__assert_fail("0 && \"Swap does not use list traits callback correctly yet!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ilist.h", 408, __func__),0)));
    std::swap(Head, RHS.Head);
  }

  iterator insert(iterator where, NodeTy *New) {
    NodeTy *CurNode = where.getNodePtrUnchecked();
    NodeTy *PrevNode = this->getPrev(CurNode);
    this->setNext(New, CurNode);
    this->setPrev(New, PrevNode);

    if (CurNode != Head)
      this->setNext(PrevNode, New);
    else
      Head = New;
    this->setPrev(CurNode, New);

    this->addNodeToList(New);
    return New;
  }

  iterator insertAfter(iterator where, NodeTy *New) {
    if (empty())
      return insert(begin(), New);
    else
      return insert(++where, New);
  }

  NodeTy *remove(iterator &IT) {
    ((void)((IT != end() && "Cannot remove end of list!") || (__assert_fail("IT != end() && \"Cannot remove end of list!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ilist.h", 436, __func__),0)));
    NodeTy *Node = &*IT;
    NodeTy *NextNode = this->getNext(Node);
    NodeTy *PrevNode = this->getPrev(Node);

    if (Node != Head)
      this->setNext(PrevNode, NextNode);
    else
      Head = NextNode;
    this->setPrev(NextNode, PrevNode);
    IT = NextNode;
    this->removeNodeFromList(Node);






    this->setNext(Node, 0);
    this->setPrev(Node, 0);
    return Node;
  }

  NodeTy *remove(const iterator &IT) {
    iterator MutIt = IT;
    return remove(MutIt);
  }


  iterator erase(iterator where) {
    this->deleteNode(remove(where));
    return where;
  }






  void clearAndLeakNodesUnsafely() {
    if (Head) {
      Head = getTail();
      this->setPrev(Head, Head);
    }
  }

private:



  void transfer(iterator position, iplist &L2, iterator first, iterator last) {
    ((void)((first != last && "Should be checked by callers") || (__assert_fail("first != last && \"Should be checked by callers\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ilist.h", 487, __func__),0)));


    ((void)((position != first && "Insertion point can't be one of the transferred nodes") || (__assert_fail("position != first && \"Insertion point can't be one of the transferred nodes\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ilist.h", 491, __func__),0)));


    if (position != last) {


      NodeTy *ThisSentinel = getTail();
      setTail(0);
      NodeTy *L2Sentinel = L2.getTail();
      L2.setTail(0);


      NodeTy *First = &*first, *Prev = this->getPrev(First);
      NodeTy *Next = last.getNodePtrUnchecked(), *Last = this->getPrev(Next);
      if (Prev)
        this->setNext(Prev, Next);
      else
        L2.Head = Next;
      this->setPrev(Next, Prev);


      NodeTy *PosNext = position.getNodePtrUnchecked();
      NodeTy *PosPrev = this->getPrev(PosNext);


      if (PosPrev)
        this->setNext(PosPrev, First);
      else
        Head = First;
      this->setPrev(First, PosPrev);


      this->setNext(Last, PosNext);
      this->setPrev(PosNext, Last);

      this->transferNodesFromList(L2, First, PosNext);


      L2.setTail(L2Sentinel);
      setTail(ThisSentinel);
    }
  }

public:





  size_type __attribute__((__warn_unused_result__)) size() const {
    if (Head == 0) return 0;
    return std::distance(begin(), end());
  }

  iterator erase(iterator first, iterator last) {
    while (first != last)
      first = erase(first);
    return last;
  }

  void clear() { if (Head) erase(begin(), end()); }


  void push_front(NodeTy *val) { insert(begin(), val); }
  void push_back(NodeTy *val) { insert(end(), val); }
  void pop_front() {
    ((void)((!empty() && "pop_front() on empty list!") || (__assert_fail("!empty() && \"pop_front() on empty list!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ilist.h", 556, __func__),0)));
    erase(begin());
  }
  void pop_back() {
    ((void)((!empty() && "pop_back() on empty list!") || (__assert_fail("!empty() && \"pop_back() on empty list!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ilist.h", 560, __func__),0)));
    iterator t = end(); erase(--t);
  }


  template<class InIt> void insert(iterator where, InIt first, InIt last) {
    for (; first != last; ++first) insert(where, *first);
  }


  void splice(iterator where, iplist &L2) {
    if (!L2.empty())
      transfer(where, L2, L2.begin(), L2.end());
  }
  void splice(iterator where, iplist &L2, iterator first) {
    iterator last = first; ++last;
    if (where == first || where == last) return;
    transfer(where, L2, first, last);
  }
  void splice(iterator where, iplist &L2, iterator first, iterator last) {
    if (first != last) transfer(where, L2, first, last);
  }
# 592 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/ilist.h"
  void erase(const NodeTy &val) {
    for (iterator I = begin(), E = end(); I != E; ) {
      iterator next = I; ++next;
      if (*I == val) erase(I);
      I = next;
    }
  }
  template<class Pr1> void erase_if(Pr1 pred) {
    for (iterator I = begin(), E = end(); I != E; ) {
      iterator next = I; ++next;
      if (pred(*I)) erase(I);
      I = next;
    }
  }

  template<class Pr2> void unique(Pr2 pred) {
    if (empty()) return;
    for (iterator I = begin(), E = end(), Next = begin(); ++Next != E;) {
      if (pred(*I))
        erase(Next);
      else
        I = Next;
      Next = I;
    }
  }
  void unique() { unique(op_equal); }

  template<class Pr3> void merge(iplist &right, Pr3 pred) {
    iterator first1 = begin(), last1 = end();
    iterator first2 = right.begin(), last2 = right.end();
    while (first1 != last1 && first2 != last2)
      if (pred(*first2, *first1)) {
        iterator next = first2;
        transfer(first1, right, first2, ++next);
        first2 = next;
      } else {
        ++first1;
      }
    if (first2 != last2) transfer(last1, right, first2, last2);
  }
  void merge(iplist &right) { return merge(right, op_less); }

  template<class Pr3> void sort(Pr3 pred);
  void sort() { sort(op_less); }
};


template<typename NodeTy>
struct ilist : public iplist<NodeTy> {
  typedef typename iplist<NodeTy>::size_type size_type;
  typedef typename iplist<NodeTy>::iterator iterator;

  ilist() {}
  ilist(const ilist &right) {
    insert(this->begin(), right.begin(), right.end());
  }
  explicit ilist(size_type count) {
    insert(this->begin(), count, NodeTy());
  }
  ilist(size_type count, const NodeTy &val) {
    insert(this->begin(), count, val);
  }
  template<class InIt> ilist(InIt first, InIt last) {
    insert(this->begin(), first, last);
  }


  using iplist<NodeTy>::insert;
  using iplist<NodeTy>::push_front;
  using iplist<NodeTy>::push_back;


  iterator insert(iterator where, const NodeTy &val) {
    return insert(where, this->createNode(val));
  }



  void push_front(const NodeTy &val) { insert(this->begin(), val); }
  void push_back(const NodeTy &val) { insert(this->end(), val); }

  void insert(iterator where, size_type count, const NodeTy &val) {
    for (; count != 0; --count) insert(where, val);
  }


  void assign(size_type count, const NodeTy &val) {
    iterator I = this->begin();
    for (; I != this->end() && count != 0; ++I, --count)
      *I = val;
    if (count != 0)
      insert(this->end(), val, val);
    else
      erase(I, this->end());
  }
  template<class InIt> void assign(InIt first1, InIt last1) {
    iterator first2 = this->begin(), last2 = this->end();
    for ( ; first1 != last1 && first2 != last2; ++first1, ++first2)
      *first1 = *first2;
    if (first2 == last2)
      erase(first1, last1);
    else
      insert(last1, first2, last2);
  }



  void resize(size_type newsize, NodeTy val) {
    iterator i = this->begin();
    size_type len = 0;
    for ( ; i != this->end() && len < newsize; ++i, ++len) ;

    if (len == newsize)
      erase(i, this->end());
    else
      insert(this->end(), newsize - len, val);
  }
  void resize(size_type newsize) { resize(newsize, NodeTy()); }
};

}

namespace std {

  template<class Ty>
  void swap(llvm::iplist<Ty> &Left, llvm::iplist<Ty> &Right) {
    Left.swap(Right);
  }
}
# 19 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/BasicBlock.h" 2

# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/SymbolTableListTraits.h" 1
# 30 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/SymbolTableListTraits.h"
namespace llvm {
class ValueSymbolTable;

template<typename NodeTy> class ilist_iterator;
template<typename NodeTy, typename Traits> class iplist;
template<typename Ty> struct ilist_traits;




template<typename ValueSubClass, typename ItemParentClass>
class SymbolTableListTraits : public ilist_default_traits<ValueSubClass> {
  typedef ilist_traits<ValueSubClass> TraitsClass;
public:
  SymbolTableListTraits() {}



  ItemParentClass *getListOwner() {
    size_t Offset(size_t(&((ItemParentClass*)0->*ItemParentClass::
                           getSublistAccess(static_cast<ValueSubClass*>(0)))));
    iplist<ValueSubClass>* Anchor(static_cast<iplist<ValueSubClass>*>(this));
    return reinterpret_cast<ItemParentClass*>(reinterpret_cast<char*>(Anchor)-
                                              Offset);
  }

  static iplist<ValueSubClass> &getList(ItemParentClass *Par) {
    return Par->*(Par->getSublistAccess((ValueSubClass*)0));
  }

  static ValueSymbolTable *getSymTab(ItemParentClass *Par) {
    return Par ? toPtr(Par->getValueSymbolTable()) : 0;
  }

  void addNodeToList(ValueSubClass *V);
  void removeNodeFromList(ValueSubClass *V);
  void transferNodesFromList(ilist_traits<ValueSubClass> &L2,
                             ilist_iterator<ValueSubClass> first,
                             ilist_iterator<ValueSubClass> last);

  template<typename TPtr>
  void setSymTabObject(TPtr *, TPtr);
  static ValueSymbolTable *toPtr(ValueSymbolTable *P) { return P; }
  static ValueSymbolTable *toPtr(ValueSymbolTable &R) { return &R; }
};

}
# 21 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/BasicBlock.h" 2



namespace llvm {

class LandingPadInst;
class TerminatorInst;
class LLVMContext;
class BlockAddress;

template<> struct ilist_traits<Instruction>
  : public SymbolTableListTraits<Instruction, BasicBlock> {





  Instruction *createSentinel() const {







    return static_cast<Instruction*>(&Sentinel);
  }
  static void destroySentinel(Instruction*) {}

  Instruction *provideInitialHead() const { return createSentinel(); }
  Instruction *ensureHead(Instruction*) const { return createSentinel(); }
  static void noteHead(Instruction*, Instruction*) {}
private:
  mutable ilist_half_node<Instruction> Sentinel;
};
# 72 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/BasicBlock.h"
class BasicBlock : public Value,
                   public ilist_node<BasicBlock> {
  friend class BlockAddress;
public:
  typedef iplist<Instruction> InstListType;
private:
  InstListType InstList;
  Function *Parent;

  void setParent(Function *parent);
  friend class SymbolTableListTraits<BasicBlock, Function>;

  BasicBlock(const BasicBlock &) ;
  void operator=(const BasicBlock &) ;






  explicit BasicBlock(LLVMContext &C, const Twine &Name = "",
                      Function *Parent = 0, BasicBlock *InsertBefore = 0);
public:

  LLVMContext &getContext() const;


  typedef InstListType::iterator iterator;
  typedef InstListType::const_iterator const_iterator;
  typedef InstListType::reverse_iterator reverse_iterator;
  typedef InstListType::const_reverse_iterator const_reverse_iterator;






  static BasicBlock *Create(LLVMContext &Context, const Twine &Name = "",
                            Function *Parent = 0,BasicBlock *InsertBefore = 0) {
    return new BasicBlock(Context, Name, Parent, InsertBefore);
  }
  ~BasicBlock();


  const Function *getParent() const { return Parent; }
        Function *getParent() { return Parent; }



  TerminatorInst *getTerminator();
  const TerminatorInst *getTerminator() const;







  Instruction* getFirstNonPHI();
  const Instruction* getFirstNonPHI() const {
    return const_cast<BasicBlock*>(this)->getFirstNonPHI();
  }



  Instruction* getFirstNonPHIOrDbg();
  const Instruction* getFirstNonPHIOrDbg() const {
    return const_cast<BasicBlock*>(this)->getFirstNonPHIOrDbg();
  }



  Instruction* getFirstNonPHIOrDbgOrLifetime();
  const Instruction* getFirstNonPHIOrDbgOrLifetime() const {
    return const_cast<BasicBlock*>(this)->getFirstNonPHIOrDbgOrLifetime();
  }





  iterator getFirstInsertionPt();
  const_iterator getFirstInsertionPt() const {
    return const_cast<BasicBlock*>(this)->getFirstInsertionPt();
  }


  void removeFromParent();


  void eraseFromParent();



  void moveBefore(BasicBlock *MovePos);



  void moveAfter(BasicBlock *MovePos);




  BasicBlock *getSinglePredecessor();
  const BasicBlock *getSinglePredecessor() const {
    return const_cast<BasicBlock*>(this)->getSinglePredecessor();
  }






  BasicBlock *getUniquePredecessor();
  const BasicBlock *getUniquePredecessor() const {
    return const_cast<BasicBlock*>(this)->getUniquePredecessor();
  }




  inline iterator begin() { return InstList.begin(); }
  inline const_iterator begin() const { return InstList.begin(); }
  inline iterator end () { return InstList.end(); }
  inline const_iterator end () const { return InstList.end(); }

  inline reverse_iterator rbegin() { return InstList.rbegin(); }
  inline const_reverse_iterator rbegin() const { return InstList.rbegin(); }
  inline reverse_iterator rend () { return InstList.rend(); }
  inline const_reverse_iterator rend () const { return InstList.rend(); }

  inline size_t size() const { return InstList.size(); }
  inline bool empty() const { return InstList.empty(); }
  inline const Instruction &front() const { return InstList.front(); }
  inline Instruction &front() { return InstList.front(); }
  inline const Instruction &back() const { return InstList.back(); }
  inline Instruction &back() { return InstList.back(); }





  const InstListType &getInstList() const { return InstList; }
        InstListType &getInstList() { return InstList; }


  static iplist<Instruction> BasicBlock::*getSublistAccess(Instruction*) {
    return &BasicBlock::InstList;
  }


  ValueSymbolTable *getValueSymbolTable();


  static inline bool classof(const Value *V) {
    return V->getValueID() == Value::BasicBlockVal;
  }
# 238 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/BasicBlock.h"
  void dropAllReferences();







  void removePredecessor(BasicBlock *Pred, bool DontDeleteUselessPHIs = false);
# 264 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/BasicBlock.h"
  BasicBlock *splitBasicBlock(iterator I, const Twine &BBName = "");



  bool hasAddressTaken() const { return getSubclassDataFromValue() != 0; }



  void replaceSuccessorsPhiUsesWith(BasicBlock *New);





  bool isLandingPad() const;


  LandingPadInst *getLandingPadInst();
  const LandingPadInst *getLandingPadInst() const;

private:





  void AdjustBlockAddressRefCount(int Amt) {
    setValueSubclassData(getSubclassDataFromValue()+Amt);
    ((void)(((int)(signed char)getSubclassDataFromValue() >= 0 && "Refcount wrap-around") || (__assert_fail("(int)(signed char)getSubclassDataFromValue() >= 0 && \"Refcount wrap-around\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/BasicBlock.h", 293, __func__),0)));

  }


  void setValueSubclassData(unsigned short D) {
    Value::setValueSubclassData(D);
  }
};


inline BasicBlock *unwrap(LLVMBasicBlockRef P) { return reinterpret_cast<BasicBlock*>(P); } inline LLVMBasicBlockRef wrap(const BasicBlock *P) { return reinterpret_cast<LLVMBasicBlockRef>(const_cast<BasicBlock*>(P)); }

}
# 19 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/CFG.h" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CFG.h" 1
# 18 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CFG.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/GraphTraits.h" 1
# 21 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/GraphTraits.h"
namespace llvm {




template<class GraphType>
struct GraphTraits {
# 60 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/GraphTraits.h"
  typedef typename GraphType::UnknownGraphTypeError NodeType;
};
# 77 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/GraphTraits.h"
template <class GraphType>
struct Inverse {
  const GraphType &Graph;

  inline Inverse(const GraphType &G) : Graph(G) {}
};



template<class T>
struct GraphTraits<Inverse<Inverse<T> > > {
  typedef typename GraphTraits<T>::NodeType NodeType;
  typedef typename GraphTraits<T>::ChildIteratorType ChildIteratorType;

  static NodeType *getEntryNode(Inverse<Inverse<T> > *G) {
    return GraphTraits<T>::getEntryNode(G->Graph.Graph);
  }

  static ChildIteratorType child_begin(NodeType* N) {
    return GraphTraits<T>::child_begin(N);
  }

  static ChildIteratorType child_end(NodeType* N) {
    return GraphTraits<T>::child_end(N);
  }
};

}
# 19 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CFG.h" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Function.h" 1
# 21 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Function.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Argument.h" 1
# 22 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Argument.h"
namespace llvm {

template<typename ValueSubClass, typename ItemParentClass>
  class SymbolTableListTraits;
# 35 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Argument.h"
class Argument : public Value, public ilist_node<Argument> {
  virtual void anchor();
  Function *Parent;

  friend class SymbolTableListTraits<Argument, Function>;
  void setParent(Function *parent);

public:




  explicit Argument(Type *Ty, const Twine &Name = "", Function *F = 0);

  inline const Function *getParent() const { return Parent; }
  inline Function *getParent() { return Parent; }





  unsigned getArgNo() const;



  bool hasByValAttr() const;


  unsigned getParamAlignment() const;



  bool hasNestAttr() const;



  bool hasNoAliasAttr() const;



  bool hasNoCaptureAttr() const;



  bool hasStructRetAttr() const;



  bool hasReturnedAttr() const;



  bool onlyReadsMemory() const;



  void addAttr(AttributeSet AS);


  void removeAttr(AttributeSet AS);



  static inline bool classof(const Value *V) {
    return V->getValueID() == ArgumentVal;
  }
};

}
# 22 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Function.h" 2



# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/GlobalValue.h" 1
# 21 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/GlobalValue.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Constant.h" 1
# 19 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Constant.h"
namespace llvm {
  class APInt;

  template<typename T> class SmallVectorImpl;
# 41 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Constant.h"
class Constant : public User {
  void operator=(const Constant &) ;
  Constant(const Constant &) ;
  virtual void anchor();

protected:
  Constant(Type *ty, ValueTy vty, Use *Ops, unsigned NumOps)
    : User(ty, vty, Ops, NumOps) {}

  void destroyConstantImpl();
public:


  bool isNullValue() const;



  bool isAllOnesValue() const;



  bool isNegativeZeroValue() const;


  bool isZeroValue() const;



  bool canTrap() const;


  bool isThreadDependent() const;



  bool isConstantUsed() const;

  enum PossibleRelocationsTy {
    NoRelocation = 0,
    LocalRelocation = 1,
    GlobalRelocations = 2
  };
# 98 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Constant.h"
  PossibleRelocationsTy getRelocationInfo() const;





  Constant *getAggregateElement(unsigned Elt) const;
  Constant *getAggregateElement(Constant *Elt) const;



  Constant *getSplatValue() const;



  const APInt &getUniqueInteger() const;
# 122 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Constant.h"
  virtual void destroyConstant() { ::llvm::llvm_unreachable_internal("Not reached!", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Constant.h", 122); }


  static inline bool classof(const Value *V) {
    return V->getValueID() >= ConstantFirstVal &&
           V->getValueID() <= ConstantLastVal;
  }
# 140 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Constant.h"
  virtual void replaceUsesOfWithOnConstant(Value *, Value *, Use *) {



    ((void)((getNumOperands() == 0 && "replaceUsesOfWithOnConstant must be " "implemented for all constants that have operands!") || (__assert_fail("getNumOperands() == 0 && \"replaceUsesOfWithOnConstant must be \" \"implemented for all constants that have operands!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Constant.h", 145, __func__),0)));

    ::llvm::llvm_unreachable_internal("Constants that do not have operands cannot be using " "'From'!", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Constant.h", 147);

  }

  static Constant *getNullValue(Type* Ty);




  static Constant *getAllOnesValue(Type* Ty);



  static Constant *getIntegerValue(Type* Ty, const APInt &V);





  void removeDeadConstantUsers() const;
};

}
# 22 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/GlobalValue.h" 2


namespace llvm {

class PointerType;
class Module;

class GlobalValue : public Constant {
  GlobalValue(const GlobalValue &) ;
public:

  enum LinkageTypes {
    ExternalLinkage = 0,
    AvailableExternallyLinkage,
    LinkOnceAnyLinkage,
    LinkOnceODRLinkage,
    WeakAnyLinkage,
    WeakODRLinkage,
    AppendingLinkage,
    InternalLinkage,
    PrivateLinkage,
    LinkerPrivateLinkage,
    LinkerPrivateWeakLinkage,
    DLLImportLinkage,
    DLLExportLinkage,
    ExternalWeakLinkage,
    CommonLinkage
  };


  enum VisibilityTypes {
    DefaultVisibility = 0,
    HiddenVisibility,
    ProtectedVisibility
  };

protected:
  GlobalValue(Type *ty, ValueTy vty, Use *Ops, unsigned NumOps,
              LinkageTypes linkage, const Twine &Name)
    : Constant(ty, vty, Ops, NumOps), Linkage(linkage),
      Visibility(DefaultVisibility), Alignment(0), UnnamedAddr(0), Parent(0) {
    setName(Name);
  }



  LinkageTypes Linkage : 5;
  unsigned Visibility : 2;
  unsigned Alignment : 16;
  unsigned UnnamedAddr : 1;
  Module *Parent;
  std::string Section;
public:
  ~GlobalValue() {
    removeDeadConstantUsers();
  }

  unsigned getAlignment() const {
    return (1u << Alignment) >> 1;
  }
  void setAlignment(unsigned Align);

  bool hasUnnamedAddr() const { return UnnamedAddr; }
  void setUnnamedAddr(bool Val) { UnnamedAddr = Val; }

  VisibilityTypes getVisibility() const { return VisibilityTypes(Visibility); }
  bool hasDefaultVisibility() const { return Visibility == DefaultVisibility; }
  bool hasHiddenVisibility() const { return Visibility == HiddenVisibility; }
  bool hasProtectedVisibility() const {
    return Visibility == ProtectedVisibility;
  }
  void setVisibility(VisibilityTypes V) { Visibility = V; }

  bool hasSection() const { return !Section.empty(); }
  const std::string &getSection() const { return Section; }
  void setSection(StringRef S) { Section = S; }






  bool use_empty_except_constants();


  inline PointerType *getType() const {
    return cast<PointerType>(User::getType());
  }

  static LinkageTypes getLinkOnceLinkage(bool ODR) {
    return ODR ? LinkOnceODRLinkage : LinkOnceAnyLinkage;
  }
  static LinkageTypes getWeakLinkage(bool ODR) {
    return ODR ? WeakODRLinkage : WeakAnyLinkage;
  }

  static bool isExternalLinkage(LinkageTypes Linkage) {
    return Linkage == ExternalLinkage;
  }
  static bool isAvailableExternallyLinkage(LinkageTypes Linkage) {
    return Linkage == AvailableExternallyLinkage;
  }
  static bool isLinkOnceLinkage(LinkageTypes Linkage) {
    return Linkage == LinkOnceAnyLinkage || Linkage == LinkOnceODRLinkage;
  }
  static bool isWeakLinkage(LinkageTypes Linkage) {
    return Linkage == WeakAnyLinkage || Linkage == WeakODRLinkage;
  }
  static bool isAppendingLinkage(LinkageTypes Linkage) {
    return Linkage == AppendingLinkage;
  }
  static bool isInternalLinkage(LinkageTypes Linkage) {
    return Linkage == InternalLinkage;
  }
  static bool isPrivateLinkage(LinkageTypes Linkage) {
    return Linkage == PrivateLinkage;
  }
  static bool isLinkerPrivateLinkage(LinkageTypes Linkage) {
    return Linkage == LinkerPrivateLinkage;
  }
  static bool isLinkerPrivateWeakLinkage(LinkageTypes Linkage) {
    return Linkage == LinkerPrivateWeakLinkage;
  }
  static bool isLocalLinkage(LinkageTypes Linkage) {
    return isInternalLinkage(Linkage) || isPrivateLinkage(Linkage) ||
      isLinkerPrivateLinkage(Linkage) || isLinkerPrivateWeakLinkage(Linkage);
  }
  static bool isDLLImportLinkage(LinkageTypes Linkage) {
    return Linkage == DLLImportLinkage;
  }
  static bool isDLLExportLinkage(LinkageTypes Linkage) {
    return Linkage == DLLExportLinkage;
  }
  static bool isExternalWeakLinkage(LinkageTypes Linkage) {
    return Linkage == ExternalWeakLinkage;
  }
  static bool isCommonLinkage(LinkageTypes Linkage) {
    return Linkage == CommonLinkage;
  }



  static bool isDiscardableIfUnused(LinkageTypes Linkage) {
    return isLinkOnceLinkage(Linkage) || isLocalLinkage(Linkage);
  }




  static bool mayBeOverridden(LinkageTypes Linkage) {
    return Linkage == WeakAnyLinkage ||
           Linkage == LinkOnceAnyLinkage ||
           Linkage == CommonLinkage ||
           Linkage == ExternalWeakLinkage ||
           Linkage == LinkerPrivateWeakLinkage;
  }





  static bool isWeakForLinker(LinkageTypes Linkage) {
    return Linkage == AvailableExternallyLinkage ||
           Linkage == WeakAnyLinkage ||
           Linkage == WeakODRLinkage ||
           Linkage == LinkOnceAnyLinkage ||
           Linkage == LinkOnceODRLinkage ||
           Linkage == CommonLinkage ||
           Linkage == ExternalWeakLinkage ||
           Linkage == LinkerPrivateWeakLinkage;
  }

  bool hasExternalLinkage() const { return isExternalLinkage(Linkage); }
  bool hasAvailableExternallyLinkage() const {
    return isAvailableExternallyLinkage(Linkage);
  }
  bool hasLinkOnceLinkage() const {
    return isLinkOnceLinkage(Linkage);
  }
  bool hasWeakLinkage() const {
    return isWeakLinkage(Linkage);
  }
  bool hasAppendingLinkage() const { return isAppendingLinkage(Linkage); }
  bool hasInternalLinkage() const { return isInternalLinkage(Linkage); }
  bool hasPrivateLinkage() const { return isPrivateLinkage(Linkage); }
  bool hasLinkerPrivateLinkage() const { return isLinkerPrivateLinkage(Linkage); }
  bool hasLinkerPrivateWeakLinkage() const {
    return isLinkerPrivateWeakLinkage(Linkage);
  }
  bool hasLocalLinkage() const { return isLocalLinkage(Linkage); }
  bool hasDLLImportLinkage() const { return isDLLImportLinkage(Linkage); }
  bool hasDLLExportLinkage() const { return isDLLExportLinkage(Linkage); }
  bool hasExternalWeakLinkage() const { return isExternalWeakLinkage(Linkage); }
  bool hasCommonLinkage() const { return isCommonLinkage(Linkage); }

  void setLinkage(LinkageTypes LT) { Linkage = LT; }
  LinkageTypes getLinkage() const { return Linkage; }

  bool isDiscardableIfUnused() const {
    return isDiscardableIfUnused(Linkage);
  }

  bool mayBeOverridden() const { return mayBeOverridden(Linkage); }

  bool isWeakForLinker() const { return isWeakForLinker(Linkage); }



  virtual void copyAttributesFrom(const GlobalValue *Src);




  static StringRef getRealLinkageName(StringRef Name) {
    if (!Name.empty() && Name[0] == '\1')
      return Name.substr(1);
    return Name;
  }
# 250 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/GlobalValue.h"
  bool isMaterializable() const;




  bool isDematerializable() const;




  bool Materialize(std::string *ErrInfo = 0);




  void Dematerialize();




  virtual void destroyConstant();



  bool isDeclaration() const;



  virtual void removeFromParent() = 0;



  virtual void eraseFromParent() = 0;



  inline Module *getParent() { return Parent; }
  inline const Module *getParent() const { return Parent; }


  static inline bool classof(const Value *V) {
    return V->getValueID() == Value::FunctionVal ||
           V->getValueID() == Value::GlobalVariableVal ||
           V->getValueID() == Value::GlobalAliasVal;
  }
};

}
# 26 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Function.h" 2


namespace llvm {

class FunctionType;
class LLVMContext;


template<> struct ilist_traits<BasicBlock>
  : public SymbolTableListTraits<BasicBlock, Function> {



  BasicBlock *createSentinel() const {
    return static_cast<BasicBlock*>(&Sentinel);
  }
  static void destroySentinel(BasicBlock*) {}

  BasicBlock *provideInitialHead() const { return createSentinel(); }
  BasicBlock *ensureHead(BasicBlock*) const { return createSentinel(); }
  static void noteHead(BasicBlock*, BasicBlock*) {}

  static ValueSymbolTable *getSymTab(Function *ItemParent);
private:
  mutable ilist_half_node<BasicBlock> Sentinel;
};

template<> struct ilist_traits<Argument>
  : public SymbolTableListTraits<Argument, Function> {

  Argument *createSentinel() const {
    return static_cast<Argument*>(&Sentinel);
  }
  static void destroySentinel(Argument*) {}

  Argument *provideInitialHead() const { return createSentinel(); }
  Argument *ensureHead(Argument*) const { return createSentinel(); }
  static void noteHead(Argument*, Argument*) {}

  static ValueSymbolTable *getSymTab(Function *ItemParent);
private:
  mutable ilist_half_node<Argument> Sentinel;
};

class Function : public GlobalValue,
                 public ilist_node<Function> {
public:
  typedef iplist<Argument> ArgumentListType;
  typedef iplist<BasicBlock> BasicBlockListType;


  typedef BasicBlockListType::iterator iterator;
  typedef BasicBlockListType::const_iterator const_iterator;

  typedef ArgumentListType::iterator arg_iterator;
  typedef ArgumentListType::const_iterator const_arg_iterator;

private:

  BasicBlockListType BasicBlocks;
  mutable ArgumentListType ArgumentList;
  ValueSymbolTable *SymTab;
  AttributeSet AttributeSets;







  friend class SymbolTableListTraits<Function, Module>;

  void setParent(Module *parent);





  bool hasLazyArguments() const {
    return getSubclassDataFromValue() & 1;
  }
  void CheckLazyArguments() const {
    if (hasLazyArguments())
      BuildLazyArguments();
  }
  void BuildLazyArguments() const;

  Function(const Function&) ;
  void operator=(const Function&) ;



  unsigned lookupIntrinsicID() const __attribute__((__pure__));





  Function(FunctionType *Ty, LinkageTypes Linkage,
           const Twine &N = "", Module *M = 0);

public:
  static Function *Create(FunctionType *Ty, LinkageTypes Linkage,
                          const Twine &N = "", Module *M = 0) {
    return new(0) Function(Ty, Linkage, N, M);
  }

  ~Function();

  Type *getReturnType() const;
  FunctionType *getFunctionType() const;



  LLVMContext &getContext() const;



  bool isVarArg() const;
# 155 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Function.h"
  unsigned getIntrinsicID() const __attribute__((__pure__));
  bool isIntrinsic() const { return getName().startswith("llvm."); }




  CallingConv::ID getCallingConv() const {
    return static_cast<CallingConv::ID>(getSubclassDataFromValue() >> 2);
  }
  void setCallingConv(CallingConv::ID CC) {
    setValueSubclassData((getSubclassDataFromValue() & 3) |
                         (static_cast<unsigned>(CC) << 2));
  }


  AttributeSet getAttributes() const { return AttributeSets; }


  void setAttributes(AttributeSet attrs) { AttributeSets = attrs; }


  void addFnAttr(Attribute::AttrKind N) {
    setAttributes(AttributeSets.addAttribute(getContext(),
                                             AttributeSet::FunctionIndex, N));
  }


  void removeFnAttr(Attribute::AttrKind N) {
    setAttributes(AttributeSets.removeAttribute(
        getContext(), AttributeSet::FunctionIndex, N));
  }


  void addFnAttr(StringRef Kind) {
    setAttributes(
      AttributeSets.addAttribute(getContext(),
                                 AttributeSet::FunctionIndex, Kind));
  }
  void addFnAttr(StringRef Kind, StringRef Value) {
    setAttributes(
      AttributeSets.addAttribute(getContext(),
                                 AttributeSet::FunctionIndex, Kind, Value));
  }


  bool hasFnAttribute(Attribute::AttrKind Kind) const {
    return AttributeSets.hasAttribute(AttributeSet::FunctionIndex, Kind);
  }
  bool hasFnAttribute(StringRef Kind) const {
    return AttributeSets.hasAttribute(AttributeSet::FunctionIndex, Kind);
  }


  Attribute getFnAttribute(Attribute::AttrKind Kind) const {
    return AttributeSets.getAttribute(AttributeSet::FunctionIndex, Kind);
  }
  Attribute getFnAttribute(StringRef Kind) const {
    return AttributeSets.getAttribute(AttributeSet::FunctionIndex, Kind);
  }



  bool hasGC() const;
  const char *getGC() const;
  void setGC(const char *Str);
  void clearGC();


  void addAttribute(unsigned i, Attribute::AttrKind attr);


  void addAttributes(unsigned i, AttributeSet attrs);


  void removeAttributes(unsigned i, AttributeSet attr);


  unsigned getParamAlignment(unsigned i) const {
    return AttributeSets.getParamAlignment(i);
  }


  bool doesNotAccessMemory() const {
    return AttributeSets.hasAttribute(AttributeSet::FunctionIndex,
                                      Attribute::ReadNone);
  }
  void setDoesNotAccessMemory() {
    addFnAttr(Attribute::ReadNone);
  }


  bool onlyReadsMemory() const {
    return doesNotAccessMemory() ||
      AttributeSets.hasAttribute(AttributeSet::FunctionIndex,
                                 Attribute::ReadOnly);
  }
  void setOnlyReadsMemory() {
    addFnAttr(Attribute::ReadOnly);
  }


  bool doesNotReturn() const {
    return AttributeSets.hasAttribute(AttributeSet::FunctionIndex,
                                      Attribute::NoReturn);
  }
  void setDoesNotReturn() {
    addFnAttr(Attribute::NoReturn);
  }


  bool doesNotThrow() const {
    return AttributeSets.hasAttribute(AttributeSet::FunctionIndex,
                                      Attribute::NoUnwind);
  }
  void setDoesNotThrow() {
    addFnAttr(Attribute::NoUnwind);
  }


  bool cannotDuplicate() const {
    return AttributeSets.hasAttribute(AttributeSet::FunctionIndex,
                                      Attribute::NoDuplicate);
  }
  void setCannotDuplicate() {
    addFnAttr(Attribute::NoDuplicate);
  }



  bool hasUWTable() const {
    return AttributeSets.hasAttribute(AttributeSet::FunctionIndex,
                                      Attribute::UWTable);
  }
  void setHasUWTable() {
    addFnAttr(Attribute::UWTable);
  }


  bool needsUnwindTableEntry() const {
    return hasUWTable() || !doesNotThrow();
  }



  bool hasStructRetAttr() const {
    return AttributeSets.hasAttribute(1, Attribute::StructRet);
  }



  bool doesNotAlias(unsigned n) const {
    return AttributeSets.hasAttribute(n, Attribute::NoAlias);
  }
  void setDoesNotAlias(unsigned n) {
    addAttribute(n, Attribute::NoAlias);
  }



  bool doesNotCapture(unsigned n) const {
    return AttributeSets.hasAttribute(n, Attribute::NoCapture);
  }
  void setDoesNotCapture(unsigned n) {
    addAttribute(n, Attribute::NoCapture);
  }

  bool doesNotAccessMemory(unsigned n) const {
    return AttributeSets.hasAttribute(n, Attribute::ReadNone);
  }
  void setDoesNotAccessMemory(unsigned n) {
    addAttribute(n, Attribute::ReadNone);
  }

  bool onlyReadsMemory(unsigned n) const {
    return doesNotAccessMemory(n) ||
      AttributeSets.hasAttribute(n, Attribute::ReadOnly);
  }
  void setOnlyReadsMemory(unsigned n) {
    addAttribute(n, Attribute::ReadOnly);
  }



  void copyAttributesFrom(const GlobalValue *Src);




  void deleteBody() {
    dropAllReferences();
    setLinkage(ExternalLinkage);
  }




  virtual void removeFromParent();




  virtual void eraseFromParent();





  const ArgumentListType &getArgumentList() const {
    CheckLazyArguments();
    return ArgumentList;
  }
  ArgumentListType &getArgumentList() {
    CheckLazyArguments();
    return ArgumentList;
  }
  static iplist<Argument> Function::*getSublistAccess(Argument*) {
    return &Function::ArgumentList;
  }

  const BasicBlockListType &getBasicBlockList() const { return BasicBlocks; }
        BasicBlockListType &getBasicBlockList() { return BasicBlocks; }
  static iplist<BasicBlock> Function::*getSublistAccess(BasicBlock*) {
    return &Function::BasicBlocks;
  }

  const BasicBlock &getEntryBlock() const { return front(); }
        BasicBlock &getEntryBlock() { return front(); }






  inline ValueSymbolTable &getValueSymbolTable() { return *SymTab; }
  inline const ValueSymbolTable &getValueSymbolTable() const { return *SymTab; }





  iterator begin() { return BasicBlocks.begin(); }
  const_iterator begin() const { return BasicBlocks.begin(); }
  iterator end () { return BasicBlocks.end(); }
  const_iterator end () const { return BasicBlocks.end(); }

  size_t size() const { return BasicBlocks.size(); }
  bool empty() const { return BasicBlocks.empty(); }
  const BasicBlock &front() const { return BasicBlocks.front(); }
        BasicBlock &front() { return BasicBlocks.front(); }
  const BasicBlock &back() const { return BasicBlocks.back(); }
        BasicBlock &back() { return BasicBlocks.back(); }




  arg_iterator arg_begin() {
    CheckLazyArguments();
    return ArgumentList.begin();
  }
  const_arg_iterator arg_begin() const {
    CheckLazyArguments();
    return ArgumentList.begin();
  }
  arg_iterator arg_end() {
    CheckLazyArguments();
    return ArgumentList.end();
  }
  const_arg_iterator arg_end() const {
    CheckLazyArguments();
    return ArgumentList.end();
  }

  size_t arg_size() const;
  bool arg_empty() const;

  bool hasPrefixData() const {
    return getSubclassDataFromValue() & 2;
  }

  Constant *getPrefixData() const;
  void setPrefixData(Constant *PrefixData);







  void viewCFG() const;






  void viewCFGOnly() const;


  static inline bool classof(const Value *V) {
    return V->getValueID() == Value::FunctionVal;
  }
# 469 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Function.h"
  void dropAllReferences();





  bool hasAddressTaken(const User** = 0) const;





  bool isDefTriviallyDead() const;



  bool callsFunctionThatReturnsTwice() const;

private:


  void setValueSubclassData(unsigned short D) {
    Value::setValueSubclassData(D);
  }
};

inline ValueSymbolTable *
ilist_traits<BasicBlock>::getSymTab(Function *F) {
  return F ? &F->getValueSymbolTable() : 0;
}

inline ValueSymbolTable *
ilist_traits<Argument>::getSymTab(Function *F) {
  return F ? &F->getValueSymbolTable() : 0;
}

}
# 20 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CFG.h" 2


namespace llvm {





template <class Ptr, class USE_iterator>
class PredIterator : public std::iterator<std::forward_iterator_tag,
                                          Ptr, ptrdiff_t, Ptr*, Ptr*> {
  typedef std::iterator<std::forward_iterator_tag, Ptr, ptrdiff_t, Ptr*,
                                                                    Ptr*> super;
  typedef PredIterator<Ptr, USE_iterator> Self;
  USE_iterator It;

  inline void advancePastNonTerminators() {

    while (!It.atEnd() && !isa<TerminatorInst>(*It))
      ++It;
  }

public:
  typedef typename super::pointer pointer;
  typedef typename super::reference reference;

  PredIterator() {}
  explicit inline PredIterator(Ptr *bb) : It(bb->use_begin()) {
    advancePastNonTerminators();
  }
  inline PredIterator(Ptr *bb, bool) : It(bb->use_end()) {}

  inline bool operator==(const Self& x) const { return It == x.It; }
  inline bool operator!=(const Self& x) const { return !operator==(x); }

  inline reference operator*() const {
    ((void)((!It.atEnd() && "pred_iterator out of range!") || (__assert_fail("!It.atEnd() && \"pred_iterator out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CFG.h", 56, __func__),0)));
    return cast<TerminatorInst>(*It)->getParent();
  }
  inline pointer *operator->() const { return &operator*(); }

  inline Self& operator++() {
    ((void)((!It.atEnd() && "pred_iterator out of range!") || (__assert_fail("!It.atEnd() && \"pred_iterator out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CFG.h", 62, __func__),0)));
    ++It; advancePastNonTerminators();
    return *this;
  }

  inline Self operator++(int) {
    Self tmp = *this; ++*this; return tmp;
  }



  unsigned getOperandNo() const {
    return It.getOperandNo();
  }



  Use &getUse() const {
    return It.getUse();
  }
};

typedef PredIterator<BasicBlock, Value::use_iterator> pred_iterator;
typedef PredIterator<const BasicBlock,
                     Value::const_use_iterator> const_pred_iterator;

inline pred_iterator pred_begin(BasicBlock *BB) { return pred_iterator(BB); }
inline const_pred_iterator pred_begin(const BasicBlock *BB) {
  return const_pred_iterator(BB);
}
inline pred_iterator pred_end(BasicBlock *BB) { return pred_iterator(BB, true);}
inline const_pred_iterator pred_end(const BasicBlock *BB) {
  return const_pred_iterator(BB, true);
}







template <class Term_, class BB_>
class SuccIterator : public std::iterator<std::bidirectional_iterator_tag,
                                          BB_, ptrdiff_t, BB_*, BB_*> {
  const Term_ Term;
  unsigned idx;
  typedef std::iterator<std::bidirectional_iterator_tag, BB_, ptrdiff_t, BB_*,
                                                                    BB_*> super;
  typedef SuccIterator<Term_, BB_> Self;

  inline bool index_is_valid(int idx) {
    return idx >= 0 && (unsigned) idx < Term->getNumSuccessors();
  }

public:
  typedef typename super::pointer pointer;
  typedef typename super::reference reference;


  explicit inline SuccIterator(Term_ T) : Term(T), idx(0) {
  }
  inline SuccIterator(Term_ T, bool)
    : Term(T) {
    if (Term)
      idx = Term->getNumSuccessors();
    else





      idx = 0;
  }

  inline const Self &operator=(const Self &I) {
    ((void)((Term == I.Term &&"Cannot assign iterators to two different blocks!") || (__assert_fail("Term == I.Term &&\"Cannot assign iterators to two different blocks!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CFG.h", 137, __func__),0)));
    idx = I.idx;
    return *this;
  }



  unsigned getSuccessorIndex() const { return idx; }

  inline bool operator==(const Self& x) const { return idx == x.idx; }
  inline bool operator!=(const Self& x) const { return !operator==(x); }

  inline reference operator*() const { return Term->getSuccessor(idx); }
  inline pointer operator->() const { return operator*(); }

  inline Self& operator++() { ++idx; return *this; }

  inline Self operator++(int) {
    Self tmp = *this; ++*this; return tmp;
  }

  inline Self& operator--() { --idx; return *this; }
  inline Self operator--(int) {
    Self tmp = *this; --*this; return tmp;
  }

  inline bool operator<(const Self& x) const {
    ((void)((Term == x.Term && "Cannot compare iterators of different blocks!") || (__assert_fail("Term == x.Term && \"Cannot compare iterators of different blocks!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CFG.h", 164, __func__),0)));
    return idx < x.idx;
  }

  inline bool operator<=(const Self& x) const {
    ((void)((Term == x.Term && "Cannot compare iterators of different blocks!") || (__assert_fail("Term == x.Term && \"Cannot compare iterators of different blocks!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CFG.h", 169, __func__),0)));
    return idx <= x.idx;
  }
  inline bool operator>=(const Self& x) const {
    ((void)((Term == x.Term && "Cannot compare iterators of different blocks!") || (__assert_fail("Term == x.Term && \"Cannot compare iterators of different blocks!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CFG.h", 173, __func__),0)));
    return idx >= x.idx;
  }

  inline bool operator>(const Self& x) const {
    ((void)((Term == x.Term && "Cannot compare iterators of different blocks!") || (__assert_fail("Term == x.Term && \"Cannot compare iterators of different blocks!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CFG.h", 178, __func__),0)));
    return idx > x.idx;
  }

  inline Self& operator+=(int Right) {
    unsigned new_idx = idx + Right;
    ((void)((index_is_valid(new_idx) && "Iterator index out of bound") || (__assert_fail("index_is_valid(new_idx) && \"Iterator index out of bound\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CFG.h", 184, __func__),0)));
    idx = new_idx;
    return *this;
  }

  inline Self operator+(int Right) {
    Self tmp = *this;
    tmp += Right;
    return tmp;
  }

  inline Self& operator-=(int Right) {
    return operator+=(-Right);
  }

  inline Self operator-(int Right) {
    return operator+(-Right);
  }

  inline int operator-(const Self& x) {
    ((void)((Term == x.Term && "Cannot work on iterators of different blocks!") || (__assert_fail("Term == x.Term && \"Cannot work on iterators of different blocks!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CFG.h", 204, __func__),0)));
    int distance = idx - x.idx;
    return distance;
  }
# 220 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CFG.h"
  inline BB_ *getSource() {
    ((void)((Term && "Source not available, if basic block was malformed") || (__assert_fail("Term && \"Source not available, if basic block was malformed\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CFG.h", 221, __func__),0)));
    return Term->getParent();
  }
};

typedef SuccIterator<TerminatorInst*, BasicBlock> succ_iterator;
typedef SuccIterator<const TerminatorInst*,
                     const BasicBlock> succ_const_iterator;

inline succ_iterator succ_begin(BasicBlock *BB) {
  return succ_iterator(BB->getTerminator());
}
inline succ_const_iterator succ_begin(const BasicBlock *BB) {
  return succ_const_iterator(BB->getTerminator());
}
inline succ_iterator succ_end(BasicBlock *BB) {
  return succ_iterator(BB->getTerminator(), true);
}
inline succ_const_iterator succ_end(const BasicBlock *BB) {
  return succ_const_iterator(BB->getTerminator(), true);
}

template <typename T, typename U> struct isPodLike<SuccIterator<T, U> > {
  static const bool value = isPodLike<T>::value;
};
# 256 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CFG.h"
template <> struct GraphTraits<BasicBlock*> {
  typedef BasicBlock NodeType;
  typedef succ_iterator ChildIteratorType;

  static NodeType *getEntryNode(BasicBlock *BB) { return BB; }
  static inline ChildIteratorType child_begin(NodeType *N) {
    return succ_begin(N);
  }
  static inline ChildIteratorType child_end(NodeType *N) {
    return succ_end(N);
  }
};

template <> struct GraphTraits<const BasicBlock*> {
  typedef const BasicBlock NodeType;
  typedef succ_const_iterator ChildIteratorType;

  static NodeType *getEntryNode(const BasicBlock *BB) { return BB; }

  static inline ChildIteratorType child_begin(NodeType *N) {
    return succ_begin(N);
  }
  static inline ChildIteratorType child_end(NodeType *N) {
    return succ_end(N);
  }
};






template <> struct GraphTraits<Inverse<BasicBlock*> > {
  typedef BasicBlock NodeType;
  typedef pred_iterator ChildIteratorType;
  static NodeType *getEntryNode(Inverse<BasicBlock *> G) { return G.Graph; }
  static inline ChildIteratorType child_begin(NodeType *N) {
    return pred_begin(N);
  }
  static inline ChildIteratorType child_end(NodeType *N) {
    return pred_end(N);
  }
};

template <> struct GraphTraits<Inverse<const BasicBlock*> > {
  typedef const BasicBlock NodeType;
  typedef const_pred_iterator ChildIteratorType;
  static NodeType *getEntryNode(Inverse<const BasicBlock*> G) {
    return G.Graph;
  }
  static inline ChildIteratorType child_begin(NodeType *N) {
    return pred_begin(N);
  }
  static inline ChildIteratorType child_end(NodeType *N) {
    return pred_end(N);
  }
};
# 324 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/CFG.h"
template <> struct GraphTraits<Function*> : public GraphTraits<BasicBlock*> {
  static NodeType *getEntryNode(Function *F) { return &F->getEntryBlock(); }


  typedef Function::iterator nodes_iterator;
  static nodes_iterator nodes_begin(Function *F) { return F->begin(); }
  static nodes_iterator nodes_end (Function *F) { return F->end(); }
  static size_t size (Function *F) { return F->size(); }
};
template <> struct GraphTraits<const Function*> :
  public GraphTraits<const BasicBlock*> {
  static NodeType *getEntryNode(const Function *F) {return &F->getEntryBlock();}


  typedef Function::const_iterator nodes_iterator;
  static nodes_iterator nodes_begin(const Function *F) { return F->begin(); }
  static nodes_iterator nodes_end (const Function *F) { return F->end(); }
  static size_t size (const Function *F) { return F->size(); }
};







template <> struct GraphTraits<Inverse<Function*> > :
  public GraphTraits<Inverse<BasicBlock*> > {
  static NodeType *getEntryNode(Inverse<Function*> G) {
    return &G.Graph->getEntryBlock();
  }
};
template <> struct GraphTraits<Inverse<const Function*> > :
  public GraphTraits<Inverse<const BasicBlock*> > {
  static NodeType *getEntryNode(Inverse<const Function *> G) {
    return &G.Graph->getEntryBlock();
  }
};

}
# 20 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/CFG.h" 2

namespace llvm {

class BasicBlock;
class DominatorTree;
class Function;
class Instruction;
class LoopInfo;
class TerminatorInst;






void FindFunctionBackedges(
    const Function &F,
    SmallVectorImpl<std::pair<const BasicBlock *, const BasicBlock *> > &
        Result);




unsigned GetSuccessorNumber(BasicBlock *BB, BasicBlock *Succ);





bool isCriticalEdge(const TerminatorInst *TI, unsigned SuccNum,
                    bool AllowIdenticalEdges = false);
# 67 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/CFG.h"
bool isPotentiallyReachable(const Instruction *From, const Instruction *To,
                            const DominatorTree *DT = 0,
                            const LoopInfo *LI = 0);







bool isPotentiallyReachable(const BasicBlock *From, const BasicBlock *To,
                            const DominatorTree *DT = 0,
                            const LoopInfo *LI = 0);

}
# 30 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/lib/Analysis/AliasAnalysis.cpp" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/Dominators.h" 1
# 19 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/Dominators.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DepthFirstIterator.h" 1
# 38 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DepthFirstIterator.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallPtrSet.h" 1
# 21 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallPtrSet.h"
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 1 3
# 21 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/assert.h" 1 3
# 12 "/mnt/home/ec2-user/build/emscripten/system/include/libc/assert.h" 3
extern "C" {



__attribute__((__noreturn__))

void __assert_fail (const char *, const char *, int, const char *);


}
# 22 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 2 3
# 25 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 3
# 22 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallPtrSet.h" 2




namespace llvm {

class SmallPtrSetIteratorImpl;
# 48 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallPtrSet.h"
class SmallPtrSetImpl {
  friend class SmallPtrSetIteratorImpl;
protected:

  const void **SmallArray;


  const void **CurArray;

  unsigned CurArraySize;


  unsigned NumElements;
  unsigned NumTombstones;


  SmallPtrSetImpl(const void **SmallStorage, const SmallPtrSetImpl& that);
  explicit SmallPtrSetImpl(const void **SmallStorage, unsigned SmallSize) :
    SmallArray(SmallStorage), CurArray(SmallStorage), CurArraySize(SmallSize) {
    ((void)((SmallSize && (SmallSize & (SmallSize-1)) == 0 && "Initial size must be a power of two!") || (__assert_fail("SmallSize && (SmallSize & (SmallSize-1)) == 0 && \"Initial size must be a power of two!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallPtrSet.h", 68, __func__),0)));

    clear();
  }
  ~SmallPtrSetImpl();

public:
  bool __attribute__((__warn_unused_result__)) empty() const { return size() == 0; }
  unsigned size() const { return NumElements; }

  void clear() {


    if (!isSmall() && NumElements*4 < CurArraySize && CurArraySize > 32)
      return shrink_and_clear();


    memset(CurArray, -1, CurArraySize*sizeof(void*));
    NumElements = 0;
    NumTombstones = 0;
  }

protected:
  static void *getTombstoneMarker() { return reinterpret_cast<void*>(-2); }
  static void *getEmptyMarker() {


    return reinterpret_cast<void*>(-1);
  }




  bool insert_imp(const void * Ptr);





  bool erase_imp(const void * Ptr);

  bool count_imp(const void * Ptr) const {
    if (isSmall()) {

      for (const void *const *APtr = SmallArray,
                      *const *E = SmallArray+NumElements; APtr != E; ++APtr)
        if (*APtr == Ptr)
          return true;
      return false;
    }


    return *FindBucketFor(Ptr) == Ptr;
  }

private:
  bool isSmall() const { return CurArray == SmallArray; }

  const void * const *FindBucketFor(const void *Ptr) const;
  void shrink_and_clear();


  void Grow(unsigned NewSize);

  void operator=(const SmallPtrSetImpl &RHS) ;
protected:


  void swap(SmallPtrSetImpl &RHS);

  void CopyFrom(const SmallPtrSetImpl &RHS);
};



class SmallPtrSetIteratorImpl {
protected:
  const void *const *Bucket;
  const void *const *End;
public:
  explicit SmallPtrSetIteratorImpl(const void *const *BP, const void*const *E)
    : Bucket(BP), End(E) {
      AdvanceIfNotValid();
  }

  bool operator==(const SmallPtrSetIteratorImpl &RHS) const {
    return Bucket == RHS.Bucket;
  }
  bool operator!=(const SmallPtrSetIteratorImpl &RHS) const {
    return Bucket != RHS.Bucket;
  }

protected:



  void AdvanceIfNotValid() {
    ((void)((Bucket <= End) || (__assert_fail("Bucket <= End", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallPtrSet.h", 164, __func__),0)));
    while (Bucket != End &&
           (*Bucket == SmallPtrSetImpl::getEmptyMarker() ||
            *Bucket == SmallPtrSetImpl::getTombstoneMarker()))
      ++Bucket;
  }
};


template<typename PtrTy>
class SmallPtrSetIterator : public SmallPtrSetIteratorImpl {
  typedef PointerLikeTypeTraits<PtrTy> PtrTraits;

public:
  typedef PtrTy value_type;
  typedef PtrTy reference;
  typedef PtrTy pointer;
  typedef std::ptrdiff_t difference_type;
  typedef std::forward_iterator_tag iterator_category;

  explicit SmallPtrSetIterator(const void *const *BP, const void *const *E)
    : SmallPtrSetIteratorImpl(BP, E) {}



  const PtrTy operator*() const {
    ((void)((Bucket < End) || (__assert_fail("Bucket < End", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallPtrSet.h", 190, __func__),0)));
    return PtrTraits::getFromVoidPointer(const_cast<void*>(*Bucket));
  }

  inline SmallPtrSetIterator& operator++() {
    ++Bucket;
    AdvanceIfNotValid();
    return *this;
  }

  SmallPtrSetIterator operator++(int) {
    SmallPtrSetIterator tmp = *this; ++*this; return tmp;
  }
};



template<unsigned N>
struct RoundUpToPowerOfTwo;



template<unsigned N, bool isPowerTwo>
struct RoundUpToPowerOfTwoH {
  enum { Val = N };
};
template<unsigned N>
struct RoundUpToPowerOfTwoH<N, false> {
  enum {


    Val = RoundUpToPowerOfTwo<(N|(N-1)) + 1>::Val
  };
};

template<unsigned N>
struct RoundUpToPowerOfTwo {
  enum { Val = RoundUpToPowerOfTwoH<N, (N&(N-1)) == 0>::Val };
};






template<class PtrType, unsigned SmallSize>
class SmallPtrSet : public SmallPtrSetImpl {

  enum { SmallSizePowTwo = RoundUpToPowerOfTwo<SmallSize>::Val };

  const void *SmallStorage[SmallSizePowTwo];
  typedef PointerLikeTypeTraits<PtrType> PtrTraits;
public:
  SmallPtrSet() : SmallPtrSetImpl(SmallStorage, SmallSizePowTwo) {}
  SmallPtrSet(const SmallPtrSet &that) : SmallPtrSetImpl(SmallStorage, that) {}

  template<typename It>
  SmallPtrSet(It I, It E) : SmallPtrSetImpl(SmallStorage, SmallSizePowTwo) {
    insert(I, E);
  }



  bool insert(PtrType Ptr) {
    return insert_imp(PtrTraits::getAsVoidPointer(Ptr));
  }



  bool erase(PtrType Ptr) {
    return erase_imp(PtrTraits::getAsVoidPointer(Ptr));
  }


  bool count(PtrType Ptr) const {
    return count_imp(PtrTraits::getAsVoidPointer(Ptr));
  }

  template <typename IterT>
  void insert(IterT I, IterT E) {
    for (; I != E; ++I)
      insert(*I);
  }

  typedef SmallPtrSetIterator<PtrType> iterator;
  typedef SmallPtrSetIterator<PtrType> const_iterator;
  inline iterator begin() const {
    return iterator(CurArray, CurArray+CurArraySize);
  }
  inline iterator end() const {
    return iterator(CurArray+CurArraySize, CurArray+CurArraySize);
  }



  const SmallPtrSet<PtrType, SmallSize>&
  operator=(const SmallPtrSet<PtrType, SmallSize> &RHS) {
    CopyFrom(RHS);
    return *this;
  }


  void swap(SmallPtrSet<PtrType, SmallSize> &RHS) {
    SmallPtrSetImpl::swap(RHS);
  }
};

}

namespace std {

  template<class T, unsigned N>
  inline void swap(llvm::SmallPtrSet<T, N> &LHS, llvm::SmallPtrSet<T, N> &RHS) {
    LHS.swap(RHS);
  }
}
# 39 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DepthFirstIterator.h" 2
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/set" 1 3
# 392 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/set" 3


namespace std {inline namespace __1 {

template <class _Key, class _Compare = less<_Key>,
          class _Allocator = allocator<_Key> >
class __attribute__ ((__type_visibility__("default"))) set
{
public:

    typedef _Key key_type;
    typedef key_type value_type;
    typedef _Compare key_compare;
    typedef key_compare value_compare;
    typedef _Allocator allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;

private:
    typedef __tree<value_type, value_compare, allocator_type> __base;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __base::__node_holder __node_holder;

    __base __tree_;

public:
    typedef typename __base::pointer pointer;
    typedef typename __base::const_pointer const_pointer;
    typedef typename __base::size_type size_type;
    typedef typename __base::difference_type difference_type;
    typedef typename __base::const_iterator iterator;
    typedef typename __base::const_iterator const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    set()




        : __tree_(value_compare()) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit set(const value_compare& __comp)



        : __tree_(__comp) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit set(const value_compare& __comp, const allocator_type& __a)
        : __tree_(__comp, __a) {}
    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        set(_InputIterator __f, _InputIterator __l,
            const value_compare& __comp = value_compare())
        : __tree_(__comp)
        {
            insert(__f, __l);
        }

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        set(_InputIterator __f, _InputIterator __l, const value_compare& __comp,
            const allocator_type& __a)
        : __tree_(__comp, __a)
        {
            insert(__f, __l);
        }
# 470 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/set" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    set(const set& __s)
        : __tree_(__s.__tree_)
        {
            insert(__s.begin(), __s.end());
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    set& operator=(const set& __s)
        {
            __tree_ = __s.__tree_;
            return *this;
        }
# 491 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/set" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit set(const allocator_type& __a)
        : __tree_(__a) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    set(const set& __s, const allocator_type& __a)
        : __tree_(__s.__tree_.value_comp(), __a)
        {
            insert(__s.begin(), __s.end());
        }
# 546 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/set" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
          iterator begin() throw() {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator begin() const throw() {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
          iterator end() throw() {return __tree_.end();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator end() const throw() {return __tree_.end();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
          reverse_iterator rbegin() throw()
            {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator rbegin() const throw()
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
          reverse_iterator rend() throw()
            {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator rend() const throw()
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator cbegin() const throw() {return begin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator cend() const throw() {return end();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator crbegin() const throw() {return rbegin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator crend() const throw() {return rend();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool empty() const throw() {return __tree_.size() == 0;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type size() const throw() {return __tree_.size();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type max_size() const throw() {return __tree_.max_size();}
# 595 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/set" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair<iterator,bool> insert(const value_type& __v)
        {return __tree_.__insert_unique(__v);}





    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator insert(const_iterator __p, const value_type& __v)
        {return __tree_.__insert_unique(__p, __v);}





    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void insert(_InputIterator __f, _InputIterator __l)
        {
            for (const_iterator __e = cend(); __f != __l; ++__f)
                __tree_.__insert_unique(__e, *__f);
        }







    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator erase(const_iterator __p) {return __tree_.erase(__p);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type erase(const key_type& __k)
        {return __tree_.__erase_unique(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator erase(const_iterator __f, const_iterator __l)
        {return __tree_.erase(__f, __l);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void clear() throw() {__tree_.clear();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(set& __s)
        {__tree_.swap(__s.__tree_);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    allocator_type get_allocator() const throw() {return __tree_.__alloc();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    key_compare key_comp() const {return __tree_.value_comp();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    value_compare value_comp() const {return __tree_.value_comp();}


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator find(const key_type& __k) {return __tree_.find(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}
# 663 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/set" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type count(const key_type& __k) const
        {return __tree_.__count_unique(__k);}






    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator lower_bound(const key_type& __k)
        {return __tree_.lower_bound(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator lower_bound(const key_type& __k) const
        {return __tree_.lower_bound(__k);}
# 690 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/set" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator upper_bound(const key_type& __k)
        {return __tree_.upper_bound(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator upper_bound(const key_type& __k) const
        {return __tree_.upper_bound(__k);}
# 707 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/set" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair<iterator,iterator> equal_range(const key_type& __k)
        {return __tree_.__equal_range_unique(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const
        {return __tree_.__equal_range_unique(__k);}
# 723 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/set" 3
};
# 741 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/set" 3
template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return __x.size() == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return !(__y < __x);
}


template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(set<_Key, _Compare, _Allocator>& __x,
     set<_Key, _Compare, _Allocator>& __y)

{
    __x.swap(__y);
}

template <class _Key, class _Compare = less<_Key>,
          class _Allocator = allocator<_Key> >
class __attribute__ ((__type_visibility__("default"))) multiset
{
public:

    typedef _Key key_type;
    typedef key_type value_type;
    typedef _Compare key_compare;
    typedef key_compare value_compare;
    typedef _Allocator allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;

private:
    typedef __tree<value_type, value_compare, allocator_type> __base;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __base::__node_holder __node_holder;

    __base __tree_;

public:
    typedef typename __base::pointer pointer;
    typedef typename __base::const_pointer const_pointer;
    typedef typename __base::size_type size_type;
    typedef typename __base::difference_type difference_type;
    typedef typename __base::const_iterator iterator;
    typedef typename __base::const_iterator const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    multiset()




        : __tree_(value_compare()) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit multiset(const value_compare& __comp)



        : __tree_(__comp) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit multiset(const value_compare& __comp, const allocator_type& __a)
        : __tree_(__comp, __a) {}
    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        multiset(_InputIterator __f, _InputIterator __l,
                 const value_compare& __comp = value_compare())
        : __tree_(__comp)
        {
            insert(__f, __l);
        }
# 872 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/set" 3
    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        multiset(_InputIterator __f, _InputIterator __l,
                 const value_compare& __comp, const allocator_type& __a)
        : __tree_(__comp, __a)
        {
            insert(__f, __l);
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    multiset(const multiset& __s)
        : __tree_(__s.__tree_.value_comp(),
          __alloc_traits::select_on_container_copy_construction(__s.__tree_.__alloc()))
        {
            insert(__s.begin(), __s.end());
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    multiset& operator=(const multiset& __s)
        {
            __tree_ = __s.__tree_;
            return *this;
        }







    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit multiset(const allocator_type& __a)
        : __tree_(__a) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    multiset(const multiset& __s, const allocator_type& __a)
        : __tree_(__s.__tree_.value_comp(), __a)
        {
            insert(__s.begin(), __s.end());
        }
# 955 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/set" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
          iterator begin() throw() {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator begin() const throw() {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
          iterator end() throw() {return __tree_.end();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator end() const throw() {return __tree_.end();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
          reverse_iterator rbegin() throw()
            {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator rbegin() const throw()
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
          reverse_iterator rend() throw()
            {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator rend() const throw()
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator cbegin() const throw() {return begin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator cend() const throw() {return end();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator crbegin() const throw() {return rbegin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator crend() const throw() {return rend();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool empty() const throw() {return __tree_.size() == 0;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type size() const throw() {return __tree_.size();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type max_size() const throw() {return __tree_.max_size();}
# 1004 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/set" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator insert(const value_type& __v)
        {return __tree_.__insert_multi(__v);}





    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator insert(const_iterator __p, const value_type& __v)
        {return __tree_.__insert_multi(__p, __v);}





    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void insert(_InputIterator __f, _InputIterator __l)
        {
            for (const_iterator __e = cend(); __f != __l; ++__f)
                __tree_.__insert_multi(__e, *__f);
        }







    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator erase(const_iterator __p) {return __tree_.erase(__p);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator erase(const_iterator __f, const_iterator __l)
        {return __tree_.erase(__f, __l);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void clear() throw() {__tree_.clear();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(multiset& __s)

        {__tree_.swap(__s.__tree_);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    allocator_type get_allocator() const throw() {return __tree_.__alloc();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    key_compare key_comp() const {return __tree_.value_comp();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    value_compare value_comp() const {return __tree_.value_comp();}


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator find(const key_type& __k) {return __tree_.find(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}
# 1072 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/set" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type count(const key_type& __k) const
        {return __tree_.__count_multi(__k);}







    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator lower_bound(const key_type& __k)
        {return __tree_.lower_bound(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator lower_bound(const key_type& __k) const
            {return __tree_.lower_bound(__k);}
# 1100 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/set" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator upper_bound(const key_type& __k)
            {return __tree_.upper_bound(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator upper_bound(const key_type& __k) const
            {return __tree_.upper_bound(__k);}
# 1117 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/set" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair<iterator,iterator> equal_range(const key_type& __k)
            {return __tree_.__equal_range_multi(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const
            {return __tree_.__equal_range_multi(__k);}
# 1133 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/set" 3
};
# 1151 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/set" 3
template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return __x.size() == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(multiset<_Key, _Compare, _Allocator>& __x,
     multiset<_Key, _Compare, _Allocator>& __y)

{
    __x.swap(__y);
}

} }
# 40 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/DepthFirstIterator.h" 2


namespace llvm {



template<class SetType, bool External>
class df_iterator_storage {
public:
  SetType Visited;
};

template<class SetType>
class df_iterator_storage<SetType, true> {
public:
  df_iterator_storage(SetType &VSet) : Visited(VSet) {}
  df_iterator_storage(const df_iterator_storage &S) : Visited(S.Visited) {}
  SetType &Visited;
};



template<class GraphT,
class SetType = llvm::SmallPtrSet<typename GraphTraits<GraphT>::NodeType*, 8>,
         bool ExtStorage = false, class GT = GraphTraits<GraphT> >
class df_iterator : public std::iterator<std::forward_iterator_tag,
                                         typename GT::NodeType, ptrdiff_t>,
                    public df_iterator_storage<SetType, ExtStorage> {
  typedef std::iterator<std::forward_iterator_tag,
                        typename GT::NodeType, ptrdiff_t> super;

  typedef typename GT::NodeType NodeType;
  typedef typename GT::ChildIteratorType ChildItTy;
  typedef PointerIntPair<NodeType*, 1> PointerIntTy;




  std::vector<std::pair<PointerIntTy, ChildItTy> > VisitStack;
private:
  inline df_iterator(NodeType *Node) {
    this->Visited.insert(Node);
    VisitStack.push_back(std::make_pair(PointerIntTy(Node, 0),
                                        GT::child_begin(Node)));
  }
  inline df_iterator() {

  }
  inline df_iterator(NodeType *Node, SetType &S)
    : df_iterator_storage<SetType, ExtStorage>(S) {
    if (!S.count(Node)) {
      VisitStack.push_back(std::make_pair(PointerIntTy(Node, 0),
                                          GT::child_begin(Node)));
      this->Visited.insert(Node);
    }
  }
  inline df_iterator(SetType &S)
    : df_iterator_storage<SetType, ExtStorage>(S) {

  }

  inline void toNext() {
    do {
      std::pair<PointerIntTy, ChildItTy> &Top = VisitStack.back();
      NodeType *Node = Top.first.getPointer();
      ChildItTy &It = Top.second;
      if (!Top.first.getInt()) {

        It = GT::child_begin(Node);
        Top.first.setInt(1);
      }

      while (It != GT::child_end(Node)) {
        NodeType *Next = *It++;

        if (Next && !this->Visited.count(Next)) {

          this->Visited.insert(Next);
          VisitStack.push_back(std::make_pair(PointerIntTy(Next, 0),
                                              GT::child_begin(Next)));
          return;
        }
      }


      VisitStack.pop_back();
    } while (!VisitStack.empty());
  }

public:
  typedef typename super::pointer pointer;
  typedef df_iterator<GraphT, SetType, ExtStorage, GT> _Self;


  static inline _Self begin(const GraphT& G) {
    return _Self(GT::getEntryNode(G));
  }
  static inline _Self end(const GraphT& G) { return _Self(); }


  static inline _Self begin(const GraphT& G, SetType &S) {
    return _Self(GT::getEntryNode(G), S);
  }
  static inline _Self end(const GraphT& G, SetType &S) { return _Self(S); }

  inline bool operator==(const _Self& x) const {
    return VisitStack == x.VisitStack;
  }
  inline bool operator!=(const _Self& x) const { return !operator==(x); }

  inline pointer operator*() const {
    return VisitStack.back().first.getPointer();
  }





  inline NodeType *operator->() const { return operator*(); }

  inline _Self& operator++() {
    toNext();
    return *this;
  }



  inline _Self& skipChildren() {
    VisitStack.pop_back();
    if (!VisitStack.empty())
      toNext();
    return *this;
  }

  inline _Self operator++(int) {
    _Self tmp = *this; ++*this; return tmp;
  }





  inline bool nodeVisited(NodeType *Node) const {
    return this->Visited.count(Node) != 0;
  }



  unsigned getPathLength() const { return VisitStack.size(); }



  NodeType *getPath(unsigned n) const {
    return VisitStack[n].first.getPointer();
  }
};




template <class T>
df_iterator<T> df_begin(const T& G) {
  return df_iterator<T>::begin(G);
}

template <class T>
df_iterator<T> df_end(const T& G) {
  return df_iterator<T>::end(G);
}


template <class T, class SetTy = std::set<typename GraphTraits<T>::NodeType*> >
struct df_ext_iterator : public df_iterator<T, SetTy, true> {
  df_ext_iterator(const df_iterator<T, SetTy, true> &V)
    : df_iterator<T, SetTy, true>(V) {}
};

template <class T, class SetTy>
df_ext_iterator<T, SetTy> df_ext_begin(const T& G, SetTy &S) {
  return df_ext_iterator<T, SetTy>::begin(G, S);
}

template <class T, class SetTy>
df_ext_iterator<T, SetTy> df_ext_end(const T& G, SetTy &S) {
  return df_ext_iterator<T, SetTy>::end(G, S);
}



template <class T,
  class SetTy = llvm::SmallPtrSet<typename GraphTraits<T>::NodeType*, 8>,
          bool External = false>
struct idf_iterator : public df_iterator<Inverse<T>, SetTy, External> {
  idf_iterator(const df_iterator<Inverse<T>, SetTy, External> &V)
    : df_iterator<Inverse<T>, SetTy, External>(V) {}
};

template <class T>
idf_iterator<T> idf_begin(const T& G) {
  return idf_iterator<T>::begin(Inverse<T>(G));
}

template <class T>
idf_iterator<T> idf_end(const T& G){
  return idf_iterator<T>::end(Inverse<T>(G));
}


template <class T, class SetTy = std::set<typename GraphTraits<T>::NodeType*> >
struct idf_ext_iterator : public idf_iterator<T, SetTy, true> {
  idf_ext_iterator(const idf_iterator<T, SetTy, true> &V)
    : idf_iterator<T, SetTy, true>(V) {}
  idf_ext_iterator(const df_iterator<Inverse<T>, SetTy, true> &V)
    : idf_iterator<T, SetTy, true>(V) {}
};

template <class T, class SetTy>
idf_ext_iterator<T, SetTy> idf_ext_begin(const T& G, SetTy &S) {
  return idf_ext_iterator<T, SetTy>::begin(Inverse<T>(G), S);
}

template <class T, class SetTy>
idf_ext_iterator<T, SetTy> idf_ext_end(const T& G, SetTy &S) {
  return idf_ext_iterator<T, SetTy>::end(Inverse<T>(G), S);
}

}
# 20 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/Dominators.h" 2




# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Pass.h" 1
# 35 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Pass.h"
namespace llvm {

class BasicBlock;
class Function;
class Module;
class AnalysisUsage;
class PassInfo;
class ImmutablePass;
class PMStack;
class AnalysisResolver;
class PMDataManager;
class raw_ostream;
class StringRef;


typedef const void* AnalysisID;




enum PassManagerType {
  PMT_Unknown = 0,
  PMT_ModulePassManager = 1,
  PMT_CallGraphPassManager,
  PMT_FunctionPassManager,
  PMT_LoopPassManager,
  PMT_RegionPassManager,
  PMT_BasicBlockPassManager,
  PMT_Last
};


enum PassKind {
  PT_BasicBlock,
  PT_Region,
  PT_Loop,
  PT_Function,
  PT_CallGraphSCC,
  PT_Module,
  PT_PassManager
};






class Pass {
  AnalysisResolver *Resolver;
  const void *PassID;
  PassKind Kind;
  void operator=(const Pass&) ;
  Pass(const Pass &) ;

public:
  explicit Pass(PassKind K, char &pid) : Resolver(0), PassID(&pid), Kind(K) { }
  virtual ~Pass();


  PassKind getPassKind() const { return Kind; }





  virtual const char *getPassName() const;


  AnalysisID getPassID() const {
    return PassID;
  }




  virtual bool doInitialization(Module &) { return false; }




  virtual bool doFinalization(Module &) { return false; }
# 124 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Pass.h"
  virtual void print(raw_ostream &O, const Module *M) const;
  void dump() const;



  virtual Pass *createPrinterPass(raw_ostream &O,
                                  const std::string &Banner) const = 0;



  virtual void assignPassManager(PMStack &,
                                 PassManagerType) {}

  virtual void preparePassManager(PMStack &);


  virtual PassManagerType getPotentialPassManagerType() const;


  void setResolver(AnalysisResolver *AR);
  AnalysisResolver *getResolver() const { return Resolver; }






  virtual void getAnalysisUsage(AnalysisUsage &) const;
# 164 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Pass.h"
  virtual void releaseMemory();





  virtual void *getAdjustedAnalysisPointer(AnalysisID ID);
  virtual ImmutablePass *getAsImmutablePass();
  virtual PMDataManager *getAsPMDataManager();



  virtual void verifyAnalysis() const;


  virtual void dumpPassStructure(unsigned Offset = 0);



  static const PassInfo *lookupPassInfo(const void *TI);



  static const PassInfo *lookupPassInfo(StringRef Arg);



  static Pass *createPass(AnalysisID ID);
# 201 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Pass.h"
  template<typename AnalysisType> AnalysisType *
    getAnalysisIfAvailable() const;







  bool mustPreserveAnalysisID(char &AID) const;





  template<typename AnalysisType>
  AnalysisType &getAnalysis() const;

  template<typename AnalysisType>
  AnalysisType &getAnalysis(Function &F);

  template<typename AnalysisType>
  AnalysisType &getAnalysisID(AnalysisID PI) const;

  template<typename AnalysisType>
  AnalysisType &getAnalysisID(AnalysisID PI, Function &F);
};







class ModulePass : public Pass {
public:

  Pass *createPrinterPass(raw_ostream &O, const std::string &Banner) const;



  virtual bool runOnModule(Module &M) = 0;

  virtual void assignPassManager(PMStack &PMS,
                                 PassManagerType T);


  virtual PassManagerType getPotentialPassManagerType() const;

  explicit ModulePass(char &pid) : Pass(PT_Module, pid) {}

  virtual ~ModulePass();
};







class ImmutablePass : public ModulePass {
public:






  virtual void initializePass();

  virtual ImmutablePass *getAsImmutablePass() { return this; }



  bool runOnModule(Module &) { return false; }

  explicit ImmutablePass(char &pid)
  : ModulePass(pid) {}


  virtual ~ImmutablePass();
};
# 293 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Pass.h"
class FunctionPass : public Pass {
public:
  explicit FunctionPass(char &pid) : Pass(PT_Function, pid) {}


  Pass *createPrinterPass(raw_ostream &O, const std::string &Banner) const;




  virtual bool runOnFunction(Function &F) = 0;

  virtual void assignPassManager(PMStack &PMS,
                                 PassManagerType T);


  virtual PassManagerType getPotentialPassManagerType() const;
};
# 324 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Pass.h"
class BasicBlockPass : public Pass {
public:
  explicit BasicBlockPass(char &pid) : Pass(PT_BasicBlock, pid) {}


  Pass *createPrinterPass(raw_ostream &O, const std::string &Banner) const;

  using llvm::Pass::doInitialization;
  using llvm::Pass::doFinalization;




  virtual bool doInitialization(Function &);




  virtual bool runOnBasicBlock(BasicBlock &BB) = 0;




  virtual bool doFinalization(Function &);

  virtual void assignPassManager(PMStack &PMS,
                                 PassManagerType T);


  virtual PassManagerType getPotentialPassManagerType() const;
};




extern bool TimePassesIsEnabled;

}





# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassSupport.h" 1
# 24 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassSupport.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Pass.h" 1
# 25 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassSupport.h" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/InitializePasses.h" 1
# 18 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/InitializePasses.h"
namespace llvm {

class PassRegistry;



void initializeCore(PassRegistry&);



void initializeTransformUtils(PassRegistry&);



void initializeScalarOpts(PassRegistry&);



void initializeObjCARCOpts(PassRegistry&);



void initializeVectorization(PassRegistry&);



void initializeInstCombine(PassRegistry&);


void initializeIPO(PassRegistry&);



void initializeInstrumentation(PassRegistry&);


void initializeAnalysis(PassRegistry&);


void initializeIPA(PassRegistry&);


void initializeCodeGen(PassRegistry&);


void initializeTarget(PassRegistry&);

void initializeAAEvalPass(PassRegistry&);
void initializeADCEPass(PassRegistry&);
void initializeAliasAnalysisAnalysisGroup(PassRegistry&);
void initializeAliasAnalysisCounterPass(PassRegistry&);
void initializeAliasDebuggerPass(PassRegistry&);
void initializeAliasSetPrinterPass(PassRegistry&);
void initializeAlwaysInlinerPass(PassRegistry&);
void initializeArgPromotionPass(PassRegistry&);
void initializeSampleProfileLoaderPass(PassRegistry&);
void initializeBarrierNoopPass(PassRegistry&);
void initializeBasicAliasAnalysisPass(PassRegistry&);
void initializeCallGraphPass(PassRegistry&);
void initializeBasicTTIPass(PassRegistry&);
void initializeBlockExtractorPassPass(PassRegistry&);
void initializeBlockFrequencyInfoPass(PassRegistry&);
void initializeBoundsCheckingPass(PassRegistry&);
void initializeBranchFolderPassPass(PassRegistry&);
void initializeBranchProbabilityInfoPass(PassRegistry&);
void initializeBreakCriticalEdgesPass(PassRegistry&);
void initializeCallGraphPrinterPass(PassRegistry&);
void initializeCallGraphViewerPass(PassRegistry&);
void initializeCFGOnlyPrinterPass(PassRegistry&);
void initializeCFGOnlyViewerPass(PassRegistry&);
void initializeCFGPrinterPass(PassRegistry&);
void initializeCFGSimplifyPassPass(PassRegistry&);
void initializeFlattenCFGPassPass(PassRegistry&);
void initializeStructurizeCFGPass(PassRegistry&);
void initializeCFGViewerPass(PassRegistry&);
void initializeCodeGenPreparePass(PassRegistry&);
void initializeConstantMergePass(PassRegistry&);
void initializeConstantPropagationPass(PassRegistry&);
void initializeMachineCopyPropagationPass(PassRegistry&);
void initializeCostModelAnalysisPass(PassRegistry&);
void initializeCorrelatedValuePropagationPass(PassRegistry&);
void initializeDAEPass(PassRegistry&);
void initializeDAHPass(PassRegistry&);
void initializeDCEPass(PassRegistry&);
void initializeDSEPass(PassRegistry&);
void initializeDebugIRPass(PassRegistry&);
void initializeDeadInstEliminationPass(PassRegistry&);
void initializeDeadMachineInstructionElimPass(PassRegistry&);
void initializeDelinearizationPass(PassRegistry &);
void initializeDependenceAnalysisPass(PassRegistry&);
void initializeDomOnlyPrinterPass(PassRegistry&);
void initializeDomOnlyViewerPass(PassRegistry&);
void initializeDomPrinterPass(PassRegistry&);
void initializeDomViewerPass(PassRegistry&);
void initializeDominanceFrontierPass(PassRegistry&);
void initializeDominatorTreePass(PassRegistry&);
void initializeEarlyIfConverterPass(PassRegistry&);
void initializeEdgeBundlesPass(PassRegistry&);
void initializeExpandPostRAPass(PassRegistry&);
void initializeGCOVProfilerPass(PassRegistry&);
void initializeAddressSanitizerPass(PassRegistry&);
void initializeAddressSanitizerModulePass(PassRegistry&);
void initializeMemorySanitizerPass(PassRegistry&);
void initializeThreadSanitizerPass(PassRegistry&);
void initializeDataFlowSanitizerPass(PassRegistry&);
void initializeEarlyCSEPass(PassRegistry&);
void initializeExpandISelPseudosPass(PassRegistry&);
void initializeFindUsedTypesPass(PassRegistry&);
void initializeFunctionAttrsPass(PassRegistry&);
void initializeGCMachineCodeAnalysisPass(PassRegistry&);
void initializeGCModuleInfoPass(PassRegistry&);
void initializeGVNPass(PassRegistry&);
void initializeGlobalDCEPass(PassRegistry&);
void initializeGlobalOptPass(PassRegistry&);
void initializeGlobalsModRefPass(PassRegistry&);
void initializeIPCPPass(PassRegistry&);
void initializeIPSCCPPass(PassRegistry&);
void initializeIVUsersPass(PassRegistry&);
void initializeIfConverterPass(PassRegistry&);
void initializeIndVarSimplifyPass(PassRegistry&);
void initializeInlineCostAnalysisPass(PassRegistry&);
void initializeInstCombinerPass(PassRegistry&);
void initializeInstCountPass(PassRegistry&);
void initializeInstNamerPass(PassRegistry&);
void initializeInternalizePassPass(PassRegistry&);
void initializeIntervalPartitionPass(PassRegistry&);
void initializeJumpThreadingPass(PassRegistry&);
void initializeLCSSAPass(PassRegistry&);
void initializeLICMPass(PassRegistry&);
void initializeLazyValueInfoPass(PassRegistry&);
void initializeLibCallAliasAnalysisPass(PassRegistry&);
void initializeLintPass(PassRegistry&);
void initializeLiveDebugVariablesPass(PassRegistry&);
void initializeLiveIntervalsPass(PassRegistry&);
void initializeLiveRegMatrixPass(PassRegistry&);
void initializeLiveStacksPass(PassRegistry&);
void initializeLiveVariablesPass(PassRegistry&);
void initializeLoaderPassPass(PassRegistry&);
void initializeLocalStackSlotPassPass(PassRegistry&);
void initializeLoopDeletionPass(PassRegistry&);
void initializeLoopExtractorPass(PassRegistry&);
void initializeLoopInfoPass(PassRegistry&);
void initializeLoopInstSimplifyPass(PassRegistry&);
void initializeLoopRotatePass(PassRegistry&);
void initializeLoopSimplifyPass(PassRegistry&);
void initializeLoopStrengthReducePass(PassRegistry&);
void initializeGlobalMergePass(PassRegistry&);
void initializeLoopRerollPass(PassRegistry&);
void initializeLoopUnrollPass(PassRegistry&);
void initializeLoopUnswitchPass(PassRegistry&);
void initializeLoopIdiomRecognizePass(PassRegistry&);
void initializeLowerAtomicPass(PassRegistry&);
void initializeLowerExpectIntrinsicPass(PassRegistry&);
void initializeLowerIntrinsicsPass(PassRegistry&);
void initializeLowerInvokePass(PassRegistry&);
void initializeLowerSwitchPass(PassRegistry&);
void initializeMachineBlockFrequencyInfoPass(PassRegistry&);
void initializeMachineBlockPlacementPass(PassRegistry&);
void initializeMachineBlockPlacementStatsPass(PassRegistry&);
void initializeMachineBranchProbabilityInfoPass(PassRegistry&);
void initializeMachineCSEPass(PassRegistry&);
void initializeMachineDominatorTreePass(PassRegistry&);
void initializeMachinePostDominatorTreePass(PassRegistry&);
void initializeMachineLICMPass(PassRegistry&);
void initializeMachineLoopInfoPass(PassRegistry&);
void initializeMachineModuleInfoPass(PassRegistry&);
void initializeMachineSchedulerPass(PassRegistry&);
void initializeMachineSinkingPass(PassRegistry&);
void initializeMachineTraceMetricsPass(PassRegistry&);
void initializeMachineVerifierPassPass(PassRegistry&);
void initializeMemCpyOptPass(PassRegistry&);
void initializeMemDepPrinterPass(PassRegistry&);
void initializeMemoryDependenceAnalysisPass(PassRegistry&);
void initializeMetaRenamerPass(PassRegistry&);
void initializeMergeFunctionsPass(PassRegistry&);
void initializeModuleDebugInfoPrinterPass(PassRegistry&);
void initializeNoAAPass(PassRegistry&);
void initializeObjCARCAliasAnalysisPass(PassRegistry&);
void initializeObjCARCAPElimPass(PassRegistry&);
void initializeObjCARCExpandPass(PassRegistry&);
void initializeObjCARCContractPass(PassRegistry&);
void initializeObjCARCOptPass(PassRegistry&);
void initializeOptimizePHIsPass(PassRegistry&);
void initializePartiallyInlineLibCallsPass(PassRegistry&);
void initializePEIPass(PassRegistry&);
void initializePHIEliminationPass(PassRegistry&);
void initializePartialInlinerPass(PassRegistry&);
void initializePeepholeOptimizerPass(PassRegistry&);
void initializePostDomOnlyPrinterPass(PassRegistry&);
void initializePostDomOnlyViewerPass(PassRegistry&);
void initializePostDomPrinterPass(PassRegistry&);
void initializePostDomViewerPass(PassRegistry&);
void initializePostDominatorTreePass(PassRegistry&);
void initializePostRASchedulerPass(PassRegistry&);
void initializePreVerifierPass(PassRegistry&);
void initializePrintFunctionPassPass(PassRegistry&);
void initializePrintModulePassPass(PassRegistry&);
void initializePrintBasicBlockPassPass(PassRegistry&);
void initializeProcessImplicitDefsPass(PassRegistry&);
void initializePromotePassPass(PassRegistry&);
void initializePruneEHPass(PassRegistry&);
void initializeReassociatePass(PassRegistry&);
void initializeRegToMemPass(PassRegistry&);
void initializeRegionInfoPass(PassRegistry&);
void initializeRegionOnlyPrinterPass(PassRegistry&);
void initializeRegionOnlyViewerPass(PassRegistry&);
void initializeRegionPrinterPass(PassRegistry&);
void initializeRegionViewerPass(PassRegistry&);
void initializeSCCPPass(PassRegistry&);
void initializeSROAPass(PassRegistry&);
void initializeSROA_DTPass(PassRegistry&);
void initializeSROA_SSAUpPass(PassRegistry&);
void initializeScalarEvolutionAliasAnalysisPass(PassRegistry&);
void initializeScalarEvolutionPass(PassRegistry&);
void initializeSimpleInlinerPass(PassRegistry&);
void initializeRegisterCoalescerPass(PassRegistry&);
void initializeSingleLoopExtractorPass(PassRegistry&);
void initializeSinkingPass(PassRegistry&);
void initializeSlotIndexesPass(PassRegistry&);
void initializeSpillPlacementPass(PassRegistry&);
void initializeStackProtectorPass(PassRegistry&);
void initializeStackColoringPass(PassRegistry&);
void initializeStackSlotColoringPass(PassRegistry&);
void initializeStripDeadDebugInfoPass(PassRegistry&);
void initializeStripDeadPrototypesPassPass(PassRegistry&);
void initializeStripDebugDeclarePass(PassRegistry&);
void initializeStripNonDebugSymbolsPass(PassRegistry&);
void initializeStripSymbolsPass(PassRegistry&);
void initializeTailCallElimPass(PassRegistry&);
void initializeTailDuplicatePassPass(PassRegistry&);
void initializeTargetPassConfigPass(PassRegistry&);
void initializeDataLayoutPass(PassRegistry&);
void initializeTargetTransformInfoAnalysisGroup(PassRegistry&);
void initializeNoTTIPass(PassRegistry&);
void initializeTargetLibraryInfoPass(PassRegistry&);
void initializeTwoAddressInstructionPassPass(PassRegistry&);
void initializeTypeBasedAliasAnalysisPass(PassRegistry&);
void initializeUnifyFunctionExitNodesPass(PassRegistry&);
void initializeUnreachableBlockElimPass(PassRegistry&);
void initializeUnreachableMachineBlockElimPass(PassRegistry&);
void initializeVerifierPass(PassRegistry&);
void initializeVirtRegMapPass(PassRegistry&);
void initializeVirtRegRewriterPass(PassRegistry&);
void initializeInstSimplifierPass(PassRegistry&);
void initializeUnpackMachineBundlesPass(PassRegistry&);
void initializeFinalizeMachineBundlesPass(PassRegistry&);
void initializeLoopVectorizePass(PassRegistry&);
void initializeSLPVectorizerPass(PassRegistry&);
void initializeBBVectorizePass(PassRegistry&);
void initializeMachineFunctionPrinterPassPass(PassRegistry&);

void initializeAddPNaClExternalDeclsPass(PassRegistry&);
void initializeCanonicalizeMemIntrinsicsPass(PassRegistry&);
void initializeExpandArithWithOverflowPass(PassRegistry&);
void initializeExpandByValPass(PassRegistry&);
void initializeExpandConstantExprPass(PassRegistry&);
void initializeExpandCtorsPass(PassRegistry&);
void initializeExpandGetElementPtrPass(PassRegistry&);
void initializeExpandIndirectBrPass(PassRegistry&);
void initializeExpandSmallArgumentsPass(PassRegistry&);
void initializeExpandStructRegsPass(PassRegistry&);
void initializeExpandTlsConstantExprPass(PassRegistry&);
void initializeExpandTlsPass(PassRegistry&);
void initializeExpandVarArgsPass(PassRegistry&);
void initializeFlattenGlobalsPass(PassRegistry&);
void initializeGlobalCleanupPass(PassRegistry&);
void initializeInsertDivideCheckPass(PassRegistry&);
void initializeNaClCcRewritePass(PassRegistry&);
void initializePNaClABIVerifyFunctionsPass(PassRegistry&);
void initializePNaClABIVerifyModulePass(PassRegistry&);
void initializePNaClSjLjEHPass(PassRegistry&);
void initializePromoteI1OpsPass(PassRegistry&);
void initializePromoteIntegersPass(PassRegistry&);
void initializeRemoveAsmMemoryPass(PassRegistry&);
void initializeReplacePtrsWithIntsPass(PassRegistry&);
void initializeResolveAliasesPass(PassRegistry&);
void initializeResolvePNaClIntrinsicsPass(PassRegistry&);
void initializeRewriteAtomicsPass(PassRegistry&);
void initializeRewriteLLVMIntrinsicsPass(PassRegistry&);
void initializeRewritePNaClLibraryCallsPass(PassRegistry&);
void initializeStripAttributesPass(PassRegistry&);
void initializeStripMetadataPass(PassRegistry&);
void initializeExpandI64Pass(PassRegistry&);
void initializeExpandInsertExtractElementPass(PassRegistry&);
void initializeLowerEmExceptionsPass(PassRegistry&);
void initializeLowerEmSetjmpPass(PassRegistry&);
void initializeLowerEmAsyncifyPass(PassRegistry&);
void initializeNoExitRuntimePass(PassRegistry&);

}
# 26 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassSupport.h" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassRegistry.h" 1
# 24 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassRegistry.h"
namespace llvm {

class PassInfo;
struct PassRegistrationListener;







class PassRegistry {
  mutable void *pImpl;
  void *getImpl() const;

public:
  PassRegistry() : pImpl(0) { }
  ~PassRegistry();




  static PassRegistry *getPassRegistry();



  const PassInfo *getPassInfo(const void *TI) const;



  const PassInfo *getPassInfo(StringRef Arg) const;



  void registerPass(const PassInfo &PI, bool ShouldFree = false);



  void unregisterPass(const PassInfo &PI);




  void registerAnalysisGroup(const void *InterfaceID, const void *PassID,
                             PassInfo& Registeree, bool isDefault,
                             bool ShouldFree = false);



  void enumerateWith(PassRegistrationListener *L);



  void addRegistrationListener(PassRegistrationListener *L);



  void removeRegistrationListener(PassRegistrationListener *L);
};


inline PassRegistry *unwrap(LLVMPassRegistryRef P) { return reinterpret_cast<PassRegistry*>(P); } inline LLVMPassRegistryRef wrap(const PassRegistry *P) { return reinterpret_cast<LLVMPassRegistryRef>(const_cast<PassRegistry*>(P)); } template<typename T> inline T *unwrap(LLVMPassRegistryRef P) { T *Q = (T*)unwrap(P); ((void)((Q && "Invalid cast!") || (__assert_fail("Q && \"Invalid cast!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassRegistry.h", 85, __func__),0))); return Q; }

}
# 27 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassSupport.h" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/Atomic.h" 1
# 19 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/Atomic.h"
namespace llvm {
  namespace sys {
    void MemoryFence();




    typedef uint32_t cas_flag;

    cas_flag CompareAndSwap(volatile cas_flag* ptr,
                            cas_flag new_value,
                            cas_flag old_value);
    cas_flag AtomicIncrement(volatile cas_flag* ptr);
    cas_flag AtomicDecrement(volatile cas_flag* ptr);
    cas_flag AtomicAdd(volatile cas_flag* ptr, cas_flag val);
    cas_flag AtomicMul(volatile cas_flag* ptr, cas_flag val);
    cas_flag AtomicDiv(volatile cas_flag* ptr, cas_flag val);
  }
}
# 28 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassSupport.h" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/Valgrind.h" 1
# 19 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/Valgrind.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/build/include/llvm/Config/llvm-config.h" 1
# 20 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/Valgrind.h" 2
# 36 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/Valgrind.h"
namespace llvm {
namespace sys {

  bool RunningOnValgrind();



  void ValgrindDiscardTranslations(const void *Addr, size_t Len);
# 72 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/Valgrind.h"
}
}
# 29 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassSupport.h" 2


namespace llvm {







class PassInfo {
public:
  typedef Pass* (*NormalCtor_t)();

private:
  const char *const PassName;
  const char *const PassArgument;
  const void *PassID;
  const bool IsCFGOnlyPass;
  const bool IsAnalysis;
  const bool IsAnalysisGroup;
  std::vector<const PassInfo*> ItfImpl;

  NormalCtor_t NormalCtor;

public:


  PassInfo(const char *name, const char *arg, const void *pi,
           NormalCtor_t normal, bool isCFGOnly, bool is_analysis)
    : PassName(name), PassArgument(arg), PassID(pi),
      IsCFGOnlyPass(isCFGOnly),
      IsAnalysis(is_analysis), IsAnalysisGroup(false), NormalCtor(normal) { }



  PassInfo(const char *name, const void *pi)
    : PassName(name), PassArgument(""), PassID(pi),
      IsCFGOnlyPass(false),
      IsAnalysis(false), IsAnalysisGroup(true), NormalCtor(0) { }



  const char *getPassName() const { return PassName; }





  const char *getPassArgument() const { return PassArgument; }



  const void *getTypeInfo() const { return PassID; }


  bool isPassID(const void *IDPtr) const {
    return PassID == IDPtr;
  }




  bool isAnalysisGroup() const { return IsAnalysisGroup; }
  bool isAnalysis() const { return IsAnalysis; }



  bool isCFGOnlyPass() const { return IsCFGOnlyPass; }





  NormalCtor_t getNormalCtor() const {
    return NormalCtor;
  }
  void setNormalCtor(NormalCtor_t Ctor) {
    NormalCtor = Ctor;
  }


  Pass *createPass() const;





  void addInterfaceImplemented(const PassInfo *ItfPI) {
    ItfImpl.push_back(ItfPI);
  }




  const std::vector<const PassInfo*> &getInterfacesImplemented() const {
    return ItfImpl;
  }

private:
  void operator=(const PassInfo &) ;
  PassInfo(const PassInfo &) ;
};
# 182 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassSupport.h"
template<typename PassName>
Pass *callDefaultCtor() { return new PassName(); }
# 202 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassSupport.h"
template<typename passName>
struct RegisterPass : public PassInfo {


  RegisterPass(const char *PassArg, const char *Name, bool CFGOnly = false,
               bool is_analysis = false)
    : PassInfo(Name, PassArg, &passName::ID,
               PassInfo::NormalCtor_t(callDefaultCtor<passName>),
               CFGOnly, is_analysis) {
    PassRegistry::getPassRegistry()->registerPass(*this);
  }
};
# 235 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassSupport.h"
class RegisterAGBase : public PassInfo {
public:
  RegisterAGBase(const char *Name,
                 const void *InterfaceID,
                 const void *PassID = 0,
                 bool isDefault = false);
};

template<typename Interface, bool Default = false>
struct RegisterAnalysisGroup : public RegisterAGBase {
  explicit RegisterAnalysisGroup(PassInfo &RPB)
    : RegisterAGBase(RPB.getPassName(),
                     &Interface::ID, RPB.getTypeInfo(),
                     Default) {
  }

  explicit RegisterAnalysisGroup(const char *Name)
    : RegisterAGBase(Name, &Interface::ID) {
  }
};
# 312 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassSupport.h"
struct PassRegistrationListener {



  PassRegistrationListener();



  virtual ~PassRegistrationListener();




  virtual void passRegistered(const PassInfo *) {}




  void enumeratePasses();




  virtual void passEnumerate(const PassInfo *) {}
};


}
# 367 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Pass.h" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassAnalysisSupport.h" 1
# 24 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassAnalysisSupport.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Pass.h" 1
# 25 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassAnalysisSupport.h" 2


namespace llvm {
# 37 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassAnalysisSupport.h"
class AnalysisUsage {
public:
  typedef SmallVector<AnalysisID, 32> VectorType;

private:

  VectorType Required, RequiredTransitive, Preserved;
  bool PreservesAll;

public:
  AnalysisUsage() : PreservesAll(false) {}




  AnalysisUsage &addRequiredID(const void *ID);
  AnalysisUsage &addRequiredID(char &ID);
  template<class PassClass>
  AnalysisUsage &addRequired() {
    return addRequiredID(PassClass::ID);
  }

  AnalysisUsage &addRequiredTransitiveID(char &ID);
  template<class PassClass>
  AnalysisUsage &addRequiredTransitive() {
    return addRequiredTransitiveID(PassClass::ID);
  }




  AnalysisUsage &addPreservedID(const void *ID) {
    Preserved.push_back(ID);
    return *this;
  }
  AnalysisUsage &addPreservedID(char &ID) {
    Preserved.push_back(&ID);
    return *this;
  }




  template<class PassClass>
  AnalysisUsage &addPreserved() {
    Preserved.push_back(&PassClass::ID);
    return *this;
  }






  AnalysisUsage &addPreserved(StringRef Arg);


  void setPreservesAll() { PreservesAll = true; }
  bool getPreservesAll() const { return PreservesAll; }
# 106 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassAnalysisSupport.h"
  void setPreservesCFG();

  const VectorType &getRequiredSet() const { return Required; }
  const VectorType &getRequiredTransitiveSet() const {
    return RequiredTransitive;
  }
  const VectorType &getPreservedSet() const { return Preserved; }
};






class PMDataManager;
class AnalysisResolver {
private:
  AnalysisResolver() ;

public:
  explicit AnalysisResolver(PMDataManager &P) : PM(P) { }

  inline PMDataManager &getPMDataManager() { return PM; }


  Pass *findImplPass(AnalysisID PI) {
    Pass *ResultPass = 0;
    for (unsigned i = 0; i < AnalysisImpls.size() ; ++i) {
      if (AnalysisImpls[i].first == PI) {
        ResultPass = AnalysisImpls[i].second;
        break;
      }
    }
    return ResultPass;
  }


  Pass *findImplPass(Pass *P, AnalysisID PI, Function &F);

  void addAnalysisImplsPair(AnalysisID PI, Pass *P) {
    if (findImplPass(PI) == P)
      return;
    std::pair<AnalysisID, Pass*> pir = std::make_pair(PI,P);
    AnalysisImpls.push_back(pir);
  }



  void clearAnalysisImpls() {
    AnalysisImpls.clear();
  }


  Pass *getAnalysisIfAvailable(AnalysisID ID, bool Direction) const;

private:


  std::vector<std::pair<AnalysisID, Pass*> > AnalysisImpls;


  PMDataManager &PM;
};
# 178 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassAnalysisSupport.h"
template<typename AnalysisType>
AnalysisType *Pass::getAnalysisIfAvailable() const {
  ((void)((Resolver && "Pass not resident in a PassManager object!") || (__assert_fail("Resolver && \"Pass not resident in a PassManager object!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassAnalysisSupport.h", 180, __func__),0)));

  const void *PI = &AnalysisType::ID;

  Pass *ResultPass = Resolver->getAnalysisIfAvailable(PI, true);
  if (ResultPass == 0) return 0;





  return (AnalysisType*)ResultPass->getAdjustedAnalysisPointer(PI);
}





template<typename AnalysisType>
AnalysisType &Pass::getAnalysis() const {
  ((void)((Resolver && "Pass has not been inserted into a PassManager object!") || (__assert_fail("Resolver && \"Pass has not been inserted into a PassManager object!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassAnalysisSupport.h", 200, __func__),0)));
  return getAnalysisID<AnalysisType>(&AnalysisType::ID);
}

template<typename AnalysisType>
AnalysisType &Pass::getAnalysisID(AnalysisID PI) const {
  ((void)((PI && "getAnalysis for unregistered pass!") || (__assert_fail("PI && \"getAnalysis for unregistered pass!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassAnalysisSupport.h", 206, __func__),0)));
  ((void)((Resolver&&"Pass has not been inserted into a PassManager object!") || (__assert_fail("Resolver&&\"Pass has not been inserted into a PassManager object!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassAnalysisSupport.h", 207, __func__),0)));



  Pass *ResultPass = Resolver->findImplPass(PI);
  ((void)((ResultPass && "getAnalysis*() called on an analysis that was not " "'required' by pass!") || (__assert_fail("ResultPass && \"getAnalysis*() called on an analysis that was not \" \"'required' by pass!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassAnalysisSupport.h", 214, __func__),0)));







  return *(AnalysisType*)ResultPass->getAdjustedAnalysisPointer(PI);
}





template<typename AnalysisType>
AnalysisType &Pass::getAnalysis(Function &F) {
  ((void)((Resolver &&"Pass has not been inserted into a PassManager object!") || (__assert_fail("Resolver &&\"Pass has not been inserted into a PassManager object!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassAnalysisSupport.h", 229, __func__),0)));

  return getAnalysisID<AnalysisType>(&AnalysisType::ID, F);
}

template<typename AnalysisType>
AnalysisType &Pass::getAnalysisID(AnalysisID PI, Function &F) {
  ((void)((PI && "getAnalysis for unregistered pass!") || (__assert_fail("PI && \"getAnalysis for unregistered pass!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassAnalysisSupport.h", 236, __func__),0)));
  ((void)((Resolver && "Pass has not been inserted into a PassManager object!") || (__assert_fail("Resolver && \"Pass has not been inserted into a PassManager object!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassAnalysisSupport.h", 237, __func__),0)));



  Pass *ResultPass = Resolver->findImplPass(this, PI, F);
  ((void)((ResultPass && "Unable to find requested analysis info") || (__assert_fail("ResultPass && \"Unable to find requested analysis info\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/PassAnalysisSupport.h", 242, __func__),0)));





  return *(AnalysisType*)ResultPass->getAdjustedAnalysisPointer(PI);
}

}
# 368 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Pass.h" 2
# 25 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/Dominators.h" 2


# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/raw_ostream.h" 1
# 20 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/raw_ostream.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h" 1
# 30 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/IntrusiveRefCntPtr.h" 1
# 28 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/IntrusiveRefCntPtr.h"
namespace llvm {

  template <class T>
  class IntrusiveRefCntPtr;
# 43 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/IntrusiveRefCntPtr.h"
  template <class Derived>
  class RefCountedBase {
    mutable unsigned ref_cnt;

  public:
    RefCountedBase() : ref_cnt(0) {}
    RefCountedBase(const RefCountedBase &) : ref_cnt(0) {}

    void Retain() const { ++ref_cnt; }
    void Release() const {
      ((void)((ref_cnt > 0 && "Reference count is already zero.") || (__assert_fail("ref_cnt > 0 && \"Reference count is already zero.\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/IntrusiveRefCntPtr.h", 53, __func__),0)));
      if (--ref_cnt == 0) delete static_cast<const Derived*>(this);
    }
  };
# 66 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/IntrusiveRefCntPtr.h"
  class RefCountedBaseVPTR {
    mutable unsigned ref_cnt;
    virtual void anchor();

  protected:
    RefCountedBaseVPTR() : ref_cnt(0) {}
    RefCountedBaseVPTR(const RefCountedBaseVPTR &) : ref_cnt(0) {}

    virtual ~RefCountedBaseVPTR() {}

    void Retain() const { ++ref_cnt; }
    void Release() const {
      ((void)((ref_cnt > 0 && "Reference count is already zero.") || (__assert_fail("ref_cnt > 0 && \"Reference count is already zero.\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/IntrusiveRefCntPtr.h", 78, __func__),0)));
      if (--ref_cnt == 0) delete this;
    }

    template <typename T>
    friend struct IntrusiveRefCntPtrInfo;
  };


  template <typename T> struct IntrusiveRefCntPtrInfo {
    static void retain(T *obj) { obj->Retain(); }
    static void release(T *obj) { obj->Release(); }
  };
# 109 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/IntrusiveRefCntPtr.h"
  template <typename T>
  class IntrusiveRefCntPtr {
    T* Obj;
    typedef IntrusiveRefCntPtr this_type;
  public:
    typedef T element_type;

    explicit IntrusiveRefCntPtr() : Obj(0) {}

    IntrusiveRefCntPtr(T* obj) : Obj(obj) {
      retain();
    }

    IntrusiveRefCntPtr(const IntrusiveRefCntPtr& S) : Obj(S.Obj) {
      retain();
    }
# 137 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/IntrusiveRefCntPtr.h"
    template <class X>
    IntrusiveRefCntPtr(const IntrusiveRefCntPtr<X>& S)
      : Obj(S.getPtr()) {
      retain();
    }

    IntrusiveRefCntPtr& operator=(IntrusiveRefCntPtr S) {
      swap(S);
      return *this;
    }

    ~IntrusiveRefCntPtr() { release(); }

    T& operator*() const { return *Obj; }

    T* operator->() const { return Obj; }

    T* getPtr() const { return Obj; }

    typedef T* (IntrusiveRefCntPtr::*unspecified_bool_type) () const;
    operator unspecified_bool_type() const {
      return Obj == 0 ? 0 : &IntrusiveRefCntPtr::getPtr;
    }

    void swap(IntrusiveRefCntPtr& other) {
      T* tmp = other.Obj;
      other.Obj = Obj;
      Obj = tmp;
    }

    void reset() {
      release();
      Obj = 0;
    }

    void resetWithoutRelease() {
      Obj = 0;
    }

  private:
    void retain() { if (Obj) IntrusiveRefCntPtrInfo<T>::retain(Obj); }
    void release() { if (Obj) IntrusiveRefCntPtrInfo<T>::release(Obj); }
  };

  template<class T, class U>
  inline bool operator==(const IntrusiveRefCntPtr<T>& A,
                         const IntrusiveRefCntPtr<U>& B)
  {
    return A.getPtr() == B.getPtr();
  }

  template<class T, class U>
  inline bool operator!=(const IntrusiveRefCntPtr<T>& A,
                         const IntrusiveRefCntPtr<U>& B)
  {
    return A.getPtr() != B.getPtr();
  }

  template<class T, class U>
  inline bool operator==(const IntrusiveRefCntPtr<T>& A,
                         U* B)
  {
    return A.getPtr() == B;
  }

  template<class T, class U>
  inline bool operator!=(const IntrusiveRefCntPtr<T>& A,
                         U* B)
  {
    return A.getPtr() != B;
  }

  template<class T, class U>
  inline bool operator==(T* A,
                         const IntrusiveRefCntPtr<U>& B)
  {
    return A == B.getPtr();
  }

  template<class T, class U>
  inline bool operator!=(T* A,
                         const IntrusiveRefCntPtr<U>& B)
  {
    return A != B.getPtr();
  }





  template<class T> struct simplify_type<IntrusiveRefCntPtr<T> > {
    typedef T* SimpleType;
    static SimpleType getSimplifiedValue(IntrusiveRefCntPtr<T>& Val) {
      return Val.getPtr();
    }
  };

  template<class T> struct simplify_type<const IntrusiveRefCntPtr<T> > {
    typedef T* SimpleType;
    static SimpleType getSimplifiedValue(const IntrusiveRefCntPtr<T>& Val) {
      return Val.getPtr();
    }
  };

}
# 31 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/OwningPtr.h" 1
# 18 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/OwningPtr.h"
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 1 3
# 21 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/assert.h" 1 3
# 12 "/mnt/home/ec2-user/build/emscripten/system/include/libc/assert.h" 3
extern "C" {



__attribute__((__noreturn__))

void __assert_fail (const char *, const char *, int, const char *);


}
# 22 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 2 3
# 25 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cassert" 3
# 19 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/OwningPtr.h" 2


namespace llvm {





template<class T>
class OwningPtr {
  OwningPtr(OwningPtr const &) ;
  OwningPtr &operator=(OwningPtr const &) ;
  T *Ptr;
public:
  explicit OwningPtr(T *P = 0) : Ptr(P) {}
# 44 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/OwningPtr.h"
  ~OwningPtr() {
    delete Ptr;
  }




  void reset(T *P = 0) {
    if (P == Ptr) return;
    T *Tmp = Ptr;
    Ptr = P;
    delete Tmp;
  }



  T *take() {
    T *Tmp = Ptr;
    Ptr = 0;
    return Tmp;
  }

  T &operator*() const {
    ((void)((Ptr && "Cannot dereference null pointer") || (__assert_fail("Ptr && \"Cannot dereference null pointer\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/OwningPtr.h", 67, __func__),0)));
    return *Ptr;
  }

  T *operator->() const { return Ptr; }
  T *get() const { return Ptr; }
                operator bool() const { return Ptr != 0; }
  bool operator!() const { return Ptr == 0; }
  bool isValid() const { return Ptr != 0; }

  void swap(OwningPtr &RHS) {
    T *Tmp = RHS.Ptr;
    RHS.Ptr = Ptr;
    Ptr = Tmp;
  }
};

template<class T>
inline void swap(OwningPtr<T> &a, OwningPtr<T> &b) {
  a.swap(b);
}



template<class T>
class OwningArrayPtr {
  OwningArrayPtr(OwningArrayPtr const &) ;
  OwningArrayPtr &operator=(OwningArrayPtr const &) ;
  T *Ptr;
public:
  explicit OwningArrayPtr(T *P = 0) : Ptr(P) {}
# 108 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/OwningPtr.h"
  ~OwningArrayPtr() {
    delete [] Ptr;
  }




  void reset(T *P = 0) {
    if (P == Ptr) return;
    T *Tmp = Ptr;
    Ptr = P;
    delete [] Tmp;
  }



  T *take() {
    T *Tmp = Ptr;
    Ptr = 0;
    return Tmp;
  }

  T &operator[](std::ptrdiff_t i) const {
    ((void)((Ptr && "Cannot dereference null pointer") || (__assert_fail("Ptr && \"Cannot dereference null pointer\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/OwningPtr.h", 131, __func__),0)));
    return Ptr[i];
  }

  T *get() const { return Ptr; }
                operator bool() const { return Ptr != 0; }
  bool operator!() const { return Ptr == 0; }

  void swap(OwningArrayPtr &RHS) {
    T *Tmp = RHS.Ptr;
    RHS.Ptr = Ptr;
    Ptr = Tmp;
  }
};

template<class T>
inline void swap(OwningArrayPtr<T> &a, OwningArrayPtr<T> &b) {
  a.swap(b);
}

}
# 32 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallString.h" 1
# 20 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallString.h"
namespace llvm {



template<unsigned InternalLen>
class SmallString : public SmallVector<char, InternalLen> {
public:

  SmallString() {}


  SmallString(StringRef S) : SmallVector<char, InternalLen>(S.begin(), S.end()) {}


  template<typename ItTy>
  SmallString(ItTy S, ItTy E) : SmallVector<char, InternalLen>(S, E) {}


  SmallString(const SmallString &RHS) : SmallVector<char, InternalLen>(RHS) {}
# 48 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallString.h"
  void assign(size_t NumElts, char Elt) {
    this->SmallVectorImpl<char>::assign(NumElts, Elt);
  }


  template<typename in_iter>
  void assign(in_iter S, in_iter E) {
    this->clear();
    SmallVectorImpl<char>::append(S, E);
  }


  void assign(StringRef RHS) {
    this->clear();
    SmallVectorImpl<char>::append(RHS.begin(), RHS.end());
  }


  void assign(const SmallVectorImpl<char> &RHS) {
    this->clear();
    SmallVectorImpl<char>::append(RHS.begin(), RHS.end());
  }






  template<typename in_iter>
  void append(in_iter S, in_iter E) {
    SmallVectorImpl<char>::append(S, E);
  }

  void append(size_t NumInputs, char Elt) {
    SmallVectorImpl<char>::append(NumInputs, Elt);
  }



  void append(StringRef RHS) {
    SmallVectorImpl<char>::append(RHS.begin(), RHS.end());
  }


  void append(const SmallVectorImpl<char> &RHS) {
    SmallVectorImpl<char>::append(RHS.begin(), RHS.end());
  }







  bool equals(StringRef RHS) const {
    return str().equals(RHS);
  }


  bool equals_lower(StringRef RHS) const {
    return str().equals_lower(RHS);
  }



  int compare(StringRef RHS) const {
    return str().compare(RHS);
  }


  int compare_lower(StringRef RHS) const {
    return str().compare_lower(RHS);
  }



  int compare_numeric(StringRef RHS) const {
    return str().compare_numeric(RHS);
  }






  bool startswith(StringRef Prefix) const {
    return str().startswith(Prefix);
  }


  bool endswith(StringRef Suffix) const {
    return str().endswith(Suffix);
  }
# 150 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallString.h"
  size_t find(char C, size_t From = 0) const {
    return str().find(C, From);
  }





  size_t find(StringRef Str, size_t From = 0) const {
    return str().find(Str, From);
  }





  size_t rfind(char C, size_t From = StringRef::npos) const {
    return str().rfind(C, From);
  }





  size_t rfind(StringRef Str) const {
    return str().rfind(Str);
  }



  size_t find_first_of(char C, size_t From = 0) const {
    return str().find_first_of(C, From);
  }





  size_t find_first_of(StringRef Chars, size_t From = 0) const {
    return str().find_first_of(Chars, From);
  }



  size_t find_first_not_of(char C, size_t From = 0) const {
    return str().find_first_not_of(C, From);
  }





  size_t find_first_not_of(StringRef Chars, size_t From = 0) const {
    return str().find_first_not_of(Chars, From);
  }



  size_t find_last_of(char C, size_t From = StringRef::npos) const {
    return str().find_last_of(C, From);
  }





  size_t find_last_of(
      StringRef Chars, size_t From = StringRef::npos) const {
    return str().find_last_of(Chars, From);
  }






  size_t count(char C) const {
    return str().count(C);
  }



  size_t count(StringRef Str) const {
    return str().count(Str);
  }
# 249 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallString.h"
  StringRef substr(size_t Start, size_t N = StringRef::npos) const {
    return str().substr(Start, N);
  }
# 263 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/ADT/SmallString.h"
  StringRef slice(size_t Start, size_t End) const {
    return str().slice(Start, End);
  }




  StringRef str() const { return StringRef(this->begin(), this->size()); }


  const char* c_str() {
    this->push_back(0);
    this->pop_back();
    return this->data();
  }


  operator StringRef() const { return str(); }


  const SmallString &operator=(StringRef RHS) {
    this->clear();
    return *this += RHS;
  }

  SmallString &operator+=(StringRef RHS) {
    this->append(RHS.begin(), RHS.end());
    return *this;
  }
  SmallString &operator+=(char C) {
    this->push_back(C);
    return *this;
  }
};

}
# 33 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h" 2



# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/TimeValue.h" 1
# 20 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/TimeValue.h"
namespace llvm {
namespace sys {
# 31 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/TimeValue.h"
  class TimeValue {



  public:





    static const TimeValue MinTime;





    static const TimeValue MaxTime;




    static const TimeValue ZeroTime;




    static const TimeValue PosixZeroTime;




    static const TimeValue Win32ZeroTime;




  public:
    typedef int64_t SecondsType;
    typedef int32_t NanoSecondsType;

    enum TimeConversions {
      NANOSECONDS_PER_SECOND = 1000000000,
      MICROSECONDS_PER_SECOND = 1000000,
      MILLISECONDS_PER_SECOND = 1000,
      NANOSECONDS_PER_MICROSECOND = 1000,
      NANOSECONDS_PER_MILLISECOND = 1000000,
      NANOSECONDS_PER_POSIX_TICK = 100,
      NANOSECONDS_PER_WIN32_TICK = 100
    };




  public:

    TimeValue() : seconds_(0), nanos_(0) {}




    explicit TimeValue (SecondsType seconds, NanoSecondsType nanos = 0)
      : seconds_( seconds ), nanos_( nanos ) { this->normalize(); }




    explicit TimeValue( double new_time )
      : seconds_( 0 ) , nanos_ ( 0 ) {
      SecondsType integer_part = static_cast<SecondsType>( new_time );
      seconds_ = integer_part;
      nanos_ = static_cast<NanoSecondsType>( (new_time -
               static_cast<double>(integer_part)) * NANOSECONDS_PER_SECOND );
      this->normalize();
    }




    static TimeValue now();




  public:



    TimeValue& operator += (const TimeValue& that ) {
      this->seconds_ += that.seconds_ ;
      this->nanos_ += that.nanos_ ;
      this->normalize();
      return *this;
    }




    TimeValue& operator -= (const TimeValue &that ) {
      this->seconds_ -= that.seconds_ ;
      this->nanos_ -= that.nanos_ ;
      this->normalize();
      return *this;
    }




    int operator < (const TimeValue &that) const { return that > *this; }




    int operator > (const TimeValue &that) const {
      if ( this->seconds_ > that.seconds_ ) {
          return 1;
      } else if ( this->seconds_ == that.seconds_ ) {
          if ( this->nanos_ > that.nanos_ ) return 1;
      }
      return 0;
    }




    int operator <= (const TimeValue &that) const { return that >= *this; }



    int operator >= (const TimeValue &that) const {
      if ( this->seconds_ > that.seconds_ ) {
          return 1;
      } else if ( this->seconds_ == that.seconds_ ) {
          if ( this->nanos_ >= that.nanos_ ) return 1;
      }
      return 0;
    }



    int operator == (const TimeValue &that) const {
      return (this->seconds_ == that.seconds_) &&
             (this->nanos_ == that.nanos_);
    }




    int operator != (const TimeValue &that) const { return !(*this == that); }




    friend TimeValue operator + (const TimeValue &tv1, const TimeValue &tv2);




    friend TimeValue operator - (const TimeValue &tv1, const TimeValue &tv2);




  public:




    SecondsType seconds() const { return seconds_; }




    NanoSecondsType nanoseconds() const { return nanos_; }




    uint32_t microseconds() const {
      return nanos_ / NANOSECONDS_PER_MICROSECOND;
    }




    uint32_t milliseconds() const {
      return nanos_ / NANOSECONDS_PER_MILLISECOND;
    }






    uint64_t usec() const {
      return seconds_ * MICROSECONDS_PER_SECOND +
             ( nanos_ / NANOSECONDS_PER_MICROSECOND );
    }






    uint64_t msec() const {
      return seconds_ * MILLISECONDS_PER_SECOND +
             ( nanos_ / NANOSECONDS_PER_MILLISECOND );
    }




    uint64_t toPosixTime() const {
      uint64_t result = seconds_ - PosixZeroTimeSeconds;
      result += nanos_ / NANOSECONDS_PER_POSIX_TICK;
      return result;
    }



    uint64_t toEpochTime() const {
      return seconds_ - PosixZeroTimeSeconds;
    }





    uint64_t toWin32Time() const {
      uint64_t result = (uint64_t)10000000 * (seconds_ - Win32ZeroTimeSeconds);
      result += nanos_ / NANOSECONDS_PER_WIN32_TICK;
      return result;
    }




    void getTimespecTime( uint64_t& seconds, uint32_t& nanos ) const {
      seconds = seconds_ - PosixZeroTimeSeconds;
      nanos = nanos_;
    }




    std::string str() const;




  public:




    void seconds (SecondsType sec ) {
      this->seconds_ = sec;
      this->normalize();
    }







    void nanoseconds ( NanoSecondsType nanos ) {
      this->nanos_ = nanos;
      this->normalize();
    }



    void microseconds ( int32_t micros ) {
      this->nanos_ = micros * NANOSECONDS_PER_MICROSECOND;
      this->normalize();
    }



    void milliseconds ( int32_t millis ) {
      this->nanos_ = millis * NANOSECONDS_PER_MILLISECOND;
      this->normalize();
    }


    void usec( int64_t microseconds ) {
      this->seconds_ = microseconds / MICROSECONDS_PER_SECOND;
      this->nanos_ = NanoSecondsType(microseconds % MICROSECONDS_PER_SECOND) *
        NANOSECONDS_PER_MICROSECOND;
      this->normalize();
    }


    void msec( int64_t milliseconds ) {
      this->seconds_ = milliseconds / MILLISECONDS_PER_SECOND;
      this->nanos_ = NanoSecondsType(milliseconds % MILLISECONDS_PER_SECOND) *
        NANOSECONDS_PER_MILLISECOND;
      this->normalize();
    }




    void fromEpochTime( SecondsType seconds ) {
      seconds_ = seconds + PosixZeroTimeSeconds;
      nanos_ = 0;
      this->normalize();
    }




    void fromWin32Time( uint64_t win32Time ) {
      this->seconds_ = win32Time / 10000000 + Win32ZeroTimeSeconds;
      this->nanos_ = NanoSecondsType(win32Time % 10000000) * 100;
    }




  private:



    void normalize();




  private:

    SecondsType seconds_;
    NanoSecondsType nanos_;

    static const SecondsType PosixZeroTimeSeconds;
    static const SecondsType Win32ZeroTimeSeconds;


  };

inline TimeValue operator + (const TimeValue &tv1, const TimeValue &tv2) {
  TimeValue sum (tv1.seconds_ + tv2.seconds_, tv1.nanos_ + tv2.nanos_);
  sum.normalize ();
  return sum;
}

inline TimeValue operator - (const TimeValue &tv1, const TimeValue &tv2) {
  TimeValue difference (tv1.seconds_ - tv2.seconds_, tv1.nanos_ - tv2.nanos_ );
  difference.normalize ();
  return difference;
}

}
}
# 37 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/system_error.h" 1
# 227 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/system_error.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/build/include/llvm/Config/llvm-config.h" 1
# 228 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/system_error.h" 2

# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cerrno" 1 3
# 31 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/cerrno" 3
# 230 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/system_error.h" 2
# 473 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/system_error.h"
namespace llvm {



template <class Tp> struct is_error_code_enum : public false_type {};



template <class Tp> struct is_error_condition_enum : public false_type {};





struct errc {
enum _ {
  success = 0,
  address_family_not_supported = 97,
  address_in_use = 98,
  address_not_available = 99,
  already_connected = 106,
  argument_list_too_long = 7,
  argument_out_of_domain = 33,
  bad_address = 14,
  bad_file_descriptor = 9,

  bad_message = 74,



  broken_pipe = 32,
  connection_aborted = 103,
  connection_already_in_progress = 114,
  connection_refused = 111,
  connection_reset = 104,
  cross_device_link = 18,
  destination_address_required = 89,
  device_or_resource_busy = 16,
  directory_not_empty = 39,
  executable_format_error = 8,
  file_exists = 17,
  file_too_large = 27,
  filename_too_long = 36,
  function_not_supported = 38,
  host_unreachable = 113,
  identifier_removed = 43,
  illegal_byte_sequence = 84,
  inappropriate_io_control_operation = 25,
  interrupted = 4,
  invalid_argument = 22,
  invalid_seek = 29,
  io_error = 5,
  is_a_directory = 21,
  message_size = 90,
  network_down = 100,
  network_reset = 102,
  network_unreachable = 101,
  no_buffer_space = 105,
  no_child_process = 10,

  no_link = 67,



  no_lock_available = 37,

  no_message_available = 61,



  no_message = 42,
  no_protocol_option = 92,
  no_space_on_device = 28,

  no_stream_resources = 63,



  no_such_device_or_address = 6,
  no_such_device = 19,
  no_such_file_or_directory = 2,
  no_such_process = 3,
  not_a_directory = 20,
  not_a_socket = 88,

  not_a_stream = 60,



  not_connected = 107,
  not_enough_memory = 12,
  not_supported = 95,

  operation_canceled = 125,



  operation_in_progress = 115,
  operation_not_permitted = 1,
  operation_not_supported = 95,
  operation_would_block = 11,

  owner_dead = 130,



  permission_denied = 13,

  protocol_error = 71,



  protocol_not_supported = 93,
  read_only_file_system = 30,
  resource_deadlock_would_occur = 35,
  resource_unavailable_try_again = 11,
  result_out_of_range = 34,

  state_not_recoverable = 131,




  stream_timeout = 62,



  text_file_busy = 22,
  timed_out = 110,
  too_many_files_open_in_system = 23,
  too_many_files_open = 24,
  too_many_links = 31,
  too_many_symbolic_link_levels = 40,
  value_too_large = 75,
  wrong_protocol_type = 91
};

  _ v_;

  errc(_ v) : v_(v) {}
  operator int() const {return v_;}
};

template <> struct is_error_condition_enum<errc> : true_type { };

template <> struct is_error_condition_enum<errc::_> : true_type { };

class error_condition;
class error_code;



class _do_message;

class error_category
{
public:
  virtual ~error_category();

private:
  error_category();
  error_category(const error_category&) ;
  error_category& operator=(const error_category&) ;

public:
  virtual const char* name() const = 0;
  virtual error_condition default_error_condition(int _ev) const;
  virtual bool equivalent(int _code, const error_condition& _condition) const;
  virtual bool equivalent(const error_code& _code, int _condition) const;
  virtual std::string message(int _ev) const = 0;

  bool operator==(const error_category& _rhs) const {return this == &_rhs;}

  bool operator!=(const error_category& _rhs) const {return !(*this == _rhs);}

  bool operator< (const error_category& _rhs) const {return this < &_rhs;}

  friend class _do_message;
};

class _do_message : public error_category
{
public:
  virtual std::string message(int ev) const ;
};

const error_category& generic_category();
const error_category& system_category();




const error_category& posix_category();

class error_condition
{
  int _val_;
  const error_category* _cat_;
public:
  error_condition() : _val_(0), _cat_(&generic_category()) {}

  error_condition(int _val, const error_category& _cat)
    : _val_(_val), _cat_(&_cat) {}

  template <class E>
  error_condition(E _e, typename enable_if_c<
                          is_error_condition_enum<E>::value
                        >::type* = 0)
    {*this = make_error_condition(_e);}

  void assign(int _val, const error_category& _cat) {
    _val_ = _val;
    _cat_ = &_cat;
  }

  template <class E>
    typename enable_if_c
    <
      is_error_condition_enum<E>::value,
      error_condition&
    >::type
    operator=(E _e)
      {*this = make_error_condition(_e); return *this;}

  void clear() {
    _val_ = 0;
    _cat_ = &generic_category();
  }

  int value() const {return _val_;}

  const error_category& category() const {return *_cat_;}
  std::string message() const;

  typedef void (*unspecified_bool_type)();
  static void unspecified_bool_true() {}

  operator unspecified_bool_type() const {
    return _val_ == 0 ? 0 : unspecified_bool_true;
  }
};

inline error_condition make_error_condition(errc _e) {
  return error_condition(static_cast<int>(_e), generic_category());
}

inline bool operator<(const error_condition& _x, const error_condition& _y) {
  return _x.category() < _y.category()
      || (_x.category() == _y.category() && _x.value() < _y.value());
}



class error_code {
  int _val_;
  const error_category* _cat_;
public:
  error_code() : _val_(0), _cat_(&system_category()) {}

  static error_code success() {
    return error_code();
  }

  error_code(int _val, const error_category& _cat)
    : _val_(_val), _cat_(&_cat) {}

  template <class E>
  error_code(E _e, typename enable_if_c<
                     is_error_code_enum<E>::value
                   >::type* = 0) {
    *this = make_error_code(_e);
  }

  void assign(int _val, const error_category& _cat) {
      _val_ = _val;
      _cat_ = &_cat;
  }

  template <class E>
    typename enable_if_c
    <
      is_error_code_enum<E>::value,
      error_code&
    >::type
    operator=(E _e)
      {*this = make_error_code(_e); return *this;}

  void clear() {
    _val_ = 0;
    _cat_ = &system_category();
  }

  int value() const {return _val_;}

  const error_category& category() const {return *_cat_;}

  error_condition default_error_condition() const
    {return _cat_->default_error_condition(_val_);}

  std::string message() const;

  typedef void (*unspecified_bool_type)();
  static void unspecified_bool_true() {}

  operator unspecified_bool_type() const {
    return _val_ == 0 ? 0 : unspecified_bool_true;
  }
};

inline error_code make_error_code(errc _e) {
  return error_code(static_cast<int>(_e), generic_category());
}

inline bool operator<(const error_code& _x, const error_code& _y) {
  return _x.category() < _y.category()
      || (_x.category() == _y.category() && _x.value() < _y.value());
}

inline bool operator==(const error_code& _x, const error_code& _y) {
  return _x.category() == _y.category() && _x.value() == _y.value();
}

inline bool operator==(const error_code& _x, const error_condition& _y) {
  return _x.category().equivalent(_x.value(), _y)
      || _y.category().equivalent(_x, _y.value());
}

inline bool operator==(const error_condition& _x, const error_code& _y) {
  return _y == _x;
}

inline bool operator==(const error_condition& _x, const error_condition& _y) {
   return _x.category() == _y.category() && _x.value() == _y.value();
}

inline bool operator!=(const error_code& _x, const error_code& _y) {
  return !(_x == _y);
}

inline bool operator!=(const error_code& _x, const error_condition& _y) {
  return !(_x == _y);
}

inline bool operator!=(const error_condition& _x, const error_code& _y) {
  return !(_x == _y);
}

inline bool operator!=(const error_condition& _x, const error_condition& _y) {
  return !(_x == _y);
}






struct windows_error {
enum _ {
  success = 0,



  invalid_function = 1,
  file_not_found = 2,
  path_not_found = 3,
  too_many_open_files = 4,
  access_denied = 5,
  invalid_handle = 6,
  arena_trashed = 7,
  not_enough_memory = 8,
  invalid_block = 9,
  bad_environment = 10,
  bad_format = 11,
  invalid_access = 12,
  outofmemory = 14,
  invalid_drive = 15,
  current_directory = 16,
  not_same_device = 17,
  no_more_files = 18,
  write_protect = 19,
  bad_unit = 20,
  not_ready = 21,
  bad_command = 22,
  crc = 23,
  bad_length = 24,
  seek = 25,
  not_dos_disk = 26,
  sector_not_found = 27,
  out_of_paper = 28,
  write_fault = 29,
  read_fault = 30,
  gen_failure = 31,
  sharing_violation = 32,
  lock_violation = 33,
  wrong_disk = 34,
  sharing_buffer_exceeded = 36,
  handle_eof = 38,
  handle_disk_full = 39,
  rem_not_list = 51,
  dup_name = 52,
  bad_net_path = 53,
  network_busy = 54,
  file_exists = 80,
  cannot_make = 82,
  broken_pipe = 109,
  open_failed = 110,
  buffer_overflow = 111,
  disk_full = 112,
  insufficient_buffer = 122,
  lock_failed = 167,
  busy = 170,
  cancel_violation = 173,
  already_exists = 183
};
  _ v_;

  windows_error(_ v) : v_(v) {}
  explicit windows_error(int v) : v_(_(v)) {}
  operator int() const {return v_;}
};


template <> struct is_error_code_enum<windows_error> : true_type { };

template <> struct is_error_code_enum<windows_error::_> : true_type { };

inline error_code make_error_code(windows_error e) {
  return error_code(static_cast<int>(e), system_category());
}

}
# 38 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h" 2
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/ctime" 1 3
# 48 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/ctime" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/compat/time.h" 1 3




extern "C" {


int dysize(int year);




}



# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/time.h" 1 3




extern "C" {
# 31 "/mnt/home/ec2-user/build/emscripten/system/include/libc/time.h" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libc/bits/alltypes.h" 1 3
# 32 "/mnt/home/ec2-user/build/emscripten/system/include/libc/time.h" 2 3






struct tm
{
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 long tm_gmtoff;
 const char *tm_zone;
};

clock_t clock (void);
time_t time (time_t *);
double difftime (time_t, time_t);
time_t mktime (struct tm *);
size_t strftime (char *__restrict, size_t, const char *__restrict, const struct tm *__restrict);
struct tm *gmtime (const time_t *);
struct tm *localtime (const time_t *);
char *asctime (const struct tm *);
char *ctime (const time_t *);
# 70 "/mnt/home/ec2-user/build/emscripten/system/include/libc/time.h" 3
size_t strftime_l (char * __restrict, size_t, const char * __restrict, const struct tm * __restrict, locale_t);

struct tm *gmtime_r (const time_t *__restrict, struct tm *__restrict);
struct tm *localtime_r (const time_t *__restrict, struct tm *__restrict);
char *asctime_r (const struct tm *__restrict, char *__restrict);
char *ctime_r (const time_t *, char *);

void tzset (void);

struct itimerspec
{
 struct timespec it_interval;
 struct timespec it_value;
};
# 100 "/mnt/home/ec2-user/build/emscripten/system/include/libc/time.h" 3
int nanosleep (const struct timespec *, struct timespec *);
int clock_getres (clockid_t, struct timespec *);
int clock_gettime (clockid_t, struct timespec *);
int clock_settime (clockid_t, const struct timespec *);
int clock_nanosleep (clockid_t, int, const struct timespec *, struct timespec *);
int clock_getcpuclockid (pid_t, clockid_t *);

struct sigevent;
int timer_create (clockid_t, struct sigevent *__restrict, timer_t *__restrict);
int timer_delete (timer_t);
int timer_settime (timer_t, int, const struct itimerspec *__restrict, struct itimerspec *__restrict);
int timer_gettime (timer_t, struct itimerspec *);
int timer_getoverrun (timer_t);





char *strptime (const char *__restrict, const char *__restrict, struct tm *__restrict);
extern int daylight;
extern long timezone;
extern char *tzname[2];
extern int getdate_err;
struct tm *getdate (const char *);




int stime(const time_t *);
time_t timegm(struct tm *);



}
# 17 "/mnt/home/ec2-user/build/emscripten/system/include/compat/time.h" 2 3
# 49 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/ctime" 2 3
# 52 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/ctime" 3


namespace std {inline namespace __1 {

using ::clock_t;
using ::size_t;
using ::time_t;
using ::tm;
using ::clock;
using ::difftime;
using ::mktime;
using ::time;
using ::asctime;
using ::ctime;
using ::gmtime;
using ::localtime;
using ::strftime;

} }
# 39 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h" 2

# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/stack" 1 3
# 86 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/stack" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/deque" 1 3
# 156 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/deque" 3
# 166 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/deque" 3
# 1 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/__undef_min_max" 1 3
# 167 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/deque" 2 3

namespace std {inline namespace __1 {

template <class _Tp, class _Allocator> class __deque_base;

template <class _ValueType, class _Pointer, class _Reference, class _MapPointer,
          class _DiffType, _DiffType _BlockSize>
class __attribute__ ((__type_visibility__("default"))) __deque_iterator;

template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy(_RAIter __f,
     _RAIter __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
     typename enable_if<__is_random_access_iterator<_RAIter>::value>::type* = 0);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     _OutputIterator __r);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);

template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy_backward(_RAIter __f,
              _RAIter __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
              typename enable_if<__is_random_access_iterator<_RAIter>::value>::type* = 0);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              _OutputIterator __r);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);

template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move(_RAIter __f,
     _RAIter __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
     typename enable_if<__is_random_access_iterator<_RAIter>::value>::type* = 0);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     _OutputIterator __r);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);

template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move_backward(_RAIter __f,
              _RAIter __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
              typename enable_if<__is_random_access_iterator<_RAIter>::value>::type* = 0);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              _OutputIterator __r);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);

template <class _ValueType, class _Pointer, class _Reference, class _MapPointer,
          class _DiffType, _DiffType _BlockSize>
class __attribute__ ((__type_visibility__("default"))) __deque_iterator
{
    typedef _MapPointer __map_iterator;
public:
    typedef _Pointer pointer;
    typedef _DiffType difference_type;
private:
    __map_iterator __m_iter_;
    pointer __ptr_;

    static const difference_type __block_size = _BlockSize;
public:
    typedef _ValueType value_type;
    typedef random_access_iterator_tag iterator_category;
    typedef _Reference reference;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __deque_iterator() throw()



     {}

    template <class _Pp, class _Rp, class _MP>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __deque_iterator(const __deque_iterator<value_type, _Pp, _Rp, _MP, difference_type, __block_size>& __it,
                typename enable_if<is_convertible<_Pp, pointer>::value>::type* = 0) throw()
        : __m_iter_(__it.__m_iter_), __ptr_(__it.__ptr_) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator*() const {return *__ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer operator->() const {return __ptr_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __deque_iterator& operator++()
    {
        if (++__ptr_ - *__m_iter_ == __block_size)
        {
            ++__m_iter_;
            __ptr_ = *__m_iter_;
        }
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __deque_iterator operator++(int)
    {
        __deque_iterator __tmp = *this;
        ++(*this);
        return __tmp;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __deque_iterator& operator--()
    {
        if (__ptr_ == *__m_iter_)
        {
            --__m_iter_;
            __ptr_ = *__m_iter_ + __block_size;
        }
        --__ptr_;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __deque_iterator operator--(int)
    {
        __deque_iterator __tmp = *this;
        --(*this);
        return __tmp;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __deque_iterator& operator+=(difference_type __n)
    {
        if (__n != 0)
        {
            __n += __ptr_ - *__m_iter_;
            if (__n > 0)
            {
                __m_iter_ += __n / __block_size;
                __ptr_ = *__m_iter_ + __n % __block_size;
            }
            else
            {
                difference_type __z = __block_size - 1 - __n;
                __m_iter_ -= __z / __block_size;
                __ptr_ = *__m_iter_ + (__block_size - 1 - __z % __block_size);
            }
        }
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __deque_iterator& operator-=(difference_type __n)
    {
        return *this += -__n;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __deque_iterator operator+(difference_type __n) const
    {
        __deque_iterator __t(*this);
        __t += __n;
        return __t;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __deque_iterator operator-(difference_type __n) const
    {
        __deque_iterator __t(*this);
        __t -= __n;
        return __t;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    friend __deque_iterator operator+(difference_type __n, const __deque_iterator& __it)
        {return __it + __n;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    friend difference_type operator-(const __deque_iterator& __x, const __deque_iterator& __y)
    {
        if (__x != __y)
            return (__x.__m_iter_ - __y.__m_iter_) * __block_size
                 + (__x.__ptr_ - *__x.__m_iter_)
                 - (__y.__ptr_ - *__y.__m_iter_);
        return 0;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](difference_type __n) const
        {return *(*this + __n);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend
        bool operator==(const __deque_iterator& __x, const __deque_iterator& __y)
        {return __x.__ptr_ == __y.__ptr_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend
        bool operator!=(const __deque_iterator& __x, const __deque_iterator& __y)
        {return !(__x == __y);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend
        bool operator<(const __deque_iterator& __x, const __deque_iterator& __y)
        {return __x.__m_iter_ < __y.__m_iter_ ||
               (__x.__m_iter_ == __y.__m_iter_ && __x.__ptr_ < __y.__ptr_);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend
        bool operator>(const __deque_iterator& __x, const __deque_iterator& __y)
        {return __y < __x;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend
        bool operator<=(const __deque_iterator& __x, const __deque_iterator& __y)
        {return !(__y < __x);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend
        bool operator>=(const __deque_iterator& __x, const __deque_iterator& __y)
        {return !(__x < __y);}

private:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __deque_iterator(__map_iterator __m, pointer __p) throw()
        : __m_iter_(__m), __ptr_(__p) {}

    template <class _Tp, class _Ap> friend class __deque_base;
    template <class _Tp, class _Ap> friend class __attribute__ ((__type_visibility__("default"))) deque;
    template <class _Vp, class _Pp, class _Rp, class _MP, class _Dp, _Dp>
        friend class __attribute__ ((__type_visibility__("default"))) __deque_iterator;

    template <class _RAIter,
              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
    friend
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
    copy(_RAIter __f,
         _RAIter __l,
         __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
         typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*);

    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
              class _OutputIterator>
    friend
    _OutputIterator
    copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
         __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
         _OutputIterator __r);

    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
    friend
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
    copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
         __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
         __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);

    template <class _RAIter,
              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
    friend
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
    copy_backward(_RAIter __f,
                  _RAIter __l,
                  __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
                  typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*);

    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
              class _OutputIterator>
    friend
    _OutputIterator
    copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
                  __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
                  _OutputIterator __r);

    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
    friend
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
    copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
                  __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
                  __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);

    template <class _RAIter,
              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
    friend
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
    move(_RAIter __f,
         _RAIter __l,
         __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
         typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*);

    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
              class _OutputIterator>
    friend
    _OutputIterator
    move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
         __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
         _OutputIterator __r);

    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
    friend
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
    move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
         __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
         __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);

    template <class _RAIter,
              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
    friend
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
    move_backward(_RAIter __f,
                  _RAIter __l,
                  __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
                  typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*);

    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
              class _OutputIterator>
    friend
    _OutputIterator
    move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
                  __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
                  _OutputIterator __r);

    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
    friend
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
    move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
                  __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
                  __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);
};



template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy(_RAIter __f,
     _RAIter __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
     typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*)
{
    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;
    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;
    while (__f != __l)
    {
        pointer __rb = __r.__ptr_;
        pointer __re = *__r.__m_iter_ + _B2;
        difference_type __bs = __re - __rb;
        difference_type __n = __l - __f;
        _RAIter __m = __l;
        if (__n > __bs)
        {
            __n = __bs;
            __m = __f + __n;
        }
        std::__1::copy(__f, __m, __rb);
        __f = __m;
        __r += __n;
    }
    return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     _OutputIterator __r)
{
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
    difference_type __n = __l - __f;
    while (__n > 0)
    {
        pointer __fb = __f.__ptr_;
        pointer __fe = *__f.__m_iter_ + _B1;
        difference_type __bs = __fe - __fb;
        if (__bs > __n)
        {
            __bs = __n;
            __fe = __fb + __bs;
        }
        __r = std::__1::copy(__fb, __fe, __r);
        __n -= __bs;
        __f += __bs;
    }
    return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r)
{
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
    difference_type __n = __l - __f;
    while (__n > 0)
    {
        pointer __fb = __f.__ptr_;
        pointer __fe = *__f.__m_iter_ + _B1;
        difference_type __bs = __fe - __fb;
        if (__bs > __n)
        {
            __bs = __n;
            __fe = __fb + __bs;
        }
        __r = std::__1::copy(__fb, __fe, __r);
        __n -= __bs;
        __f += __bs;
    }
    return __r;
}



template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy_backward(_RAIter __f,
              _RAIter __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
              typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*)
{
    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;
    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;
    while (__f != __l)
    {
        __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __rp = std::__1::prev(__r);
        pointer __rb = *__rp.__m_iter_;
        pointer __re = __rp.__ptr_ + 1;
        difference_type __bs = __re - __rb;
        difference_type __n = __l - __f;
        _RAIter __m = __f;
        if (__n > __bs)
        {
            __n = __bs;
            __m = __l - __n;
        }
        std::__1::copy_backward(__m, __l, __re);
        __l = __m;
        __r -= __n;
    }
    return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              _OutputIterator __r)
{
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
    difference_type __n = __l - __f;
    while (__n > 0)
    {
        --__l;
        pointer __lb = *__l.__m_iter_;
        pointer __le = __l.__ptr_ + 1;
        difference_type __bs = __le - __lb;
        if (__bs > __n)
        {
            __bs = __n;
            __lb = __le - __bs;
        }
        __r = std::__1::copy_backward(__lb, __le, __r);
        __n -= __bs;
        __l -= __bs - 1;
    }
    return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r)
{
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
    difference_type __n = __l - __f;
    while (__n > 0)
    {
        --__l;
        pointer __lb = *__l.__m_iter_;
        pointer __le = __l.__ptr_ + 1;
        difference_type __bs = __le - __lb;
        if (__bs > __n)
        {
            __bs = __n;
            __lb = __le - __bs;
        }
        __r = std::__1::copy_backward(__lb, __le, __r);
        __n -= __bs;
        __l -= __bs - 1;
    }
    return __r;
}



template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move(_RAIter __f,
     _RAIter __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
     typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*)
{
    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;
    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;
    while (__f != __l)
    {
        pointer __rb = __r.__ptr_;
        pointer __re = *__r.__m_iter_ + _B2;
        difference_type __bs = __re - __rb;
        difference_type __n = __l - __f;
        _RAIter __m = __l;
        if (__n > __bs)
        {
            __n = __bs;
            __m = __f + __n;
        }
        std::__1::move(__f, __m, __rb);
        __f = __m;
        __r += __n;
    }
    return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     _OutputIterator __r)
{
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
    difference_type __n = __l - __f;
    while (__n > 0)
    {
        pointer __fb = __f.__ptr_;
        pointer __fe = *__f.__m_iter_ + _B1;
        difference_type __bs = __fe - __fb;
        if (__bs > __n)
        {
            __bs = __n;
            __fe = __fb + __bs;
        }
        __r = std::__1::move(__fb, __fe, __r);
        __n -= __bs;
        __f += __bs;
    }
    return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r)
{
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
    difference_type __n = __l - __f;
    while (__n > 0)
    {
        pointer __fb = __f.__ptr_;
        pointer __fe = *__f.__m_iter_ + _B1;
        difference_type __bs = __fe - __fb;
        if (__bs > __n)
        {
            __bs = __n;
            __fe = __fb + __bs;
        }
        __r = std::__1::move(__fb, __fe, __r);
        __n -= __bs;
        __f += __bs;
    }
    return __r;
}



template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move_backward(_RAIter __f,
              _RAIter __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
              typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*)
{
    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;
    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;
    while (__f != __l)
    {
        __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __rp = std::__1::prev(__r);
        pointer __rb = *__rp.__m_iter_;
        pointer __re = __rp.__ptr_ + 1;
        difference_type __bs = __re - __rb;
        difference_type __n = __l - __f;
        _RAIter __m = __f;
        if (__n > __bs)
        {
            __n = __bs;
            __m = __l - __n;
        }
        std::__1::move_backward(__m, __l, __re);
        __l = __m;
        __r -= __n;
    }
    return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              _OutputIterator __r)
{
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
    difference_type __n = __l - __f;
    while (__n > 0)
    {
        --__l;
        pointer __lb = *__l.__m_iter_;
        pointer __le = __l.__ptr_ + 1;
        difference_type __bs = __le - __lb;
        if (__bs > __n)
        {
            __bs = __n;
            __lb = __le - __bs;
        }
        __r = std::__1::move_backward(__lb, __le, __r);
        __n -= __bs;
        __l -= __bs - 1;
    }
    return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r)
{
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
    difference_type __n = __l - __f;
    while (__n > 0)
    {
        --__l;
        pointer __lb = *__l.__m_iter_;
        pointer __le = __l.__ptr_ + 1;
        difference_type __bs = __le - __lb;
        if (__bs > __n)
        {
            __bs = __n;
            __lb = __le - __bs;
        }
        __r = std::__1::move_backward(__lb, __le, __r);
        __n -= __bs;
        __l -= __bs - 1;
    }
    return __r;
}

template <bool>
class __deque_base_common
{
protected:
    void __throw_length_error() const;
    void __throw_out_of_range() const;
};

template <bool __b>
void
__deque_base_common<__b>::__throw_length_error() const
{



}

template <bool __b>
void
__deque_base_common<__b>::__throw_out_of_range() const
{



}

template <class _Tp, class _Allocator>
class __deque_base
    : protected __deque_base_common<true>
{
    __deque_base(const __deque_base& __c);
    __deque_base& operator=(const __deque_base& __c);
protected:
    typedef _Tp value_type;
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;

    static const difference_type __block_size = sizeof(value_type) < 256 ? 4096 / sizeof(value_type) : 16;

    typedef typename __alloc_traits::template



                rebind_alloc<pointer>::other

                                                         __pointer_allocator;
    typedef allocator_traits<__pointer_allocator> __map_traits;
    typedef typename __map_traits::pointer __map_pointer;
    typedef typename __alloc_traits::template



                rebind_alloc<const_pointer>::other

                                                         __const_pointer_allocator;
    typedef typename allocator_traits<__const_pointer_allocator>::const_pointer __map_const_pointer;
    typedef __split_buffer<pointer, __pointer_allocator> __map;

    typedef __deque_iterator<value_type, pointer, reference, __map_pointer,
                             difference_type, __block_size> iterator;
    typedef __deque_iterator<value_type, const_pointer, const_reference, __map_const_pointer,
                             difference_type, __block_size> const_iterator;

    __map __map_;
    size_type __start_;
    __compressed_pair<size_type, allocator_type> __size_;

    iterator begin() throw();
    const_iterator begin() const throw();
    iterator end() throw();
    const_iterator end() const throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type& size() {return __size_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const size_type& size() const throw() {return __size_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) allocator_type& __alloc() {return __size_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const allocator_type& __alloc() const throw() {return __size_.second();}

    __deque_base()
                                                                           ;
    explicit __deque_base(const allocator_type& __a);
public:
    ~__deque_base();
# 967 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/deque" 3
    void swap(__deque_base& __c)

                                                                 ;
protected:
    void clear() throw();

    bool __invariants() const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign(__deque_base& __c)


    {
        __map_ = std::__1::move(__c.__map_);
        __start_ = __c.__start_;
        size() = __c.size();
        __move_assign_alloc(__c);
        __c.__start_ = __c.size() = 0;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign_alloc(__deque_base& __c)


        {__move_assign_alloc(__c, integral_constant<bool,
                      __alloc_traits::propagate_on_container_move_assignment::value>());}

private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign_alloc(__deque_base& __c, true_type)

        {
            __alloc() = std::__1::move(__c.__alloc());
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign_alloc(__deque_base&, false_type) throw()
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void __swap_alloc(allocator_type& __x, allocator_type& __y)


        {__swap_alloc(__x, __y, integral_constant<bool,
                      __alloc_traits::propagate_on_container_swap::value>());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void __swap_alloc(allocator_type& __x, allocator_type& __y, true_type)

        {
            using std::__1::swap;
            swap(__x, __y);
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void __swap_alloc(allocator_type&, allocator_type&, false_type)
        throw()
        {}
};

template <class _Tp, class _Allocator>
bool
__deque_base<_Tp, _Allocator>::__invariants() const
{
    if (!__map_.__invariants())
        return false;
    if (__map_.size() >= size_type(-1) / __block_size)
        return false;
    for (typename __map::const_iterator __i = __map_.begin(), __e = __map_.end();
         __i != __e; ++__i)
        if (*__i == std::__1::__get_nullptr_t())
            return false;
    if (__map_.size() != 0)
    {
        if (size() >= __map_.size() * __block_size)
            return false;
        if (__start_ >= __map_.size() * __block_size - size())
            return false;
    }
    else
    {
        if (size() != 0)
            return false;
        if (__start_ != 0)
            return false;
    }
    return true;
}

template <class _Tp, class _Allocator>
typename __deque_base<_Tp, _Allocator>::iterator
__deque_base<_Tp, _Allocator>::begin() throw()
{
    __map_pointer __mp = __map_.begin() + __start_ / __block_size;
    return iterator(__mp, __map_.empty() ? 0 : *__mp + __start_ % __block_size);
}

template <class _Tp, class _Allocator>
typename __deque_base<_Tp, _Allocator>::const_iterator
__deque_base<_Tp, _Allocator>::begin() const throw()
{
    __map_const_pointer __mp = static_cast<__map_const_pointer>(__map_.begin() + __start_ / __block_size);
    return const_iterator(__mp, __map_.empty() ? 0 : *__mp + __start_ % __block_size);
}

template <class _Tp, class _Allocator>
typename __deque_base<_Tp, _Allocator>::iterator
__deque_base<_Tp, _Allocator>::end() throw()
{
    size_type __p = size() + __start_;
    __map_pointer __mp = __map_.begin() + __p / __block_size;
    return iterator(__mp, __map_.empty() ? 0 : *__mp + __p % __block_size);
}

template <class _Tp, class _Allocator>
typename __deque_base<_Tp, _Allocator>::const_iterator
__deque_base<_Tp, _Allocator>::end() const throw()
{
    size_type __p = size() + __start_;
    __map_const_pointer __mp = static_cast<__map_const_pointer>(__map_.begin() + __p / __block_size);
    return const_iterator(__mp, __map_.empty() ? 0 : *__mp + __p % __block_size);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__deque_base<_Tp, _Allocator>::__deque_base()

    : __start_(0), __size_(0) {}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__deque_base<_Tp, _Allocator>::__deque_base(const allocator_type& __a)
    : __map_(__pointer_allocator(__a)), __start_(0), __size_(0, __a) {}

template <class _Tp, class _Allocator>
__deque_base<_Tp, _Allocator>::~__deque_base()
{
    clear();
    typename __map::iterator __i = __map_.begin();
    typename __map::iterator __e = __map_.end();
    for (; __i != __e; ++__i)
        __alloc_traits::deallocate(__alloc(), *__i, __block_size);
}
# 1145 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/deque" 3
template <class _Tp, class _Allocator>
void
__deque_base<_Tp, _Allocator>::swap(__deque_base& __c)


{
    __map_.swap(__c.__map_);
    std::__1::swap(__start_, __c.__start_);
    std::__1::swap(size(), __c.size());
    __swap_alloc(__alloc(), __c.__alloc());
}

template <class _Tp, class _Allocator>
void
__deque_base<_Tp, _Allocator>::clear() throw()
{
    allocator_type& __a = __alloc();
    for (iterator __i = begin(), __e = end(); __i != __e; ++__i)
        __alloc_traits::destroy(__a, std::__1::addressof(*__i));
    size() = 0;
    while (__map_.size() > 2)
    {
        __alloc_traits::deallocate(__a, __map_.front(), __block_size);
        __map_.pop_front();
    }
    switch (__map_.size())
    {
    case 1:
        __start_ = __block_size / 2;
        break;
    case 2:
        __start_ = __block_size;
        break;
    }
}

template <class _Tp, class _Allocator = allocator<_Tp> >
class __attribute__ ((__type_visibility__("default"))) deque
    : private __deque_base<_Tp, _Allocator>
{
public:


    typedef _Tp value_type;
    typedef _Allocator allocator_type;

    typedef __deque_base<value_type, allocator_type> __base;

    typedef typename __base::__alloc_traits __alloc_traits;
    typedef typename __base::reference reference;
    typedef typename __base::const_reference const_reference;
    typedef typename __base::iterator iterator;
    typedef typename __base::const_iterator const_iterator;
    typedef typename __base::size_type size_type;
    typedef typename __base::difference_type difference_type;

    typedef typename __base::pointer pointer;
    typedef typename __base::const_pointer const_pointer;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    deque()

        {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit deque(const allocator_type& __a) : __base(__a) {}
    explicit deque(size_type __n);



    deque(size_type __n, const value_type& __v);
    deque(size_type __n, const value_type& __v, const allocator_type& __a);
    template <class _InputIter>
        deque(_InputIter __f, _InputIter __l,
              typename enable_if<__is_input_iterator<_InputIter>::value>::type* = 0);
    template <class _InputIter>
        deque(_InputIter __f, _InputIter __l, const allocator_type& __a,
              typename enable_if<__is_input_iterator<_InputIter>::value>::type* = 0);
    deque(const deque& __c);
    deque(const deque& __c, const allocator_type& __a);





    deque& operator=(const deque& __c);
# 1245 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/deque" 3
    template <class _InputIter>
        void assign(_InputIter __f, _InputIter __l,
                    typename enable_if<__is_input_iterator<_InputIter>::value &&
                                      !__is_random_access_iterator<_InputIter>::value>::type* = 0);
    template <class _RAIter>
        void assign(_RAIter __f, _RAIter __l,
                    typename enable_if<__is_random_access_iterator<_RAIter>::value>::type* = 0);
    void assign(size_type __n, const value_type& __v);





    allocator_type get_allocator() const throw();



    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator begin() throw() {return __base::begin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator begin() const throw() {return __base::begin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator end() throw() {return __base::end();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator end() const throw() {return __base::end();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    reverse_iterator rbegin() throw()
        {return reverse_iterator(__base::end());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator rbegin() const throw()
        {return const_reverse_iterator(__base::end());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    reverse_iterator rend() throw()
        {return reverse_iterator(__base::begin());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator rend() const throw()
        {return const_reverse_iterator(__base::begin());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator cbegin() const throw()
        {return __base::begin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator cend() const throw()
        {return __base::end();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator crbegin() const throw()
        {return const_reverse_iterator(__base::end());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator crend() const throw()
        {return const_reverse_iterator(__base::begin());}


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type size() const throw() {return __base::size();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type max_size() const throw()
        {return __alloc_traits::max_size(__base::__alloc());}
    void resize(size_type __n);
    void resize(size_type __n, const value_type& __v);
    void shrink_to_fit() throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool empty() const throw() {return __base::size() == 0;}


    reference operator[](size_type __i);
    const_reference operator[](size_type __i) const;
    reference at(size_type __i);
    const_reference at(size_type __i) const;
    reference front();
    const_reference front() const;
    reference back();
    const_reference back() const;


    void push_front(const value_type& __v);
    void push_back(const value_type& __v);
# 1332 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/deque" 3
    iterator insert(const_iterator __p, const value_type& __v);
    iterator insert(const_iterator __p, size_type __n, const value_type& __v);
    template <class _InputIter>
        iterator insert (const_iterator __p, _InputIter __f, _InputIter __l,
                         typename enable_if<__is_input_iterator<_InputIter>::value
                                         &&!__is_bidirectional_iterator<_InputIter>::value>::type* = 0);
    template <class _BiIter>
        iterator insert (const_iterator __p, _BiIter __f, _BiIter __l,
                         typename enable_if<__is_bidirectional_iterator<_BiIter>::value>::type* = 0);





    void pop_front();
    void pop_back();
    iterator erase(const_iterator __p);
    iterator erase(const_iterator __f, const_iterator __l);

    void swap(deque& __c)

                                                                 ;
    void clear() throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool __invariants() const {return __base::__invariants();}
private:
    typedef typename __base::__map_const_pointer __map_const_pointer;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static size_type __recommend_blocks(size_type __n)
    {
        return __n / __base::__block_size + (__n % __base::__block_size != 0);
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type __capacity() const
    {
        return __base::__map_.size() == 0 ? 0 : __base::__map_.size() * __base::__block_size - 1;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type __front_spare() const
    {
        return __base::__start_;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type __back_spare() const
    {
        return __capacity() - (__base::__start_ + __base::size());
    }

    template <class _InpIter>
        void __append(_InpIter __f, _InpIter __l,
                 typename enable_if<__is_input_iterator<_InpIter>::value &&
                                   !__is_forward_iterator<_InpIter>::value>::type* = 0);
    template <class _ForIter>
        void __append(_ForIter __f, _ForIter __l,
                      typename enable_if<__is_forward_iterator<_ForIter>::value>::type* = 0);
    void __append(size_type __n);
    void __append(size_type __n, const value_type& __v);
    void __erase_to_end(const_iterator __f);
    void __add_front_capacity();
    void __add_front_capacity(size_type __n);
    void __add_back_capacity();
    void __add_back_capacity(size_type __n);
    iterator __move_and_check(iterator __f, iterator __l, iterator __r,
                              const_pointer& __vt);
    iterator __move_backward_and_check(iterator __f, iterator __l, iterator __r,
                                       const_pointer& __vt);
    void __move_construct_and_check(iterator __f, iterator __l,
                                    iterator __r, const_pointer& __vt);
    void __move_construct_backward_and_check(iterator __f, iterator __l,
                                             iterator __r, const_pointer& __vt);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __copy_assign_alloc(const deque& __c)
        {__copy_assign_alloc(__c, integral_constant<bool,
                      __alloc_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __copy_assign_alloc(const deque& __c, true_type)
        {
            if (__base::__alloc() != __c.__alloc())
            {
                clear();
                shrink_to_fit();
            }
            __base::__alloc() = __c.__alloc();
            __base::__map_.__alloc() = __c.__map_.__alloc();
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __copy_assign_alloc(const deque&, false_type)
        {}

    void __move_assign(deque& __c, true_type)
                                                                     ;
    void __move_assign(deque& __c, false_type);
};

template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(size_type __n)
{
    if (__n > 0)
        __append(__n);
}
# 1448 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/deque" 3
template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(size_type __n, const value_type& __v)
{
    if (__n > 0)
        __append(__n, __v);
}

template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(size_type __n, const value_type& __v, const allocator_type& __a)
    : __base(__a)
{
    if (__n > 0)
        __append(__n, __v);
}

template <class _Tp, class _Allocator>
template <class _InputIter>
deque<_Tp, _Allocator>::deque(_InputIter __f, _InputIter __l,
              typename enable_if<__is_input_iterator<_InputIter>::value>::type*)
{
    __append(__f, __l);
}

template <class _Tp, class _Allocator>
template <class _InputIter>
deque<_Tp, _Allocator>::deque(_InputIter __f, _InputIter __l, const allocator_type& __a,
              typename enable_if<__is_input_iterator<_InputIter>::value>::type*)
    : __base(__a)
{
    __append(__f, __l);
}

template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(const deque& __c)
    : __base(__alloc_traits::select_on_container_copy_construction(__c.__alloc()))
{
    __append(__c.begin(), __c.end());
}

template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(const deque& __c, const allocator_type& __a)
    : __base(__a)
{
    __append(__c.begin(), __c.end());
}
# 1511 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/deque" 3
template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>&
deque<_Tp, _Allocator>::operator=(const deque& __c)
{
    if (this != &__c)
    {
        __copy_assign_alloc(__c);
        assign(__c.begin(), __c.end());
    }
    return *this;
}
# 1582 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/deque" 3
template <class _Tp, class _Allocator>
template <class _InputIter>
void
deque<_Tp, _Allocator>::assign(_InputIter __f, _InputIter __l,
                               typename enable_if<__is_input_iterator<_InputIter>::value &&
                                                 !__is_random_access_iterator<_InputIter>::value>::type*)
{
    iterator __i = __base::begin();
    iterator __e = __base::end();
    for (; __f != __l && __i != __e; ++__f, ++__i)
        *__i = *__f;
    if (__f != __l)
        __append(__f, __l);
    else
        __erase_to_end(__i);
}

template <class _Tp, class _Allocator>
template <class _RAIter>
void
deque<_Tp, _Allocator>::assign(_RAIter __f, _RAIter __l,
                               typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*)
{
    if (static_cast<size_type>(__l - __f) > __base::size())
    {
        _RAIter __m = __f + __base::size();
        std::__1::copy(__f, __m, __base::begin());
        __append(__m, __l);
    }
    else
        __erase_to_end(std::__1::copy(__f, __l, __base::begin()));
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::assign(size_type __n, const value_type& __v)
{
    if (__n > __base::size())
    {
        std::__1::fill_n(__base::begin(), __base::size(), __v);
        __n -= __base::size();
        __append(__n, __v);
    }
    else
        __erase_to_end(std::__1::fill_n(__base::begin(), __n, __v));
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Allocator
deque<_Tp, _Allocator>::get_allocator() const throw()
{
    return __base::__alloc();
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::resize(size_type __n)
{
    if (__n > __base::size())
        __append(__n - __base::size());
    else if (__n < __base::size())
        __erase_to_end(__base::begin() + __n);
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::resize(size_type __n, const value_type& __v)
{
    if (__n > __base::size())
        __append(__n - __base::size(), __v);
    else if (__n < __base::size())
        __erase_to_end(__base::begin() + __n);
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::shrink_to_fit() throw()
{
    allocator_type& __a = __base::__alloc();
    if (empty())
    {
        while (__base::__map_.size() > 0)
        {
            __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);
            __base::__map_.pop_back();
        }
        __base::__start_ = 0;
    }
    else
    {
        if (__front_spare() >= __base::__block_size)
        {
            __alloc_traits::deallocate(__a, __base::__map_.front(), __base::__block_size);
            __base::__map_.pop_front();
            __base::__start_ -= __base::__block_size;
        }
        if (__back_spare() >= __base::__block_size)
        {
            __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);
            __base::__map_.pop_back();
        }
    }
    __base::__map_.shrink_to_fit();
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename deque<_Tp, _Allocator>::reference
deque<_Tp, _Allocator>::operator[](size_type __i)
{
    size_type __p = __base::__start_ + __i;
    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename deque<_Tp, _Allocator>::const_reference
deque<_Tp, _Allocator>::operator[](size_type __i) const
{
    size_type __p = __base::__start_ + __i;
    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename deque<_Tp, _Allocator>::reference
deque<_Tp, _Allocator>::at(size_type __i)
{
    if (__i >= __base::size())
        __base::__throw_out_of_range();
    size_type __p = __base::__start_ + __i;
    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename deque<_Tp, _Allocator>::const_reference
deque<_Tp, _Allocator>::at(size_type __i) const
{
    if (__i >= __base::size())
        __base::__throw_out_of_range();
    size_type __p = __base::__start_ + __i;
    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename deque<_Tp, _Allocator>::reference
deque<_Tp, _Allocator>::front()
{
    return *(*(__base::__map_.begin() + __base::__start_ / __base::__block_size)
                                      + __base::__start_ % __base::__block_size);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename deque<_Tp, _Allocator>::const_reference
deque<_Tp, _Allocator>::front() const
{
    return *(*(__base::__map_.begin() + __base::__start_ / __base::__block_size)
                                      + __base::__start_ % __base::__block_size);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename deque<_Tp, _Allocator>::reference
deque<_Tp, _Allocator>::back()
{
    size_type __p = __base::size() + __base::__start_ - 1;
    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename deque<_Tp, _Allocator>::const_reference
deque<_Tp, _Allocator>::back() const
{
    size_type __p = __base::size() + __base::__start_ - 1;
    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::push_back(const value_type& __v)
{
    allocator_type& __a = __base::__alloc();
    if (__back_spare() == 0)
        __add_back_capacity();

    __alloc_traits::construct(__a, std::__1::addressof(*__base::end()), __v);
    ++__base::size();
}
# 1808 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/deque" 3
template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::push_front(const value_type& __v)
{
    allocator_type& __a = __base::__alloc();
    if (__front_spare() == 0)
        __add_front_capacity();

    __alloc_traits::construct(__a, std::__1::addressof(*--__base::begin()), __v);
    --__base::__start_;
    ++__base::size();
}
# 1855 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/deque" 3
template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::insert(const_iterator __p, const value_type& __v)
{
    size_type __pos = __p - __base::begin();
    size_type __to_end = __base::size() - __pos;
    allocator_type& __a = __base::__alloc();
    if (__pos < __to_end)
    {
        if (__front_spare() == 0)
            __add_front_capacity();

        if (__pos == 0)
        {
            __alloc_traits::construct(__a, std::__1::addressof(*--__base::begin()), __v);
            --__base::__start_;
            ++__base::size();
        }
        else
        {
            const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
            iterator __b = __base::begin();
            iterator __bm1 = std::__1::prev(__b);
            if (__vt == pointer_traits<const_pointer>::pointer_to(*__b))
                __vt = pointer_traits<const_pointer>::pointer_to(*__bm1);
            __alloc_traits::construct(__a, std::__1::addressof(*__bm1), std::__1::move(*__b));
            --__base::__start_;
            ++__base::size();
            if (__pos > 1)
                __b = __move_and_check(std::__1::next(__b), __b + __pos, __b, __vt);
            *__b = *__vt;
        }
    }
    else
    {
        if (__back_spare() == 0)
            __add_back_capacity();

        size_type __de = __base::size() - __pos;
        if (__de == 0)
        {
            __alloc_traits::construct(__a, std::__1::addressof(*__base::end()), __v);
            ++__base::size();
        }
        else
        {
            const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
            iterator __e = __base::end();
            iterator __em1 = std::__1::prev(__e);
            if (__vt == pointer_traits<const_pointer>::pointer_to(*__em1))
                __vt = pointer_traits<const_pointer>::pointer_to(*__e);
            __alloc_traits::construct(__a, std::__1::addressof(*__e), std::__1::move(*__em1));
            ++__base::size();
            if (__de > 1)
                __e = __move_backward_and_check(__e - __de, __em1, __e, __vt);
            *--__e = *__vt;
        }
    }
    return __base::begin() + __pos;
}
# 2036 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/deque" 3
template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::insert(const_iterator __p, size_type __n, const value_type& __v)
{
    size_type __pos = __p - __base::begin();
    size_type __to_end = __base::size() - __pos;
    allocator_type& __a = __base::__alloc();
    if (__pos < __to_end)
    {
        if (__n > __front_spare())
            __add_front_capacity(__n - __front_spare());

        size_type __old_n = __n;
        iterator __old_begin = __base::begin();
        iterator __i = __old_begin;
        if (__n > __pos)
        {
            for (size_type __m = __n - __pos; __m; --__m, --__base::__start_, ++__base::size())
                __alloc_traits::construct(__a, std::__1::addressof(*--__i), __v);
            __n = __pos;
        }
        if (__n > 0)
        {
            const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
            iterator __obn = __old_begin + __n;
            __move_construct_backward_and_check(__old_begin, __obn, __i, __vt);
            if (__n < __pos)
                __old_begin = __move_and_check(__obn, __old_begin + __pos, __old_begin, __vt);
            std::__1::fill_n(__old_begin, __n, *__vt);
        }
    }
    else
    {
        size_type __back_capacity = __back_spare();
        if (__n > __back_capacity)
            __add_back_capacity(__n - __back_capacity);

        size_type __old_n = __n;
        iterator __old_end = __base::end();
        iterator __i = __old_end;
        size_type __de = __base::size() - __pos;
        if (__n > __de)
        {
            for (size_type __m = __n - __de; __m; --__m, ++__i, ++__base::size())
                __alloc_traits::construct(__a, std::__1::addressof(*__i), __v);
            __n = __de;
        }
        if (__n > 0)
        {
            const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
            iterator __oen = __old_end - __n;
            __move_construct_and_check(__oen, __old_end, __i, __vt);
            if (__n < __de)
                __old_end = __move_backward_and_check(__old_end - __de, __oen, __old_end, __vt);
            std::__1::fill_n(__old_end - __n, __n, *__vt);
        }
    }
    return __base::begin() + __pos;
}

template <class _Tp, class _Allocator>
template <class _InputIter>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::insert(const_iterator __p, _InputIter __f, _InputIter __l,
                               typename enable_if<__is_input_iterator<_InputIter>::value
                                               &&!__is_bidirectional_iterator<_InputIter>::value>::type*)
{
    __split_buffer<value_type, allocator_type&> __buf(__base::__alloc());
    __buf.__construct_at_end(__f, __l);
    typedef typename __split_buffer<value_type, allocator_type&>::iterator __bi;
    return insert(__p, move_iterator<__bi>(__buf.begin()), move_iterator<__bi>(__buf.end()));
}

template <class _Tp, class _Allocator>
template <class _BiIter>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::insert(const_iterator __p, _BiIter __f, _BiIter __l,
                               typename enable_if<__is_bidirectional_iterator<_BiIter>::value>::type*)
{
    size_type __n = std::__1::distance(__f, __l);
    size_type __pos = __p - __base::begin();
    size_type __to_end = __base::size() - __pos;
    allocator_type& __a = __base::__alloc();
    if (__pos < __to_end)
    {
        if (__n > __front_spare())
            __add_front_capacity(__n - __front_spare());

        size_type __old_n = __n;
        iterator __old_begin = __base::begin();
        iterator __i = __old_begin;
        _BiIter __m = __f;
        if (__n > __pos)
        {
            __m = __pos < __n / 2 ? std::__1::prev(__l, __pos) : std::__1::next(__f, __n - __pos);
            for (_BiIter __j = __m; __j != __f; --__base::__start_, ++__base::size())
                __alloc_traits::construct(__a, std::__1::addressof(*--__i), *--__j);
            __n = __pos;
        }
        if (__n > 0)
        {
            iterator __obn = __old_begin + __n;
            for (iterator __j = __obn; __j != __old_begin;)
            {
                __alloc_traits::construct(__a, std::__1::addressof(*--__i), std::__1::move(*--__j));
                --__base::__start_;
                ++__base::size();
            }
            if (__n < __pos)
                __old_begin = std::__1::move(__obn, __old_begin + __pos, __old_begin);
            std::__1::copy(__m, __l, __old_begin);
        }
    }
    else
    {
        size_type __back_capacity = __back_spare();
        if (__n > __back_capacity)
            __add_back_capacity(__n - __back_capacity);

        size_type __old_n = __n;
        iterator __old_end = __base::end();
        iterator __i = __old_end;
        _BiIter __m = __l;
        size_type __de = __base::size() - __pos;
        if (__n > __de)
        {
            __m = __de < __n / 2 ? std::__1::next(__f, __de) : std::__1::prev(__l, __n - __de);
            for (_BiIter __j = __m; __j != __l; ++__i, ++__j, ++__base::size())
                __alloc_traits::construct(__a, std::__1::addressof(*__i), *__j);
            __n = __de;
        }
        if (__n > 0)
        {
            iterator __oen = __old_end - __n;
            for (iterator __j = __oen; __j != __old_end; ++__i, ++__j, ++__base::size())
                __alloc_traits::construct(__a, std::__1::addressof(*__i), std::__1::move(*__j));
            if (__n < __de)
                __old_end = std::__1::move_backward(__old_end - __de, __oen, __old_end);
            std::__1::copy_backward(__f, __m, __old_end);
        }
    }
    return __base::begin() + __pos;
}

template <class _Tp, class _Allocator>
template <class _InpIter>
void
deque<_Tp, _Allocator>::__append(_InpIter __f, _InpIter __l,
                                 typename enable_if<__is_input_iterator<_InpIter>::value &&
                                                   !__is_forward_iterator<_InpIter>::value>::type*)
{
    for (; __f != __l; ++__f)
        push_back(*__f);
}

template <class _Tp, class _Allocator>
template <class _ForIter>
void
deque<_Tp, _Allocator>::__append(_ForIter __f, _ForIter __l,
                                 typename enable_if<__is_forward_iterator<_ForIter>::value>::type*)
{
    size_type __n = std::__1::distance(__f, __l);
    allocator_type& __a = __base::__alloc();
    size_type __back_capacity = __back_spare();
    if (__n > __back_capacity)
        __add_back_capacity(__n - __back_capacity);

    for (iterator __i = __base::end(); __f != __l; ++__i, ++__f, ++__base::size())
        __alloc_traits::construct(__a, std::__1::addressof(*__i), *__f);
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__append(size_type __n)
{
    allocator_type& __a = __base::__alloc();
    size_type __back_capacity = __back_spare();
    if (__n > __back_capacity)
        __add_back_capacity(__n - __back_capacity);

    for (iterator __i = __base::end(); __n; --__n, ++__i, ++__base::size())
        __alloc_traits::construct(__a, std::__1::addressof(*__i));
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__append(size_type __n, const value_type& __v)
{
    allocator_type& __a = __base::__alloc();
    size_type __back_capacity = __back_spare();
    if (__n > __back_capacity)
        __add_back_capacity(__n - __back_capacity);

    for (iterator __i = __base::end(); __n; --__n, ++__i, ++__base::size())
        __alloc_traits::construct(__a, std::__1::addressof(*__i), __v);
}



template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__add_front_capacity()
{
    allocator_type& __a = __base::__alloc();
    if (__back_spare() >= __base::__block_size)
    {
        __base::__start_ += __base::__block_size;
        pointer __pt = __base::__map_.back();
        __base::__map_.pop_back();
        __base::__map_.push_front(__pt);
    }

    else if (__base::__map_.size() < __base::__map_.capacity())
    {


        if (__base::__map_.__front_spare() > 0)
            __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));
        else
        {
            __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));

            pointer __pt = __base::__map_.back();
            __base::__map_.pop_back();
            __base::__map_.push_front(__pt);
        }
        __base::__start_ = __base::__map_.size() == 1 ?
                               __base::__block_size / 2 :
                               __base::__start_ + __base::__block_size;
    }

    else
    {
        __split_buffer<pointer, typename __base::__pointer_allocator&>
            __buf(max<size_type>(2 * __base::__map_.capacity(), 1),
                  0, __base::__map_.__alloc());




            __buf.push_back(__alloc_traits::allocate(__a, __base::__block_size));
# 2285 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/deque" 3
        for (typename __base::__map_pointer __i = __base::__map_.begin();
                __i != __base::__map_.end(); ++__i)
            __buf.push_back(*__i);
        std::__1::swap(__base::__map_.__first_, __buf.__first_);
        std::__1::swap(__base::__map_.__begin_, __buf.__begin_);
        std::__1::swap(__base::__map_.__end_, __buf.__end_);
        std::__1::swap(__base::__map_.__end_cap(), __buf.__end_cap());
        __base::__start_ = __base::__map_.size() == 1 ?
                               __base::__block_size / 2 :
                               __base::__start_ + __base::__block_size;
    }
}



template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__add_front_capacity(size_type __n)
{
    allocator_type& __a = __base::__alloc();
    size_type __nb = __recommend_blocks(__n + __base::__map_.empty());

    size_type __back_capacity = __back_spare() / __base::__block_size;
    __back_capacity = std::__1::min(__back_capacity, __nb);
    __nb -= __back_capacity;

    if (__nb == 0)
    {
        __base::__start_ += __base::__block_size * __back_capacity;
        for (; __back_capacity > 0; --__back_capacity)
        {
            pointer __pt = __base::__map_.back();
            __base::__map_.pop_back();
            __base::__map_.push_front(__pt);
        }
    }

    else if (__nb <= __base::__map_.capacity() - __base::__map_.size())
    {


        for (; __nb > 0; --__nb, __base::__start_ += __base::__block_size - (__base::__map_.size() == 1))
        {
            if (__base::__map_.__front_spare() == 0)
                break;
            __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));
        }
        for (; __nb > 0; --__nb, ++__back_capacity)
            __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));

        __base::__start_ += __back_capacity * __base::__block_size;
        for (; __back_capacity > 0; --__back_capacity)
        {
            pointer __pt = __base::__map_.back();
            __base::__map_.pop_back();
            __base::__map_.push_front(__pt);
        }
    }

    else
    {
        size_type __ds = (__nb + __back_capacity) * __base::__block_size - __base::__map_.empty();
        __split_buffer<pointer, typename __base::__pointer_allocator&>
            __buf(max<size_type>(2* __base::__map_.capacity(),
                                 __nb + __base::__map_.size()),
                  0, __base::__map_.__alloc());




            for (; __nb > 0; --__nb)
                __buf.push_back(__alloc_traits::allocate(__a, __base::__block_size));
# 2367 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/deque" 3
        for (; __back_capacity > 0; --__back_capacity)
        {
            __buf.push_back(__base::__map_.back());
            __base::__map_.pop_back();
        }
        for (typename __base::__map_pointer __i = __base::__map_.begin();
                __i != __base::__map_.end(); ++__i)
            __buf.push_back(*__i);
        std::__1::swap(__base::__map_.__first_, __buf.__first_);
        std::__1::swap(__base::__map_.__begin_, __buf.__begin_);
        std::__1::swap(__base::__map_.__end_, __buf.__end_);
        std::__1::swap(__base::__map_.__end_cap(), __buf.__end_cap());
        __base::__start_ += __ds;
    }
}



template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__add_back_capacity()
{
    allocator_type& __a = __base::__alloc();
    if (__front_spare() >= __base::__block_size)
    {
        __base::__start_ -= __base::__block_size;
        pointer __pt = __base::__map_.front();
        __base::__map_.pop_front();
        __base::__map_.push_back(__pt);
    }

    else if (__base::__map_.size() < __base::__map_.capacity())
    {


        if (__base::__map_.__back_spare() != 0)
            __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));
        else
        {
            __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));

            pointer __pt = __base::__map_.front();
            __base::__map_.pop_front();
            __base::__map_.push_back(__pt);
        }
    }

    else
    {
        __split_buffer<pointer, typename __base::__pointer_allocator&>
            __buf(max<size_type>(2* __base::__map_.capacity(), 1),
                  __base::__map_.size(),
                  __base::__map_.__alloc());




            __buf.push_back(__alloc_traits::allocate(__a, __base::__block_size));
# 2433 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/deque" 3
        for (typename __base::__map_pointer __i = __base::__map_.end();
                __i != __base::__map_.begin();)
            __buf.push_front(*--__i);
        std::__1::swap(__base::__map_.__first_, __buf.__first_);
        std::__1::swap(__base::__map_.__begin_, __buf.__begin_);
        std::__1::swap(__base::__map_.__end_, __buf.__end_);
        std::__1::swap(__base::__map_.__end_cap(), __buf.__end_cap());
    }
}



template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__add_back_capacity(size_type __n)
{
    allocator_type& __a = __base::__alloc();
    size_type __nb = __recommend_blocks(__n + __base::__map_.empty());

    size_type __front_capacity = __front_spare() / __base::__block_size;
    __front_capacity = std::__1::min(__front_capacity, __nb);
    __nb -= __front_capacity;

    if (__nb == 0)
    {
        __base::__start_ -= __base::__block_size * __front_capacity;
        for (; __front_capacity > 0; --__front_capacity)
        {
            pointer __pt = __base::__map_.front();
            __base::__map_.pop_front();
            __base::__map_.push_back(__pt);
        }
    }

    else if (__nb <= __base::__map_.capacity() - __base::__map_.size())
    {


        for (; __nb > 0; --__nb)
        {
            if (__base::__map_.__back_spare() == 0)
                break;
            __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));
        }
        for (; __nb > 0; --__nb, ++__front_capacity, __base::__start_ +=
                                 __base::__block_size - (__base::__map_.size() == 1))
            __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));

        __base::__start_ -= __base::__block_size * __front_capacity;
        for (; __front_capacity > 0; --__front_capacity)
        {
            pointer __pt = __base::__map_.front();
            __base::__map_.pop_front();
            __base::__map_.push_back(__pt);
        }
    }

    else
    {
        size_type __ds = __front_capacity * __base::__block_size;
        __split_buffer<pointer, typename __base::__pointer_allocator&>
            __buf(max<size_type>(2* __base::__map_.capacity(),
                                 __nb + __base::__map_.size()),
                  __base::__map_.size() - __front_capacity,
                  __base::__map_.__alloc());




            for (; __nb > 0; --__nb)
                __buf.push_back(__alloc_traits::allocate(__a, __base::__block_size));
# 2514 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/deque" 3
        for (; __front_capacity > 0; --__front_capacity)
        {
            __buf.push_back(__base::__map_.front());
            __base::__map_.pop_front();
        }
        for (typename __base::__map_pointer __i = __base::__map_.end();
                __i != __base::__map_.begin();)
            __buf.push_front(*--__i);
        std::__1::swap(__base::__map_.__first_, __buf.__first_);
        std::__1::swap(__base::__map_.__begin_, __buf.__begin_);
        std::__1::swap(__base::__map_.__end_, __buf.__end_);
        std::__1::swap(__base::__map_.__end_cap(), __buf.__end_cap());
        __base::__start_ -= __ds;
    }
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::pop_front()
{
    allocator_type& __a = __base::__alloc();
    __alloc_traits::destroy(__a, __to_raw_pointer(*(__base::__map_.begin() +
                                                    __base::__start_ / __base::__block_size) +
                                                    __base::__start_ % __base::__block_size));
    --__base::size();
    if (++__base::__start_ >= 2 * __base::__block_size)
    {
        __alloc_traits::deallocate(__a, __base::__map_.front(), __base::__block_size);
        __base::__map_.pop_front();
        __base::__start_ -= __base::__block_size;
    }
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::pop_back()
{
    allocator_type& __a = __base::__alloc();
    size_type __p = __base::size() + __base::__start_ - 1;
    __alloc_traits::destroy(__a, __to_raw_pointer(*(__base::__map_.begin() +
                                                    __p / __base::__block_size) +
                                                    __p % __base::__block_size));
    --__base::size();
    if (__back_spare() >= 2 * __base::__block_size)
    {
        __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);
        __base::__map_.pop_back();
    }
}



template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::__move_and_check(iterator __f, iterator __l, iterator __r,
                                         const_pointer& __vt)
{



    difference_type __n = __l - __f;
    while (__n > 0)
    {
        pointer __fb = __f.__ptr_;
        pointer __fe = *__f.__m_iter_ + __base::__block_size;
        difference_type __bs = __fe - __fb;
        if (__bs > __n)
        {
            __bs = __n;
            __fe = __fb + __bs;
        }
        if (__fb <= __vt && __vt < __fe)
            __vt = (const_iterator(static_cast<__map_const_pointer>(__f.__m_iter_), __vt) -= __f - __r).__ptr_;
        __r = std::__1::move(__fb, __fe, __r);
        __n -= __bs;
        __f += __bs;
    }
    return __r;
}



template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::__move_backward_and_check(iterator __f, iterator __l, iterator __r,
                                                  const_pointer& __vt)
{



    difference_type __n = __l - __f;
    while (__n > 0)
    {
        --__l;
        pointer __lb = *__l.__m_iter_;
        pointer __le = __l.__ptr_ + 1;
        difference_type __bs = __le - __lb;
        if (__bs > __n)
        {
            __bs = __n;
            __lb = __le - __bs;
        }
        if (__lb <= __vt && __vt < __le)
            __vt = (const_iterator(static_cast<__map_const_pointer>(__l.__m_iter_), __vt) += __r - __l - 1).__ptr_;
        __r = std::__1::move_backward(__lb, __le, __r);
        __n -= __bs;
        __l -= __bs - 1;
    }
    return __r;
}



template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__move_construct_and_check(iterator __f, iterator __l,
                                                   iterator __r, const_pointer& __vt)
{
    allocator_type& __a = __base::__alloc();



    difference_type __n = __l - __f;
    while (__n > 0)
    {
        pointer __fb = __f.__ptr_;
        pointer __fe = *__f.__m_iter_ + __base::__block_size;
        difference_type __bs = __fe - __fb;
        if (__bs > __n)
        {
            __bs = __n;
            __fe = __fb + __bs;
        }
        if (__fb <= __vt && __vt < __fe)
            __vt = (const_iterator(static_cast<__map_const_pointer>(__f.__m_iter_), __vt) += __r - __f).__ptr_;
        for (; __fb != __fe; ++__fb, ++__r, ++__base::size())
            __alloc_traits::construct(__a, std::__1::addressof(*__r), std::__1::move(*__fb));
        __n -= __bs;
        __f += __bs;
    }
}



template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__move_construct_backward_and_check(iterator __f, iterator __l,
                                                            iterator __r, const_pointer& __vt)
{
    allocator_type& __a = __base::__alloc();







    difference_type __n = __l - __f;
    while (__n > 0)
    {
        --__l;
        pointer __lb = *__l.__m_iter_;
        pointer __le = __l.__ptr_ + 1;
        difference_type __bs = __le - __lb;
        if (__bs > __n)
        {
            __bs = __n;
            __lb = __le - __bs;
        }
        if (__lb <= __vt && __vt < __le)
            __vt = (const_iterator(static_cast<__map_const_pointer>(__l.__m_iter_), __vt) -= __l - __r + 1).__ptr_;
        while (__le != __lb)
        {
            __alloc_traits::construct(__a, std::__1::addressof(*--__r), std::__1::move(*--__le));
            --__base::__start_;
            ++__base::size();
        }
        __n -= __bs;
        __l -= __bs - 1;
    }
}

template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::erase(const_iterator __f)
{
    difference_type __n = 1;
    iterator __b = __base::begin();
    difference_type __pos = __f - __b;
    iterator __p = __b + __pos;
    allocator_type& __a = __base::__alloc();
    if (__pos < (__base::size() - 1) / 2)
    {
        std::__1::move_backward(__b, __p, std::__1::next(__p));
        __alloc_traits::destroy(__a, std::__1::addressof(*__b));
        --__base::size();
        ++__base::__start_;
        if (__front_spare() >= 2 * __base::__block_size)
        {
            __alloc_traits::deallocate(__a, __base::__map_.front(), __base::__block_size);
            __base::__map_.pop_front();
            __base::__start_ -= __base::__block_size;
        }
    }
    else
    {
        iterator __i = std::__1::move(std::__1::next(__p), __base::end(), __p);
        __alloc_traits::destroy(__a, std::__1::addressof(*__i));
        --__base::size();
        if (__back_spare() >= 2 * __base::__block_size)
        {
            __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);
            __base::__map_.pop_back();
        }
    }
    return __base::begin() + __pos;
}

template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::erase(const_iterator __f, const_iterator __l)
{
    difference_type __n = __l - __f;
    iterator __b = __base::begin();
    difference_type __pos = __f - __b;
    iterator __p = __b + __pos;
    if (__n > 0)
    {
        allocator_type& __a = __base::__alloc();
        if (__pos < (__base::size() - __n) / 2)
        {
            iterator __i = std::__1::move_backward(__b, __p, __p + __n);
            for (; __b != __i; ++__b)
                __alloc_traits::destroy(__a, std::__1::addressof(*__b));
            __base::size() -= __n;
            __base::__start_ += __n;
            while (__front_spare() >= 2 * __base::__block_size)
            {
                __alloc_traits::deallocate(__a, __base::__map_.front(), __base::__block_size);
                __base::__map_.pop_front();
                __base::__start_ -= __base::__block_size;
            }
        }
        else
        {
            iterator __i = std::__1::move(__p + __n, __base::end(), __p);
            for (iterator __e = __base::end(); __i != __e; ++__i)
                __alloc_traits::destroy(__a, std::__1::addressof(*__i));
            __base::size() -= __n;
            while (__back_spare() >= 2 * __base::__block_size)
            {
                __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);
                __base::__map_.pop_back();
            }
        }
    }
    return __base::begin() + __pos;
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__erase_to_end(const_iterator __f)
{
    iterator __e = __base::end();
    difference_type __n = __e - __f;
    if (__n > 0)
    {
        allocator_type& __a = __base::__alloc();
        iterator __b = __base::begin();
        difference_type __pos = __f - __b;
        for (iterator __p = __b + __pos; __p != __e; ++__p)
            __alloc_traits::destroy(__a, std::__1::addressof(*__p));
        __base::size() -= __n;
        while (__back_spare() >= 2 * __base::__block_size)
        {
            __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);
            __base::__map_.pop_back();
        }
    }
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
deque<_Tp, _Allocator>::swap(deque& __c)


{
    __base::swap(__c);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
deque<_Tp, _Allocator>::clear() throw()
{
    __base::clear();
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)
{
    const typename deque<_Tp, _Allocator>::size_type __sz = __x.size();
    return __sz == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(deque<_Tp, _Allocator>& __x, deque<_Tp, _Allocator>& __y)

{
    __x.swap(__y);
}

} }
# 87 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/stack" 2 3
# 90 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/stack" 3


namespace std {inline namespace __1 {

template <class _Tp, class _Container> class __attribute__ ((__type_visibility__("default"))) stack;

template <class _Tp, class _Container>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y);

template <class _Tp, class _Container>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y);

template <class _Tp, class _Container = deque<_Tp> >
class __attribute__ ((__type_visibility__("default"))) stack
{
public:
    typedef _Container container_type;
    typedef typename container_type::value_type value_type;
    typedef typename container_type::reference reference;
    typedef typename container_type::const_reference const_reference;
    typedef typename container_type::size_type size_type;

protected:
    container_type c;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    stack()

        : c() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    stack(const stack& __q) : c(__q.c) {}
# 135 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/stack" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    stack& operator=(const stack& __q) {c = __q.c; return *this;}
# 145 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/stack" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit stack(const container_type& __c) : c(__c) {}




    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        explicit stack(const _Alloc& __a,
                       typename enable_if<uses_allocator<container_type,
                                                         _Alloc>::value>::type* = 0)
            : c(__a) {}
    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        stack(const container_type& __c, const _Alloc& __a,
              typename enable_if<uses_allocator<container_type,
                                                _Alloc>::value>::type* = 0)
            : c(__c, __a) {}
    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        stack(const stack& __s, const _Alloc& __a,
              typename enable_if<uses_allocator<container_type,
                                                _Alloc>::value>::type* = 0)
            : c(__s.c, __a) {}
# 184 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/stack" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool empty() const {return c.empty();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type size() const {return c.size();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    reference top() {return c.back();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reference top() const {return c.back();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void push(const value_type& __v) {c.push_back(__v);}
# 205 "/mnt/home/ec2-user/build/emscripten/system/include/libcxx/stack" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void pop() {c.pop_back();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(stack& __s)

    {
        using std::__1::swap;
        swap(c, __s.c);
    }

    template <class T1, class _C1>
    friend
    bool
    operator==(const stack<T1, _C1>& __x, const stack<T1, _C1>& __y);

    template <class T1, class _C1>
    friend
    bool
    operator< (const stack<T1, _C1>& __x, const stack<T1, _C1>& __y);
};

template <class _Tp, class _Container>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y)
{
    return __x.c == __y.c;
}

template <class _Tp, class _Container>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y)
{
    return __x.c < __y.c;
}

template <class _Tp, class _Container>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y)
{
    return !(__x == __y);
}

template <class _Tp, class _Container>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y)
{
    return __y < __x;
}

template <class _Tp, class _Container>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y)
{
    return !(__x < __y);
}

template <class _Tp, class _Container>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y)
{
    return !(__y < __x);
}

template <class _Tp, class _Container>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(stack<_Tp, _Container>& __x, stack<_Tp, _Container>& __y)

{
    __x.swap(__y);
}

template <class _Tp, class _Container, class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) uses_allocator<stack<_Tp, _Container>, _Alloc>
    : public uses_allocator<_Container, _Alloc>
{
};

} }
# 41 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h" 2







namespace llvm {
namespace sys {
namespace fs {



struct file_type {
  enum _ {
    status_error,
    file_not_found,
    regular_file,
    directory_file,
    symlink_file,
    block_file,
    character_file,
    fifo_file,
    socket_file,
    type_unknown
  };

  file_type(_ v) : v_(v) {}
  explicit file_type(int v) : v_(_(v)) {}
  operator int() const {return v_;}

private:
  int v_;
};


struct space_info {
  uint64_t capacity;
  uint64_t free;
  uint64_t available;
};

enum perms {
  no_perms = 0,
  owner_read = 0400,
  owner_write = 0200,
  owner_exe = 0100,
  owner_all = owner_read | owner_write | owner_exe,
  group_read = 040,
  group_write = 020,
  group_exe = 010,
  group_all = group_read | group_write | group_exe,
  others_read = 04,
  others_write = 02,
  others_exe = 01,
  others_all = others_read | others_write | others_exe,
  all_read = owner_read | group_read | others_read,
  all_write = owner_write | group_write | others_write,
  all_exe = owner_exe | group_exe | others_exe,
  all_all = owner_all | group_all | others_all,
  set_uid_on_exe = 04000,
  set_gid_on_exe = 02000,
  sticky_bit = 01000,
  perms_not_known = 0xFFFF
};


inline perms operator|(perms l , perms r) {
  return static_cast<perms>(
             static_cast<unsigned short>(l) | static_cast<unsigned short>(r));
}
inline perms operator&(perms l , perms r) {
  return static_cast<perms>(
             static_cast<unsigned short>(l) & static_cast<unsigned short>(r));
}
inline perms &operator|=(perms &l, perms r) {
  l = l | r;
  return l;
}
inline perms &operator&=(perms &l, perms r) {
  l = l & r;
  return l;
}
inline perms operator~(perms x) {
  return static_cast<perms>(~static_cast<unsigned short>(x));
}

class UniqueID {
  uint64_t Device;
  uint64_t File;

public:
  UniqueID() {}
  UniqueID(uint64_t Device, uint64_t File) : Device(Device), File(File) {}
  bool operator==(const UniqueID &Other) const {
    return Device == Other.Device && File == Other.File;
  }
  bool operator!=(const UniqueID &Other) const { return !(*this == Other); }
  bool operator<(const UniqueID &Other) const {
    return Device < Other.Device ||
           (Device == Other.Device && File < Other.File);
  }
  uint64_t getDevice() const { return Device; }
  uint64_t getFile() const { return File; }
};



class file_status
{

  dev_t fs_st_dev;
  ino_t fs_st_ino;
  time_t fs_st_mtime;
  uid_t fs_st_uid;
  gid_t fs_st_gid;
  off_t fs_st_size;
# 167 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h"
  friend bool equivalent(file_status A, file_status B);
  file_type Type;
  perms Perms;
public:
  file_status() : Type(file_type::status_error) {}
  file_status(file_type Type) : Type(Type) {}


    file_status(file_type Type, perms Perms, dev_t Dev, ino_t Ino, time_t MTime,
                uid_t UID, gid_t GID, off_t Size)
        : fs_st_dev(Dev), fs_st_ino(Ino), fs_st_mtime(MTime), fs_st_uid(UID),
          fs_st_gid(GID), fs_st_size(Size), Type(Type), Perms(Perms) {}
# 192 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h"
  file_type type() const { return Type; }
  perms permissions() const { return Perms; }
  TimeValue getLastModificationTime() const;
  UniqueID getUniqueID() const;


  uint32_t getUser() const { return fs_st_uid; }
  uint32_t getGroup() const { return fs_st_gid; }
  uint64_t getSize() const { return fs_st_size; }
# 214 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h"
  void type(file_type v) { Type = v; }
  void permissions(perms p) { Perms = p; }
};



struct file_magic {
  enum Impl {
    unknown = 0,
    bitcode,
    archive,
    elf_relocatable,
    elf_executable,
    elf_shared_object,
    elf_core,
    macho_object,
    macho_executable,
    macho_fixed_virtual_memory_shared_lib,
    macho_core,
    macho_preload_executable,
    macho_dynamically_linked_shared_lib,
    macho_dynamic_linker,
    macho_bundle,
    macho_dynamically_linked_shared_lib_stub,
    macho_dsym_companion,
    macho_universal_binary,
    coff_object,
    coff_import_library,
    pecoff_executable,
    windows_resource
  };

  bool is_object() const {
    return V == unknown ? false : true;
  }

  file_magic() : V(unknown) {}
  file_magic(Impl V) : V(V) {}
  operator Impl() const { return V; }

private:
  Impl V;
};
# 273 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h"
error_code make_absolute(SmallVectorImpl<char> &path);







error_code create_directories(const Twine &path, bool &existed);



inline error_code create_directories(const Twine &Path) {
  bool Existed;
  return create_directories(Path, Existed);
}







error_code create_directory(const Twine &path, bool &existed);



inline error_code create_directory(const Twine &Path) {
  bool Existed;
  return create_directory(Path, Existed);
}







error_code create_hard_link(const Twine &to, const Twine &from);







error_code create_symlink(const Twine &to, const Twine &from);






error_code current_path(SmallVectorImpl<char> &result);
# 335 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h"
error_code remove(const Twine &path, bool &existed);



inline error_code remove(const Twine &Path) {
  bool Existed;
  return remove(Path, Existed);
}
# 351 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h"
error_code remove_all(const Twine &path, uint32_t &num_removed);



inline error_code remove_all(const Twine &Path) {
  uint32_t Removed;
  return remove_all(Path, Removed);
}





error_code rename(const Twine &from, const Twine &to);







error_code resize_file(const Twine &path, uint64_t size);
# 383 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h"
bool exists(file_status status);
# 392 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h"
error_code exists(const Twine &path, bool &result);



inline bool exists(const Twine &path) {
  bool result;
  return !exists(path, result) && result;
}





bool can_execute(const Twine &Path);





bool can_write(const Twine &Path);
# 422 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h"
bool equivalent(file_status A, file_status B);
# 434 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h"
error_code equivalent(const Twine &A, const Twine &B, bool &result);



inline bool equivalent(const Twine &A, const Twine &B) {
  bool result;
  return !equivalent(A, B, result) && result;
}





bool is_directory(file_status status);
# 456 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h"
error_code is_directory(const Twine &path, bool &result);



inline bool is_directory(const Twine &Path) {
  bool Result;
  return !is_directory(Path, Result) && Result;
}





bool is_regular_file(file_status status);
# 478 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h"
error_code is_regular_file(const Twine &path, bool &result);



inline bool is_regular_file(const Twine &Path) {
  bool Result;
  if (is_regular_file(Path, Result))
    return false;
  return Result;
}







bool is_other(file_status status);
# 505 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h"
error_code is_other(const Twine &path, bool &result);





bool is_symlink(file_status status);
# 520 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h"
error_code is_symlink(const Twine &path, bool &result);







error_code status(const Twine &path, file_status &result);


error_code status(int FD, file_status &Result);







inline error_code file_size(const Twine &Path, uint64_t &Result) {
  file_status Status;
  error_code EC = status(Path, Status);
  if (EC)
    return EC;
  Result = Status.getSize();
  return error_code::success();
}

error_code setLastModificationAndAccessTime(int FD, TimeValue Time);





bool status_known(file_status s);







error_code status_known(const Twine &path, bool &result);
# 585 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h"
error_code createUniqueFile(const Twine &Model, int &ResultFD,
                            SmallVectorImpl<char> &ResultPath,
                            unsigned Mode = all_read | all_write);


error_code createUniqueFile(const Twine &Model,
                            SmallVectorImpl<char> &ResultPath);
# 601 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h"
error_code createTemporaryFile(const Twine &Prefix, StringRef Suffix,
                               int &ResultFD,
                               SmallVectorImpl<char> &ResultPath);


error_code createTemporaryFile(const Twine &Prefix, StringRef Suffix,
                               SmallVectorImpl<char> &ResultPath);

error_code createUniqueDirectory(const Twine &Prefix,
                                 SmallVectorImpl<char> &ResultPath);

enum OpenFlags {
  F_None = 0,



  F_Excl = 1,




  F_Append = 2,



  F_Binary = 4
};

inline OpenFlags operator|(OpenFlags A, OpenFlags B) {
  return OpenFlags(unsigned(A) | unsigned(B));
}

inline OpenFlags &operator|=(OpenFlags &A, OpenFlags B) {
  A = A | B;
  return A;
}

error_code openFileForWrite(const Twine &Name, int &ResultFD, OpenFlags Flags,
                            unsigned Mode = 0666);

error_code openFileForRead(const Twine &Name, int &ResultFD);







error_code has_magic(const Twine &path, const Twine &magic, bool &result);
# 661 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h"
error_code get_magic(const Twine &path, uint32_t len,
                     SmallVectorImpl<char> &result);


file_magic identify_magic(StringRef magic);







error_code identify_magic(const Twine &path, file_magic &result);

error_code getUniqueID(const Twine Path, UniqueID &Result);



class mapped_file_region {
  mapped_file_region() ;
  mapped_file_region(mapped_file_region&) ;
  mapped_file_region &operator =(mapped_file_region&) ;

public:
  enum mapmode {
    readonly,
    readwrite,
    priv
  };

private:

  mapmode Mode;
  uint64_t Size;
  void *Mapping;






  error_code init(int FD, bool CloseFD, uint64_t Offset);

public:
  typedef char char_type;
# 726 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h"
  mapped_file_region(const Twine &path,
                     mapmode mode,
                     uint64_t length,
                     uint64_t offset,
                     error_code &ec);




  mapped_file_region(int fd,
                     bool closefd,
                     mapmode mode,
                     uint64_t length,
                     uint64_t offset,
                     error_code &ec);

  ~mapped_file_region();

  mapmode flags() const;
  uint64_t size() const;
  char *data() const;



  const char *const_data() const;


  static int alignment();
};
# 768 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h"
error_code map_file_pages(const Twine &path, off_t file_offset, size_t size,
                          bool map_writable, void *&result);
# 778 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h"
error_code unmap_file_pages(void *base, size_t size);




std::string getMainExecutable(const char *argv0, void *MainExecAddr);
# 792 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h"
class directory_entry {
  std::string Path;
  mutable file_status Status;

public:
  explicit directory_entry(const Twine &path, file_status st = file_status())
    : Path(path.str())
    , Status(st) {}

  directory_entry() {}

  void assign(const Twine &path, file_status st = file_status()) {
    Path = path.str();
    Status = st;
  }

  void replace_filename(const Twine &filename, file_status st = file_status());

  const std::string &path() const { return Path; }
  error_code status(file_status &result) const;

  bool operator==(const directory_entry& rhs) const { return Path == rhs.Path; }
  bool operator!=(const directory_entry& rhs) const { return !(*this == rhs); }
  bool operator< (const directory_entry& rhs) const;
  bool operator<=(const directory_entry& rhs) const;
  bool operator> (const directory_entry& rhs) const;
  bool operator>=(const directory_entry& rhs) const;
};

namespace detail {
  struct DirIterState;

  error_code directory_iterator_construct(DirIterState&, StringRef);
  error_code directory_iterator_increment(DirIterState&);
  error_code directory_iterator_destruct(DirIterState&);



  struct DirIterState : public RefCountedBase<DirIterState> {
    DirIterState()
      : IterationHandle(0) {}

    ~DirIterState() {
      directory_iterator_destruct(*this);
    }

    intptr_t IterationHandle;
    directory_entry CurrentEntry;
  };
}




class directory_iterator {
  IntrusiveRefCntPtr<detail::DirIterState> State;

public:
  explicit directory_iterator(const Twine &path, error_code &ec) {
    State = new detail::DirIterState;
    SmallString<128> path_storage;
    ec = detail::directory_iterator_construct(*State,
            path.toStringRef(path_storage));
  }

  explicit directory_iterator(const directory_entry &de, error_code &ec) {
    State = new detail::DirIterState;
    ec = detail::directory_iterator_construct(*State, de.path());
  }


  directory_iterator() : State(0) {}


  directory_iterator &increment(error_code &ec) {
    ec = directory_iterator_increment(*State);
    return *this;
  }

  const directory_entry &operator*() const { return State->CurrentEntry; }
  const directory_entry *operator->() const { return &State->CurrentEntry; }

  bool operator==(const directory_iterator &RHS) const {
    if (State == RHS.State)
      return true;
    if (RHS.State == 0)
      return State->CurrentEntry == directory_entry();
    if (State == 0)
      return RHS.State->CurrentEntry == directory_entry();
    return State->CurrentEntry == RHS.State->CurrentEntry;
  }

  bool operator!=(const directory_iterator &RHS) const {
    return !(*this == RHS);
  }


};

namespace detail {


  struct RecDirIterState : public RefCountedBase<RecDirIterState> {
    RecDirIterState()
      : Level(0)
      , HasNoPushRequest(false) {}

    std::stack<directory_iterator, std::vector<directory_iterator> > Stack;
    uint16_t Level;
    bool HasNoPushRequest;
  };
}



class recursive_directory_iterator {
  IntrusiveRefCntPtr<detail::RecDirIterState> State;

public:
  recursive_directory_iterator() {}
  explicit recursive_directory_iterator(const Twine &path, error_code &ec)
    : State(new detail::RecDirIterState) {
    State->Stack.push(directory_iterator(path, ec));
    if (State->Stack.top() == directory_iterator())
      State.reset();
  }

  recursive_directory_iterator &increment(error_code &ec) {
    const directory_iterator end_itr;

    if (State->HasNoPushRequest)
      State->HasNoPushRequest = false;
    else {
      file_status st;
      if ((ec = State->Stack.top()->status(st))) return *this;
      if (is_directory(st)) {
        State->Stack.push(directory_iterator(*State->Stack.top(), ec));
        if (ec) return *this;
        if (State->Stack.top() != end_itr) {
          ++State->Level;
          return *this;
        }
        State->Stack.pop();
      }
    }

    while (!State->Stack.empty()
           && State->Stack.top().increment(ec) == end_itr) {
      State->Stack.pop();
      --State->Level;
    }


    if (State->Stack.empty())
      State.reset();

    return *this;
  }

  const directory_entry &operator*() const { return *State->Stack.top(); }
  const directory_entry *operator->() const { return &*State->Stack.top(); }



  int level() const { return State->Level; }


  bool no_push_request() const { return State->HasNoPushRequest; }



  void pop() {
    ((void)((State && "Cannot pop an end iterator!") || (__assert_fail("State && \"Cannot pop an end iterator!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h", 964, __func__),0)));
    ((void)((State->Level > 0 && "Cannot pop an iterator with level < 1") || (__assert_fail("State->Level > 0 && \"Cannot pop an iterator with level < 1\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/FileSystem.h", 965, __func__),0)));

    const directory_iterator end_itr;
    error_code ec;
    do {
      if (ec)
        report_fatal_error("Error incrementing directory iterator.");
      State->Stack.pop();
      --State->Level;
    } while (!State->Stack.empty()
             && State->Stack.top().increment(ec) == end_itr);


    if (State->Stack.empty())
      State.reset();
  }


  void no_push() { State->HasNoPushRequest = true; }

  bool operator==(const recursive_directory_iterator &RHS) const {
    return State == RHS.State;
  }

  bool operator!=(const recursive_directory_iterator &RHS) const {
    return !(*this == RHS);
  }


};



}
}
}
# 21 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/raw_ostream.h" 2

namespace llvm {
  class format_object_base;
  template <typename T>
  class SmallVectorImpl;





class raw_ostream {
private:
  void operator=(const raw_ostream &) ;
  raw_ostream(const raw_ostream &) ;
# 54 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/raw_ostream.h"
  char *OutBufStart, *OutBufEnd, *OutBufCur;

  enum BufferKind {
    Unbuffered = 0,
    InternalBuffer,
    ExternalBuffer
  } BufferMode;

public:

  enum Colors {
    BLACK=0,
    RED,
    GREEN,
    YELLOW,
    BLUE,
    MAGENTA,
    CYAN,
    WHITE,
    SAVEDCOLOR
  };

  explicit raw_ostream(bool unbuffered=false)
    : BufferMode(unbuffered ? Unbuffered : InternalBuffer) {

    OutBufStart = OutBufEnd = OutBufCur = 0;
  }

  virtual ~raw_ostream();


  uint64_t tell() const { return current_pos() + GetNumBytesInBuffer(); }







  void SetBuffered();



  void SetBufferSize(size_t Size) {
    flush();
    SetBufferAndMode(new char[Size], Size, InternalBuffer);
  }

  size_t GetBufferSize() const {


    if (BufferMode != Unbuffered && OutBufStart == 0)
      return preferred_buffer_size();


    return OutBufEnd - OutBufStart;
  }





  void SetUnbuffered() {
    flush();
    SetBufferAndMode(0, 0, Unbuffered);
  }

  size_t GetNumBytesInBuffer() const {
    return OutBufCur - OutBufStart;
  }





  void flush() {
    if (OutBufCur != OutBufStart)
      flush_nonempty();
  }

  raw_ostream &operator<<(char C) {
    if (OutBufCur >= OutBufEnd)
      return write(C);
    *OutBufCur++ = C;
    return *this;
  }

  raw_ostream &operator<<(unsigned char C) {
    if (OutBufCur >= OutBufEnd)
      return write(C);
    *OutBufCur++ = C;
    return *this;
  }

  raw_ostream &operator<<(signed char C) {
    if (OutBufCur >= OutBufEnd)
      return write(C);
    *OutBufCur++ = C;
    return *this;
  }

  raw_ostream &operator<<(StringRef Str) {

    size_t Size = Str.size();


    if (OutBufCur+Size > OutBufEnd)
      return write(Str.data(), Size);

    memcpy(OutBufCur, Str.data(), Size);
    OutBufCur += Size;
    return *this;
  }

  raw_ostream &operator<<(const char *Str) {



    return this->operator<<(StringRef(Str));
  }

  raw_ostream &operator<<(const std::string &Str) {

    return write(Str.data(), Str.length());
  }

  raw_ostream &operator<<(unsigned long N);
  raw_ostream &operator<<(long N);
  raw_ostream &operator<<(unsigned long long N);
  raw_ostream &operator<<(long long N);
  raw_ostream &operator<<(const void *P);
  raw_ostream &operator<<(unsigned int N) {
    return this->operator<<(static_cast<unsigned long>(N));
  }

  raw_ostream &operator<<(int N) {
    return this->operator<<(static_cast<long>(N));
  }

  raw_ostream &operator<<(double N);


  raw_ostream &write_hex(unsigned long long N);



  raw_ostream &write_escaped(StringRef Str, bool UseHexEscapes = false);

  raw_ostream &write(unsigned char C);
  raw_ostream &write(const char *Ptr, size_t Size);


  raw_ostream &operator<<(const format_object_base &Fmt);


  raw_ostream &indent(unsigned NumSpaces);
# 219 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/raw_ostream.h"
  virtual raw_ostream &changeColor(enum Colors Color,
                                   bool Bold = false,
                                   bool BG = false) {
    (void)Color;
    (void)Bold;
    (void)BG;
    return *this;
  }



  virtual raw_ostream &resetColor() { return *this; }


  virtual raw_ostream &reverseColor() { return *this; }




  virtual bool is_displayed() const { return false; }


  virtual bool has_colors() const { return is_displayed(); }





private:
# 261 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/raw_ostream.h"
  virtual void write_impl(const char *Ptr, size_t Size) = 0;


  virtual void handle();



  virtual uint64_t current_pos() const = 0;

protected:




  void SetBuffer(char *BufferStart, size_t Size) {
    SetBufferAndMode(BufferStart, Size, ExternalBuffer);
  }



  virtual size_t preferred_buffer_size() const;



  const char *getBufferStart() const { return OutBufStart; }




private:

  void SetBufferAndMode(char *BufferStart, size_t Size, BufferKind Mode);




  void flush_nonempty();



  void copy_to_buffer(const char *Ptr, size_t Size);
};







class raw_fd_ostream : public raw_ostream {
  int FD;
  bool ShouldClose;



  bool Error;



  bool UseAtomicWrites;

  uint64_t pos;


  virtual void write_impl(const char *Ptr, size_t Size) ;



  virtual uint64_t current_pos() const { return pos; }


  virtual size_t preferred_buffer_size() const ;



  void error_detected() { Error = true; }

public:
# 349 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/raw_ostream.h"
  raw_fd_ostream(const char *Filename, std::string &ErrorInfo,
                 sys::fs::OpenFlags Flags = sys::fs::F_None);



  raw_fd_ostream(int fd, bool shouldClose, bool unbuffered=false);

  ~raw_fd_ostream();



  void close();



  uint64_t seek(uint64_t off);







  void SetUseAtomicWrites(bool Value) {
    UseAtomicWrites = Value;
  }

  virtual raw_ostream &changeColor(enum Colors colors, bool bold=false,
                                   bool bg=false) ;
  virtual raw_ostream &resetColor() ;

  virtual raw_ostream &reverseColor() ;

  virtual bool is_displayed() const ;

  virtual bool has_colors() const ;





  bool has_error() const {
    return Error;
  }
# 403 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Support/raw_ostream.h"
  void clear_error() {
    Error = false;
  }
};



raw_ostream &outs();



raw_ostream &errs();



raw_ostream &nulls();







class raw_string_ostream : public raw_ostream {
  std::string &OS;


  virtual void write_impl(const char *Ptr, size_t Size) ;



  virtual uint64_t current_pos() const { return OS.size(); }
public:
  explicit raw_string_ostream(std::string &O) : OS(O) {}
  ~raw_string_ostream();



  std::string& str() {
    flush();
    return OS;
  }
};




class raw_svector_ostream : public raw_ostream {
  SmallVectorImpl<char> &OS;


  virtual void write_impl(const char *Ptr, size_t Size) ;



  virtual uint64_t current_pos() const ;
public:




  explicit raw_svector_ostream(SmallVectorImpl<char> &O);
  ~raw_svector_ostream();




  void resync();



  StringRef str();
};


class raw_null_ostream : public raw_ostream {

  virtual void write_impl(const char *Ptr, size_t size) ;



  virtual uint64_t current_pos() const ;

public:
  explicit raw_null_ostream() {}
  ~raw_null_ostream();
};

}
# 28 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/Dominators.h" 2


namespace llvm {





template <class NodeT>
class DominatorBase {
protected:
  std::vector<NodeT*> Roots;
  const bool IsPostDominators;
  inline explicit DominatorBase(bool isPostDom) :
    Roots(), IsPostDominators(isPostDom) {}
public:





  inline const std::vector<NodeT*> &getRoots() const { return Roots; }



  bool isPostDominator() const { return IsPostDominators; }
};




template<class NodeT> class DominatorTreeBase;
struct PostDominatorTree;
class MachineBasicBlock;

template <class NodeT>
class DomTreeNodeBase {
  NodeT *TheBB;
  DomTreeNodeBase<NodeT> *IDom;
  std::vector<DomTreeNodeBase<NodeT> *> Children;
  int DFSNumIn, DFSNumOut;

  template<class N> friend class DominatorTreeBase;
  friend struct PostDominatorTree;
public:
  typedef typename std::vector<DomTreeNodeBase<NodeT> *>::iterator iterator;
  typedef typename std::vector<DomTreeNodeBase<NodeT> *>::const_iterator
                   const_iterator;

  iterator begin() { return Children.begin(); }
  iterator end() { return Children.end(); }
  const_iterator begin() const { return Children.begin(); }
  const_iterator end() const { return Children.end(); }

  NodeT *getBlock() const { return TheBB; }
  DomTreeNodeBase<NodeT> *getIDom() const { return IDom; }
  const std::vector<DomTreeNodeBase<NodeT>*> &getChildren() const {
    return Children;
  }

  DomTreeNodeBase(NodeT *BB, DomTreeNodeBase<NodeT> *iDom)
    : TheBB(BB), IDom(iDom), DFSNumIn(-1), DFSNumOut(-1) { }

  DomTreeNodeBase<NodeT> *addChild(DomTreeNodeBase<NodeT> *C) {
    Children.push_back(C);
    return C;
  }

  size_t getNumChildren() const {
    return Children.size();
  }

  void clearAllChildren() {
    Children.clear();
  }

  bool compare(const DomTreeNodeBase<NodeT> *Other) const {
    if (getNumChildren() != Other->getNumChildren())
      return true;

    SmallPtrSet<const NodeT *, 4> OtherChildren;
    for (const_iterator I = Other->begin(), E = Other->end(); I != E; ++I) {
      const NodeT *Nd = (*I)->getBlock();
      OtherChildren.insert(Nd);
    }

    for (const_iterator I = begin(), E = end(); I != E; ++I) {
      const NodeT *N = (*I)->getBlock();
      if (OtherChildren.count(N) == 0)
        return true;
    }
    return false;
  }

  void setIDom(DomTreeNodeBase<NodeT> *NewIDom) {
    ((void)((IDom && "No immediate dominator?") || (__assert_fail("IDom && \"No immediate dominator?\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/Dominators.h", 123, __func__),0)));
    if (IDom != NewIDom) {
      typename std::vector<DomTreeNodeBase<NodeT>*>::iterator I =
                  std::find(IDom->Children.begin(), IDom->Children.end(), this);
      ((void)((I != IDom->Children.end() && "Not in immediate dominator children set!") || (__assert_fail("I != IDom->Children.end() && \"Not in immediate dominator children set!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/Dominators.h", 128, __func__),0)));


      IDom->Children.erase(I);


      IDom = NewIDom;
      IDom->Children.push_back(this);
    }
  }



  unsigned getDFSNumIn() const { return DFSNumIn; }
  unsigned getDFSNumOut() const { return DFSNumOut; }
private:


  bool DominatedBy(const DomTreeNodeBase<NodeT> *other) const {
    return this->DFSNumIn >= other->DFSNumIn &&
      this->DFSNumOut <= other->DFSNumOut;
  }
};

__extension__ extern template class DomTreeNodeBase<BasicBlock>;
__extension__ extern template class DomTreeNodeBase<MachineBasicBlock>;

template<class NodeT>
inline raw_ostream &operator<<(raw_ostream &o,
                               const DomTreeNodeBase<NodeT> *Node) {
  if (Node->getBlock())
    WriteAsOperand(o, Node->getBlock(), false);
  else
    o << " <<exit node>>";

  o << " {" << Node->getDFSNumIn() << "," << Node->getDFSNumOut() << "}";

  return o << "\n";
}

template<class NodeT>
inline void PrintDomTree(const DomTreeNodeBase<NodeT> *N, raw_ostream &o,
                         unsigned Lev) {
  o.indent(2*Lev) << "[" << Lev << "] " << N;
  for (typename DomTreeNodeBase<NodeT>::const_iterator I = N->begin(),
       E = N->end(); I != E; ++I)
    PrintDomTree<NodeT>(*I, o, Lev+1);
}

typedef DomTreeNodeBase<BasicBlock> DomTreeNode;





template<class FuncT, class N>
void Calculate(DominatorTreeBase<typename GraphTraits<N>::NodeType>& DT,
               FuncT& F);

template<class NodeT>
class DominatorTreeBase : public DominatorBase<NodeT> {
  bool dominatedBySlowTreeWalk(const DomTreeNodeBase<NodeT> *A,
                               const DomTreeNodeBase<NodeT> *B) const {
    ((void)((A != B) || (__assert_fail("A != B", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/Dominators.h", 190, __func__),0)));
    ((void)((isReachableFromEntry(B)) || (__assert_fail("isReachableFromEntry(B)", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/Dominators.h", 191, __func__),0)));
    ((void)((isReachableFromEntry(A)) || (__assert_fail("isReachableFromEntry(A)", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/Dominators.h", 192, __func__),0)));

    const DomTreeNodeBase<NodeT> *IDom;
    while ((IDom = B->getIDom()) != 0 && IDom != A && IDom != B)
      B = IDom;
    return IDom != 0;
  }

protected:
  typedef DenseMap<NodeT*, DomTreeNodeBase<NodeT>*> DomTreeNodeMapType;
  DomTreeNodeMapType DomTreeNodes;
  DomTreeNodeBase<NodeT> *RootNode;

  bool DFSInfoValid;
  unsigned int SlowQueries;

  struct InfoRec {
    unsigned DFSNum;
    unsigned Parent;
    unsigned Semi;
    NodeT *Label;

    InfoRec() : DFSNum(0), Parent(0), Semi(0), Label(0) {}
  };

  DenseMap<NodeT*, NodeT*> IDoms;


  std::vector<NodeT*> Vertex;


  DenseMap<NodeT*, InfoRec> Info;

  void reset() {
    for (typename DomTreeNodeMapType::iterator I = this->DomTreeNodes.begin(),
           E = DomTreeNodes.end(); I != E; ++I)
      delete I->second;
    DomTreeNodes.clear();
    IDoms.clear();
    this->Roots.clear();
    Vertex.clear();
    RootNode = 0;
  }



  template<class N, class GraphT>
  void Split(DominatorTreeBase<typename GraphT::NodeType>& DT,
             typename GraphT::NodeType* NewBB) {
    ((void)((std::distance(GraphT::child_begin(NewBB), GraphT::child_end(NewBB)) == 1 && "NewBB should have a single successor!") || (__assert_fail("std::distance(GraphT::child_begin(NewBB), GraphT::child_end(NewBB)) == 1 && \"NewBB should have a single successor!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/Dominators.h", 243, __func__),0)));


    typename GraphT::NodeType* NewBBSucc = *GraphT::child_begin(NewBB);

    std::vector<typename GraphT::NodeType*> PredBlocks;
    typedef GraphTraits<Inverse<N> > InvTraits;
    for (typename InvTraits::ChildIteratorType PI =
         InvTraits::child_begin(NewBB),
         PE = InvTraits::child_end(NewBB); PI != PE; ++PI)
      PredBlocks.push_back(*PI);

    ((void)((!PredBlocks.empty() && "No predblocks?") || (__assert_fail("!PredBlocks.empty() && \"No predblocks?\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/Dominators.h", 253, __func__),0)));

    bool NewBBDominatesNewBBSucc = true;
    for (typename InvTraits::ChildIteratorType PI =
         InvTraits::child_begin(NewBBSucc),
         E = InvTraits::child_end(NewBBSucc); PI != E; ++PI) {
      typename InvTraits::NodeType *ND = *PI;
      if (ND != NewBB && !DT.dominates(NewBBSucc, ND) &&
          DT.isReachableFromEntry(ND)) {
        NewBBDominatesNewBBSucc = false;
        break;
      }
    }



    NodeT *NewBBIDom = 0;
    unsigned i = 0;
    for (i = 0; i < PredBlocks.size(); ++i)
      if (DT.isReachableFromEntry(PredBlocks[i])) {
        NewBBIDom = PredBlocks[i];
        break;
      }




    if (!NewBBIDom)
      return;

    for (i = i + 1; i < PredBlocks.size(); ++i) {
      if (DT.isReachableFromEntry(PredBlocks[i]))
        NewBBIDom = DT.findNearestCommonDominator(NewBBIDom, PredBlocks[i]);
    }


    DomTreeNodeBase<NodeT> *NewBBNode = DT.addNewBlock(NewBB, NewBBIDom);



    if (NewBBDominatesNewBBSucc) {
      DomTreeNodeBase<NodeT> *NewBBSuccNode = DT.getNode(NewBBSucc);
      DT.changeImmediateDominator(NewBBSuccNode, NewBBNode);
    }
  }

public:
  explicit DominatorTreeBase(bool isPostDom)
    : DominatorBase<NodeT>(isPostDom), DFSInfoValid(false), SlowQueries(0) {}
  virtual ~DominatorTreeBase() { reset(); }



  bool compare(DominatorTreeBase &Other) const {

    const DomTreeNodeMapType &OtherDomTreeNodes = Other.DomTreeNodes;
    if (DomTreeNodes.size() != OtherDomTreeNodes.size())
      return true;

    for (typename DomTreeNodeMapType::const_iterator
           I = this->DomTreeNodes.begin(),
           E = this->DomTreeNodes.end(); I != E; ++I) {
      NodeT *BB = I->first;
      typename DomTreeNodeMapType::const_iterator OI = OtherDomTreeNodes.find(BB);
      if (OI == OtherDomTreeNodes.end())
        return true;

      DomTreeNodeBase<NodeT>* MyNd = I->second;
      DomTreeNodeBase<NodeT>* OtherNd = OI->second;

      if (MyNd->compare(OtherNd))
        return true;
    }

    return false;
  }

  virtual void releaseMemory() { reset(); }




  inline DomTreeNodeBase<NodeT> *getNode(NodeT *BB) const {
    return DomTreeNodes.lookup(BB);
  }
# 346 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/Dominators.h"
  DomTreeNodeBase<NodeT> *getRootNode() { return RootNode; }
  const DomTreeNodeBase<NodeT> *getRootNode() const { return RootNode; }


  void getDescendants(NodeT *R, SmallVectorImpl<NodeT *> &Result) const {
    const DomTreeNodeBase<NodeT> *RN = getNode(R);
    SmallVector<const DomTreeNodeBase<NodeT> *, 8> WL;
    WL.push_back(RN);
    Result.clear();

    while (!WL.empty()) {
      const DomTreeNodeBase<NodeT> *N = WL.pop_back_val();
      Result.push_back(N->getBlock());
      WL.append(N->begin(), N->end());
    }
  }




  bool properlyDominates(const DomTreeNodeBase<NodeT> *A,
                         const DomTreeNodeBase<NodeT> *B) {
    if (A == 0 || B == 0)
      return false;
    if (A == B)
      return false;
    return dominates(A, B);
  }

  bool properlyDominates(const NodeT *A, const NodeT *B);



  bool isReachableFromEntry(const NodeT* A) const {
    ((void)((!this->isPostDominator() && "This is not implemented for post dominators") || (__assert_fail("!this->isPostDominator() && \"This is not implemented for post dominators\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/Dominators.h", 381, __func__),0)));

    return isReachableFromEntry(getNode(const_cast<NodeT *>(A)));
  }

  inline bool isReachableFromEntry(const DomTreeNodeBase<NodeT> *A) const {
    return A;
  }




  inline bool dominates(const DomTreeNodeBase<NodeT> *A,
                        const DomTreeNodeBase<NodeT> *B) {

    if (B == A)
      return true;


    if (!isReachableFromEntry(B))
      return true;


    if (!isReachableFromEntry(A))
      return false;
# 414 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/Dominators.h"
    if (DFSInfoValid)
      return B->DominatedBy(A);



    SlowQueries++;
    if (SlowQueries > 32) {
      updateDFSNumbers();
      return B->DominatedBy(A);
    }

    return dominatedBySlowTreeWalk(A, B);
  }

  bool dominates(const NodeT *A, const NodeT *B);

  NodeT *getRoot() const {
    ((void)((this->Roots.size() == 1 && "Should always have entry node!") || (__assert_fail("this->Roots.size() == 1 && \"Should always have entry node!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/Dominators.h", 431, __func__),0)));
    return this->Roots[0];
  }



  NodeT *findNearestCommonDominator(NodeT *A, NodeT *B) {
    ((void)((A->getParent() == B->getParent() && "Two blocks are not in same function") || (__assert_fail("A->getParent() == B->getParent() && \"Two blocks are not in same function\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/Dominators.h", 439, __func__),0)));




    if (!this->isPostDominator()) {
      NodeT &Entry = A->getParent()->front();
      if (A == &Entry || B == &Entry)
        return &Entry;
    }


    if (dominates(B, A))
      return B;


    if (dominates(A, B))
      return A;

    DomTreeNodeBase<NodeT> *NodeA = getNode(A);
    DomTreeNodeBase<NodeT> *NodeB = getNode(B);


    SmallPtrSet<DomTreeNodeBase<NodeT>*, 16> NodeADoms;
    NodeADoms.insert(NodeA);
    DomTreeNodeBase<NodeT> *IDomA = NodeA->getIDom();
    while (IDomA) {
      NodeADoms.insert(IDomA);
      IDomA = IDomA->getIDom();
    }


    DomTreeNodeBase<NodeT> *IDomB = NodeB->getIDom();
    while (IDomB) {
      if (NodeADoms.count(IDomB) != 0)
        return IDomB->getBlock();

      IDomB = IDomB->getIDom();
    }

    return 0L;
  }

  const NodeT *findNearestCommonDominator(const NodeT *A, const NodeT *B) {


    return findNearestCommonDominator(const_cast<NodeT *>(A),
                                      const_cast<NodeT *>(B));
  }
# 495 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/Dominators.h"
  DomTreeNodeBase<NodeT> *addNewBlock(NodeT *BB, NodeT *DomBB) {
    ((void)((getNode(BB) == 0 && "Block already in dominator tree!") || (__assert_fail("getNode(BB) == 0 && \"Block already in dominator tree!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/Dominators.h", 496, __func__),0)));
    DomTreeNodeBase<NodeT> *IDomNode = getNode(DomBB);
    ((void)((IDomNode && "Not immediate dominator specified for block!") || (__assert_fail("IDomNode && \"Not immediate dominator specified for block!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/Dominators.h", 498, __func__),0)));
    DFSInfoValid = false;
    return DomTreeNodes[BB] =
      IDomNode->addChild(new DomTreeNodeBase<NodeT>(BB, IDomNode));
  }




  void changeImmediateDominator(DomTreeNodeBase<NodeT> *N,
                                DomTreeNodeBase<NodeT> *NewIDom) {
    ((void)((N && NewIDom && "Cannot change null node pointers!") || (__assert_fail("N && NewIDom && \"Cannot change null node pointers!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/Dominators.h", 509, __func__),0)));
    DFSInfoValid = false;
    N->setIDom(NewIDom);
  }

  void changeImmediateDominator(NodeT *BB, NodeT *NewBB) {
    changeImmediateDominator(getNode(BB), getNode(NewBB));
  }




  void eraseNode(NodeT *BB) {
    DomTreeNodeBase<NodeT> *Node = getNode(BB);
    ((void)((Node && "Removing node that isn't in dominator tree.") || (__assert_fail("Node && \"Removing node that isn't in dominator tree.\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/Dominators.h", 523, __func__),0)));
    ((void)((Node->getChildren().empty() && "Node is not a leaf node.") || (__assert_fail("Node->getChildren().empty() && \"Node is not a leaf node.\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/Dominators.h", 524, __func__),0)));


    DomTreeNodeBase<NodeT> *IDom = Node->getIDom();
    if (IDom) {
      typename std::vector<DomTreeNodeBase<NodeT>*>::iterator I =
        std::find(IDom->Children.begin(), IDom->Children.end(), Node);
      ((void)((I != IDom->Children.end() && "Not in immediate dominator children set!") || (__assert_fail("I != IDom->Children.end() && \"Not in immediate dominator children set!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/Dominators.h", 532, __func__),0)));


      IDom->Children.erase(I);
    }

    DomTreeNodes.erase(BB);
    delete Node;
  }




  void removeNode(NodeT *BB) {
    ((void)((getNode(BB) && "Removing node that isn't in dominator tree.") || (__assert_fail("getNode(BB) && \"Removing node that isn't in dominator tree.\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/Dominators.h", 545, __func__),0)));
    DomTreeNodes.erase(BB);
  }



  void splitBlock(NodeT* NewBB) {
    if (this->IsPostDominators)
      this->Split<Inverse<NodeT*>, GraphTraits<Inverse<NodeT*> > >(*this, NewBB);
    else
      this->Split<NodeT*, GraphTraits<NodeT*> >(*this, NewBB);
  }



  void print(raw_ostream &o) const {
    o << "=============================--------------------------------\n";
    if (this->isPostDominator())
      o << "Inorder PostDominator Tree: ";
    else
      o << "Inorder Dominator Tree: ";
    if (!this->DFSInfoValid)
      o << "DFSNumbers invalid: " << SlowQueries << " slow queries.";
    o << "\n";


    if (getRootNode())
      PrintDomTree<NodeT>(getRootNode(), o, 1);
  }

protected:
  template<class GraphT>
  friend typename GraphT::NodeType* Eval(
                               DominatorTreeBase<typename GraphT::NodeType>& DT,
                                         typename GraphT::NodeType* V,
                                         unsigned LastLinked);

  template<class GraphT>
  friend unsigned DFSPass(DominatorTreeBase<typename GraphT::NodeType>& DT,
                          typename GraphT::NodeType* V,
                          unsigned N);

  template<class FuncT, class N>
  friend void Calculate(DominatorTreeBase<typename GraphTraits<N>::NodeType>& DT,
                        FuncT& F);



  void updateDFSNumbers() {
    unsigned DFSNum = 0;

    SmallVector<std::pair<DomTreeNodeBase<NodeT>*,
                typename DomTreeNodeBase<NodeT>::iterator>, 32> WorkStack;

    DomTreeNodeBase<NodeT> *ThisRoot = getRootNode();

    if (!ThisRoot)
      return;





    WorkStack.push_back(std::make_pair(ThisRoot, ThisRoot->begin()));
    ThisRoot->DFSNumIn = DFSNum++;

    while (!WorkStack.empty()) {
      DomTreeNodeBase<NodeT> *Node = WorkStack.back().first;
      typename DomTreeNodeBase<NodeT>::iterator ChildIt =
        WorkStack.back().second;



      if (ChildIt == Node->end()) {
        Node->DFSNumOut = DFSNum++;
        WorkStack.pop_back();
      } else {

        DomTreeNodeBase<NodeT> *Child = *ChildIt;
        ++WorkStack.back().second;

        WorkStack.push_back(std::make_pair(Child, Child->begin()));
        Child->DFSNumIn = DFSNum++;
      }
    }

    SlowQueries = 0;
    DFSInfoValid = true;
  }

  DomTreeNodeBase<NodeT> *getNodeForBlock(NodeT *BB) {
    if (DomTreeNodeBase<NodeT> *Node = getNode(BB))
      return Node;



    NodeT *IDom = getIDom(BB);

    ((void)((IDom || this->DomTreeNodes[0L]) || (__assert_fail("IDom || this->DomTreeNodes[NULL]", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/Dominators.h", 643, __func__),0)));
    DomTreeNodeBase<NodeT> *IDomNode = getNodeForBlock(IDom);



    DomTreeNodeBase<NodeT> *C = new DomTreeNodeBase<NodeT>(BB, IDomNode);
    return this->DomTreeNodes[BB] = IDomNode->addChild(C);
  }

  inline NodeT *getIDom(NodeT *BB) const {
    return IDoms.lookup(BB);
  }

  inline void addRoot(NodeT* BB) {
    this->Roots.push_back(BB);
  }

public:

  template<class FT>
  void recalculate(FT& F) {
    typedef GraphTraits<FT*> TraitsTy;
    reset();
    this->Vertex.push_back(0);

    if (!this->IsPostDominators) {

      NodeT *entry = TraitsTy::getEntryNode(&F);
      this->Roots.push_back(entry);
      this->IDoms[entry] = 0;
      this->DomTreeNodes[entry] = 0;

      Calculate<FT, NodeT*>(*this, F);
    } else {

      for (typename TraitsTy::nodes_iterator I = TraitsTy::nodes_begin(&F),
                                        E = TraitsTy::nodes_end(&F); I != E; ++I) {
        if (TraitsTy::child_begin(I) == TraitsTy::child_end(I))
          addRoot(I);


        this->IDoms[I] = 0;
        this->DomTreeNodes[I] = 0;
      }

      Calculate<FT, Inverse<NodeT*> >(*this, F);
    }
  }
};



template<class NodeT>
bool DominatorTreeBase<NodeT>::dominates(const NodeT *A, const NodeT *B) {
  if (A == B)
    return true;




  return dominates(getNode(const_cast<NodeT *>(A)),
                   getNode(const_cast<NodeT *>(B)));
}
template<class NodeT>
bool
DominatorTreeBase<NodeT>::properlyDominates(const NodeT *A, const NodeT *B) {
  if (A == B)
    return false;




  return dominates(getNode(const_cast<NodeT *>(A)),
                   getNode(const_cast<NodeT *>(B)));
}

__extension__ extern template class DominatorTreeBase<BasicBlock>;

class BasicBlockEdge {
  const BasicBlock *Start;
  const BasicBlock *End;
public:
  BasicBlockEdge(const BasicBlock *Start_, const BasicBlock *End_) :
    Start(Start_), End(End_) { }
  const BasicBlock *getStart() const {
    return Start;
  }
  const BasicBlock *getEnd() const {
    return End;
  }
  bool isSingleEdge() const;
};





class DominatorTree : public FunctionPass {
public:
  static char ID;
  DominatorTreeBase<BasicBlock>* DT;

  DominatorTree() : FunctionPass(ID) {
    initializeDominatorTreePass(*PassRegistry::getPassRegistry());
    DT = new DominatorTreeBase<BasicBlock>(false);
  }

  ~DominatorTree() {
    delete DT;
  }

  DominatorTreeBase<BasicBlock>& getBase() { return *DT; }





  inline const std::vector<BasicBlock*> &getRoots() const {
    return DT->getRoots();
  }

  inline BasicBlock *getRoot() const {
    return DT->getRoot();
  }

  inline DomTreeNode *getRootNode() const {
    return DT->getRootNode();
  }


  void getDescendants(BasicBlock *R,
                     SmallVectorImpl<BasicBlock *> &Result) const {
    DT->getDescendants(R, Result);
  }



  inline bool compare(DominatorTree &Other) const {
    DomTreeNode *R = getRootNode();
    DomTreeNode *OtherR = Other.getRootNode();

    if (!R || !OtherR || R->getBlock() != OtherR->getBlock())
      return true;

    if (DT->compare(Other.getBase()))
      return true;

    return false;
  }

  virtual bool runOnFunction(Function &F);

  virtual void verifyAnalysis() const;

  virtual void getAnalysisUsage(AnalysisUsage &AU) const {
    AU.setPreservesAll();
  }

  inline bool dominates(const DomTreeNode* A, const DomTreeNode* B) const {
    return DT->dominates(A, B);
  }

  inline bool dominates(const BasicBlock* A, const BasicBlock* B) const {
    return DT->dominates(A, B);
  }




  bool dominates(const Instruction *Def, const Use &U) const;
  bool dominates(const Instruction *Def, const Instruction *User) const;
  bool dominates(const Instruction *Def, const BasicBlock *BB) const;
  bool dominates(const BasicBlockEdge &BBE, const Use &U) const;
  bool dominates(const BasicBlockEdge &BBE, const BasicBlock *BB) const;

  bool properlyDominates(const DomTreeNode *A, const DomTreeNode *B) const {
    return DT->properlyDominates(A, B);
  }

  bool properlyDominates(const BasicBlock *A, const BasicBlock *B) const {
    return DT->properlyDominates(A, B);
  }



  inline BasicBlock *findNearestCommonDominator(BasicBlock *A, BasicBlock *B) {
    return DT->findNearestCommonDominator(A, B);
  }

  inline const BasicBlock *findNearestCommonDominator(const BasicBlock *A,
                                                      const BasicBlock *B) {
    return DT->findNearestCommonDominator(A, B);
  }

  inline DomTreeNode *operator[](BasicBlock *BB) const {
    return DT->getNode(BB);
  }




  inline DomTreeNode *getNode(BasicBlock *BB) const {
    return DT->getNode(BB);
  }




  inline DomTreeNode *addNewBlock(BasicBlock *BB, BasicBlock *DomBB) {
    return DT->addNewBlock(BB, DomBB);
  }




  inline void changeImmediateDominator(BasicBlock *N, BasicBlock* NewIDom) {
    DT->changeImmediateDominator(N, NewIDom);
  }

  inline void changeImmediateDominator(DomTreeNode *N, DomTreeNode* NewIDom) {
    DT->changeImmediateDominator(N, NewIDom);
  }




  inline void eraseNode(BasicBlock *BB) {
    DT->eraseNode(BB);
  }



  inline void splitBlock(BasicBlock* NewBB) {
    DT->splitBlock(NewBB);
  }

  bool isReachableFromEntry(const BasicBlock* A) const {
    return DT->isReachableFromEntry(A);
  }

  bool isReachableFromEntry(const Use &U) const;


  virtual void releaseMemory() {
    DT->releaseMemory();
  }

  virtual void print(raw_ostream &OS, const Module* M= 0) const;
};





template <> struct GraphTraits<DomTreeNode*> {
  typedef DomTreeNode NodeType;
  typedef NodeType::iterator ChildIteratorType;

  static NodeType *getEntryNode(NodeType *N) {
    return N;
  }
  static inline ChildIteratorType child_begin(NodeType *N) {
    return N->begin();
  }
  static inline ChildIteratorType child_end(NodeType *N) {
    return N->end();
  }

  typedef df_iterator<DomTreeNode*> nodes_iterator;

  static nodes_iterator nodes_begin(DomTreeNode *N) {
    return df_begin(getEntryNode(N));
  }

  static nodes_iterator nodes_end(DomTreeNode *N) {
    return df_end(getEntryNode(N));
  }
};

template <> struct GraphTraits<DominatorTree*>
  : public GraphTraits<DomTreeNode*> {
  static NodeType *getEntryNode(DominatorTree *DT) {
    return DT->getRootNode();
  }

  static nodes_iterator nodes_begin(DominatorTree *N) {
    return df_begin(getEntryNode(N));
  }

  static nodes_iterator nodes_end(DominatorTree *N) {
    return df_end(getEntryNode(N));
  }
};


}
# 31 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/lib/Analysis/AliasAnalysis.cpp" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/ValueTracking.h" 1
# 21 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/ValueTracking.h"
namespace llvm {
  class Value;
  class Instruction;
  class APInt;
  class DataLayout;
  class StringRef;
  class MDNode;
  class TargetLibraryInfo;
# 40 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/ValueTracking.h"
  void ComputeMaskedBits(Value *V, APInt &KnownZero, APInt &KnownOne,
                         const DataLayout *TD = 0, unsigned Depth = 0);
  void computeMaskedBitsLoad(const MDNode &Ranges, APInt &KnownZero);



  void ComputeSignBit(Value *V, bool &KnownZero, bool &KnownOne,
                      const DataLayout *TD = 0, unsigned Depth = 0);






  bool isKnownToBeAPowerOfTwo(Value *V, bool OrZero = false, unsigned Depth = 0);





  bool isKnownNonZero(Value *V, const DataLayout *TD = 0, unsigned Depth = 0);
# 71 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/ValueTracking.h"
  bool MaskedValueIsZero(Value *V, const APInt &Mask,
                         const DataLayout *TD = 0, unsigned Depth = 0);
# 83 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/ValueTracking.h"
  unsigned ComputeNumSignBits(Value *Op, const DataLayout *TD = 0,
                              unsigned Depth = 0);






  bool ComputeMultiple(Value *V, unsigned Base, Value *&Multiple,
                       bool LookThroughSExt = false,
                       unsigned Depth = 0);




  bool CannotBeNegativeZero(const Value *V, unsigned Depth = 0);






  Value *isBytewiseValue(Value *V);







  Value *FindInsertedValue(Value *V,
                           ArrayRef<unsigned> idx_range,
                           Instruction *InsertBefore = 0);




  Value *GetPointerBaseWithConstantOffset(Value *Ptr, int64_t &Offset,
                                          const DataLayout *TD);
  static inline const Value *
  GetPointerBaseWithConstantOffset(const Value *Ptr, int64_t &Offset,
                                   const DataLayout *TD) {
    return GetPointerBaseWithConstantOffset(const_cast<Value*>(Ptr), Offset,TD);
  }







  bool getConstantStringInfo(const Value *V, StringRef &Str,
                             uint64_t Offset = 0, bool TrimAtNul = true);



  uint64_t GetStringLength(Value *V);






  Value *GetUnderlyingObject(Value *V, const DataLayout *TD = 0,
                             unsigned MaxLookup = 6);
  static inline const Value *
  GetUnderlyingObject(const Value *V, const DataLayout *TD = 0,
                      unsigned MaxLookup = 6) {
    return GetUnderlyingObject(const_cast<Value *>(V), TD, MaxLookup);
  }




  void GetUnderlyingObjects(Value *V,
                            SmallVectorImpl<Value *> &Objects,
                            const DataLayout *TD = 0,
                            unsigned MaxLookup = 6);



  bool onlyUsedByLifetimeMarkers(const Value *V);
# 184 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Analysis/ValueTracking.h"
  bool isSafeToSpeculativelyExecute(const Value *V,
                                    const DataLayout *TD = 0);




  bool isKnownNonNull(const Value *V, const TargetLibraryInfo *TLI = 0);

}
# 32 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/lib/Analysis/AliasAnalysis.cpp" 2

# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/DataLayout.h" 1
# 30 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/DataLayout.h"
namespace llvm {

class Value;
class Type;
class IntegerType;
class StructType;
class StructLayout;
class GlobalVariable;
class LLVMContext;
template<typename T>
class ArrayRef;


enum AlignTypeEnum {
  INVALID_ALIGN = 0,
  INTEGER_ALIGN = 'i',
  VECTOR_ALIGN = 'v',
  FLOAT_ALIGN = 'f',
  AGGREGATE_ALIGN = 'a',
  STACK_ALIGN = 's'
};
# 59 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/DataLayout.h"
struct LayoutAlignElem {
  unsigned AlignType : 8;
  unsigned TypeBitWidth : 24;
  unsigned ABIAlign : 16;
  unsigned PrefAlign : 16;


  static LayoutAlignElem get(AlignTypeEnum align_type, unsigned abi_align,
                             unsigned pref_align, uint32_t bit_width);

  bool operator==(const LayoutAlignElem &rhs) const;
};







struct PointerAlignElem {
  unsigned ABIAlign;
  unsigned PrefAlign;
  uint32_t TypeBitWidth;
  uint32_t AddressSpace;


  static PointerAlignElem get(uint32_t addr_space, unsigned abi_align,
                             unsigned pref_align, uint32_t bit_width);

  bool operator==(const PointerAlignElem &rhs) const;
};
# 98 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/DataLayout.h"
class DataLayout : public ImmutablePass {
private:
  bool LittleEndian;
  unsigned StackNaturalAlign;

  SmallVector<unsigned char, 8> LegalIntWidths;







  SmallVector<LayoutAlignElem, 16> Alignments;
  DenseMap<unsigned, PointerAlignElem> Pointers;



  static const LayoutAlignElem InvalidAlignmentElem;



  static const PointerAlignElem InvalidPointerElem;


  mutable void *LayoutMap;


  void setAlignment(AlignTypeEnum align_type, unsigned abi_align,
                    unsigned pref_align, uint32_t bit_width);
  unsigned getAlignmentInfo(AlignTypeEnum align_type, uint32_t bit_width,
                            bool ABIAlign, Type *Ty) const;


  void setPointerAlignment(uint32_t addr_space, unsigned abi_align,
      unsigned pref_align, uint32_t bit_width);


  unsigned getAlignment(Type *Ty, bool abi_or_pref) const;





  bool validAlignment(const LayoutAlignElem &align) const {
    return &align != &InvalidAlignmentElem;
  }





  bool validPointer(const PointerAlignElem &align) const {
    return &align != &InvalidPointerElem;
  }



  void parseSpecifier(StringRef LayoutDescription);

public:




  DataLayout();


  explicit DataLayout(StringRef LayoutDescription)
    : ImmutablePass(ID) {
    init(LayoutDescription);
  }


  explicit DataLayout(const Module *M);

  DataLayout(const DataLayout &DL) :
    ImmutablePass(ID),
    LittleEndian(DL.isLittleEndian()),
    StackNaturalAlign(DL.StackNaturalAlign),
    LegalIntWidths(DL.LegalIntWidths),
    Alignments(DL.Alignments),
    Pointers(DL.Pointers),
    LayoutMap(0)
  { }

  ~DataLayout();



  bool doFinalization(Module &M);



  void init(StringRef LayoutDescription);


  bool isLittleEndian() const { return LittleEndian; }
  bool isBigEndian() const { return !LittleEndian; }




  std::string getStringRepresentation() const;
# 210 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/DataLayout.h"
  bool isLegalInteger(unsigned Width) const {
    for (unsigned i = 0, e = (unsigned)LegalIntWidths.size(); i != e; ++i)
      if (LegalIntWidths[i] == Width)
        return true;
    return false;
  }

  bool isIllegalInteger(unsigned Width) const {
    return !isLegalInteger(Width);
  }


  bool exceedsNaturalStackAlignment(unsigned Align) const {
    return (StackNaturalAlign != 0) && (Align > StackNaturalAlign);
  }





  bool fitsInLegalInteger(unsigned Width) const {
    for (unsigned i = 0, e = (unsigned)LegalIntWidths.size(); i != e; ++i)
      if (Width <= LegalIntWidths[i])
        return true;
    return false;
  }




  unsigned getPointerABIAlignment(unsigned AS = 0) const {
    DenseMap<unsigned, PointerAlignElem>::const_iterator val = Pointers.find(AS);
    if (val == Pointers.end()) {
      val = Pointers.find(0);
    }
    return val->second.ABIAlign;
  }




  unsigned getPointerPrefAlignment(unsigned AS = 0) const {
    DenseMap<unsigned, PointerAlignElem>::const_iterator val = Pointers.find(AS);
    if (val == Pointers.end()) {
      val = Pointers.find(0);
    }
    return val->second.PrefAlign;
  }



  unsigned getPointerSize(unsigned AS = 0) const {
    DenseMap<unsigned, PointerAlignElem>::const_iterator val = Pointers.find(AS);
    if (val == Pointers.end()) {
      val = Pointers.find(0);
    }
    return val->second.TypeBitWidth;
  }



  unsigned getPointerSizeInBits(unsigned AS = 0) const {
    return getPointerSize(AS) * 8;
  }






  unsigned getPointerTypeSizeInBits(Type *) const;

  unsigned getPointerTypeSize(Type *Ty) const {
    return getPointerTypeSizeInBits(Ty) / 8;
  }
# 306 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/DataLayout.h"
  uint64_t getTypeSizeInBits(Type *Ty) const;




  uint64_t getTypeStoreSize(Type *Ty) const {
    return (getTypeSizeInBits(Ty)+7)/8;
  }




  uint64_t getTypeStoreSizeInBits(Type *Ty) const {
    return 8*getTypeStoreSize(Ty);
  }





  uint64_t getTypeAllocSize(Type *Ty) const {

    return RoundUpAlignment(getTypeStoreSize(Ty), getABITypeAlignment(Ty));
  }





  uint64_t getTypeAllocSizeInBits(Type *Ty) const {
    return 8*getTypeAllocSize(Ty);
  }



  unsigned getABITypeAlignment(Type *Ty) const;



  unsigned getABIIntegerTypeAlignment(unsigned BitWidth) const;



  unsigned getCallFrameTypeAlignment(Type *Ty) const;



  unsigned getPrefTypeAlignment(Type *Ty) const;



  unsigned getPreferredTypeAlignmentShift(Type *Ty) const;



  IntegerType *getIntPtrType(LLVMContext &C, unsigned AddressSpace = 0) const;




  Type *getIntPtrType(Type *) const;



  Type *getSmallestLegalIntType(LLVMContext &C, unsigned Width = 0) const;



  Type *getLargestLegalIntType(LLVMContext &C) const {
    unsigned LargestSize = getLargestLegalIntTypeSize();
    return (LargestSize == 0) ? 0 : Type::getIntNTy(C, LargestSize);
  }



  unsigned getLargestLegalIntTypeSize() const;



  uint64_t getIndexedOffset(Type *Ty, ArrayRef<Value *> Indices) const;




  const StructLayout *getStructLayout(StructType *Ty) const;




  unsigned getPreferredAlignment(const GlobalVariable *GV) const;




  unsigned getPreferredAlignmentLog(const GlobalVariable *GV) const;





  template <typename UIntTy>
  static UIntTy RoundUpAlignment(UIntTy Val, unsigned Alignment) {
    ((void)(((Alignment & (Alignment-1)) == 0 && "Alignment must be power of 2!") || (__assert_fail("(Alignment & (Alignment-1)) == 0 && \"Alignment must be power of 2!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/DataLayout.h", 408, __func__),0)));
    return (Val + (Alignment-1)) & ~UIntTy(Alignment-1);
  }

  static char ID;
};




class StructLayout {
  uint64_t StructSize;
  unsigned StructAlignment;
  unsigned NumElements;
  uint64_t MemberOffsets[1];
public:

  uint64_t getSizeInBytes() const {
    return StructSize;
  }

  uint64_t getSizeInBits() const {
    return 8*StructSize;
  }

  unsigned getAlignment() const {
    return StructAlignment;
  }




  unsigned getElementContainingOffset(uint64_t Offset) const;

  uint64_t getElementOffset(unsigned Idx) const {
    ((void)((Idx < NumElements && "Invalid element idx!") || (__assert_fail("Idx < NumElements && \"Invalid element idx!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/DataLayout.h", 443, __func__),0)));
    return MemberOffsets[Idx];
  }

  uint64_t getElementOffsetInBits(unsigned Idx) const {
    return getElementOffset(Idx)*8;
  }

private:
  friend class DataLayout;
  StructLayout(StructType *ST, const DataLayout &DL);
};




inline uint64_t DataLayout::getTypeSizeInBits(Type *Ty) const {
  ((void)((Ty->isSized() && "Cannot getTypeInfo() on a type that is unsized!") || (__assert_fail("Ty->isSized() && \"Cannot getTypeInfo() on a type that is unsized!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/DataLayout.h", 460, __func__),0)));
  switch (Ty->getTypeID()) {
  case Type::LabelTyID:
    return getPointerSizeInBits(0);
  case Type::PointerTyID:
    return getPointerSizeInBits(Ty->getPointerAddressSpace());
  case Type::ArrayTyID: {
    ArrayType *ATy = cast<ArrayType>(Ty);
    return ATy->getNumElements() *
           getTypeAllocSizeInBits(ATy->getElementType());
  }
  case Type::StructTyID:

    return getStructLayout(cast<StructType>(Ty))->getSizeInBits();
  case Type::IntegerTyID:
    return Ty->getIntegerBitWidth();
  case Type::HalfTyID:
    return 16;
  case Type::FloatTyID:
    return 32;
  case Type::DoubleTyID:
  case Type::X86_MMXTyID:
    return 64;
  case Type::PPC_FP128TyID:
  case Type::FP128TyID:
    return 128;


  case Type::X86_FP80TyID:
    return 80;
  case Type::VectorTyID: {
    VectorType *VTy = cast<VectorType>(Ty);
    return VTy->getNumElements() * getTypeSizeInBits(VTy->getElementType());
  }
  default:
    ::llvm::llvm_unreachable_internal("DataLayout::getTypeSizeInBits(): Unsupported type", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/DataLayout.h", 495);
  }
}

}
# 34 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/lib/Analysis/AliasAnalysis.cpp" 2


# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/IntrinsicInst.h" 1
# 27 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/IntrinsicInst.h"
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Constants.h" 1
# 31 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Constants.h"
namespace llvm {

class ArrayType;
class IntegerType;
class StructType;
class PointerType;
class VectorType;
class SequentialType;

template<class ConstantClass, class TypeClass, class ValType>
struct ConstantCreator;
template<class ConstantClass, class TypeClass>
struct ConstantArrayCreator;
template<class ConstantClass, class TypeClass>
struct ConvertConstantType;





class ConstantInt : public Constant {
  virtual void anchor();
  void *operator new(size_t, unsigned) ;
  ConstantInt(const ConstantInt &) ;
  ConstantInt(IntegerType *Ty, const APInt& V);
  APInt Val;
protected:

  void *operator new(size_t s) {
    return User::operator new(s, 0);
  }
public:
  static ConstantInt *getTrue(LLVMContext &Context);
  static ConstantInt *getFalse(LLVMContext &Context);
  static Constant *getTrue(Type *Ty);
  static Constant *getFalse(Type *Ty);



  static Constant *get(Type *Ty, uint64_t V, bool isSigned = false);







  static ConstantInt *get(IntegerType *Ty, uint64_t V,
                          bool isSigned = false);






  static ConstantInt *getSigned(IntegerType *Ty, int64_t V);
  static Constant *getSigned(Type *Ty, int64_t V);



  static ConstantInt *get(LLVMContext &Context, const APInt &V);



  static ConstantInt *get(IntegerType *Ty, StringRef Str,
                          uint8_t radix);



  static Constant *get(Type* Ty, const APInt& V);




  inline const APInt &getValue() const {
    return Val;
  }


  unsigned getBitWidth() const { return Val.getBitWidth(); }





  inline uint64_t getZExtValue() const {
    return Val.getZExtValue();
  }





  inline int64_t getSExtValue() const {
    return Val.getSExtValue();
  }





  bool equalsInt(uint64_t V) const {
    return Val == V;
  }




  inline IntegerType *getType() const {
    return cast<IntegerType>(Value::getType());
  }
# 152 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Constants.h"
  static bool isValueValidForType(Type *Ty, uint64_t V);
  static bool isValueValidForType(Type *Ty, int64_t V);

  bool isNegative() const { return Val.isNegative(); }




  bool isZero() const {
    return Val == 0;
  }





  bool isOne() const {
    return Val == 1;
  }





  bool isMinusOne() const {
    return Val.isAllOnesValue();
  }






  bool isMaxValue(bool isSigned) const {
    if (isSigned)
      return Val.isMaxSignedValue();
    else
      return Val.isMaxValue();
  }






  bool isMinValue(bool isSigned) const {
    if (isSigned)
      return Val.isMinSignedValue();
    else
      return Val.isMinValue();
  }






  bool uge(uint64_t Num) const {
    return Val.getActiveBits() > 64 || Val.getZExtValue() >= Num;
  }






  uint64_t getLimitedValue(uint64_t Limit = ~0ULL) const {
    return Val.getLimitedValue(Limit);
  }


  static bool classof(const Value *V) {
    return V->getValueID() == ConstantIntVal;
  }
};





class ConstantFP : public Constant {
  APFloat Val;
  virtual void anchor();
  void *operator new(size_t, unsigned) ;
  ConstantFP(const ConstantFP &) ;
  friend class LLVMContextImpl;
protected:
  ConstantFP(Type *Ty, const APFloat& V);
protected:

  void *operator new(size_t s) {
    return User::operator new(s, 0);
  }
public:



  static Constant *getZeroValueForNegation(Type *Ty);





  static Constant *get(Type* Ty, double V);
  static Constant *get(Type* Ty, StringRef Str);
  static ConstantFP *get(LLVMContext &Context, const APFloat &V);
  static ConstantFP *getNegativeZero(Type* Ty);
  static ConstantFP *getInfinity(Type *Ty, bool Negative = false);


  static bool isValueValidForType(Type *Ty, const APFloat &V);
  inline const APFloat &getValueAPF() const { return Val; }


  bool isZero() const { return Val.isZero(); }


  bool isNegative() const { return Val.isNegative(); }


  bool isNaN() const { return Val.isNaN(); }







  bool isExactlyValue(const APFloat &V) const;

  bool isExactlyValue(double V) const {
    bool ignored;
    APFloat FV(V);
    FV.convert(Val.getSemantics(), APFloat::rmNearestTiesToEven, &ignored);
    return isExactlyValue(FV);
  }

  static bool classof(const Value *V) {
    return V->getValueID() == ConstantFPVal;
  }
};




class ConstantAggregateZero : public Constant {
  void *operator new(size_t, unsigned) ;
  ConstantAggregateZero(const ConstantAggregateZero &) ;
protected:
  explicit ConstantAggregateZero(Type *ty)
    : Constant(ty, ConstantAggregateZeroVal, 0, 0) {}
protected:

  void *operator new(size_t s) {
    return User::operator new(s, 0);
  }
public:
  static ConstantAggregateZero *get(Type *Ty);

  virtual void destroyConstant();



  Constant *getSequentialElement() const;



  Constant *getStructElement(unsigned Elt) const;



  Constant *getElementValue(Constant *C) const;



  Constant *getElementValue(unsigned Idx) const;



  static bool classof(const Value *V) {
    return V->getValueID() == ConstantAggregateZeroVal;
  }
};





class ConstantArray : public Constant {
  friend struct ConstantArrayCreator<ConstantArray, ArrayType>;
  ConstantArray(const ConstantArray &) ;
protected:
  ConstantArray(ArrayType *T, ArrayRef<Constant *> Val);
public:

  static Constant *get(ArrayType *T, ArrayRef<Constant*> V);


  public: inline Constant *getOperand(unsigned) const; inline void setOperand(unsigned, Constant*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;




  inline ArrayType *getType() const {
    return cast<ArrayType>(Value::getType());
  }

  virtual void destroyConstant();
  virtual void replaceUsesOfWithOnConstant(Value *From, Value *To, Use *U);


  static bool classof(const Value *V) {
    return V->getValueID() == ConstantArrayVal;
  }
};

template <>
struct OperandTraits<ConstantArray> :
  public VariadicOperandTraits<ConstantArray> {
};

ConstantArray::op_iterator ConstantArray::op_begin() { return OperandTraits<ConstantArray>::op_begin(this); } ConstantArray::const_op_iterator ConstantArray::op_begin() const { return OperandTraits<ConstantArray>::op_begin(const_cast<ConstantArray*>(this)); } ConstantArray::op_iterator ConstantArray::op_end() { return OperandTraits<ConstantArray>::op_end(this); } ConstantArray::const_op_iterator ConstantArray::op_end() const { return OperandTraits<ConstantArray>::op_end(const_cast<ConstantArray*>(this)); } Constant *ConstantArray::getOperand(unsigned i_nocapture) const { ((void)((i_nocapture < OperandTraits<ConstantArray>::operands(this) && "getOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<ConstantArray>::operands(this) && \"getOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Constants.h", 373, __func__),0))); return cast_or_null<Constant>( OperandTraits<ConstantArray>::op_begin(const_cast<ConstantArray*>(this))[i_nocapture].get()); } void ConstantArray::setOperand(unsigned i_nocapture, Constant *Val_nocapture) { ((void)((i_nocapture < OperandTraits<ConstantArray>::operands(this) && "setOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<ConstantArray>::operands(this) && \"setOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Constants.h", 373, __func__),0))); OperandTraits<ConstantArray>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned ConstantArray::getNumOperands() const { return OperandTraits<ConstantArray>::operands(this); } template <int Idx_nocapture> Use &ConstantArray::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &ConstantArray::Op() const { return this->OpFrom<Idx_nocapture>(this); }




class ConstantStruct : public Constant {
  friend struct ConstantArrayCreator<ConstantStruct, StructType>;
  ConstantStruct(const ConstantStruct &) ;
protected:
  ConstantStruct(StructType *T, ArrayRef<Constant *> Val);
public:

  static Constant *get(StructType *T, ArrayRef<Constant*> V);
  static Constant *get(StructType *T, ...) __attribute__((sentinel));




  static Constant *getAnon(ArrayRef<Constant*> V, bool Packed = false) {
    return get(getTypeForElements(V, Packed), V);
  }
  static Constant *getAnon(LLVMContext &Ctx,
                           ArrayRef<Constant*> V, bool Packed = false) {
    return get(getTypeForElements(Ctx, V, Packed), V);
  }



  static StructType *getTypeForElements(ArrayRef<Constant*> V,
                                        bool Packed = false);

  static StructType *getTypeForElements(LLVMContext &Ctx,
                                        ArrayRef<Constant*> V,
                                        bool Packed = false);


  public: inline Constant *getOperand(unsigned) const; inline void setOperand(unsigned, Constant*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;



  inline StructType *getType() const {
    return cast<StructType>(Value::getType());
  }

  virtual void destroyConstant();
  virtual void replaceUsesOfWithOnConstant(Value *From, Value *To, Use *U);


  static bool classof(const Value *V) {
    return V->getValueID() == ConstantStructVal;
  }
};

template <>
struct OperandTraits<ConstantStruct> :
  public VariadicOperandTraits<ConstantStruct> {
};

ConstantStruct::op_iterator ConstantStruct::op_begin() { return OperandTraits<ConstantStruct>::op_begin(this); } ConstantStruct::const_op_iterator ConstantStruct::op_begin() const { return OperandTraits<ConstantStruct>::op_begin(const_cast<ConstantStruct*>(this)); } ConstantStruct::op_iterator ConstantStruct::op_end() { return OperandTraits<ConstantStruct>::op_end(this); } ConstantStruct::const_op_iterator ConstantStruct::op_end() const { return OperandTraits<ConstantStruct>::op_end(const_cast<ConstantStruct*>(this)); } Constant *ConstantStruct::getOperand(unsigned i_nocapture) const { ((void)((i_nocapture < OperandTraits<ConstantStruct>::operands(this) && "getOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<ConstantStruct>::operands(this) && \"getOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Constants.h", 431, __func__),0))); return cast_or_null<Constant>( OperandTraits<ConstantStruct>::op_begin(const_cast<ConstantStruct*>(this))[i_nocapture].get()); } void ConstantStruct::setOperand(unsigned i_nocapture, Constant *Val_nocapture) { ((void)((i_nocapture < OperandTraits<ConstantStruct>::operands(this) && "setOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<ConstantStruct>::operands(this) && \"setOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Constants.h", 431, __func__),0))); OperandTraits<ConstantStruct>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned ConstantStruct::getNumOperands() const { return OperandTraits<ConstantStruct>::operands(this); } template <int Idx_nocapture> Use &ConstantStruct::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &ConstantStruct::Op() const { return this->OpFrom<Idx_nocapture>(this); }





class ConstantVector : public Constant {
  friend struct ConstantArrayCreator<ConstantVector, VectorType>;
  ConstantVector(const ConstantVector &) ;
protected:
  ConstantVector(VectorType *T, ArrayRef<Constant *> Val);
public:

  static Constant *get(ArrayRef<Constant*> V);



  static Constant *getSplat(unsigned NumElts, Constant *Elt);


  public: inline Constant *getOperand(unsigned) const; inline void setOperand(unsigned, Constant*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;




  inline VectorType *getType() const {
    return cast<VectorType>(Value::getType());
  }



  Constant *getSplatValue() const;

  virtual void destroyConstant();
  virtual void replaceUsesOfWithOnConstant(Value *From, Value *To, Use *U);


  static bool classof(const Value *V) {
    return V->getValueID() == ConstantVectorVal;
  }
};

template <>
struct OperandTraits<ConstantVector> :
  public VariadicOperandTraits<ConstantVector> {
};

ConstantVector::op_iterator ConstantVector::op_begin() { return OperandTraits<ConstantVector>::op_begin(this); } ConstantVector::const_op_iterator ConstantVector::op_begin() const { return OperandTraits<ConstantVector>::op_begin(const_cast<ConstantVector*>(this)); } ConstantVector::op_iterator ConstantVector::op_end() { return OperandTraits<ConstantVector>::op_end(this); } ConstantVector::const_op_iterator ConstantVector::op_end() const { return OperandTraits<ConstantVector>::op_end(const_cast<ConstantVector*>(this)); } Constant *ConstantVector::getOperand(unsigned i_nocapture) const { ((void)((i_nocapture < OperandTraits<ConstantVector>::operands(this) && "getOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<ConstantVector>::operands(this) && \"getOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Constants.h", 478, __func__),0))); return cast_or_null<Constant>( OperandTraits<ConstantVector>::op_begin(const_cast<ConstantVector*>(this))[i_nocapture].get()); } void ConstantVector::setOperand(unsigned i_nocapture, Constant *Val_nocapture) { ((void)((i_nocapture < OperandTraits<ConstantVector>::operands(this) && "setOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<ConstantVector>::operands(this) && \"setOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Constants.h", 478, __func__),0))); OperandTraits<ConstantVector>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned ConstantVector::getNumOperands() const { return OperandTraits<ConstantVector>::operands(this); } template <int Idx_nocapture> Use &ConstantVector::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &ConstantVector::Op() const { return this->OpFrom<Idx_nocapture>(this); }




class ConstantPointerNull : public Constant {
  void *operator new(size_t, unsigned) ;
  ConstantPointerNull(const ConstantPointerNull &) ;
protected:
  explicit ConstantPointerNull(PointerType *T)
    : Constant(T,
               Value::ConstantPointerNullVal, 0, 0) {}

protected:

  void *operator new(size_t s) {
    return User::operator new(s, 0);
  }
public:

  static ConstantPointerNull *get(PointerType *T);

  virtual void destroyConstant();




  inline PointerType *getType() const {
    return cast<PointerType>(Value::getType());
  }


  static bool classof(const Value *V) {
    return V->getValueID() == ConstantPointerNullVal;
  }
};
# 524 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Constants.h"
class ConstantDataSequential : public Constant {
  friend class LLVMContextImpl;


  const char *DataElements;





  ConstantDataSequential *Next;
  void *operator new(size_t, unsigned) ;
  ConstantDataSequential(const ConstantDataSequential &) ;
protected:
  explicit ConstantDataSequential(Type *ty, ValueTy VT, const char *Data)
    : Constant(ty, VT, 0, 0), DataElements(Data), Next(0) {}
  ~ConstantDataSequential() { delete Next; }

  static Constant *getImpl(StringRef Bytes, Type *Ty);

protected:

  void *operator new(size_t s) {
    return User::operator new(s, 0);
  }
public:





  static bool isElementTypeCompatible(const Type *Ty);



  uint64_t getElementAsInteger(unsigned i) const;



  APFloat getElementAsAPFloat(unsigned i) const;



  float getElementAsFloat(unsigned i) const;



  double getElementAsDouble(unsigned i) const;




  Constant *getElementAsConstant(unsigned i) const;




  inline SequentialType *getType() const {
    return cast<SequentialType>(Value::getType());
  }


  Type *getElementType() const;


  unsigned getNumElements() const;




  uint64_t getElementByteSize() const;



  bool isString() const;



  bool isCString() const;




  StringRef getAsString() const {
    ((void)((isString() && "Not a string") || (__assert_fail("isString() && \"Not a string\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Constants.h", 608, __func__),0)));
    return getRawDataValues();
  }





  StringRef getAsCString() const {
    ((void)((isCString() && "Isn't a C string") || (__assert_fail("isCString() && \"Isn't a C string\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Constants.h", 617, __func__),0)));
    StringRef Str = getAsString();
    return Str.substr(0, Str.size()-1);
  }




  StringRef getRawDataValues() const;

  virtual void destroyConstant();



  static bool classof(const Value *V) {
    return V->getValueID() == ConstantDataArrayVal ||
           V->getValueID() == ConstantDataVectorVal;
  }
private:
  const char *getElementPointer(unsigned Elt) const;
};







class ConstantDataArray : public ConstantDataSequential {
  void *operator new(size_t, unsigned) ;
  ConstantDataArray(const ConstantDataArray &) ;
  virtual void anchor();
  friend class ConstantDataSequential;
  explicit ConstantDataArray(Type *ty, const char *Data)
    : ConstantDataSequential(ty, ConstantDataArrayVal, Data) {}
protected:

  void *operator new(size_t s) {
    return User::operator new(s, 0);
  }
public:




  static Constant *get(LLVMContext &Context, ArrayRef<uint8_t> Elts);
  static Constant *get(LLVMContext &Context, ArrayRef<uint16_t> Elts);
  static Constant *get(LLVMContext &Context, ArrayRef<uint32_t> Elts);
  static Constant *get(LLVMContext &Context, ArrayRef<uint64_t> Elts);
  static Constant *get(LLVMContext &Context, ArrayRef<float> Elts);
  static Constant *get(LLVMContext &Context, ArrayRef<double> Elts);






  static Constant *getString(LLVMContext &Context, StringRef Initializer,
                             bool AddNull = true);




  inline ArrayType *getType() const {
    return cast<ArrayType>(Value::getType());
  }



  static bool classof(const Value *V) {
    return V->getValueID() == ConstantDataArrayVal;
  }
};







class ConstantDataVector : public ConstantDataSequential {
  void *operator new(size_t, unsigned) ;
  ConstantDataVector(const ConstantDataVector &) ;
  virtual void anchor();
  friend class ConstantDataSequential;
  explicit ConstantDataVector(Type *ty, const char *Data)
  : ConstantDataSequential(ty, ConstantDataVectorVal, Data) {}
protected:

  void *operator new(size_t s) {
    return User::operator new(s, 0);
  }
public:




  static Constant *get(LLVMContext &Context, ArrayRef<uint8_t> Elts);
  static Constant *get(LLVMContext &Context, ArrayRef<uint16_t> Elts);
  static Constant *get(LLVMContext &Context, ArrayRef<uint32_t> Elts);
  static Constant *get(LLVMContext &Context, ArrayRef<uint64_t> Elts);
  static Constant *get(LLVMContext &Context, ArrayRef<float> Elts);
  static Constant *get(LLVMContext &Context, ArrayRef<double> Elts);




  static Constant *getSplat(unsigned NumElts, Constant *Elt);



  Constant *getSplatValue() const;




  inline VectorType *getType() const {
    return cast<VectorType>(Value::getType());
  }



  static bool classof(const Value *V) {
    return V->getValueID() == ConstantDataVectorVal;
  }
};





class BlockAddress : public Constant {
  void *operator new(size_t, unsigned) ;
  void *operator new(size_t s) { return User::operator new(s, 2); }
  BlockAddress(Function *F, BasicBlock *BB);
public:

  static BlockAddress *get(Function *F, BasicBlock *BB);



  static BlockAddress *get(BasicBlock *BB);


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;

  Function *getFunction() const { return (Function*)Op<0>().get(); }
  BasicBlock *getBasicBlock() const { return (BasicBlock*)Op<1>().get(); }

  virtual void destroyConstant();
  virtual void replaceUsesOfWithOnConstant(Value *From, Value *To, Use *U);


  static inline bool classof(const Value *V) {
    return V->getValueID() == BlockAddressVal;
  }
};

template <>
struct OperandTraits<BlockAddress> :
  public FixedNumOperandTraits<BlockAddress, 2> {
};

BlockAddress::op_iterator BlockAddress::op_begin() { return OperandTraits<BlockAddress>::op_begin(this); } BlockAddress::const_op_iterator BlockAddress::op_begin() const { return OperandTraits<BlockAddress>::op_begin(const_cast<BlockAddress*>(this)); } BlockAddress::op_iterator BlockAddress::op_end() { return OperandTraits<BlockAddress>::op_end(this); } BlockAddress::const_op_iterator BlockAddress::op_end() const { return OperandTraits<BlockAddress>::op_end(const_cast<BlockAddress*>(this)); } Value *BlockAddress::getOperand(unsigned i_nocapture) const { ((void)((i_nocapture < OperandTraits<BlockAddress>::operands(this) && "getOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<BlockAddress>::operands(this) && \"getOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Constants.h", 780, __func__),0))); return cast_or_null<Value>( OperandTraits<BlockAddress>::op_begin(const_cast<BlockAddress*>(this))[i_nocapture].get()); } void BlockAddress::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((void)((i_nocapture < OperandTraits<BlockAddress>::operands(this) && "setOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<BlockAddress>::operands(this) && \"setOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Constants.h", 780, __func__),0))); OperandTraits<BlockAddress>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned BlockAddress::getNumOperands() const { return OperandTraits<BlockAddress>::operands(this); } template <int Idx_nocapture> Use &BlockAddress::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &BlockAddress::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 790 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Constants.h"
class ConstantExpr : public Constant {
  friend struct ConstantCreator<ConstantExpr,Type,
                            std::pair<unsigned, std::vector<Constant*> > >;
  friend struct ConvertConstantType<ConstantExpr, Type>;

protected:
  ConstantExpr(Type *ty, unsigned Opcode, Use *Ops, unsigned NumOps)
    : Constant(ty, ConstantExprVal, Ops, NumOps) {

    setValueSubclassData(Opcode);
  }

public:







  static Constant *getAlignOf(Type *Ty);





  static Constant *getSizeOf(Type *Ty);




  static Constant *getOffsetOf(StructType *STy, unsigned FieldNo);




  static Constant *getOffsetOf(Type *Ty, Constant *FieldNo);

  static Constant *getNeg(Constant *C, bool HasNUW = false, bool HasNSW =false);
  static Constant *getFNeg(Constant *C);
  static Constant *getNot(Constant *C);
  static Constant *getAdd(Constant *C1, Constant *C2,
                          bool HasNUW = false, bool HasNSW = false);
  static Constant *getFAdd(Constant *C1, Constant *C2);
  static Constant *getSub(Constant *C1, Constant *C2,
                          bool HasNUW = false, bool HasNSW = false);
  static Constant *getFSub(Constant *C1, Constant *C2);
  static Constant *getMul(Constant *C1, Constant *C2,
                          bool HasNUW = false, bool HasNSW = false);
  static Constant *getFMul(Constant *C1, Constant *C2);
  static Constant *getUDiv(Constant *C1, Constant *C2, bool isExact = false);
  static Constant *getSDiv(Constant *C1, Constant *C2, bool isExact = false);
  static Constant *getFDiv(Constant *C1, Constant *C2);
  static Constant *getURem(Constant *C1, Constant *C2);
  static Constant *getSRem(Constant *C1, Constant *C2);
  static Constant *getFRem(Constant *C1, Constant *C2);
  static Constant *getAnd(Constant *C1, Constant *C2);
  static Constant *getOr(Constant *C1, Constant *C2);
  static Constant *getXor(Constant *C1, Constant *C2);
  static Constant *getShl(Constant *C1, Constant *C2,
                          bool HasNUW = false, bool HasNSW = false);
  static Constant *getLShr(Constant *C1, Constant *C2, bool isExact = false);
  static Constant *getAShr(Constant *C1, Constant *C2, bool isExact = false);
  static Constant *getTrunc (Constant *C, Type *Ty);
  static Constant *getSExt (Constant *C, Type *Ty);
  static Constant *getZExt (Constant *C, Type *Ty);
  static Constant *getFPTrunc (Constant *C, Type *Ty);
  static Constant *getFPExtend(Constant *C, Type *Ty);
  static Constant *getUIToFP (Constant *C, Type *Ty);
  static Constant *getSIToFP (Constant *C, Type *Ty);
  static Constant *getFPToUI (Constant *C, Type *Ty);
  static Constant *getFPToSI (Constant *C, Type *Ty);
  static Constant *getPtrToInt(Constant *C, Type *Ty);
  static Constant *getIntToPtr(Constant *C, Type *Ty);
  static Constant *getBitCast (Constant *C, Type *Ty);
  static Constant *getAddrSpaceCast(Constant *C, Type *Ty);

  static Constant *getNSWNeg(Constant *C) { return getNeg(C, false, true); }
  static Constant *getNUWNeg(Constant *C) { return getNeg(C, true, false); }
  static Constant *getNSWAdd(Constant *C1, Constant *C2) {
    return getAdd(C1, C2, false, true);
  }
  static Constant *getNUWAdd(Constant *C1, Constant *C2) {
    return getAdd(C1, C2, true, false);
  }
  static Constant *getNSWSub(Constant *C1, Constant *C2) {
    return getSub(C1, C2, false, true);
  }
  static Constant *getNUWSub(Constant *C1, Constant *C2) {
    return getSub(C1, C2, true, false);
  }
  static Constant *getNSWMul(Constant *C1, Constant *C2) {
    return getMul(C1, C2, false, true);
  }
  static Constant *getNUWMul(Constant *C1, Constant *C2) {
    return getMul(C1, C2, true, false);
  }
  static Constant *getNSWShl(Constant *C1, Constant *C2) {
    return getShl(C1, C2, false, true);
  }
  static Constant *getNUWShl(Constant *C1, Constant *C2) {
    return getShl(C1, C2, true, false);
  }
  static Constant *getExactSDiv(Constant *C1, Constant *C2) {
    return getSDiv(C1, C2, true);
  }
  static Constant *getExactUDiv(Constant *C1, Constant *C2) {
    return getUDiv(C1, C2, true);
  }
  static Constant *getExactAShr(Constant *C1, Constant *C2) {
    return getAShr(C1, C2, true);
  }
  static Constant *getExactLShr(Constant *C1, Constant *C2) {
    return getLShr(C1, C2, true);
  }




  static Constant *getBinOpIdentity(unsigned Opcode, Type *Ty);





  static Constant *getBinOpAbsorber(unsigned Opcode, Type *Ty);


  public: inline Constant *getOperand(unsigned) const; inline void setOperand(unsigned, Constant*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;



  static Constant *getCast(
    unsigned ops,
    Constant *C,
    Type *Ty
  );


  static Constant *getZExtOrBitCast(
    Constant *C,
    Type *Ty
  );


  static Constant *getSExtOrBitCast(
    Constant *C,
    Type *Ty
  );


  static Constant *getTruncOrBitCast(
    Constant *C,
    Type *Ty
  );


  static Constant *getPointerCast(
    Constant *C,
    Type *Ty
  );


  static Constant *getIntegerCast(
    Constant *C,
    Type *Ty,
    bool isSigned
  );


  static Constant *getFPCast(
    Constant *C,
    Type *Ty
  );


  bool isCast() const;


  bool isCompare() const;



  bool hasIndices() const;






  bool isGEPWithNoNotionalOverIndexing() const;



  static Constant *getSelect(Constant *C, Constant *V1, Constant *V2);




  static Constant *get(unsigned Opcode, Constant *C1, Constant *C2,
                       unsigned Flags = 0);


  static Constant *getCompare(unsigned short pred, Constant *C1, Constant *C2);




  static Constant *getICmp(unsigned short pred, Constant *LHS, Constant *RHS);
  static Constant *getFCmp(unsigned short pred, Constant *LHS, Constant *RHS);




  static Constant *getGetElementPtr(Constant *C,
                                    ArrayRef<Constant *> IdxList,
                                    bool InBounds = false) {
    return getGetElementPtr(C, makeArrayRef((Value * const *)IdxList.data(),
                                            IdxList.size()),
                            InBounds);
  }
  static Constant *getGetElementPtr(Constant *C,
                                    Constant *Idx,
                                    bool InBounds = false) {



    return getGetElementPtr(C, cast<Value>(Idx), InBounds);
  }
  static Constant *getGetElementPtr(Constant *C,
                                    ArrayRef<Value *> IdxList,
                                    bool InBounds = false);



  static Constant *getInBoundsGetElementPtr(Constant *C,
                                            ArrayRef<Constant *> IdxList) {
    return getGetElementPtr(C, IdxList, true);
  }
  static Constant *getInBoundsGetElementPtr(Constant *C,
                                            Constant *Idx) {



    return getGetElementPtr(C, Idx, true);
  }
  static Constant *getInBoundsGetElementPtr(Constant *C,
                                            ArrayRef<Value *> IdxList) {
    return getGetElementPtr(C, IdxList, true);
  }

  static Constant *getExtractElement(Constant *Vec, Constant *Idx);
  static Constant *getInsertElement(Constant *Vec, Constant *Elt,Constant *Idx);
  static Constant *getShuffleVector(Constant *V1, Constant *V2, Constant *Mask);
  static Constant *getExtractValue(Constant *Agg, ArrayRef<unsigned> Idxs);
  static Constant *getInsertValue(Constant *Agg, Constant *Val,
                                  ArrayRef<unsigned> Idxs);


  unsigned getOpcode() const { return getSubclassDataFromValue(); }



  unsigned getPredicate() const;



  ArrayRef<unsigned> getIndices() const;


  const char *getOpcodeName() const;



  Constant *getWithOperandReplaced(unsigned OpNo, Constant *Op) const;




  Constant *getWithOperands(ArrayRef<Constant*> Ops) const {
    return getWithOperands(Ops, getType());
  }





  Constant *getWithOperands(ArrayRef<Constant*> Ops, Type *Ty) const;
# 1086 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Constants.h"
  Instruction *getAsInstruction();

  virtual void destroyConstant();
  virtual void replaceUsesOfWithOnConstant(Value *From, Value *To, Use *U);


  static inline bool classof(const Value *V) {
    return V->getValueID() == ConstantExprVal;
  }

private:


  void setValueSubclassData(unsigned short D) {
    Value::setValueSubclassData(D);
  }
};

template <>
struct OperandTraits<ConstantExpr> :
  public VariadicOperandTraits<ConstantExpr, 1> {
};

ConstantExpr::op_iterator ConstantExpr::op_begin() { return OperandTraits<ConstantExpr>::op_begin(this); } ConstantExpr::const_op_iterator ConstantExpr::op_begin() const { return OperandTraits<ConstantExpr>::op_begin(const_cast<ConstantExpr*>(this)); } ConstantExpr::op_iterator ConstantExpr::op_end() { return OperandTraits<ConstantExpr>::op_end(this); } ConstantExpr::const_op_iterator ConstantExpr::op_end() const { return OperandTraits<ConstantExpr>::op_end(const_cast<ConstantExpr*>(this)); } Constant *ConstantExpr::getOperand(unsigned i_nocapture) const { ((void)((i_nocapture < OperandTraits<ConstantExpr>::operands(this) && "getOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<ConstantExpr>::operands(this) && \"getOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Constants.h", 1109, __func__),0))); return cast_or_null<Constant>( OperandTraits<ConstantExpr>::op_begin(const_cast<ConstantExpr*>(this))[i_nocapture].get()); } void ConstantExpr::setOperand(unsigned i_nocapture, Constant *Val_nocapture) { ((void)((i_nocapture < OperandTraits<ConstantExpr>::operands(this) && "setOperand() out of range!") || (__assert_fail("i_nocapture < OperandTraits<ConstantExpr>::operands(this) && \"setOperand() out of range!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Constants.h", 1109, __func__),0))); OperandTraits<ConstantExpr>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned ConstantExpr::getNumOperands() const { return OperandTraits<ConstantExpr>::operands(this); } template <int Idx_nocapture> Use &ConstantExpr::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &ConstantExpr::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 1121 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Constants.h"
class UndefValue : public Constant {
  void *operator new(size_t, unsigned) ;
  UndefValue(const UndefValue &) ;
protected:
  explicit UndefValue(Type *T) : Constant(T, UndefValueVal, 0, 0) {}
protected:

  void *operator new(size_t s) {
    return User::operator new(s, 0);
  }
public:



  static UndefValue *get(Type *T);



  UndefValue *getSequentialElement() const;



  UndefValue *getStructElement(unsigned Elt) const;



  UndefValue *getElementValue(Constant *C) const;



  UndefValue *getElementValue(unsigned Idx) const;

  virtual void destroyConstant();


  static bool classof(const Value *V) {
    return V->getValueID() == UndefValueVal;
  }
};

}
# 28 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/IntrinsicInst.h" 2


# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Intrinsics.h" 1
# 22 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Intrinsics.h"
namespace llvm {

class Type;
class FunctionType;
class Function;
class LLVMContext;
class Module;
class AttributeSet;





namespace Intrinsic {
  enum ID {
    not_intrinsic = 0,




# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/build/include/llvm/IR/Intrinsics.gen" 1
# 19 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/build/include/llvm/IR/Intrinsics.gen"
    aarch64_neon_fcvtas,
    aarch64_neon_fcvtau,
    aarch64_neon_fcvtms,
    aarch64_neon_fcvtmu,
    aarch64_neon_fcvtns,
    aarch64_neon_fcvtnu,
    aarch64_neon_fcvtps,
    aarch64_neon_fcvtpu,
    aarch64_neon_fcvtxn,
    aarch64_neon_frintn,
    aarch64_neon_fsqrt,
    aarch64_neon_rbit,
    aarch64_neon_saddlv,
    aarch64_neon_sha1c,
    aarch64_neon_sha1m,
    aarch64_neon_sha1p,
    aarch64_neon_smaxv,
    aarch64_neon_sminv,
    aarch64_neon_suqadd,
    aarch64_neon_uaddlv,
    aarch64_neon_umaxv,
    aarch64_neon_uminv,
    aarch64_neon_usqadd,
    aarch64_neon_vabs,
    aarch64_neon_vacgeq,
    aarch64_neon_vacgtq,
    aarch64_neon_vaddds,
    aarch64_neon_vadddu,
    aarch64_neon_vaddv,
    aarch64_neon_vcage,
    aarch64_neon_vcagt,
    aarch64_neon_vceq,
    aarch64_neon_vcge,
    aarch64_neon_vcgt,
    aarch64_neon_vchi,
    aarch64_neon_vchs,
    aarch64_neon_vclez,
    aarch64_neon_vcltz,
    aarch64_neon_vcvtd_n_s64_f64,
    aarch64_neon_vcvtd_n_u64_f64,
    aarch64_neon_vcvtf32_n_s32,
    aarch64_neon_vcvtf32_n_u32,
    aarch64_neon_vcvtf32_s32,
    aarch64_neon_vcvtf32_u32,
    aarch64_neon_vcvtf64_n_s64,
    aarch64_neon_vcvtf64_n_u64,
    aarch64_neon_vcvtf64_s64,
    aarch64_neon_vcvtf64_u64,
    aarch64_neon_vcvts_n_s32_f32,
    aarch64_neon_vcvts_n_u32_f32,
    aarch64_neon_vld1x2,
    aarch64_neon_vld1x3,
    aarch64_neon_vld1x4,
    aarch64_neon_vmaxnm,
    aarch64_neon_vmaxnmv,
    aarch64_neon_vmaxv,
    aarch64_neon_vminnm,
    aarch64_neon_vminnmv,
    aarch64_neon_vminv,
    aarch64_neon_vmulx,
    aarch64_neon_vneg,
    aarch64_neon_vpadd,
    aarch64_neon_vpfadd,
    aarch64_neon_vpfaddq,
    aarch64_neon_vpfmaxnm,
    aarch64_neon_vpfmaxnmq,
    aarch64_neon_vpfminnm,
    aarch64_neon_vpfminnmq,
    aarch64_neon_vpmax,
    aarch64_neon_vpmaxnm,
    aarch64_neon_vpmaxq,
    aarch64_neon_vpmin,
    aarch64_neon_vpminnm,
    aarch64_neon_vpminq,
    aarch64_neon_vqadds,
    aarch64_neon_vqaddu,
    aarch64_neon_vqdmlal,
    aarch64_neon_vqdmlsl,
    aarch64_neon_vqdmull,
    aarch64_neon_vqrshls,
    aarch64_neon_vqrshlu,
    aarch64_neon_vqshls,
    aarch64_neon_vqshls_n,
    aarch64_neon_vqshlu,
    aarch64_neon_vqshlu_n,
    aarch64_neon_vqshlus_n,
    aarch64_neon_vqsubs,
    aarch64_neon_vqsubu,
    aarch64_neon_vrecpx,
    aarch64_neon_vrshlds,
    aarch64_neon_vrshldu,
    aarch64_neon_vrshrn,
    aarch64_neon_vrsrads_n,
    aarch64_neon_vrsradu_n,
    aarch64_neon_vshld_n,
    aarch64_neon_vshlds,
    aarch64_neon_vshldu,
    aarch64_neon_vshrds_n,
    aarch64_neon_vshrdu_n,
    aarch64_neon_vsli,
    aarch64_neon_vsqadd,
    aarch64_neon_vsqrshrn,
    aarch64_neon_vsqrshrun,
    aarch64_neon_vsqshlu,
    aarch64_neon_vsqshrn,
    aarch64_neon_vsqshrun,
    aarch64_neon_vsrads_n,
    aarch64_neon_vsradu_n,
    aarch64_neon_vsri,
    aarch64_neon_vsrshr,
    aarch64_neon_vst1x2,
    aarch64_neon_vst1x3,
    aarch64_neon_vst1x4,
    aarch64_neon_vsubds,
    aarch64_neon_vsubdu,
    aarch64_neon_vtbl1,
    aarch64_neon_vtbl2,
    aarch64_neon_vtbl3,
    aarch64_neon_vtbl4,
    aarch64_neon_vtbx1,
    aarch64_neon_vtbx2,
    aarch64_neon_vtbx3,
    aarch64_neon_vtbx4,
    aarch64_neon_vtstd,
    aarch64_neon_vuqadd,
    aarch64_neon_vuqrshrn,
    aarch64_neon_vuqshrn,
    aarch64_neon_vurshr,
    aarch64_neon_xtn,
    adjust_trampoline,
    annotation,
    arm_cdp,
    arm_cdp2,
    arm_clrex,
    arm_crc32b,
    arm_crc32cb,
    arm_crc32ch,
    arm_crc32cw,
    arm_crc32h,
    arm_crc32w,
    arm_dmb,
    arm_dsb,
    arm_get_fpscr,
    arm_ldrex,
    arm_ldrexd,
    arm_mcr,
    arm_mcr2,
    arm_mcrr,
    arm_mcrr2,
    arm_mrc,
    arm_mrc2,
    arm_neon_aesd,
    arm_neon_aese,
    arm_neon_aesimc,
    arm_neon_aesmc,
    arm_neon_sha1c,
    arm_neon_sha1h,
    arm_neon_sha1m,
    arm_neon_sha1p,
    arm_neon_sha1su0,
    arm_neon_sha1su1,
    arm_neon_sha256h,
    arm_neon_sha256h2,
    arm_neon_sha256su0,
    arm_neon_sha256su1,
    arm_neon_vabds,
    arm_neon_vabdu,
    arm_neon_vabs,
    arm_neon_vacged,
    arm_neon_vacgeq,
    arm_neon_vacgtd,
    arm_neon_vacgtq,
    arm_neon_vbsl,
    arm_neon_vcls,
    arm_neon_vclz,
    arm_neon_vcnt,
    arm_neon_vcvtas,
    arm_neon_vcvtau,
    arm_neon_vcvtfp2fxs,
    arm_neon_vcvtfp2fxu,
    arm_neon_vcvtfp2hf,
    arm_neon_vcvtfxs2fp,
    arm_neon_vcvtfxu2fp,
    arm_neon_vcvthf2fp,
    arm_neon_vcvtms,
    arm_neon_vcvtmu,
    arm_neon_vcvtns,
    arm_neon_vcvtnu,
    arm_neon_vcvtps,
    arm_neon_vcvtpu,
    arm_neon_vhadds,
    arm_neon_vhaddu,
    arm_neon_vhsubs,
    arm_neon_vhsubu,
    arm_neon_vld1,
    arm_neon_vld2,
    arm_neon_vld2lane,
    arm_neon_vld3,
    arm_neon_vld3lane,
    arm_neon_vld4,
    arm_neon_vld4lane,
    arm_neon_vmaxnm,
    arm_neon_vmaxs,
    arm_neon_vmaxu,
    arm_neon_vminnm,
    arm_neon_vmins,
    arm_neon_vminu,
    arm_neon_vmullp,
    arm_neon_vmulls,
    arm_neon_vmullu,
    arm_neon_vmulp,
    arm_neon_vpadals,
    arm_neon_vpadalu,
    arm_neon_vpadd,
    arm_neon_vpaddls,
    arm_neon_vpaddlu,
    arm_neon_vpmaxs,
    arm_neon_vpmaxu,
    arm_neon_vpmins,
    arm_neon_vpminu,
    arm_neon_vqabs,
    arm_neon_vqadds,
    arm_neon_vqaddu,
    arm_neon_vqdmulh,
    arm_neon_vqdmull,
    arm_neon_vqmovns,
    arm_neon_vqmovnsu,
    arm_neon_vqmovnu,
    arm_neon_vqneg,
    arm_neon_vqrdmulh,
    arm_neon_vqrshiftns,
    arm_neon_vqrshiftnsu,
    arm_neon_vqrshiftnu,
    arm_neon_vqrshifts,
    arm_neon_vqrshiftu,
    arm_neon_vqshiftns,
    arm_neon_vqshiftnsu,
    arm_neon_vqshiftnu,
    arm_neon_vqshifts,
    arm_neon_vqshiftsu,
    arm_neon_vqshiftu,
    arm_neon_vqsubs,
    arm_neon_vqsubu,
    arm_neon_vraddhn,
    arm_neon_vrecpe,
    arm_neon_vrecps,
    arm_neon_vrhadds,
    arm_neon_vrhaddu,
    arm_neon_vrinta,
    arm_neon_vrintm,
    arm_neon_vrintn,
    arm_neon_vrintp,
    arm_neon_vrintx,
    arm_neon_vrintz,
    arm_neon_vrshiftn,
    arm_neon_vrshifts,
    arm_neon_vrshiftu,
    arm_neon_vrsqrte,
    arm_neon_vrsqrts,
    arm_neon_vrsubhn,
    arm_neon_vshiftins,
    arm_neon_vshiftls,
    arm_neon_vshiftlu,
    arm_neon_vshiftn,
    arm_neon_vshifts,
    arm_neon_vshiftu,
    arm_neon_vst1,
    arm_neon_vst2,
    arm_neon_vst2lane,
    arm_neon_vst3,
    arm_neon_vst3lane,
    arm_neon_vst4,
    arm_neon_vst4lane,
    arm_neon_vtbl1,
    arm_neon_vtbl2,
    arm_neon_vtbl3,
    arm_neon_vtbl4,
    arm_neon_vtbx1,
    arm_neon_vtbx2,
    arm_neon_vtbx3,
    arm_neon_vtbx4,
    arm_qadd,
    arm_qsub,
    arm_set_fpscr,
    arm_sevl,
    arm_ssat,
    arm_strex,
    arm_strexd,
    arm_thread_pointer,
    arm_usat,
    arm_vcvtr,
    arm_vcvtru,
    bswap,
    ceil,
    convert_from_fp16,
    convert_to_fp16,
    convertff,
    convertfsi,
    convertfui,
    convertsif,
    convertss,
    convertsu,
    convertuif,
    convertus,
    convertuu,
    copysign,
    cos,
    ctlz,
    ctpop,
    cttz,
    cuda_syncthreads,
    dbg_declare,
    dbg_value,
    debugtrap,
    donothing,
    eh_dwarf_cfa,
    eh_return_i32,
    eh_return_i64,
    eh_sjlj_callsite,
    eh_sjlj_functioncontext,
    eh_sjlj_longjmp,
    eh_sjlj_lsda,
    eh_sjlj_setjmp,
    eh_typeid_for,
    eh_unwind_init,
    exp,
    exp2,
    expect,
    experimental_patchpoint_i64,
    experimental_patchpoint_void,
    experimental_stackmap,
    fabs,
    floor,
    flt_rounds,
    fma,
    fmuladd,
    frameaddress,
    gcread,
    gcroot,
    gcwrite,
    hexagon_A2_abs,
    hexagon_A2_absp,
    hexagon_A2_abssat,
    hexagon_A2_add,
    hexagon_A2_addh_h16_hh,
    hexagon_A2_addh_h16_hl,
    hexagon_A2_addh_h16_lh,
    hexagon_A2_addh_h16_ll,
    hexagon_A2_addh_h16_sat_hh,
    hexagon_A2_addh_h16_sat_hl,
    hexagon_A2_addh_h16_sat_lh,
    hexagon_A2_addh_h16_sat_ll,
    hexagon_A2_addh_l16_hl,
    hexagon_A2_addh_l16_ll,
    hexagon_A2_addh_l16_sat_hl,
    hexagon_A2_addh_l16_sat_ll,
    hexagon_A2_addi,
    hexagon_A2_addp,
    hexagon_A2_addpsat,
    hexagon_A2_addsat,
    hexagon_A2_addsp,
    hexagon_A2_and,
    hexagon_A2_andir,
    hexagon_A2_andp,
    hexagon_A2_aslh,
    hexagon_A2_asrh,
    hexagon_A2_combine_hh,
    hexagon_A2_combine_hl,
    hexagon_A2_combine_lh,
    hexagon_A2_combine_ll,
    hexagon_A2_combineii,
    hexagon_A2_combinew,
    hexagon_A2_max,
    hexagon_A2_maxp,
    hexagon_A2_maxu,
    hexagon_A2_maxup,
    hexagon_A2_min,
    hexagon_A2_minp,
    hexagon_A2_minu,
    hexagon_A2_minup,
    hexagon_A2_neg,
    hexagon_A2_negp,
    hexagon_A2_negsat,
    hexagon_A2_not,
    hexagon_A2_notp,
    hexagon_A2_or,
    hexagon_A2_orir,
    hexagon_A2_orp,
    hexagon_A2_roundsat,
    hexagon_A2_sat,
    hexagon_A2_satb,
    hexagon_A2_sath,
    hexagon_A2_satub,
    hexagon_A2_satuh,
    hexagon_A2_sub,
    hexagon_A2_subh_h16_hh,
    hexagon_A2_subh_h16_hl,
    hexagon_A2_subh_h16_lh,
    hexagon_A2_subh_h16_ll,
    hexagon_A2_subh_h16_sat_hh,
    hexagon_A2_subh_h16_sat_hl,
    hexagon_A2_subh_h16_sat_lh,
    hexagon_A2_subh_h16_sat_ll,
    hexagon_A2_subh_l16_hl,
    hexagon_A2_subh_l16_ll,
    hexagon_A2_subh_l16_sat_hl,
    hexagon_A2_subh_l16_sat_ll,
    hexagon_A2_subp,
    hexagon_A2_subri,
    hexagon_A2_subsat,
    hexagon_A2_svaddh,
    hexagon_A2_svaddhs,
    hexagon_A2_svadduhs,
    hexagon_A2_svavgh,
    hexagon_A2_svavghs,
    hexagon_A2_svnavgh,
    hexagon_A2_svsubh,
    hexagon_A2_svsubhs,
    hexagon_A2_svsubuhs,
    hexagon_A2_swiz,
    hexagon_A2_sxtb,
    hexagon_A2_sxth,
    hexagon_A2_sxtw,
    hexagon_A2_tfr,
    hexagon_A2_tfrih,
    hexagon_A2_tfril,
    hexagon_A2_tfrp,
    hexagon_A2_tfrpi,
    hexagon_A2_tfrsi,
    hexagon_A2_vabsh,
    hexagon_A2_vabshsat,
    hexagon_A2_vabsw,
    hexagon_A2_vabswsat,
    hexagon_A2_vaddb_map,
    hexagon_A2_vaddh,
    hexagon_A2_vaddhs,
    hexagon_A2_vaddub,
    hexagon_A2_vaddubs,
    hexagon_A2_vadduhs,
    hexagon_A2_vaddw,
    hexagon_A2_vaddws,
    hexagon_A2_vavgh,
    hexagon_A2_vavghcr,
    hexagon_A2_vavghr,
    hexagon_A2_vavgub,
    hexagon_A2_vavgubr,
    hexagon_A2_vavguh,
    hexagon_A2_vavguhr,
    hexagon_A2_vavguw,
    hexagon_A2_vavguwr,
    hexagon_A2_vavgw,
    hexagon_A2_vavgwcr,
    hexagon_A2_vavgwr,
    hexagon_A2_vcmpbeq,
    hexagon_A2_vcmpbgtu,
    hexagon_A2_vcmpheq,
    hexagon_A2_vcmphgt,
    hexagon_A2_vcmphgtu,
    hexagon_A2_vcmpweq,
    hexagon_A2_vcmpwgt,
    hexagon_A2_vcmpwgtu,
    hexagon_A2_vconj,
    hexagon_A2_vmaxb,
    hexagon_A2_vmaxh,
    hexagon_A2_vmaxub,
    hexagon_A2_vmaxuh,
    hexagon_A2_vmaxuw,
    hexagon_A2_vmaxw,
    hexagon_A2_vminb,
    hexagon_A2_vminh,
    hexagon_A2_vminub,
    hexagon_A2_vminuh,
    hexagon_A2_vminuw,
    hexagon_A2_vminw,
    hexagon_A2_vnavgh,
    hexagon_A2_vnavghcr,
    hexagon_A2_vnavghr,
    hexagon_A2_vnavgw,
    hexagon_A2_vnavgwcr,
    hexagon_A2_vnavgwr,
    hexagon_A2_vraddub,
    hexagon_A2_vraddub_acc,
    hexagon_A2_vrsadub,
    hexagon_A2_vrsadub_acc,
    hexagon_A2_vsubb_map,
    hexagon_A2_vsubh,
    hexagon_A2_vsubhs,
    hexagon_A2_vsubub,
    hexagon_A2_vsububs,
    hexagon_A2_vsubuhs,
    hexagon_A2_vsubw,
    hexagon_A2_vsubws,
    hexagon_A2_xor,
    hexagon_A2_xorp,
    hexagon_A2_zxtb,
    hexagon_A2_zxth,
    hexagon_A4_andn,
    hexagon_A4_andnp,
    hexagon_A4_bitsplit,
    hexagon_A4_bitspliti,
    hexagon_A4_boundscheck,
    hexagon_A4_cmpbeq,
    hexagon_A4_cmpbeqi,
    hexagon_A4_cmpbgt,
    hexagon_A4_cmpbgti,
    hexagon_A4_cmpbgtu,
    hexagon_A4_cmpbgtui,
    hexagon_A4_cmpheq,
    hexagon_A4_cmpheqi,
    hexagon_A4_cmphgt,
    hexagon_A4_cmphgti,
    hexagon_A4_cmphgtu,
    hexagon_A4_cmphgtui,
    hexagon_A4_combineir,
    hexagon_A4_combineri,
    hexagon_A4_cround_ri,
    hexagon_A4_cround_rr,
    hexagon_A4_modwrapu,
    hexagon_A4_orn,
    hexagon_A4_ornp,
    hexagon_A4_rcmpeq,
    hexagon_A4_rcmpeqi,
    hexagon_A4_rcmpneq,
    hexagon_A4_rcmpneqi,
    hexagon_A4_round_ri,
    hexagon_A4_round_ri_sat,
    hexagon_A4_round_rr,
    hexagon_A4_round_rr_sat,
    hexagon_A4_tlbmatch,
    hexagon_A4_vcmpbeq_any,
    hexagon_A4_vcmpbeqi,
    hexagon_A4_vcmpbgt,
    hexagon_A4_vcmpbgti,
    hexagon_A4_vcmpbgtui,
    hexagon_A4_vcmpheqi,
    hexagon_A4_vcmphgti,
    hexagon_A4_vcmphgtui,
    hexagon_A4_vcmpweqi,
    hexagon_A4_vcmpwgti,
    hexagon_A4_vcmpwgtui,
    hexagon_A4_vrmaxh,
    hexagon_A4_vrmaxuh,
    hexagon_A4_vrmaxuw,
    hexagon_A4_vrmaxw,
    hexagon_A4_vrminh,
    hexagon_A4_vrminuh,
    hexagon_A4_vrminuw,
    hexagon_A4_vrminw,
    hexagon_A5_vaddhubs,
    hexagon_C2_all8,
    hexagon_C2_and,
    hexagon_C2_andn,
    hexagon_C2_any8,
    hexagon_C2_bitsclr,
    hexagon_C2_bitsclri,
    hexagon_C2_bitsset,
    hexagon_C2_cmpeq,
    hexagon_C2_cmpeqi,
    hexagon_C2_cmpeqp,
    hexagon_C2_cmpgei,
    hexagon_C2_cmpgeui,
    hexagon_C2_cmpgt,
    hexagon_C2_cmpgti,
    hexagon_C2_cmpgtp,
    hexagon_C2_cmpgtu,
    hexagon_C2_cmpgtui,
    hexagon_C2_cmpgtup,
    hexagon_C2_cmplt,
    hexagon_C2_cmpltu,
    hexagon_C2_mask,
    hexagon_C2_mux,
    hexagon_C2_muxii,
    hexagon_C2_muxir,
    hexagon_C2_muxri,
    hexagon_C2_not,
    hexagon_C2_or,
    hexagon_C2_orn,
    hexagon_C2_pxfer_map,
    hexagon_C2_tfrpr,
    hexagon_C2_tfrrp,
    hexagon_C2_vitpack,
    hexagon_C2_vmux,
    hexagon_C2_xor,
    hexagon_C4_and_and,
    hexagon_C4_and_andn,
    hexagon_C4_and_or,
    hexagon_C4_and_orn,
    hexagon_C4_cmplte,
    hexagon_C4_cmpltei,
    hexagon_C4_cmplteu,
    hexagon_C4_cmplteui,
    hexagon_C4_cmpneq,
    hexagon_C4_cmpneqi,
    hexagon_C4_fastcorner9,
    hexagon_C4_fastcorner9_not,
    hexagon_C4_nbitsclr,
    hexagon_C4_nbitsclri,
    hexagon_C4_nbitsset,
    hexagon_C4_or_and,
    hexagon_C4_or_andn,
    hexagon_C4_or_or,
    hexagon_C4_or_orn,
    hexagon_F2_conv_d2df,
    hexagon_F2_conv_d2sf,
    hexagon_F2_conv_df2d,
    hexagon_F2_conv_df2d_chop,
    hexagon_F2_conv_df2sf,
    hexagon_F2_conv_df2ud,
    hexagon_F2_conv_df2ud_chop,
    hexagon_F2_conv_df2uw,
    hexagon_F2_conv_df2uw_chop,
    hexagon_F2_conv_df2w,
    hexagon_F2_conv_df2w_chop,
    hexagon_F2_conv_sf2d,
    hexagon_F2_conv_sf2d_chop,
    hexagon_F2_conv_sf2df,
    hexagon_F2_conv_sf2ud,
    hexagon_F2_conv_sf2ud_chop,
    hexagon_F2_conv_sf2uw,
    hexagon_F2_conv_sf2uw_chop,
    hexagon_F2_conv_sf2w,
    hexagon_F2_conv_sf2w_chop,
    hexagon_F2_conv_ud2df,
    hexagon_F2_conv_ud2sf,
    hexagon_F2_conv_uw2df,
    hexagon_F2_conv_uw2sf,
    hexagon_F2_conv_w2df,
    hexagon_F2_conv_w2sf,
    hexagon_F2_dfadd,
    hexagon_F2_dfclass,
    hexagon_F2_dfcmpeq,
    hexagon_F2_dfcmpge,
    hexagon_F2_dfcmpgt,
    hexagon_F2_dfcmpuo,
    hexagon_F2_dffixupd,
    hexagon_F2_dffixupn,
    hexagon_F2_dffixupr,
    hexagon_F2_dffma,
    hexagon_F2_dffma_lib,
    hexagon_F2_dffma_sc,
    hexagon_F2_dffms,
    hexagon_F2_dffms_lib,
    hexagon_F2_dfimm_n,
    hexagon_F2_dfimm_p,
    hexagon_F2_dfmax,
    hexagon_F2_dfmin,
    hexagon_F2_dfmpy,
    hexagon_F2_dfsub,
    hexagon_F2_sfadd,
    hexagon_F2_sfclass,
    hexagon_F2_sfcmpeq,
    hexagon_F2_sfcmpge,
    hexagon_F2_sfcmpgt,
    hexagon_F2_sfcmpuo,
    hexagon_F2_sffixupd,
    hexagon_F2_sffixupn,
    hexagon_F2_sffixupr,
    hexagon_F2_sffma,
    hexagon_F2_sffma_lib,
    hexagon_F2_sffma_sc,
    hexagon_F2_sffms,
    hexagon_F2_sffms_lib,
    hexagon_F2_sfimm_n,
    hexagon_F2_sfimm_p,
    hexagon_F2_sfmax,
    hexagon_F2_sfmin,
    hexagon_F2_sfmpy,
    hexagon_F2_sfsub,
    hexagon_M2_acci,
    hexagon_M2_accii,
    hexagon_M2_cmaci_s0,
    hexagon_M2_cmacr_s0,
    hexagon_M2_cmacs_s0,
    hexagon_M2_cmacs_s1,
    hexagon_M2_cmacsc_s0,
    hexagon_M2_cmacsc_s1,
    hexagon_M2_cmpyi_s0,
    hexagon_M2_cmpyr_s0,
    hexagon_M2_cmpyrs_s0,
    hexagon_M2_cmpyrs_s1,
    hexagon_M2_cmpyrsc_s0,
    hexagon_M2_cmpyrsc_s1,
    hexagon_M2_cmpys_s0,
    hexagon_M2_cmpys_s1,
    hexagon_M2_cmpysc_s0,
    hexagon_M2_cmpysc_s1,
    hexagon_M2_cnacs_s0,
    hexagon_M2_cnacs_s1,
    hexagon_M2_cnacsc_s0,
    hexagon_M2_cnacsc_s1,
    hexagon_M2_dpmpyss_acc_s0,
    hexagon_M2_dpmpyss_nac_s0,
    hexagon_M2_dpmpyss_rnd_s0,
    hexagon_M2_dpmpyss_s0,
    hexagon_M2_dpmpyuu_acc_s0,
    hexagon_M2_dpmpyuu_nac_s0,
    hexagon_M2_dpmpyuu_s0,
    hexagon_M2_hmmpyh_rs1,
    hexagon_M2_hmmpyh_s1,
    hexagon_M2_hmmpyl_rs1,
    hexagon_M2_hmmpyl_s1,
    hexagon_M2_maci,
    hexagon_M2_macsin,
    hexagon_M2_macsip,
    hexagon_M2_mmachs_rs0,
    hexagon_M2_mmachs_rs1,
    hexagon_M2_mmachs_s0,
    hexagon_M2_mmachs_s1,
    hexagon_M2_mmacls_rs0,
    hexagon_M2_mmacls_rs1,
    hexagon_M2_mmacls_s0,
    hexagon_M2_mmacls_s1,
    hexagon_M2_mmacuhs_rs0,
    hexagon_M2_mmacuhs_rs1,
    hexagon_M2_mmacuhs_s0,
    hexagon_M2_mmacuhs_s1,
    hexagon_M2_mmaculs_rs0,
    hexagon_M2_mmaculs_rs1,
    hexagon_M2_mmaculs_s0,
    hexagon_M2_mmaculs_s1,
    hexagon_M2_mmpyh_rs0,
    hexagon_M2_mmpyh_rs1,
    hexagon_M2_mmpyh_s0,
    hexagon_M2_mmpyh_s1,
    hexagon_M2_mmpyl_rs0,
    hexagon_M2_mmpyl_rs1,
    hexagon_M2_mmpyl_s0,
    hexagon_M2_mmpyl_s1,
    hexagon_M2_mmpyuh_rs0,
    hexagon_M2_mmpyuh_rs1,
    hexagon_M2_mmpyuh_s0,
    hexagon_M2_mmpyuh_s1,
    hexagon_M2_mmpyul_rs0,
    hexagon_M2_mmpyul_rs1,
    hexagon_M2_mmpyul_s0,
    hexagon_M2_mmpyul_s1,
    hexagon_M2_mpy_acc_hh_s0,
    hexagon_M2_mpy_acc_hh_s1,
    hexagon_M2_mpy_acc_hl_s0,
    hexagon_M2_mpy_acc_hl_s1,
    hexagon_M2_mpy_acc_lh_s0,
    hexagon_M2_mpy_acc_lh_s1,
    hexagon_M2_mpy_acc_ll_s0,
    hexagon_M2_mpy_acc_ll_s1,
    hexagon_M2_mpy_acc_sat_hh_s0,
    hexagon_M2_mpy_acc_sat_hh_s1,
    hexagon_M2_mpy_acc_sat_hl_s0,
    hexagon_M2_mpy_acc_sat_hl_s1,
    hexagon_M2_mpy_acc_sat_lh_s0,
    hexagon_M2_mpy_acc_sat_lh_s1,
    hexagon_M2_mpy_acc_sat_ll_s0,
    hexagon_M2_mpy_acc_sat_ll_s1,
    hexagon_M2_mpy_hh_s0,
    hexagon_M2_mpy_hh_s1,
    hexagon_M2_mpy_hl_s0,
    hexagon_M2_mpy_hl_s1,
    hexagon_M2_mpy_lh_s0,
    hexagon_M2_mpy_lh_s1,
    hexagon_M2_mpy_ll_s0,
    hexagon_M2_mpy_ll_s1,
    hexagon_M2_mpy_nac_hh_s0,
    hexagon_M2_mpy_nac_hh_s1,
    hexagon_M2_mpy_nac_hl_s0,
    hexagon_M2_mpy_nac_hl_s1,
    hexagon_M2_mpy_nac_lh_s0,
    hexagon_M2_mpy_nac_lh_s1,
    hexagon_M2_mpy_nac_ll_s0,
    hexagon_M2_mpy_nac_ll_s1,
    hexagon_M2_mpy_nac_sat_hh_s0,
    hexagon_M2_mpy_nac_sat_hh_s1,
    hexagon_M2_mpy_nac_sat_hl_s0,
    hexagon_M2_mpy_nac_sat_hl_s1,
    hexagon_M2_mpy_nac_sat_lh_s0,
    hexagon_M2_mpy_nac_sat_lh_s1,
    hexagon_M2_mpy_nac_sat_ll_s0,
    hexagon_M2_mpy_nac_sat_ll_s1,
    hexagon_M2_mpy_rnd_hh_s0,
    hexagon_M2_mpy_rnd_hh_s1,
    hexagon_M2_mpy_rnd_hl_s0,
    hexagon_M2_mpy_rnd_hl_s1,
    hexagon_M2_mpy_rnd_lh_s0,
    hexagon_M2_mpy_rnd_lh_s1,
    hexagon_M2_mpy_rnd_ll_s0,
    hexagon_M2_mpy_rnd_ll_s1,
    hexagon_M2_mpy_sat_hh_s0,
    hexagon_M2_mpy_sat_hh_s1,
    hexagon_M2_mpy_sat_hl_s0,
    hexagon_M2_mpy_sat_hl_s1,
    hexagon_M2_mpy_sat_lh_s0,
    hexagon_M2_mpy_sat_lh_s1,
    hexagon_M2_mpy_sat_ll_s0,
    hexagon_M2_mpy_sat_ll_s1,
    hexagon_M2_mpy_sat_rnd_hh_s0,
    hexagon_M2_mpy_sat_rnd_hh_s1,
    hexagon_M2_mpy_sat_rnd_hl_s0,
    hexagon_M2_mpy_sat_rnd_hl_s1,
    hexagon_M2_mpy_sat_rnd_lh_s0,
    hexagon_M2_mpy_sat_rnd_lh_s1,
    hexagon_M2_mpy_sat_rnd_ll_s0,
    hexagon_M2_mpy_sat_rnd_ll_s1,
    hexagon_M2_mpy_up,
    hexagon_M2_mpy_up_s1,
    hexagon_M2_mpy_up_s1_sat,
    hexagon_M2_mpyd_acc_hh_s0,
    hexagon_M2_mpyd_acc_hh_s1,
    hexagon_M2_mpyd_acc_hl_s0,
    hexagon_M2_mpyd_acc_hl_s1,
    hexagon_M2_mpyd_acc_lh_s0,
    hexagon_M2_mpyd_acc_lh_s1,
    hexagon_M2_mpyd_acc_ll_s0,
    hexagon_M2_mpyd_acc_ll_s1,
    hexagon_M2_mpyd_hh_s0,
    hexagon_M2_mpyd_hh_s1,
    hexagon_M2_mpyd_hl_s0,
    hexagon_M2_mpyd_hl_s1,
    hexagon_M2_mpyd_lh_s0,
    hexagon_M2_mpyd_lh_s1,
    hexagon_M2_mpyd_ll_s0,
    hexagon_M2_mpyd_ll_s1,
    hexagon_M2_mpyd_nac_hh_s0,
    hexagon_M2_mpyd_nac_hh_s1,
    hexagon_M2_mpyd_nac_hl_s0,
    hexagon_M2_mpyd_nac_hl_s1,
    hexagon_M2_mpyd_nac_lh_s0,
    hexagon_M2_mpyd_nac_lh_s1,
    hexagon_M2_mpyd_nac_ll_s0,
    hexagon_M2_mpyd_nac_ll_s1,
    hexagon_M2_mpyd_rnd_hh_s0,
    hexagon_M2_mpyd_rnd_hh_s1,
    hexagon_M2_mpyd_rnd_hl_s0,
    hexagon_M2_mpyd_rnd_hl_s1,
    hexagon_M2_mpyd_rnd_lh_s0,
    hexagon_M2_mpyd_rnd_lh_s1,
    hexagon_M2_mpyd_rnd_ll_s0,
    hexagon_M2_mpyd_rnd_ll_s1,
    hexagon_M2_mpyi,
    hexagon_M2_mpysmi,
    hexagon_M2_mpysu_up,
    hexagon_M2_mpyu_acc_hh_s0,
    hexagon_M2_mpyu_acc_hh_s1,
    hexagon_M2_mpyu_acc_hl_s0,
    hexagon_M2_mpyu_acc_hl_s1,
    hexagon_M2_mpyu_acc_lh_s0,
    hexagon_M2_mpyu_acc_lh_s1,
    hexagon_M2_mpyu_acc_ll_s0,
    hexagon_M2_mpyu_acc_ll_s1,
    hexagon_M2_mpyu_hh_s0,
    hexagon_M2_mpyu_hh_s1,
    hexagon_M2_mpyu_hl_s0,
    hexagon_M2_mpyu_hl_s1,
    hexagon_M2_mpyu_lh_s0,
    hexagon_M2_mpyu_lh_s1,
    hexagon_M2_mpyu_ll_s0,
    hexagon_M2_mpyu_ll_s1,
    hexagon_M2_mpyu_nac_hh_s0,
    hexagon_M2_mpyu_nac_hh_s1,
    hexagon_M2_mpyu_nac_hl_s0,
    hexagon_M2_mpyu_nac_hl_s1,
    hexagon_M2_mpyu_nac_lh_s0,
    hexagon_M2_mpyu_nac_lh_s1,
    hexagon_M2_mpyu_nac_ll_s0,
    hexagon_M2_mpyu_nac_ll_s1,
    hexagon_M2_mpyu_up,
    hexagon_M2_mpyud_acc_hh_s0,
    hexagon_M2_mpyud_acc_hh_s1,
    hexagon_M2_mpyud_acc_hl_s0,
    hexagon_M2_mpyud_acc_hl_s1,
    hexagon_M2_mpyud_acc_lh_s0,
    hexagon_M2_mpyud_acc_lh_s1,
    hexagon_M2_mpyud_acc_ll_s0,
    hexagon_M2_mpyud_acc_ll_s1,
    hexagon_M2_mpyud_hh_s0,
    hexagon_M2_mpyud_hh_s1,
    hexagon_M2_mpyud_hl_s0,
    hexagon_M2_mpyud_hl_s1,
    hexagon_M2_mpyud_lh_s0,
    hexagon_M2_mpyud_lh_s1,
    hexagon_M2_mpyud_ll_s0,
    hexagon_M2_mpyud_ll_s1,
    hexagon_M2_mpyud_nac_hh_s0,
    hexagon_M2_mpyud_nac_hh_s1,
    hexagon_M2_mpyud_nac_hl_s0,
    hexagon_M2_mpyud_nac_hl_s1,
    hexagon_M2_mpyud_nac_lh_s0,
    hexagon_M2_mpyud_nac_lh_s1,
    hexagon_M2_mpyud_nac_ll_s0,
    hexagon_M2_mpyud_nac_ll_s1,
    hexagon_M2_mpyui,
    hexagon_M2_nacci,
    hexagon_M2_naccii,
    hexagon_M2_subacc,
    hexagon_M2_vabsdiffh,
    hexagon_M2_vabsdiffw,
    hexagon_M2_vcmac_s0_sat_i,
    hexagon_M2_vcmac_s0_sat_r,
    hexagon_M2_vcmpy_s0_sat_i,
    hexagon_M2_vcmpy_s0_sat_r,
    hexagon_M2_vcmpy_s1_sat_i,
    hexagon_M2_vcmpy_s1_sat_r,
    hexagon_M2_vdmacs_s0,
    hexagon_M2_vdmacs_s1,
    hexagon_M2_vdmpyrs_s0,
    hexagon_M2_vdmpyrs_s1,
    hexagon_M2_vdmpys_s0,
    hexagon_M2_vdmpys_s1,
    hexagon_M2_vmac2,
    hexagon_M2_vmac2es,
    hexagon_M2_vmac2es_s0,
    hexagon_M2_vmac2es_s1,
    hexagon_M2_vmac2s_s0,
    hexagon_M2_vmac2s_s1,
    hexagon_M2_vmac2su_s0,
    hexagon_M2_vmac2su_s1,
    hexagon_M2_vmpy2es_s0,
    hexagon_M2_vmpy2es_s1,
    hexagon_M2_vmpy2s_s0,
    hexagon_M2_vmpy2s_s0pack,
    hexagon_M2_vmpy2s_s1,
    hexagon_M2_vmpy2s_s1pack,
    hexagon_M2_vmpy2su_s0,
    hexagon_M2_vmpy2su_s1,
    hexagon_M2_vraddh,
    hexagon_M2_vradduh,
    hexagon_M2_vrcmaci_s0,
    hexagon_M2_vrcmaci_s0c,
    hexagon_M2_vrcmacr_s0,
    hexagon_M2_vrcmacr_s0c,
    hexagon_M2_vrcmpyi_s0,
    hexagon_M2_vrcmpyi_s0c,
    hexagon_M2_vrcmpyr_s0,
    hexagon_M2_vrcmpyr_s0c,
    hexagon_M2_vrcmpys_acc_s1,
    hexagon_M2_vrcmpys_s1,
    hexagon_M2_vrcmpys_s1rp,
    hexagon_M2_vrmac_s0,
    hexagon_M2_vrmpy_s0,
    hexagon_M2_xor_xacc,
    hexagon_M4_and_and,
    hexagon_M4_and_andn,
    hexagon_M4_and_or,
    hexagon_M4_and_xor,
    hexagon_M4_cmpyi_wh,
    hexagon_M4_cmpyi_whc,
    hexagon_M4_cmpyr_wh,
    hexagon_M4_cmpyr_whc,
    hexagon_M4_mac_up_s1_sat,
    hexagon_M4_mpyri_addi,
    hexagon_M4_mpyri_addr,
    hexagon_M4_mpyri_addr_u2,
    hexagon_M4_mpyrr_addi,
    hexagon_M4_mpyrr_addr,
    hexagon_M4_nac_up_s1_sat,
    hexagon_M4_or_and,
    hexagon_M4_or_andn,
    hexagon_M4_or_or,
    hexagon_M4_or_xor,
    hexagon_M4_pmpyw,
    hexagon_M4_pmpyw_acc,
    hexagon_M4_vpmpyh,
    hexagon_M4_vpmpyh_acc,
    hexagon_M4_vrmpyeh_acc_s0,
    hexagon_M4_vrmpyeh_acc_s1,
    hexagon_M4_vrmpyeh_s0,
    hexagon_M4_vrmpyeh_s1,
    hexagon_M4_vrmpyoh_acc_s0,
    hexagon_M4_vrmpyoh_acc_s1,
    hexagon_M4_vrmpyoh_s0,
    hexagon_M4_vrmpyoh_s1,
    hexagon_M4_xor_and,
    hexagon_M4_xor_andn,
    hexagon_M4_xor_or,
    hexagon_M4_xor_xacc,
    hexagon_M5_vdmacbsu,
    hexagon_M5_vdmpybsu,
    hexagon_M5_vmacbsu,
    hexagon_M5_vmacbuu,
    hexagon_M5_vmpybsu,
    hexagon_M5_vmpybuu,
    hexagon_M5_vrmacbsu,
    hexagon_M5_vrmacbuu,
    hexagon_M5_vrmpybsu,
    hexagon_M5_vrmpybuu,
    hexagon_S2_addasl_rrri,
    hexagon_S2_asl_i_p,
    hexagon_S2_asl_i_p_acc,
    hexagon_S2_asl_i_p_and,
    hexagon_S2_asl_i_p_nac,
    hexagon_S2_asl_i_p_or,
    hexagon_S2_asl_i_p_xacc,
    hexagon_S2_asl_i_r,
    hexagon_S2_asl_i_r_acc,
    hexagon_S2_asl_i_r_and,
    hexagon_S2_asl_i_r_nac,
    hexagon_S2_asl_i_r_or,
    hexagon_S2_asl_i_r_sat,
    hexagon_S2_asl_i_r_xacc,
    hexagon_S2_asl_i_vh,
    hexagon_S2_asl_i_vw,
    hexagon_S2_asl_r_p,
    hexagon_S2_asl_r_p_acc,
    hexagon_S2_asl_r_p_and,
    hexagon_S2_asl_r_p_nac,
    hexagon_S2_asl_r_p_or,
    hexagon_S2_asl_r_p_xor,
    hexagon_S2_asl_r_r,
    hexagon_S2_asl_r_r_acc,
    hexagon_S2_asl_r_r_and,
    hexagon_S2_asl_r_r_nac,
    hexagon_S2_asl_r_r_or,
    hexagon_S2_asl_r_r_sat,
    hexagon_S2_asl_r_vh,
    hexagon_S2_asl_r_vw,
    hexagon_S2_asr_i_p,
    hexagon_S2_asr_i_p_acc,
    hexagon_S2_asr_i_p_and,
    hexagon_S2_asr_i_p_nac,
    hexagon_S2_asr_i_p_or,
    hexagon_S2_asr_i_p_rnd,
    hexagon_S2_asr_i_p_rnd_goodsyntax,
    hexagon_S2_asr_i_r,
    hexagon_S2_asr_i_r_acc,
    hexagon_S2_asr_i_r_and,
    hexagon_S2_asr_i_r_nac,
    hexagon_S2_asr_i_r_or,
    hexagon_S2_asr_i_r_rnd,
    hexagon_S2_asr_i_r_rnd_goodsyntax,
    hexagon_S2_asr_i_svw_trun,
    hexagon_S2_asr_i_vh,
    hexagon_S2_asr_i_vw,
    hexagon_S2_asr_r_p,
    hexagon_S2_asr_r_p_acc,
    hexagon_S2_asr_r_p_and,
    hexagon_S2_asr_r_p_nac,
    hexagon_S2_asr_r_p_or,
    hexagon_S2_asr_r_p_xor,
    hexagon_S2_asr_r_r,
    hexagon_S2_asr_r_r_acc,
    hexagon_S2_asr_r_r_and,
    hexagon_S2_asr_r_r_nac,
    hexagon_S2_asr_r_r_or,
    hexagon_S2_asr_r_r_sat,
    hexagon_S2_asr_r_svw_trun,
    hexagon_S2_asr_r_vh,
    hexagon_S2_asr_r_vw,
    hexagon_S2_brev,
    hexagon_S2_brevp,
    hexagon_S2_cl0,
    hexagon_S2_cl0p,
    hexagon_S2_cl1,
    hexagon_S2_cl1p,
    hexagon_S2_clb,
    hexagon_S2_clbnorm,
    hexagon_S2_clbp,
    hexagon_S2_clrbit_i,
    hexagon_S2_clrbit_r,
    hexagon_S2_ct0,
    hexagon_S2_ct0p,
    hexagon_S2_ct1,
    hexagon_S2_ct1p,
    hexagon_S2_deinterleave,
    hexagon_S2_extractu,
    hexagon_S2_extractu_rp,
    hexagon_S2_extractup,
    hexagon_S2_extractup_rp,
    hexagon_S2_insert,
    hexagon_S2_insert_rp,
    hexagon_S2_insertp,
    hexagon_S2_insertp_rp,
    hexagon_S2_interleave,
    hexagon_S2_lfsp,
    hexagon_S2_lsl_r_p,
    hexagon_S2_lsl_r_p_acc,
    hexagon_S2_lsl_r_p_and,
    hexagon_S2_lsl_r_p_nac,
    hexagon_S2_lsl_r_p_or,
    hexagon_S2_lsl_r_p_xor,
    hexagon_S2_lsl_r_r,
    hexagon_S2_lsl_r_r_acc,
    hexagon_S2_lsl_r_r_and,
    hexagon_S2_lsl_r_r_nac,
    hexagon_S2_lsl_r_r_or,
    hexagon_S2_lsl_r_vh,
    hexagon_S2_lsl_r_vw,
    hexagon_S2_lsr_i_p,
    hexagon_S2_lsr_i_p_acc,
    hexagon_S2_lsr_i_p_and,
    hexagon_S2_lsr_i_p_nac,
    hexagon_S2_lsr_i_p_or,
    hexagon_S2_lsr_i_p_xacc,
    hexagon_S2_lsr_i_r,
    hexagon_S2_lsr_i_r_acc,
    hexagon_S2_lsr_i_r_and,
    hexagon_S2_lsr_i_r_nac,
    hexagon_S2_lsr_i_r_or,
    hexagon_S2_lsr_i_r_xacc,
    hexagon_S2_lsr_i_vh,
    hexagon_S2_lsr_i_vw,
    hexagon_S2_lsr_r_p,
    hexagon_S2_lsr_r_p_acc,
    hexagon_S2_lsr_r_p_and,
    hexagon_S2_lsr_r_p_nac,
    hexagon_S2_lsr_r_p_or,
    hexagon_S2_lsr_r_p_xor,
    hexagon_S2_lsr_r_r,
    hexagon_S2_lsr_r_r_acc,
    hexagon_S2_lsr_r_r_and,
    hexagon_S2_lsr_r_r_nac,
    hexagon_S2_lsr_r_r_or,
    hexagon_S2_lsr_r_vh,
    hexagon_S2_lsr_r_vw,
    hexagon_S2_packhl,
    hexagon_S2_parityp,
    hexagon_S2_setbit_i,
    hexagon_S2_setbit_r,
    hexagon_S2_shuffeb,
    hexagon_S2_shuffeh,
    hexagon_S2_shuffob,
    hexagon_S2_shuffoh,
    hexagon_S2_svsathb,
    hexagon_S2_svsathub,
    hexagon_S2_tableidxb_goodsyntax,
    hexagon_S2_tableidxd_goodsyntax,
    hexagon_S2_tableidxh_goodsyntax,
    hexagon_S2_tableidxw_goodsyntax,
    hexagon_S2_togglebit_i,
    hexagon_S2_togglebit_r,
    hexagon_S2_tstbit_i,
    hexagon_S2_tstbit_r,
    hexagon_S2_valignib,
    hexagon_S2_valignrb,
    hexagon_S2_vcnegh,
    hexagon_S2_vcrotate,
    hexagon_S2_vrcnegh,
    hexagon_S2_vrndpackwh,
    hexagon_S2_vrndpackwhs,
    hexagon_S2_vsathb,
    hexagon_S2_vsathb_nopack,
    hexagon_S2_vsathub,
    hexagon_S2_vsathub_nopack,
    hexagon_S2_vsatwh,
    hexagon_S2_vsatwh_nopack,
    hexagon_S2_vsatwuh,
    hexagon_S2_vsatwuh_nopack,
    hexagon_S2_vsplatrb,
    hexagon_S2_vsplatrh,
    hexagon_S2_vspliceib,
    hexagon_S2_vsplicerb,
    hexagon_S2_vsxtbh,
    hexagon_S2_vsxthw,
    hexagon_S2_vtrunehb,
    hexagon_S2_vtrunewh,
    hexagon_S2_vtrunohb,
    hexagon_S2_vtrunowh,
    hexagon_S2_vzxtbh,
    hexagon_S2_vzxthw,
    hexagon_S4_addaddi,
    hexagon_S4_addi_asl_ri,
    hexagon_S4_addi_lsr_ri,
    hexagon_S4_andi_asl_ri,
    hexagon_S4_andi_lsr_ri,
    hexagon_S4_clbaddi,
    hexagon_S4_clbpaddi,
    hexagon_S4_clbpnorm,
    hexagon_S4_extract,
    hexagon_S4_extract_rp,
    hexagon_S4_extractp,
    hexagon_S4_extractp_rp,
    hexagon_S4_lsli,
    hexagon_S4_ntstbit_i,
    hexagon_S4_ntstbit_r,
    hexagon_S4_or_andi,
    hexagon_S4_or_andix,
    hexagon_S4_or_ori,
    hexagon_S4_ori_asl_ri,
    hexagon_S4_ori_lsr_ri,
    hexagon_S4_parity,
    hexagon_S4_subaddi,
    hexagon_S4_subi_asl_ri,
    hexagon_S4_subi_lsr_ri,
    hexagon_S4_vrcrotate,
    hexagon_S4_vrcrotate_acc,
    hexagon_S4_vxaddsubh,
    hexagon_S4_vxaddsubhr,
    hexagon_S4_vxaddsubw,
    hexagon_S4_vxsubaddh,
    hexagon_S4_vxsubaddhr,
    hexagon_S4_vxsubaddw,
    hexagon_S5_asrhub_rnd_sat_goodsyntax,
    hexagon_S5_asrhub_sat,
    hexagon_S5_popcountp,
    hexagon_S5_vasrhrnd_goodsyntax,
    hexagon_SI_to_SXTHI_asrh,
    hexagon_circ_ldd,
    init_trampoline,
    invariant_end,
    invariant_start,
    lifetime_end,
    lifetime_start,
    log,
    log10,
    log2,
    longjmp,
    memcpy,
    memmove,
    memset,
    mips_absq_s_ph,
    mips_absq_s_qb,
    mips_absq_s_w,
    mips_add_a_b,
    mips_add_a_d,
    mips_add_a_h,
    mips_add_a_w,
    mips_addq_ph,
    mips_addq_s_ph,
    mips_addq_s_w,
    mips_addqh_ph,
    mips_addqh_r_ph,
    mips_addqh_r_w,
    mips_addqh_w,
    mips_adds_a_b,
    mips_adds_a_d,
    mips_adds_a_h,
    mips_adds_a_w,
    mips_adds_s_b,
    mips_adds_s_d,
    mips_adds_s_h,
    mips_adds_s_w,
    mips_adds_u_b,
    mips_adds_u_d,
    mips_adds_u_h,
    mips_adds_u_w,
    mips_addsc,
    mips_addu_ph,
    mips_addu_qb,
    mips_addu_s_ph,
    mips_addu_s_qb,
    mips_adduh_qb,
    mips_adduh_r_qb,
    mips_addv_b,
    mips_addv_d,
    mips_addv_h,
    mips_addv_w,
    mips_addvi_b,
    mips_addvi_d,
    mips_addvi_h,
    mips_addvi_w,
    mips_addwc,
    mips_and_v,
    mips_andi_b,
    mips_append,
    mips_asub_s_b,
    mips_asub_s_d,
    mips_asub_s_h,
    mips_asub_s_w,
    mips_asub_u_b,
    mips_asub_u_d,
    mips_asub_u_h,
    mips_asub_u_w,
    mips_ave_s_b,
    mips_ave_s_d,
    mips_ave_s_h,
    mips_ave_s_w,
    mips_ave_u_b,
    mips_ave_u_d,
    mips_ave_u_h,
    mips_ave_u_w,
    mips_aver_s_b,
    mips_aver_s_d,
    mips_aver_s_h,
    mips_aver_s_w,
    mips_aver_u_b,
    mips_aver_u_d,
    mips_aver_u_h,
    mips_aver_u_w,
    mips_balign,
    mips_bclr_b,
    mips_bclr_d,
    mips_bclr_h,
    mips_bclr_w,
    mips_bclri_b,
    mips_bclri_d,
    mips_bclri_h,
    mips_bclri_w,
    mips_binsl_b,
    mips_binsl_d,
    mips_binsl_h,
    mips_binsl_w,
    mips_binsli_b,
    mips_binsli_d,
    mips_binsli_h,
    mips_binsli_w,
    mips_binsr_b,
    mips_binsr_d,
    mips_binsr_h,
    mips_binsr_w,
    mips_binsri_b,
    mips_binsri_d,
    mips_binsri_h,
    mips_binsri_w,
    mips_bitrev,
    mips_bmnz_v,
    mips_bmnzi_b,
    mips_bmz_v,
    mips_bmzi_b,
    mips_bneg_b,
    mips_bneg_d,
    mips_bneg_h,
    mips_bneg_w,
    mips_bnegi_b,
    mips_bnegi_d,
    mips_bnegi_h,
    mips_bnegi_w,
    mips_bnz_b,
    mips_bnz_d,
    mips_bnz_h,
    mips_bnz_v,
    mips_bnz_w,
    mips_bposge32,
    mips_bsel_v,
    mips_bseli_b,
    mips_bset_b,
    mips_bset_d,
    mips_bset_h,
    mips_bset_w,
    mips_bseti_b,
    mips_bseti_d,
    mips_bseti_h,
    mips_bseti_w,
    mips_bz_b,
    mips_bz_d,
    mips_bz_h,
    mips_bz_v,
    mips_bz_w,
    mips_ceq_b,
    mips_ceq_d,
    mips_ceq_h,
    mips_ceq_w,
    mips_ceqi_b,
    mips_ceqi_d,
    mips_ceqi_h,
    mips_ceqi_w,
    mips_cfcmsa,
    mips_cle_s_b,
    mips_cle_s_d,
    mips_cle_s_h,
    mips_cle_s_w,
    mips_cle_u_b,
    mips_cle_u_d,
    mips_cle_u_h,
    mips_cle_u_w,
    mips_clei_s_b,
    mips_clei_s_d,
    mips_clei_s_h,
    mips_clei_s_w,
    mips_clei_u_b,
    mips_clei_u_d,
    mips_clei_u_h,
    mips_clei_u_w,
    mips_clt_s_b,
    mips_clt_s_d,
    mips_clt_s_h,
    mips_clt_s_w,
    mips_clt_u_b,
    mips_clt_u_d,
    mips_clt_u_h,
    mips_clt_u_w,
    mips_clti_s_b,
    mips_clti_s_d,
    mips_clti_s_h,
    mips_clti_s_w,
    mips_clti_u_b,
    mips_clti_u_d,
    mips_clti_u_h,
    mips_clti_u_w,
    mips_cmp_eq_ph,
    mips_cmp_le_ph,
    mips_cmp_lt_ph,
    mips_cmpgdu_eq_qb,
    mips_cmpgdu_le_qb,
    mips_cmpgdu_lt_qb,
    mips_cmpgu_eq_qb,
    mips_cmpgu_le_qb,
    mips_cmpgu_lt_qb,
    mips_cmpu_eq_qb,
    mips_cmpu_le_qb,
    mips_cmpu_lt_qb,
    mips_copy_s_b,
    mips_copy_s_d,
    mips_copy_s_h,
    mips_copy_s_w,
    mips_copy_u_b,
    mips_copy_u_d,
    mips_copy_u_h,
    mips_copy_u_w,
    mips_ctcmsa,
    mips_div_s_b,
    mips_div_s_d,
    mips_div_s_h,
    mips_div_s_w,
    mips_div_u_b,
    mips_div_u_d,
    mips_div_u_h,
    mips_div_u_w,
    mips_dotp_s_d,
    mips_dotp_s_h,
    mips_dotp_s_w,
    mips_dotp_u_d,
    mips_dotp_u_h,
    mips_dotp_u_w,
    mips_dpa_w_ph,
    mips_dpadd_s_d,
    mips_dpadd_s_h,
    mips_dpadd_s_w,
    mips_dpadd_u_d,
    mips_dpadd_u_h,
    mips_dpadd_u_w,
    mips_dpaq_s_w_ph,
    mips_dpaq_sa_l_w,
    mips_dpaqx_s_w_ph,
    mips_dpaqx_sa_w_ph,
    mips_dpau_h_qbl,
    mips_dpau_h_qbr,
    mips_dpax_w_ph,
    mips_dps_w_ph,
    mips_dpsq_s_w_ph,
    mips_dpsq_sa_l_w,
    mips_dpsqx_s_w_ph,
    mips_dpsqx_sa_w_ph,
    mips_dpsu_h_qbl,
    mips_dpsu_h_qbr,
    mips_dpsub_s_d,
    mips_dpsub_s_h,
    mips_dpsub_s_w,
    mips_dpsub_u_d,
    mips_dpsub_u_h,
    mips_dpsub_u_w,
    mips_dpsx_w_ph,
    mips_extp,
    mips_extpdp,
    mips_extr_r_w,
    mips_extr_rs_w,
    mips_extr_s_h,
    mips_extr_w,
    mips_fadd_d,
    mips_fadd_w,
    mips_fcaf_d,
    mips_fcaf_w,
    mips_fceq_d,
    mips_fceq_w,
    mips_fclass_d,
    mips_fclass_w,
    mips_fcle_d,
    mips_fcle_w,
    mips_fclt_d,
    mips_fclt_w,
    mips_fcne_d,
    mips_fcne_w,
    mips_fcor_d,
    mips_fcor_w,
    mips_fcueq_d,
    mips_fcueq_w,
    mips_fcule_d,
    mips_fcule_w,
    mips_fcult_d,
    mips_fcult_w,
    mips_fcun_d,
    mips_fcun_w,
    mips_fcune_d,
    mips_fcune_w,
    mips_fdiv_d,
    mips_fdiv_w,
    mips_fexdo_h,
    mips_fexdo_w,
    mips_fexp2_d,
    mips_fexp2_w,
    mips_fexupl_d,
    mips_fexupl_w,
    mips_fexupr_d,
    mips_fexupr_w,
    mips_ffint_s_d,
    mips_ffint_s_w,
    mips_ffint_u_d,
    mips_ffint_u_w,
    mips_ffql_d,
    mips_ffql_w,
    mips_ffqr_d,
    mips_ffqr_w,
    mips_fill_b,
    mips_fill_d,
    mips_fill_h,
    mips_fill_w,
    mips_flog2_d,
    mips_flog2_w,
    mips_fmadd_d,
    mips_fmadd_w,
    mips_fmax_a_d,
    mips_fmax_a_w,
    mips_fmax_d,
    mips_fmax_w,
    mips_fmin_a_d,
    mips_fmin_a_w,
    mips_fmin_d,
    mips_fmin_w,
    mips_fmsub_d,
    mips_fmsub_w,
    mips_fmul_d,
    mips_fmul_w,
    mips_frcp_d,
    mips_frcp_w,
    mips_frint_d,
    mips_frint_w,
    mips_frsqrt_d,
    mips_frsqrt_w,
    mips_fsaf_d,
    mips_fsaf_w,
    mips_fseq_d,
    mips_fseq_w,
    mips_fsle_d,
    mips_fsle_w,
    mips_fslt_d,
    mips_fslt_w,
    mips_fsne_d,
    mips_fsne_w,
    mips_fsor_d,
    mips_fsor_w,
    mips_fsqrt_d,
    mips_fsqrt_w,
    mips_fsub_d,
    mips_fsub_w,
    mips_fsueq_d,
    mips_fsueq_w,
    mips_fsule_d,
    mips_fsule_w,
    mips_fsult_d,
    mips_fsult_w,
    mips_fsun_d,
    mips_fsun_w,
    mips_fsune_d,
    mips_fsune_w,
    mips_ftint_s_d,
    mips_ftint_s_w,
    mips_ftint_u_d,
    mips_ftint_u_w,
    mips_ftq_h,
    mips_ftq_w,
    mips_ftrunc_s_d,
    mips_ftrunc_s_w,
    mips_ftrunc_u_d,
    mips_ftrunc_u_w,
    mips_hadd_s_d,
    mips_hadd_s_h,
    mips_hadd_s_w,
    mips_hadd_u_d,
    mips_hadd_u_h,
    mips_hadd_u_w,
    mips_hsub_s_d,
    mips_hsub_s_h,
    mips_hsub_s_w,
    mips_hsub_u_d,
    mips_hsub_u_h,
    mips_hsub_u_w,
    mips_ilvev_b,
    mips_ilvev_d,
    mips_ilvev_h,
    mips_ilvev_w,
    mips_ilvl_b,
    mips_ilvl_d,
    mips_ilvl_h,
    mips_ilvl_w,
    mips_ilvod_b,
    mips_ilvod_d,
    mips_ilvod_h,
    mips_ilvod_w,
    mips_ilvr_b,
    mips_ilvr_d,
    mips_ilvr_h,
    mips_ilvr_w,
    mips_insert_b,
    mips_insert_d,
    mips_insert_h,
    mips_insert_w,
    mips_insv,
    mips_insve_b,
    mips_insve_d,
    mips_insve_h,
    mips_insve_w,
    mips_lbux,
    mips_ld_b,
    mips_ld_d,
    mips_ld_h,
    mips_ld_w,
    mips_ldi_b,
    mips_ldi_d,
    mips_ldi_h,
    mips_ldi_w,
    mips_lhx,
    mips_lsa,
    mips_lwx,
    mips_madd,
    mips_madd_q_h,
    mips_madd_q_w,
    mips_maddr_q_h,
    mips_maddr_q_w,
    mips_maddu,
    mips_maddv_b,
    mips_maddv_d,
    mips_maddv_h,
    mips_maddv_w,
    mips_maq_s_w_phl,
    mips_maq_s_w_phr,
    mips_maq_sa_w_phl,
    mips_maq_sa_w_phr,
    mips_max_a_b,
    mips_max_a_d,
    mips_max_a_h,
    mips_max_a_w,
    mips_max_s_b,
    mips_max_s_d,
    mips_max_s_h,
    mips_max_s_w,
    mips_max_u_b,
    mips_max_u_d,
    mips_max_u_h,
    mips_max_u_w,
    mips_maxi_s_b,
    mips_maxi_s_d,
    mips_maxi_s_h,
    mips_maxi_s_w,
    mips_maxi_u_b,
    mips_maxi_u_d,
    mips_maxi_u_h,
    mips_maxi_u_w,
    mips_min_a_b,
    mips_min_a_d,
    mips_min_a_h,
    mips_min_a_w,
    mips_min_s_b,
    mips_min_s_d,
    mips_min_s_h,
    mips_min_s_w,
    mips_min_u_b,
    mips_min_u_d,
    mips_min_u_h,
    mips_min_u_w,
    mips_mini_s_b,
    mips_mini_s_d,
    mips_mini_s_h,
    mips_mini_s_w,
    mips_mini_u_b,
    mips_mini_u_d,
    mips_mini_u_h,
    mips_mini_u_w,
    mips_mod_s_b,
    mips_mod_s_d,
    mips_mod_s_h,
    mips_mod_s_w,
    mips_mod_u_b,
    mips_mod_u_d,
    mips_mod_u_h,
    mips_mod_u_w,
    mips_modsub,
    mips_move_v,
    mips_msub,
    mips_msub_q_h,
    mips_msub_q_w,
    mips_msubr_q_h,
    mips_msubr_q_w,
    mips_msubu,
    mips_msubv_b,
    mips_msubv_d,
    mips_msubv_h,
    mips_msubv_w,
    mips_mthlip,
    mips_mul_ph,
    mips_mul_q_h,
    mips_mul_q_w,
    mips_mul_s_ph,
    mips_muleq_s_w_phl,
    mips_muleq_s_w_phr,
    mips_muleu_s_ph_qbl,
    mips_muleu_s_ph_qbr,
    mips_mulq_rs_ph,
    mips_mulq_rs_w,
    mips_mulq_s_ph,
    mips_mulq_s_w,
    mips_mulr_q_h,
    mips_mulr_q_w,
    mips_mulsa_w_ph,
    mips_mulsaq_s_w_ph,
    mips_mult,
    mips_multu,
    mips_mulv_b,
    mips_mulv_d,
    mips_mulv_h,
    mips_mulv_w,
    mips_nloc_b,
    mips_nloc_d,
    mips_nloc_h,
    mips_nloc_w,
    mips_nlzc_b,
    mips_nlzc_d,
    mips_nlzc_h,
    mips_nlzc_w,
    mips_nor_v,
    mips_nori_b,
    mips_or_v,
    mips_ori_b,
    mips_packrl_ph,
    mips_pckev_b,
    mips_pckev_d,
    mips_pckev_h,
    mips_pckev_w,
    mips_pckod_b,
    mips_pckod_d,
    mips_pckod_h,
    mips_pckod_w,
    mips_pcnt_b,
    mips_pcnt_d,
    mips_pcnt_h,
    mips_pcnt_w,
    mips_pick_ph,
    mips_pick_qb,
    mips_preceq_w_phl,
    mips_preceq_w_phr,
    mips_precequ_ph_qbl,
    mips_precequ_ph_qbla,
    mips_precequ_ph_qbr,
    mips_precequ_ph_qbra,
    mips_preceu_ph_qbl,
    mips_preceu_ph_qbla,
    mips_preceu_ph_qbr,
    mips_preceu_ph_qbra,
    mips_precr_qb_ph,
    mips_precr_sra_ph_w,
    mips_precr_sra_r_ph_w,
    mips_precrq_ph_w,
    mips_precrq_qb_ph,
    mips_precrq_rs_ph_w,
    mips_precrqu_s_qb_ph,
    mips_prepend,
    mips_raddu_w_qb,
    mips_rddsp,
    mips_repl_ph,
    mips_repl_qb,
    mips_sat_s_b,
    mips_sat_s_d,
    mips_sat_s_h,
    mips_sat_s_w,
    mips_sat_u_b,
    mips_sat_u_d,
    mips_sat_u_h,
    mips_sat_u_w,
    mips_shf_b,
    mips_shf_h,
    mips_shf_w,
    mips_shilo,
    mips_shll_ph,
    mips_shll_qb,
    mips_shll_s_ph,
    mips_shll_s_w,
    mips_shra_ph,
    mips_shra_qb,
    mips_shra_r_ph,
    mips_shra_r_qb,
    mips_shra_r_w,
    mips_shrl_ph,
    mips_shrl_qb,
    mips_sld_b,
    mips_sld_d,
    mips_sld_h,
    mips_sld_w,
    mips_sldi_b,
    mips_sldi_d,
    mips_sldi_h,
    mips_sldi_w,
    mips_sll_b,
    mips_sll_d,
    mips_sll_h,
    mips_sll_w,
    mips_slli_b,
    mips_slli_d,
    mips_slli_h,
    mips_slli_w,
    mips_splat_b,
    mips_splat_d,
    mips_splat_h,
    mips_splat_w,
    mips_splati_b,
    mips_splati_d,
    mips_splati_h,
    mips_splati_w,
    mips_sra_b,
    mips_sra_d,
    mips_sra_h,
    mips_sra_w,
    mips_srai_b,
    mips_srai_d,
    mips_srai_h,
    mips_srai_w,
    mips_srar_b,
    mips_srar_d,
    mips_srar_h,
    mips_srar_w,
    mips_srari_b,
    mips_srari_d,
    mips_srari_h,
    mips_srari_w,
    mips_srl_b,
    mips_srl_d,
    mips_srl_h,
    mips_srl_w,
    mips_srli_b,
    mips_srli_d,
    mips_srli_h,
    mips_srli_w,
    mips_srlr_b,
    mips_srlr_d,
    mips_srlr_h,
    mips_srlr_w,
    mips_srlri_b,
    mips_srlri_d,
    mips_srlri_h,
    mips_srlri_w,
    mips_st_b,
    mips_st_d,
    mips_st_h,
    mips_st_w,
    mips_subq_ph,
    mips_subq_s_ph,
    mips_subq_s_w,
    mips_subqh_ph,
    mips_subqh_r_ph,
    mips_subqh_r_w,
    mips_subqh_w,
    mips_subs_s_b,
    mips_subs_s_d,
    mips_subs_s_h,
    mips_subs_s_w,
    mips_subs_u_b,
    mips_subs_u_d,
    mips_subs_u_h,
    mips_subs_u_w,
    mips_subsus_u_b,
    mips_subsus_u_d,
    mips_subsus_u_h,
    mips_subsus_u_w,
    mips_subsuu_s_b,
    mips_subsuu_s_d,
    mips_subsuu_s_h,
    mips_subsuu_s_w,
    mips_subu_ph,
    mips_subu_qb,
    mips_subu_s_ph,
    mips_subu_s_qb,
    mips_subuh_qb,
    mips_subuh_r_qb,
    mips_subv_b,
    mips_subv_d,
    mips_subv_h,
    mips_subv_w,
    mips_subvi_b,
    mips_subvi_d,
    mips_subvi_h,
    mips_subvi_w,
    mips_vshf_b,
    mips_vshf_d,
    mips_vshf_h,
    mips_vshf_w,
    mips_wrdsp,
    mips_xor_v,
    mips_xori_b,
    nacl_atomic_cmpxchg,
    nacl_atomic_fence,
    nacl_atomic_fence_all,
    nacl_atomic_is_lock_free,
    nacl_atomic_load,
    nacl_atomic_rmw,
    nacl_atomic_store,
    nacl_longjmp,
    nacl_read_tp,
    nacl_setjmp,
    nearbyint,
    nvvm_abs_i,
    nvvm_abs_ll,
    nvvm_add_rm_d,
    nvvm_add_rm_f,
    nvvm_add_rm_ftz_f,
    nvvm_add_rn_d,
    nvvm_add_rn_f,
    nvvm_add_rn_ftz_f,
    nvvm_add_rp_d,
    nvvm_add_rp_f,
    nvvm_add_rp_ftz_f,
    nvvm_add_rz_d,
    nvvm_add_rz_f,
    nvvm_add_rz_ftz_f,
    nvvm_atomic_load_add_f32,
    nvvm_atomic_load_dec_32,
    nvvm_atomic_load_inc_32,
    nvvm_barrier0,
    nvvm_barrier0_and,
    nvvm_barrier0_or,
    nvvm_barrier0_popc,
    nvvm_bitcast_d2ll,
    nvvm_bitcast_f2i,
    nvvm_bitcast_i2f,
    nvvm_bitcast_ll2d,
    nvvm_brev32,
    nvvm_brev64,
    nvvm_ceil_d,
    nvvm_ceil_f,
    nvvm_ceil_ftz_f,
    nvvm_clz_i,
    nvvm_clz_ll,
    nvvm_compiler_error,
    nvvm_compiler_warn,
    nvvm_cos_approx_f,
    nvvm_cos_approx_ftz_f,
    nvvm_d2f_rm,
    nvvm_d2f_rm_ftz,
    nvvm_d2f_rn,
    nvvm_d2f_rn_ftz,
    nvvm_d2f_rp,
    nvvm_d2f_rp_ftz,
    nvvm_d2f_rz,
    nvvm_d2f_rz_ftz,
    nvvm_d2i_hi,
    nvvm_d2i_lo,
    nvvm_d2i_rm,
    nvvm_d2i_rn,
    nvvm_d2i_rp,
    nvvm_d2i_rz,
    nvvm_d2ll_rm,
    nvvm_d2ll_rn,
    nvvm_d2ll_rp,
    nvvm_d2ll_rz,
    nvvm_d2ui_rm,
    nvvm_d2ui_rn,
    nvvm_d2ui_rp,
    nvvm_d2ui_rz,
    nvvm_d2ull_rm,
    nvvm_d2ull_rn,
    nvvm_d2ull_rp,
    nvvm_d2ull_rz,
    nvvm_div_approx_f,
    nvvm_div_approx_ftz_f,
    nvvm_div_rm_d,
    nvvm_div_rm_f,
    nvvm_div_rm_ftz_f,
    nvvm_div_rn_d,
    nvvm_div_rn_f,
    nvvm_div_rn_ftz_f,
    nvvm_div_rp_d,
    nvvm_div_rp_f,
    nvvm_div_rp_ftz_f,
    nvvm_div_rz_d,
    nvvm_div_rz_f,
    nvvm_div_rz_ftz_f,
    nvvm_ex2_approx_d,
    nvvm_ex2_approx_f,
    nvvm_ex2_approx_ftz_f,
    nvvm_f2h_rn,
    nvvm_f2h_rn_ftz,
    nvvm_f2i_rm,
    nvvm_f2i_rm_ftz,
    nvvm_f2i_rn,
    nvvm_f2i_rn_ftz,
    nvvm_f2i_rp,
    nvvm_f2i_rp_ftz,
    nvvm_f2i_rz,
    nvvm_f2i_rz_ftz,
    nvvm_f2ll_rm,
    nvvm_f2ll_rm_ftz,
    nvvm_f2ll_rn,
    nvvm_f2ll_rn_ftz,
    nvvm_f2ll_rp,
    nvvm_f2ll_rp_ftz,
    nvvm_f2ll_rz,
    nvvm_f2ll_rz_ftz,
    nvvm_f2ui_rm,
    nvvm_f2ui_rm_ftz,
    nvvm_f2ui_rn,
    nvvm_f2ui_rn_ftz,
    nvvm_f2ui_rp,
    nvvm_f2ui_rp_ftz,
    nvvm_f2ui_rz,
    nvvm_f2ui_rz_ftz,
    nvvm_f2ull_rm,
    nvvm_f2ull_rm_ftz,
    nvvm_f2ull_rn,
    nvvm_f2ull_rn_ftz,
    nvvm_f2ull_rp,
    nvvm_f2ull_rp_ftz,
    nvvm_f2ull_rz,
    nvvm_f2ull_rz_ftz,
    nvvm_fabs_d,
    nvvm_fabs_f,
    nvvm_fabs_ftz_f,
    nvvm_floor_d,
    nvvm_floor_f,
    nvvm_floor_ftz_f,
    nvvm_fma_rm_d,
    nvvm_fma_rm_f,
    nvvm_fma_rm_ftz_f,
    nvvm_fma_rn_d,
    nvvm_fma_rn_f,
    nvvm_fma_rn_ftz_f,
    nvvm_fma_rp_d,
    nvvm_fma_rp_f,
    nvvm_fma_rp_ftz_f,
    nvvm_fma_rz_d,
    nvvm_fma_rz_f,
    nvvm_fma_rz_ftz_f,
    nvvm_fmax_d,
    nvvm_fmax_f,
    nvvm_fmax_ftz_f,
    nvvm_fmin_d,
    nvvm_fmin_f,
    nvvm_fmin_ftz_f,
    nvvm_h2f,
    nvvm_i2d_rm,
    nvvm_i2d_rn,
    nvvm_i2d_rp,
    nvvm_i2d_rz,
    nvvm_i2f_rm,
    nvvm_i2f_rn,
    nvvm_i2f_rp,
    nvvm_i2f_rz,
    nvvm_ldg_global_f,
    nvvm_ldg_global_i,
    nvvm_ldg_global_p,
    nvvm_ldu_global_f,
    nvvm_ldu_global_i,
    nvvm_ldu_global_p,
    nvvm_lg2_approx_d,
    nvvm_lg2_approx_f,
    nvvm_lg2_approx_ftz_f,
    nvvm_ll2d_rm,
    nvvm_ll2d_rn,
    nvvm_ll2d_rp,
    nvvm_ll2d_rz,
    nvvm_ll2f_rm,
    nvvm_ll2f_rn,
    nvvm_ll2f_rp,
    nvvm_ll2f_rz,
    nvvm_lohi_i2d,
    nvvm_max_i,
    nvvm_max_ll,
    nvvm_max_ui,
    nvvm_max_ull,
    nvvm_membar_cta,
    nvvm_membar_gl,
    nvvm_membar_sys,
    nvvm_min_i,
    nvvm_min_ll,
    nvvm_min_ui,
    nvvm_min_ull,
    nvvm_move_double,
    nvvm_move_float,
    nvvm_move_i16,
    nvvm_move_i32,
    nvvm_move_i64,
    nvvm_move_ptr,
    nvvm_mul24_i,
    nvvm_mul24_ui,
    nvvm_mul_rm_d,
    nvvm_mul_rm_f,
    nvvm_mul_rm_ftz_f,
    nvvm_mul_rn_d,
    nvvm_mul_rn_f,
    nvvm_mul_rn_ftz_f,
    nvvm_mul_rp_d,
    nvvm_mul_rp_f,
    nvvm_mul_rp_ftz_f,
    nvvm_mul_rz_d,
    nvvm_mul_rz_f,
    nvvm_mul_rz_ftz_f,
    nvvm_mulhi_i,
    nvvm_mulhi_ll,
    nvvm_mulhi_ui,
    nvvm_mulhi_ull,
    nvvm_popc_i,
    nvvm_popc_ll,
    nvvm_prmt,
    nvvm_ptr_constant_to_gen,
    nvvm_ptr_gen_to_constant,
    nvvm_ptr_gen_to_global,
    nvvm_ptr_gen_to_local,
    nvvm_ptr_gen_to_param,
    nvvm_ptr_gen_to_shared,
    nvvm_ptr_global_to_gen,
    nvvm_ptr_local_to_gen,
    nvvm_ptr_shared_to_gen,
    nvvm_rcp_approx_ftz_d,
    nvvm_rcp_rm_d,
    nvvm_rcp_rm_f,
    nvvm_rcp_rm_ftz_f,
    nvvm_rcp_rn_d,
    nvvm_rcp_rn_f,
    nvvm_rcp_rn_ftz_f,
    nvvm_rcp_rp_d,
    nvvm_rcp_rp_f,
    nvvm_rcp_rp_ftz_f,
    nvvm_rcp_rz_d,
    nvvm_rcp_rz_f,
    nvvm_rcp_rz_ftz_f,
    nvvm_read_ptx_sreg_ctaid_x,
    nvvm_read_ptx_sreg_ctaid_y,
    nvvm_read_ptx_sreg_ctaid_z,
    nvvm_read_ptx_sreg_nctaid_x,
    nvvm_read_ptx_sreg_nctaid_y,
    nvvm_read_ptx_sreg_nctaid_z,
    nvvm_read_ptx_sreg_ntid_x,
    nvvm_read_ptx_sreg_ntid_y,
    nvvm_read_ptx_sreg_ntid_z,
    nvvm_read_ptx_sreg_tid_x,
    nvvm_read_ptx_sreg_tid_y,
    nvvm_read_ptx_sreg_tid_z,
    nvvm_read_ptx_sreg_warpsize,
    nvvm_round_d,
    nvvm_round_f,
    nvvm_round_ftz_f,
    nvvm_rsqrt_approx_d,
    nvvm_rsqrt_approx_f,
    nvvm_rsqrt_approx_ftz_f,
    nvvm_sad_i,
    nvvm_sad_ui,
    nvvm_saturate_d,
    nvvm_saturate_f,
    nvvm_saturate_ftz_f,
    nvvm_sin_approx_f,
    nvvm_sin_approx_ftz_f,
    nvvm_sqrt_approx_f,
    nvvm_sqrt_approx_ftz_f,
    nvvm_sqrt_f,
    nvvm_sqrt_rm_d,
    nvvm_sqrt_rm_f,
    nvvm_sqrt_rm_ftz_f,
    nvvm_sqrt_rn_d,
    nvvm_sqrt_rn_f,
    nvvm_sqrt_rn_ftz_f,
    nvvm_sqrt_rp_d,
    nvvm_sqrt_rp_f,
    nvvm_sqrt_rp_ftz_f,
    nvvm_sqrt_rz_d,
    nvvm_sqrt_rz_f,
    nvvm_sqrt_rz_ftz_f,
    nvvm_trunc_d,
    nvvm_trunc_f,
    nvvm_trunc_ftz_f,
    nvvm_ui2d_rm,
    nvvm_ui2d_rn,
    nvvm_ui2d_rp,
    nvvm_ui2d_rz,
    nvvm_ui2f_rm,
    nvvm_ui2f_rn,
    nvvm_ui2f_rp,
    nvvm_ui2f_rz,
    nvvm_ull2d_rm,
    nvvm_ull2d_rn,
    nvvm_ull2d_rp,
    nvvm_ull2d_rz,
    nvvm_ull2f_rm,
    nvvm_ull2f_rn,
    nvvm_ull2f_rp,
    nvvm_ull2f_rz,
    objectsize,
    pcmarker,
    pow,
    powi,
    ppc_altivec_dss,
    ppc_altivec_dssall,
    ppc_altivec_dst,
    ppc_altivec_dstst,
    ppc_altivec_dststt,
    ppc_altivec_dstt,
    ppc_altivec_lvebx,
    ppc_altivec_lvehx,
    ppc_altivec_lvewx,
    ppc_altivec_lvsl,
    ppc_altivec_lvsr,
    ppc_altivec_lvx,
    ppc_altivec_lvxl,
    ppc_altivec_mfvscr,
    ppc_altivec_mtvscr,
    ppc_altivec_stvebx,
    ppc_altivec_stvehx,
    ppc_altivec_stvewx,
    ppc_altivec_stvx,
    ppc_altivec_stvxl,
    ppc_altivec_vaddcuw,
    ppc_altivec_vaddsbs,
    ppc_altivec_vaddshs,
    ppc_altivec_vaddsws,
    ppc_altivec_vaddubs,
    ppc_altivec_vadduhs,
    ppc_altivec_vadduws,
    ppc_altivec_vavgsb,
    ppc_altivec_vavgsh,
    ppc_altivec_vavgsw,
    ppc_altivec_vavgub,
    ppc_altivec_vavguh,
    ppc_altivec_vavguw,
    ppc_altivec_vcfsx,
    ppc_altivec_vcfux,
    ppc_altivec_vcmpbfp,
    ppc_altivec_vcmpbfp_p,
    ppc_altivec_vcmpeqfp,
    ppc_altivec_vcmpeqfp_p,
    ppc_altivec_vcmpequb,
    ppc_altivec_vcmpequb_p,
    ppc_altivec_vcmpequh,
    ppc_altivec_vcmpequh_p,
    ppc_altivec_vcmpequw,
    ppc_altivec_vcmpequw_p,
    ppc_altivec_vcmpgefp,
    ppc_altivec_vcmpgefp_p,
    ppc_altivec_vcmpgtfp,
    ppc_altivec_vcmpgtfp_p,
    ppc_altivec_vcmpgtsb,
    ppc_altivec_vcmpgtsb_p,
    ppc_altivec_vcmpgtsh,
    ppc_altivec_vcmpgtsh_p,
    ppc_altivec_vcmpgtsw,
    ppc_altivec_vcmpgtsw_p,
    ppc_altivec_vcmpgtub,
    ppc_altivec_vcmpgtub_p,
    ppc_altivec_vcmpgtuh,
    ppc_altivec_vcmpgtuh_p,
    ppc_altivec_vcmpgtuw,
    ppc_altivec_vcmpgtuw_p,
    ppc_altivec_vctsxs,
    ppc_altivec_vctuxs,
    ppc_altivec_vexptefp,
    ppc_altivec_vlogefp,
    ppc_altivec_vmaddfp,
    ppc_altivec_vmaxfp,
    ppc_altivec_vmaxsb,
    ppc_altivec_vmaxsh,
    ppc_altivec_vmaxsw,
    ppc_altivec_vmaxub,
    ppc_altivec_vmaxuh,
    ppc_altivec_vmaxuw,
    ppc_altivec_vmhaddshs,
    ppc_altivec_vmhraddshs,
    ppc_altivec_vminfp,
    ppc_altivec_vminsb,
    ppc_altivec_vminsh,
    ppc_altivec_vminsw,
    ppc_altivec_vminub,
    ppc_altivec_vminuh,
    ppc_altivec_vminuw,
    ppc_altivec_vmladduhm,
    ppc_altivec_vmsummbm,
    ppc_altivec_vmsumshm,
    ppc_altivec_vmsumshs,
    ppc_altivec_vmsumubm,
    ppc_altivec_vmsumuhm,
    ppc_altivec_vmsumuhs,
    ppc_altivec_vmulesb,
    ppc_altivec_vmulesh,
    ppc_altivec_vmuleub,
    ppc_altivec_vmuleuh,
    ppc_altivec_vmulosb,
    ppc_altivec_vmulosh,
    ppc_altivec_vmuloub,
    ppc_altivec_vmulouh,
    ppc_altivec_vnmsubfp,
    ppc_altivec_vperm,
    ppc_altivec_vpkpx,
    ppc_altivec_vpkshss,
    ppc_altivec_vpkshus,
    ppc_altivec_vpkswss,
    ppc_altivec_vpkswus,
    ppc_altivec_vpkuhus,
    ppc_altivec_vpkuwus,
    ppc_altivec_vrefp,
    ppc_altivec_vrfim,
    ppc_altivec_vrfin,
    ppc_altivec_vrfip,
    ppc_altivec_vrfiz,
    ppc_altivec_vrlb,
    ppc_altivec_vrlh,
    ppc_altivec_vrlw,
    ppc_altivec_vrsqrtefp,
    ppc_altivec_vsel,
    ppc_altivec_vsl,
    ppc_altivec_vslb,
    ppc_altivec_vslh,
    ppc_altivec_vslo,
    ppc_altivec_vslw,
    ppc_altivec_vsr,
    ppc_altivec_vsrab,
    ppc_altivec_vsrah,
    ppc_altivec_vsraw,
    ppc_altivec_vsrb,
    ppc_altivec_vsrh,
    ppc_altivec_vsro,
    ppc_altivec_vsrw,
    ppc_altivec_vsubcuw,
    ppc_altivec_vsubsbs,
    ppc_altivec_vsubshs,
    ppc_altivec_vsubsws,
    ppc_altivec_vsububs,
    ppc_altivec_vsubuhs,
    ppc_altivec_vsubuws,
    ppc_altivec_vsum2sws,
    ppc_altivec_vsum4sbs,
    ppc_altivec_vsum4shs,
    ppc_altivec_vsum4ubs,
    ppc_altivec_vsumsws,
    ppc_altivec_vupkhpx,
    ppc_altivec_vupkhsb,
    ppc_altivec_vupkhsh,
    ppc_altivec_vupklpx,
    ppc_altivec_vupklsb,
    ppc_altivec_vupklsh,
    ppc_dcba,
    ppc_dcbf,
    ppc_dcbi,
    ppc_dcbst,
    ppc_dcbt,
    ppc_dcbtst,
    ppc_dcbz,
    ppc_dcbzl,
    ppc_is_decremented_ctr_nonzero,
    ppc_mtctr,
    ppc_sync,
    prefetch,
    ptr_annotation,
    ptx_bar_sync,
    ptx_read_clock,
    ptx_read_clock64,
    ptx_read_ctaid_w,
    ptx_read_ctaid_x,
    ptx_read_ctaid_y,
    ptx_read_ctaid_z,
    ptx_read_gridid,
    ptx_read_laneid,
    ptx_read_lanemask_eq,
    ptx_read_lanemask_ge,
    ptx_read_lanemask_gt,
    ptx_read_lanemask_le,
    ptx_read_lanemask_lt,
    ptx_read_nctaid_w,
    ptx_read_nctaid_x,
    ptx_read_nctaid_y,
    ptx_read_nctaid_z,
    ptx_read_nsmid,
    ptx_read_ntid_w,
    ptx_read_ntid_x,
    ptx_read_ntid_y,
    ptx_read_ntid_z,
    ptx_read_nwarpid,
    ptx_read_pm0,
    ptx_read_pm1,
    ptx_read_pm2,
    ptx_read_pm3,
    ptx_read_smid,
    ptx_read_tid_w,
    ptx_read_tid_x,
    ptx_read_tid_y,
    ptx_read_tid_z,
    ptx_read_warpid,
    r600_read_global_size_x,
    r600_read_global_size_y,
    r600_read_global_size_z,
    r600_read_local_size_x,
    r600_read_local_size_y,
    r600_read_local_size_z,
    r600_read_ngroups_x,
    r600_read_ngroups_y,
    r600_read_ngroups_z,
    r600_read_tgid_x,
    r600_read_tgid_y,
    r600_read_tgid_z,
    r600_read_tidig_x,
    r600_read_tidig_y,
    r600_read_tidig_z,
    readcyclecounter,
    returnaddress,
    rint,
    round,
    sadd_with_overflow,
    setjmp,
    siglongjmp,
    sigsetjmp,
    sin,
    smul_with_overflow,
    sqrt,
    ssub_with_overflow,
    stackprotector,
    stackprotectorcheck,
    stackrestore,
    stacksave,
    trap,
    trunc,
    uadd_with_overflow,
    umul_with_overflow,
    usub_with_overflow,
    vacopy,
    vaend,
    var_annotation,
    vastart,
    x86_3dnow_pavgusb,
    x86_3dnow_pf2id,
    x86_3dnow_pfacc,
    x86_3dnow_pfadd,
    x86_3dnow_pfcmpeq,
    x86_3dnow_pfcmpge,
    x86_3dnow_pfcmpgt,
    x86_3dnow_pfmax,
    x86_3dnow_pfmin,
    x86_3dnow_pfmul,
    x86_3dnow_pfrcp,
    x86_3dnow_pfrcpit1,
    x86_3dnow_pfrcpit2,
    x86_3dnow_pfrsqit1,
    x86_3dnow_pfrsqrt,
    x86_3dnow_pfsub,
    x86_3dnow_pfsubr,
    x86_3dnow_pi2fd,
    x86_3dnow_pmulhrw,
    x86_3dnowa_pf2iw,
    x86_3dnowa_pfnacc,
    x86_3dnowa_pfpnacc,
    x86_3dnowa_pi2fw,
    x86_3dnowa_pswapd,
    x86_aesni_aesdec,
    x86_aesni_aesdeclast,
    x86_aesni_aesenc,
    x86_aesni_aesenclast,
    x86_aesni_aesimc,
    x86_aesni_aeskeygenassist,
    x86_avx2_gather_d_d,
    x86_avx2_gather_d_d_256,
    x86_avx2_gather_d_pd,
    x86_avx2_gather_d_pd_256,
    x86_avx2_gather_d_ps,
    x86_avx2_gather_d_ps_256,
    x86_avx2_gather_d_q,
    x86_avx2_gather_d_q_256,
    x86_avx2_gather_q_d,
    x86_avx2_gather_q_d_256,
    x86_avx2_gather_q_pd,
    x86_avx2_gather_q_pd_256,
    x86_avx2_gather_q_ps,
    x86_avx2_gather_q_ps_256,
    x86_avx2_gather_q_q,
    x86_avx2_gather_q_q_256,
    x86_avx2_maskload_d,
    x86_avx2_maskload_d_256,
    x86_avx2_maskload_q,
    x86_avx2_maskload_q_256,
    x86_avx2_maskstore_d,
    x86_avx2_maskstore_d_256,
    x86_avx2_maskstore_q,
    x86_avx2_maskstore_q_256,
    x86_avx2_movntdqa,
    x86_avx2_mpsadbw,
    x86_avx2_pabs_b,
    x86_avx2_pabs_d,
    x86_avx2_pabs_w,
    x86_avx2_packssdw,
    x86_avx2_packsswb,
    x86_avx2_packusdw,
    x86_avx2_packuswb,
    x86_avx2_padds_b,
    x86_avx2_padds_w,
    x86_avx2_paddus_b,
    x86_avx2_paddus_w,
    x86_avx2_pavg_b,
    x86_avx2_pavg_w,
    x86_avx2_pblendd_128,
    x86_avx2_pblendd_256,
    x86_avx2_pblendvb,
    x86_avx2_pblendw,
    x86_avx2_pbroadcastb_128,
    x86_avx2_pbroadcastb_256,
    x86_avx2_pbroadcastd_128,
    x86_avx2_pbroadcastd_256,
    x86_avx2_pbroadcastq_128,
    x86_avx2_pbroadcastq_256,
    x86_avx2_pbroadcastw_128,
    x86_avx2_pbroadcastw_256,
    x86_avx2_permd,
    x86_avx2_permps,
    x86_avx2_phadd_d,
    x86_avx2_phadd_sw,
    x86_avx2_phadd_w,
    x86_avx2_phsub_d,
    x86_avx2_phsub_sw,
    x86_avx2_phsub_w,
    x86_avx2_pmadd_ub_sw,
    x86_avx2_pmadd_wd,
    x86_avx2_pmaxs_b,
    x86_avx2_pmaxs_d,
    x86_avx2_pmaxs_w,
    x86_avx2_pmaxu_b,
    x86_avx2_pmaxu_d,
    x86_avx2_pmaxu_w,
    x86_avx2_pmins_b,
    x86_avx2_pmins_d,
    x86_avx2_pmins_w,
    x86_avx2_pminu_b,
    x86_avx2_pminu_d,
    x86_avx2_pminu_w,
    x86_avx2_pmovmskb,
    x86_avx2_pmovsxbd,
    x86_avx2_pmovsxbq,
    x86_avx2_pmovsxbw,
    x86_avx2_pmovsxdq,
    x86_avx2_pmovsxwd,
    x86_avx2_pmovsxwq,
    x86_avx2_pmovzxbd,
    x86_avx2_pmovzxbq,
    x86_avx2_pmovzxbw,
    x86_avx2_pmovzxdq,
    x86_avx2_pmovzxwd,
    x86_avx2_pmovzxwq,
    x86_avx2_pmul_dq,
    x86_avx2_pmul_hr_sw,
    x86_avx2_pmulh_w,
    x86_avx2_pmulhu_w,
    x86_avx2_pmulu_dq,
    x86_avx2_psad_bw,
    x86_avx2_pshuf_b,
    x86_avx2_psign_b,
    x86_avx2_psign_d,
    x86_avx2_psign_w,
    x86_avx2_psll_d,
    x86_avx2_psll_dq,
    x86_avx2_psll_dq_bs,
    x86_avx2_psll_q,
    x86_avx2_psll_w,
    x86_avx2_pslli_d,
    x86_avx2_pslli_q,
    x86_avx2_pslli_w,
    x86_avx2_psllv_d,
    x86_avx2_psllv_d_256,
    x86_avx2_psllv_q,
    x86_avx2_psllv_q_256,
    x86_avx2_psra_d,
    x86_avx2_psra_w,
    x86_avx2_psrai_d,
    x86_avx2_psrai_w,
    x86_avx2_psrav_d,
    x86_avx2_psrav_d_256,
    x86_avx2_psrl_d,
    x86_avx2_psrl_dq,
    x86_avx2_psrl_dq_bs,
    x86_avx2_psrl_q,
    x86_avx2_psrl_w,
    x86_avx2_psrli_d,
    x86_avx2_psrli_q,
    x86_avx2_psrli_w,
    x86_avx2_psrlv_d,
    x86_avx2_psrlv_d_256,
    x86_avx2_psrlv_q,
    x86_avx2_psrlv_q_256,
    x86_avx2_psubs_b,
    x86_avx2_psubs_w,
    x86_avx2_psubus_b,
    x86_avx2_psubus_w,
    x86_avx2_vbroadcast_sd_pd_256,
    x86_avx2_vbroadcast_ss_ps,
    x86_avx2_vbroadcast_ss_ps_256,
    x86_avx2_vbroadcasti128,
    x86_avx2_vextracti128,
    x86_avx2_vinserti128,
    x86_avx2_vperm2i128,
    x86_avx512_and_pi,
    x86_avx512_cmpeq_pi_512,
    x86_avx512_conflict_d_512,
    x86_avx512_conflict_d_mask_512,
    x86_avx512_conflict_d_maskz_512,
    x86_avx512_conflict_q_512,
    x86_avx512_conflict_q_mask_512,
    x86_avx512_conflict_q_maskz_512,
    x86_avx512_cvt_ps2dq_512,
    x86_avx512_cvtdq2_ps_512,
    x86_avx512_cvtsd2usi,
    x86_avx512_cvtsd2usi64,
    x86_avx512_cvtss2usi,
    x86_avx512_cvtss2usi64,
    x86_avx512_cvttsd2usi,
    x86_avx512_cvttsd2usi64,
    x86_avx512_cvttss2usi,
    x86_avx512_cvttss2usi64,
    x86_avx512_cvtusi2sd,
    x86_avx512_cvtusi2ss,
    x86_avx512_cvtusi642sd,
    x86_avx512_cvtusi642ss,
    x86_avx512_gather_dpd_512,
    x86_avx512_gather_dpd_mask_512,
    x86_avx512_gather_dpi_512,
    x86_avx512_gather_dpi_mask_512,
    x86_avx512_gather_dpq_512,
    x86_avx512_gather_dpq_mask_512,
    x86_avx512_gather_dps_512,
    x86_avx512_gather_dps_mask_512,
    x86_avx512_gather_qpd_512,
    x86_avx512_gather_qpd_mask_512,
    x86_avx512_gather_qpi_512,
    x86_avx512_gather_qpi_mask_512,
    x86_avx512_gather_qpq_512,
    x86_avx512_gather_qpq_mask_512,
    x86_avx512_gather_qps_512,
    x86_avx512_gather_qps_mask_512,
    x86_avx512_kortestc,
    x86_avx512_kortestz,
    x86_avx512_max_pd_512,
    x86_avx512_max_ps_512,
    x86_avx512_min_pd_512,
    x86_avx512_min_ps_512,
    x86_avx512_mskblend_d_512,
    x86_avx512_mskblend_pd_512,
    x86_avx512_mskblend_ps_512,
    x86_avx512_mskblend_q_512,
    x86_avx512_pbroadcastd_512,
    x86_avx512_pbroadcastd_i32_512,
    x86_avx512_pbroadcastq_512,
    x86_avx512_pbroadcastq_i64_512,
    x86_avx512_pmaxs_d,
    x86_avx512_pmaxs_q,
    x86_avx512_pmaxu_d,
    x86_avx512_pmaxu_q,
    x86_avx512_pmins_d,
    x86_avx512_pmins_q,
    x86_avx512_pminu_d,
    x86_avx512_pminu_q,
    x86_avx512_pmovzxbd,
    x86_avx512_pmovzxbq,
    x86_avx512_pmovzxdq,
    x86_avx512_pmovzxwd,
    x86_avx512_pmovzxwq,
    x86_avx512_psll_dq,
    x86_avx512_psll_dq_bs,
    x86_avx512_psrl_dq,
    x86_avx512_psrl_dq_bs,
    x86_avx512_rcp14_pd_512,
    x86_avx512_rcp14_ps_512,
    x86_avx512_rcp14_sd,
    x86_avx512_rcp14_ss,
    x86_avx512_rcp28_pd_512,
    x86_avx512_rcp28_ps_512,
    x86_avx512_rcp28_sd,
    x86_avx512_rcp28_ss,
    x86_avx512_rndscale_pd_512,
    x86_avx512_rndscale_ps_512,
    x86_avx512_rndscale_sd,
    x86_avx512_rndscale_ss,
    x86_avx512_rsqrt14_pd_512,
    x86_avx512_rsqrt14_ps_512,
    x86_avx512_rsqrt14_sd,
    x86_avx512_rsqrt14_ss,
    x86_avx512_rsqrt28_pd_512,
    x86_avx512_rsqrt28_ps_512,
    x86_avx512_rsqrt28_sd,
    x86_avx512_rsqrt28_ss,
    x86_avx512_scatter_dpd_512,
    x86_avx512_scatter_dpd_mask_512,
    x86_avx512_scatter_dpi_512,
    x86_avx512_scatter_dpi_mask_512,
    x86_avx512_scatter_dpq_512,
    x86_avx512_scatter_dpq_mask_512,
    x86_avx512_scatter_dps_512,
    x86_avx512_scatter_dps_mask_512,
    x86_avx512_scatter_qpd_512,
    x86_avx512_scatter_qpd_mask_512,
    x86_avx512_scatter_qpi_512,
    x86_avx512_scatter_qpi_mask_512,
    x86_avx512_scatter_qpq_512,
    x86_avx512_scatter_qpq_mask_512,
    x86_avx512_scatter_qps_512,
    x86_avx512_scatter_qps_mask_512,
    x86_avx512_sqrt_pd_512,
    x86_avx512_sqrt_ps_512,
    x86_avx512_sqrt_sd,
    x86_avx512_sqrt_ss,
    x86_avx512_vbroadcast_sd_512,
    x86_avx512_vbroadcast_sd_pd_512,
    x86_avx512_vbroadcast_ss_512,
    x86_avx512_vbroadcast_ss_ps_512,
    x86_avx512_vcvtph2ps_512,
    x86_avx512_vcvtps2ph_512,
    x86_avx_addsub_pd_256,
    x86_avx_addsub_ps_256,
    x86_avx_blend_pd_256,
    x86_avx_blend_ps_256,
    x86_avx_blendv_pd_256,
    x86_avx_blendv_ps_256,
    x86_avx_cmp_pd_256,
    x86_avx_cmp_ps_256,
    x86_avx_cvt_pd2_ps_256,
    x86_avx_cvt_pd2dq_256,
    x86_avx_cvt_ps2_pd_256,
    x86_avx_cvt_ps2dq_256,
    x86_avx_cvtdq2_pd_256,
    x86_avx_cvtdq2_ps_256,
    x86_avx_cvtt_pd2dq_256,
    x86_avx_cvtt_ps2dq_256,
    x86_avx_dp_ps_256,
    x86_avx_hadd_pd_256,
    x86_avx_hadd_ps_256,
    x86_avx_hsub_pd_256,
    x86_avx_hsub_ps_256,
    x86_avx_ldu_dq_256,
    x86_avx_maskload_pd,
    x86_avx_maskload_pd_256,
    x86_avx_maskload_ps,
    x86_avx_maskload_ps_256,
    x86_avx_maskstore_pd,
    x86_avx_maskstore_pd_256,
    x86_avx_maskstore_ps,
    x86_avx_maskstore_ps_256,
    x86_avx_max_pd_256,
    x86_avx_max_ps_256,
    x86_avx_min_pd_256,
    x86_avx_min_ps_256,
    x86_avx_movmsk_pd_256,
    x86_avx_movmsk_ps_256,
    x86_avx_ptestc_256,
    x86_avx_ptestnzc_256,
    x86_avx_ptestz_256,
    x86_avx_rcp_ps_256,
    x86_avx_round_pd_256,
    x86_avx_round_ps_256,
    x86_avx_rsqrt_ps_256,
    x86_avx_sqrt_pd_256,
    x86_avx_sqrt_ps_256,
    x86_avx_storeu_dq_256,
    x86_avx_storeu_pd_256,
    x86_avx_storeu_ps_256,
    x86_avx_vbroadcast_sd_256,
    x86_avx_vbroadcast_ss,
    x86_avx_vbroadcast_ss_256,
    x86_avx_vbroadcastf128_pd_256,
    x86_avx_vbroadcastf128_ps_256,
    x86_avx_vextractf128_pd_256,
    x86_avx_vextractf128_ps_256,
    x86_avx_vextractf128_si_256,
    x86_avx_vinsertf128_pd_256,
    x86_avx_vinsertf128_ps_256,
    x86_avx_vinsertf128_si_256,
    x86_avx_vperm2f128_pd_256,
    x86_avx_vperm2f128_ps_256,
    x86_avx_vperm2f128_si_256,
    x86_avx_vpermilvar_pd,
    x86_avx_vpermilvar_pd_256,
    x86_avx_vpermilvar_ps,
    x86_avx_vpermilvar_ps_256,
    x86_avx_vtestc_pd,
    x86_avx_vtestc_pd_256,
    x86_avx_vtestc_ps,
    x86_avx_vtestc_ps_256,
    x86_avx_vtestnzc_pd,
    x86_avx_vtestnzc_pd_256,
    x86_avx_vtestnzc_ps,
    x86_avx_vtestnzc_ps_256,
    x86_avx_vtestz_pd,
    x86_avx_vtestz_pd_256,
    x86_avx_vtestz_ps,
    x86_avx_vtestz_ps_256,
    x86_avx_vzeroall,
    x86_avx_vzeroupper,
    x86_bmi_bextr_32,
    x86_bmi_bextr_64,
    x86_bmi_bzhi_32,
    x86_bmi_bzhi_64,
    x86_bmi_pdep_32,
    x86_bmi_pdep_64,
    x86_bmi_pext_32,
    x86_bmi_pext_64,
    x86_fma_vfmadd_pd,
    x86_fma_vfmadd_pd_256,
    x86_fma_vfmadd_pd_512,
    x86_fma_vfmadd_ps,
    x86_fma_vfmadd_ps_256,
    x86_fma_vfmadd_ps_512,
    x86_fma_vfmadd_sd,
    x86_fma_vfmadd_ss,
    x86_fma_vfmaddsub_pd,
    x86_fma_vfmaddsub_pd_256,
    x86_fma_vfmaddsub_pd_512,
    x86_fma_vfmaddsub_ps,
    x86_fma_vfmaddsub_ps_256,
    x86_fma_vfmaddsub_ps_512,
    x86_fma_vfmsub_pd,
    x86_fma_vfmsub_pd_256,
    x86_fma_vfmsub_pd_512,
    x86_fma_vfmsub_ps,
    x86_fma_vfmsub_ps_256,
    x86_fma_vfmsub_ps_512,
    x86_fma_vfmsub_sd,
    x86_fma_vfmsub_ss,
    x86_fma_vfmsubadd_pd,
    x86_fma_vfmsubadd_pd_256,
    x86_fma_vfmsubadd_pd_512,
    x86_fma_vfmsubadd_ps,
    x86_fma_vfmsubadd_ps_256,
    x86_fma_vfmsubadd_ps_512,
    x86_fma_vfnmadd_pd,
    x86_fma_vfnmadd_pd_256,
    x86_fma_vfnmadd_pd_512,
    x86_fma_vfnmadd_ps,
    x86_fma_vfnmadd_ps_256,
    x86_fma_vfnmadd_ps_512,
    x86_fma_vfnmadd_sd,
    x86_fma_vfnmadd_ss,
    x86_fma_vfnmsub_pd,
    x86_fma_vfnmsub_pd_256,
    x86_fma_vfnmsub_pd_512,
    x86_fma_vfnmsub_ps,
    x86_fma_vfnmsub_ps_256,
    x86_fma_vfnmsub_ps_512,
    x86_fma_vfnmsub_sd,
    x86_fma_vfnmsub_ss,
    x86_int,
    x86_int2mask_v16i1,
    x86_kadd_v16i1,
    x86_kand_v16i1,
    x86_kandn_v16i1,
    x86_knot_v16i1,
    x86_kor_v16i1,
    x86_kunpck_v16i1,
    x86_kxnor_v16i1,
    x86_kxor_v16i1,
    x86_mask2int_v16i1,
    x86_mmx_emms,
    x86_mmx_femms,
    x86_mmx_maskmovq,
    x86_mmx_movnt_dq,
    x86_mmx_packssdw,
    x86_mmx_packsswb,
    x86_mmx_packuswb,
    x86_mmx_padd_b,
    x86_mmx_padd_d,
    x86_mmx_padd_q,
    x86_mmx_padd_w,
    x86_mmx_padds_b,
    x86_mmx_padds_w,
    x86_mmx_paddus_b,
    x86_mmx_paddus_w,
    x86_mmx_palignr_b,
    x86_mmx_pand,
    x86_mmx_pandn,
    x86_mmx_pavg_b,
    x86_mmx_pavg_w,
    x86_mmx_pcmpeq_b,
    x86_mmx_pcmpeq_d,
    x86_mmx_pcmpeq_w,
    x86_mmx_pcmpgt_b,
    x86_mmx_pcmpgt_d,
    x86_mmx_pcmpgt_w,
    x86_mmx_pextr_w,
    x86_mmx_pinsr_w,
    x86_mmx_pmadd_wd,
    x86_mmx_pmaxs_w,
    x86_mmx_pmaxu_b,
    x86_mmx_pmins_w,
    x86_mmx_pminu_b,
    x86_mmx_pmovmskb,
    x86_mmx_pmulh_w,
    x86_mmx_pmulhu_w,
    x86_mmx_pmull_w,
    x86_mmx_pmulu_dq,
    x86_mmx_por,
    x86_mmx_psad_bw,
    x86_mmx_psll_d,
    x86_mmx_psll_q,
    x86_mmx_psll_w,
    x86_mmx_pslli_d,
    x86_mmx_pslli_q,
    x86_mmx_pslli_w,
    x86_mmx_psra_d,
    x86_mmx_psra_w,
    x86_mmx_psrai_d,
    x86_mmx_psrai_w,
    x86_mmx_psrl_d,
    x86_mmx_psrl_q,
    x86_mmx_psrl_w,
    x86_mmx_psrli_d,
    x86_mmx_psrli_q,
    x86_mmx_psrli_w,
    x86_mmx_psub_b,
    x86_mmx_psub_d,
    x86_mmx_psub_q,
    x86_mmx_psub_w,
    x86_mmx_psubs_b,
    x86_mmx_psubs_w,
    x86_mmx_psubus_b,
    x86_mmx_psubus_w,
    x86_mmx_punpckhbw,
    x86_mmx_punpckhdq,
    x86_mmx_punpckhwd,
    x86_mmx_punpcklbw,
    x86_mmx_punpckldq,
    x86_mmx_punpcklwd,
    x86_mmx_pxor,
    x86_pclmulqdq,
    x86_rdfsbase_32,
    x86_rdfsbase_64,
    x86_rdgsbase_32,
    x86_rdgsbase_64,
    x86_rdrand_16,
    x86_rdrand_32,
    x86_rdrand_64,
    x86_rdseed_16,
    x86_rdseed_32,
    x86_rdseed_64,
    x86_sha1msg1,
    x86_sha1msg2,
    x86_sha1nexte,
    x86_sha1rnds4,
    x86_sha256msg1,
    x86_sha256msg2,
    x86_sha256rnds2,
    x86_sse2_add_sd,
    x86_sse2_clflush,
    x86_sse2_cmp_pd,
    x86_sse2_cmp_sd,
    x86_sse2_comieq_sd,
    x86_sse2_comige_sd,
    x86_sse2_comigt_sd,
    x86_sse2_comile_sd,
    x86_sse2_comilt_sd,
    x86_sse2_comineq_sd,
    x86_sse2_cvtdq2pd,
    x86_sse2_cvtdq2ps,
    x86_sse2_cvtpd2dq,
    x86_sse2_cvtpd2ps,
    x86_sse2_cvtps2dq,
    x86_sse2_cvtps2pd,
    x86_sse2_cvtsd2si,
    x86_sse2_cvtsd2si64,
    x86_sse2_cvtsd2ss,
    x86_sse2_cvtsi2sd,
    x86_sse2_cvtsi642sd,
    x86_sse2_cvtss2sd,
    x86_sse2_cvttpd2dq,
    x86_sse2_cvttps2dq,
    x86_sse2_cvttsd2si,
    x86_sse2_cvttsd2si64,
    x86_sse2_div_sd,
    x86_sse2_lfence,
    x86_sse2_maskmov_dqu,
    x86_sse2_max_pd,
    x86_sse2_max_sd,
    x86_sse2_mfence,
    x86_sse2_min_pd,
    x86_sse2_min_sd,
    x86_sse2_movmsk_pd,
    x86_sse2_mul_sd,
    x86_sse2_packssdw_128,
    x86_sse2_packsswb_128,
    x86_sse2_packuswb_128,
    x86_sse2_padds_b,
    x86_sse2_padds_w,
    x86_sse2_paddus_b,
    x86_sse2_paddus_w,
    x86_sse2_pavg_b,
    x86_sse2_pavg_w,
    x86_sse2_pmadd_wd,
    x86_sse2_pmaxs_w,
    x86_sse2_pmaxu_b,
    x86_sse2_pmins_w,
    x86_sse2_pminu_b,
    x86_sse2_pmovmskb_128,
    x86_sse2_pmulh_w,
    x86_sse2_pmulhu_w,
    x86_sse2_pmulu_dq,
    x86_sse2_psad_bw,
    x86_sse2_psll_d,
    x86_sse2_psll_dq,
    x86_sse2_psll_dq_bs,
    x86_sse2_psll_q,
    x86_sse2_psll_w,
    x86_sse2_pslli_d,
    x86_sse2_pslli_q,
    x86_sse2_pslli_w,
    x86_sse2_psra_d,
    x86_sse2_psra_w,
    x86_sse2_psrai_d,
    x86_sse2_psrai_w,
    x86_sse2_psrl_d,
    x86_sse2_psrl_dq,
    x86_sse2_psrl_dq_bs,
    x86_sse2_psrl_q,
    x86_sse2_psrl_w,
    x86_sse2_psrli_d,
    x86_sse2_psrli_q,
    x86_sse2_psrli_w,
    x86_sse2_psubs_b,
    x86_sse2_psubs_w,
    x86_sse2_psubus_b,
    x86_sse2_psubus_w,
    x86_sse2_sqrt_pd,
    x86_sse2_sqrt_sd,
    x86_sse2_storel_dq,
    x86_sse2_storeu_dq,
    x86_sse2_storeu_pd,
    x86_sse2_sub_sd,
    x86_sse2_ucomieq_sd,
    x86_sse2_ucomige_sd,
    x86_sse2_ucomigt_sd,
    x86_sse2_ucomile_sd,
    x86_sse2_ucomilt_sd,
    x86_sse2_ucomineq_sd,
    x86_sse3_addsub_pd,
    x86_sse3_addsub_ps,
    x86_sse3_hadd_pd,
    x86_sse3_hadd_ps,
    x86_sse3_hsub_pd,
    x86_sse3_hsub_ps,
    x86_sse3_ldu_dq,
    x86_sse3_monitor,
    x86_sse3_mwait,
    x86_sse41_blendpd,
    x86_sse41_blendps,
    x86_sse41_blendvpd,
    x86_sse41_blendvps,
    x86_sse41_dppd,
    x86_sse41_dpps,
    x86_sse41_extractps,
    x86_sse41_insertps,
    x86_sse41_movntdqa,
    x86_sse41_mpsadbw,
    x86_sse41_packusdw,
    x86_sse41_pblendvb,
    x86_sse41_pblendw,
    x86_sse41_pextrb,
    x86_sse41_pextrd,
    x86_sse41_pextrq,
    x86_sse41_phminposuw,
    x86_sse41_pmaxsb,
    x86_sse41_pmaxsd,
    x86_sse41_pmaxud,
    x86_sse41_pmaxuw,
    x86_sse41_pminsb,
    x86_sse41_pminsd,
    x86_sse41_pminud,
    x86_sse41_pminuw,
    x86_sse41_pmovsxbd,
    x86_sse41_pmovsxbq,
    x86_sse41_pmovsxbw,
    x86_sse41_pmovsxdq,
    x86_sse41_pmovsxwd,
    x86_sse41_pmovsxwq,
    x86_sse41_pmovzxbd,
    x86_sse41_pmovzxbq,
    x86_sse41_pmovzxbw,
    x86_sse41_pmovzxdq,
    x86_sse41_pmovzxwd,
    x86_sse41_pmovzxwq,
    x86_sse41_pmuldq,
    x86_sse41_ptestc,
    x86_sse41_ptestnzc,
    x86_sse41_ptestz,
    x86_sse41_round_pd,
    x86_sse41_round_ps,
    x86_sse41_round_sd,
    x86_sse41_round_ss,
    x86_sse42_crc32_32_16,
    x86_sse42_crc32_32_32,
    x86_sse42_crc32_32_8,
    x86_sse42_crc32_64_64,
    x86_sse42_pcmpestri128,
    x86_sse42_pcmpestria128,
    x86_sse42_pcmpestric128,
    x86_sse42_pcmpestrio128,
    x86_sse42_pcmpestris128,
    x86_sse42_pcmpestriz128,
    x86_sse42_pcmpestrm128,
    x86_sse42_pcmpistri128,
    x86_sse42_pcmpistria128,
    x86_sse42_pcmpistric128,
    x86_sse42_pcmpistrio128,
    x86_sse42_pcmpistris128,
    x86_sse42_pcmpistriz128,
    x86_sse42_pcmpistrm128,
    x86_sse4a_extrq,
    x86_sse4a_extrqi,
    x86_sse4a_insertq,
    x86_sse4a_insertqi,
    x86_sse4a_movnt_sd,
    x86_sse4a_movnt_ss,
    x86_sse_add_ss,
    x86_sse_cmp_ps,
    x86_sse_cmp_ss,
    x86_sse_comieq_ss,
    x86_sse_comige_ss,
    x86_sse_comigt_ss,
    x86_sse_comile_ss,
    x86_sse_comilt_ss,
    x86_sse_comineq_ss,
    x86_sse_cvtpd2pi,
    x86_sse_cvtpi2pd,
    x86_sse_cvtpi2ps,
    x86_sse_cvtps2pi,
    x86_sse_cvtsi2ss,
    x86_sse_cvtsi642ss,
    x86_sse_cvtss2si,
    x86_sse_cvtss2si64,
    x86_sse_cvttpd2pi,
    x86_sse_cvttps2pi,
    x86_sse_cvttss2si,
    x86_sse_cvttss2si64,
    x86_sse_div_ss,
    x86_sse_ldmxcsr,
    x86_sse_max_ps,
    x86_sse_max_ss,
    x86_sse_min_ps,
    x86_sse_min_ss,
    x86_sse_movmsk_ps,
    x86_sse_mul_ss,
    x86_sse_pshuf_w,
    x86_sse_rcp_ps,
    x86_sse_rcp_ss,
    x86_sse_rsqrt_ps,
    x86_sse_rsqrt_ss,
    x86_sse_sfence,
    x86_sse_sqrt_ps,
    x86_sse_sqrt_ss,
    x86_sse_stmxcsr,
    x86_sse_storeu_ps,
    x86_sse_sub_ss,
    x86_sse_ucomieq_ss,
    x86_sse_ucomige_ss,
    x86_sse_ucomigt_ss,
    x86_sse_ucomile_ss,
    x86_sse_ucomilt_ss,
    x86_sse_ucomineq_ss,
    x86_ssse3_pabs_b,
    x86_ssse3_pabs_b_128,
    x86_ssse3_pabs_d,
    x86_ssse3_pabs_d_128,
    x86_ssse3_pabs_w,
    x86_ssse3_pabs_w_128,
    x86_ssse3_phadd_d,
    x86_ssse3_phadd_d_128,
    x86_ssse3_phadd_sw,
    x86_ssse3_phadd_sw_128,
    x86_ssse3_phadd_w,
    x86_ssse3_phadd_w_128,
    x86_ssse3_phsub_d,
    x86_ssse3_phsub_d_128,
    x86_ssse3_phsub_sw,
    x86_ssse3_phsub_sw_128,
    x86_ssse3_phsub_w,
    x86_ssse3_phsub_w_128,
    x86_ssse3_pmadd_ub_sw,
    x86_ssse3_pmadd_ub_sw_128,
    x86_ssse3_pmul_hr_sw,
    x86_ssse3_pmul_hr_sw_128,
    x86_ssse3_pshuf_b,
    x86_ssse3_pshuf_b_128,
    x86_ssse3_psign_b,
    x86_ssse3_psign_b_128,
    x86_ssse3_psign_d,
    x86_ssse3_psign_d_128,
    x86_ssse3_psign_w,
    x86_ssse3_psign_w_128,
    x86_tbm_bextri_u32,
    x86_tbm_bextri_u64,
    x86_vcvtph2ps_128,
    x86_vcvtph2ps_256,
    x86_vcvtps2ph_128,
    x86_vcvtps2ph_256,
    x86_wrfsbase_32,
    x86_wrfsbase_64,
    x86_wrgsbase_32,
    x86_wrgsbase_64,
    x86_xabort,
    x86_xbegin,
    x86_xend,
    x86_xop_vfrcz_pd,
    x86_xop_vfrcz_pd_256,
    x86_xop_vfrcz_ps,
    x86_xop_vfrcz_ps_256,
    x86_xop_vfrcz_sd,
    x86_xop_vfrcz_ss,
    x86_xop_vpcmov,
    x86_xop_vpcmov_256,
    x86_xop_vpcomb,
    x86_xop_vpcomd,
    x86_xop_vpcomq,
    x86_xop_vpcomub,
    x86_xop_vpcomud,
    x86_xop_vpcomuq,
    x86_xop_vpcomuw,
    x86_xop_vpcomw,
    x86_xop_vpermil2pd,
    x86_xop_vpermil2pd_256,
    x86_xop_vpermil2ps,
    x86_xop_vpermil2ps_256,
    x86_xop_vphaddbd,
    x86_xop_vphaddbq,
    x86_xop_vphaddbw,
    x86_xop_vphadddq,
    x86_xop_vphaddubd,
    x86_xop_vphaddubq,
    x86_xop_vphaddubw,
    x86_xop_vphaddudq,
    x86_xop_vphadduwd,
    x86_xop_vphadduwq,
    x86_xop_vphaddwd,
    x86_xop_vphaddwq,
    x86_xop_vphsubbw,
    x86_xop_vphsubdq,
    x86_xop_vphsubwd,
    x86_xop_vpmacsdd,
    x86_xop_vpmacsdqh,
    x86_xop_vpmacsdql,
    x86_xop_vpmacssdd,
    x86_xop_vpmacssdqh,
    x86_xop_vpmacssdql,
    x86_xop_vpmacsswd,
    x86_xop_vpmacssww,
    x86_xop_vpmacswd,
    x86_xop_vpmacsww,
    x86_xop_vpmadcsswd,
    x86_xop_vpmadcswd,
    x86_xop_vpperm,
    x86_xop_vprotb,
    x86_xop_vprotbi,
    x86_xop_vprotd,
    x86_xop_vprotdi,
    x86_xop_vprotq,
    x86_xop_vprotqi,
    x86_xop_vprotw,
    x86_xop_vprotwi,
    x86_xop_vpshab,
    x86_xop_vpshad,
    x86_xop_vpshaq,
    x86_xop_vpshaw,
    x86_xop_vpshlb,
    x86_xop_vpshld,
    x86_xop_vpshlq,
    x86_xop_vpshlw,
    x86_xtest,
    xcore_bitrev,
    xcore_checkevent,
    xcore_chkct,
    xcore_clre,
    xcore_clrsr,
    xcore_crc32,
    xcore_crc8,
    xcore_eeu,
    xcore_endin,
    xcore_freer,
    xcore_geted,
    xcore_getet,
    xcore_getid,
    xcore_getps,
    xcore_getr,
    xcore_getst,
    xcore_getts,
    xcore_in,
    xcore_inct,
    xcore_initcp,
    xcore_initdp,
    xcore_initlr,
    xcore_initpc,
    xcore_initsp,
    xcore_inshr,
    xcore_int,
    xcore_mjoin,
    xcore_msync,
    xcore_out,
    xcore_outct,
    xcore_outshr,
    xcore_outt,
    xcore_peek,
    xcore_setc,
    xcore_setclk,
    xcore_setd,
    xcore_setev,
    xcore_setps,
    xcore_setpsc,
    xcore_setpt,
    xcore_setrdy,
    xcore_setsr,
    xcore_settw,
    xcore_setv,
    xcore_sext,
    xcore_ssync,
    xcore_syncr,
    xcore_testct,
    xcore_testwct,
    xcore_waitevent,
    xcore_zext
# 42 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Intrinsics.h" 2

    , num_intrinsics
  };



  std::string getName(ID id, ArrayRef<Type*> Tys = None);



  FunctionType *getType(LLVMContext &Context, ID id,
                        ArrayRef<Type*> Tys = None);



  bool isOverloaded(ID id);



  AttributeSet getAttributes(LLVMContext &C, ID id);
# 70 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Intrinsics.h"
  Function *getDeclaration(Module *M, ID id, ArrayRef<Type*> Tys = None);


  ID getIntrinsicForGCCBuiltin(const char *Prefix, const char *BuiltinName);




  struct IITDescriptor {
    enum IITDescriptorKind {
      Void, VarArg, MMX, Metadata, Half, Float, Double,
      Integer, Vector, Pointer, Struct,
      Argument, ExtendVecArgument, TruncVecArgument
    } Kind;

    union {
      unsigned Integer_Width;
      unsigned Float_Width;
      unsigned Vector_Width;
      unsigned Pointer_AddressSpace;
      unsigned Struct_NumElements;
      unsigned Argument_Info;
    };

    enum ArgKind {
      AK_AnyInteger,
      AK_AnyFloat,
      AK_AnyVector,
      AK_AnyPointer
    };
    unsigned getArgumentNumber() const {
      ((void)((Kind == Argument || Kind == ExtendVecArgument || Kind == TruncVecArgument) || (__assert_fail("Kind == Argument || Kind == ExtendVecArgument || Kind == TruncVecArgument", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Intrinsics.h", 102, __func__),0)));

      return Argument_Info >> 2;
    }
    ArgKind getArgumentKind() const {
      ((void)((Kind == Argument || Kind == ExtendVecArgument || Kind == TruncVecArgument) || (__assert_fail("Kind == Argument || Kind == ExtendVecArgument || Kind == TruncVecArgument", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/Intrinsics.h", 107, __func__),0)));

      return (ArgKind)(Argument_Info&3);
    }

    static IITDescriptor get(IITDescriptorKind K, unsigned Field) {
      IITDescriptor Result = { K, { Field } };
      return Result;
    }
  };




  void getIntrinsicInfoTableEntries(ID id, SmallVectorImpl<IITDescriptor> &T);

}

}
# 31 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/IntrinsicInst.h" 2

namespace llvm {



  class IntrinsicInst : public CallInst {
    IntrinsicInst() ;
    IntrinsicInst(const IntrinsicInst&) ;
    void operator=(const IntrinsicInst&) ;
  public:


    Intrinsic::ID getIntrinsicID() const {
      return (Intrinsic::ID)getCalledFunction()->getIntrinsicID();
    }


    static inline bool classof(const CallInst *I) {
      if (const Function *CF = I->getCalledFunction())
        return CF->isIntrinsic();
      return false;
    }
    static inline bool classof(const Value *V) {
      return isa<CallInst>(V) && classof(cast<CallInst>(V));
    }
  };



  class DbgInfoIntrinsic : public IntrinsicInst {
  public:


    static inline bool classof(const IntrinsicInst *I) {
      switch (I->getIntrinsicID()) {
      case Intrinsic::dbg_declare:
      case Intrinsic::dbg_value:
        return true;
      default: return false;
      }
    }
    static inline bool classof(const Value *V) {
      return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));
    }

    static Value *StripCast(Value *C);
  };



  class DbgDeclareInst : public DbgInfoIntrinsic {
  public:
    Value *getAddress() const;
    MDNode *getVariable() const { return cast<MDNode>(getArgOperand(1)); }


    static inline bool classof(const IntrinsicInst *I) {
      return I->getIntrinsicID() == Intrinsic::dbg_declare;
    }
    static inline bool classof(const Value *V) {
      return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));
    }
  };



  class DbgValueInst : public DbgInfoIntrinsic {
  public:
    const Value *getValue() const;
    Value *getValue();
    uint64_t getOffset() const {
      return cast<ConstantInt>(
                          const_cast<Value*>(getArgOperand(1)))->getZExtValue();
    }
    MDNode *getVariable() const { return cast<MDNode>(getArgOperand(2)); }


    static inline bool classof(const IntrinsicInst *I) {
      return I->getIntrinsicID() == Intrinsic::dbg_value;
    }
    static inline bool classof(const Value *V) {
      return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));
    }
  };



  class MemIntrinsic : public IntrinsicInst {
  public:
    Value *getRawDest() const { return const_cast<Value*>(getArgOperand(0)); }

    Value *getLength() const { return const_cast<Value*>(getArgOperand(2)); }
    ConstantInt *getAlignmentCst() const {
      return cast<ConstantInt>(const_cast<Value*>(getArgOperand(3)));
    }

    unsigned getAlignment() const {
      return getAlignmentCst()->getZExtValue();
    }

    ConstantInt *getVolatileCst() const {
      return cast<ConstantInt>(const_cast<Value*>(getArgOperand(4)));
    }
    bool isVolatile() const {
      return !getVolatileCst()->isZero();
    }

    unsigned getDestAddressSpace() const {
      return cast<PointerType>(getRawDest()->getType())->getAddressSpace();
    }




    Value *getDest() const { return getRawDest()->stripPointerCasts(); }



    void setDest(Value *Ptr) {
      ((void)((getRawDest()->getType() == Ptr->getType() && "setDest called with pointer of wrong type!") || (__assert_fail("getRawDest()->getType() == Ptr->getType() && \"setDest called with pointer of wrong type!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/IntrinsicInst.h", 151, __func__),0)));

      setArgOperand(0, Ptr);
    }

    void setLength(Value *L) {
      ((void)((getLength()->getType() == L->getType() && "setLength called with value of wrong type!") || (__assert_fail("getLength()->getType() == L->getType() && \"setLength called with value of wrong type!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/IntrinsicInst.h", 157, __func__),0)));

      setArgOperand(2, L);
    }

    void setAlignment(Constant* A) {
      setArgOperand(3, A);
    }

    void setVolatile(Constant* V) {
      setArgOperand(4, V);
    }

    Type *getAlignmentType() const {
      return getArgOperand(3)->getType();
    }


    static inline bool classof(const IntrinsicInst *I) {
      switch (I->getIntrinsicID()) {
      case Intrinsic::memcpy:
      case Intrinsic::memmove:
      case Intrinsic::memset:
        return true;
      default: return false;
      }
    }
    static inline bool classof(const Value *V) {
      return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));
    }
  };



  class MemSetInst : public MemIntrinsic {
  public:


    Value *getValue() const { return const_cast<Value*>(getArgOperand(1)); }

    void setValue(Value *Val) {
      ((void)((getValue()->getType() == Val->getType() && "setValue called with value of wrong type!") || (__assert_fail("getValue()->getType() == Val->getType() && \"setValue called with value of wrong type!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/IntrinsicInst.h", 198, __func__),0)));

      setArgOperand(1, Val);
    }


    static inline bool classof(const IntrinsicInst *I) {
      return I->getIntrinsicID() == Intrinsic::memset;
    }
    static inline bool classof(const Value *V) {
      return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));
    }
  };



  class MemTransferInst : public MemIntrinsic {
  public:


    Value *getRawSource() const { return const_cast<Value*>(getArgOperand(1)); }




    Value *getSource() const { return getRawSource()->stripPointerCasts(); }

    unsigned getSourceAddressSpace() const {
      return cast<PointerType>(getRawSource()->getType())->getAddressSpace();
    }

    void setSource(Value *Ptr) {
      ((void)((getRawSource()->getType() == Ptr->getType() && "setSource called with pointer of wrong type!") || (__assert_fail("getRawSource()->getType() == Ptr->getType() && \"setSource called with pointer of wrong type!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/IntrinsicInst.h", 230, __func__),0)));

      setArgOperand(1, Ptr);
    }


    static inline bool classof(const IntrinsicInst *I) {
      return I->getIntrinsicID() == Intrinsic::memcpy ||
             I->getIntrinsicID() == Intrinsic::memmove;
    }
    static inline bool classof(const Value *V) {
      return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));
    }
  };




  class MemCpyInst : public MemTransferInst {
  public:

    static inline bool classof(const IntrinsicInst *I) {
      return I->getIntrinsicID() == Intrinsic::memcpy;
    }
    static inline bool classof(const Value *V) {
      return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));
    }
  };



  class MemMoveInst : public MemTransferInst {
  public:

    static inline bool classof(const IntrinsicInst *I) {
      return I->getIntrinsicID() == Intrinsic::memmove;
    }
    static inline bool classof(const Value *V) {
      return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));
    }
  };



  class VAStartInst : public IntrinsicInst {
  public:
    static inline bool classof(const IntrinsicInst *I) {
      return I->getIntrinsicID() == Intrinsic::vastart;
    }
    static inline bool classof(const Value *V) {
      return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));
    }

    Value *getArgList() const { return const_cast<Value*>(getArgOperand(0)); }
  };



  class VAEndInst : public IntrinsicInst {
  public:
    static inline bool classof(const IntrinsicInst *I) {
      return I->getIntrinsicID() == Intrinsic::vaend;
    }
    static inline bool classof(const Value *V) {
      return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));
    }

    Value *getArgList() const { return const_cast<Value*>(getArgOperand(0)); }
  };



  class VACopyInst : public IntrinsicInst {
  public:
    static inline bool classof(const IntrinsicInst *I) {
      return I->getIntrinsicID() == Intrinsic::vacopy;
    }
    static inline bool classof(const Value *V) {
      return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));
    }

    Value *getDest() const { return const_cast<Value*>(getArgOperand(0)); }
    Value *getSrc() const { return const_cast<Value*>(getArgOperand(1)); }
  };

}
# 37 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/lib/Analysis/AliasAnalysis.cpp" 2
# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/LLVMContext.h" 1
# 22 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/LLVMContext.h"
namespace llvm {

class LLVMContextImpl;
class StringRef;
class Twine;
class Instruction;
class Module;
class SMDiagnostic;
template <typename T> class SmallVectorImpl;






class LLVMContext {
public:
  LLVMContextImpl *const pImpl;
  LLVMContext();
  ~LLVMContext();



  enum {
    MD_dbg = 0,
    MD_tbaa = 1,
    MD_prof = 2,
    MD_fpmath = 3,
    MD_range = 4,
    MD_tbaa_struct = 5,
    MD_invariant_load = 6
  };



  unsigned getMDKindID(StringRef Name) const;



  void getMDKindNames(SmallVectorImpl<StringRef> &Result) const;


  typedef void (*InlineAsmDiagHandlerTy)(const SMDiagnostic&, void *Context,
                                         unsigned LocCookie);
# 74 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/IR/LLVMContext.h"
  void setInlineAsmDiagnosticHandler(InlineAsmDiagHandlerTy DiagHandler,
                                     void *DiagContext = 0);



  InlineAsmDiagHandlerTy getInlineAsmDiagnosticHandler() const;



  void *getInlineAsmDiagnosticContext() const;







  void emitError(unsigned LocCookie, const Twine &ErrorStr);
  void emitError(const Instruction *I, const Twine &ErrorStr);
  void emitError(const Twine &ErrorStr);

private:
  LLVMContext(LLVMContext&) ;
  void operator=(LLVMContext&) ;



  void addModule(Module*);


  void removeModule(Module*);


  friend class Module;
};



extern LLVMContext &getGlobalContext();


inline LLVMContext *unwrap(LLVMContextRef P) { return reinterpret_cast<LLVMContext*>(P); } inline LLVMContextRef wrap(const LLVMContext *P) { return reinterpret_cast<LLVMContextRef>(const_cast<LLVMContext*>(P)); }



inline LLVMContext **unwrap(LLVMContextRef* Tys) {
  return reinterpret_cast<LLVMContext**>(Tys);
}

inline LLVMContextRef *wrap(const LLVMContext **Tys) {
  return reinterpret_cast<LLVMContextRef*>(const_cast<LLVMContext**>(Tys));
}

}
# 38 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/lib/Analysis/AliasAnalysis.cpp" 2


# 1 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Target/TargetLibraryInfo.h" 1
# 16 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Target/TargetLibraryInfo.h"
namespace llvm {
  class Triple;

  namespace LibFunc {
    enum Func {

      under_IO_getc,

      under_IO_putc,

      ZdaPv,

      ZdaPvRKSt9nothrow_t,

      ZdlPv,

      ZdlPvRKSt9nothrow_t,

      Znaj,

      ZnajRKSt9nothrow_t,

      Znam,

      ZnamRKSt9nothrow_t,

      Znwj,

      ZnwjRKSt9nothrow_t,

      Znwm,

      ZnwmRKSt9nothrow_t,

      cospi,

      cospif,

      cxa_atexit,


      cxa_guard_abort,

      cxa_guard_acquire,

      cxa_guard_release,

      dunder_isoc99_scanf,

      dunder_isoc99_sscanf,

      memcpy_chk,

      sincospi_stret,

      sincospi_stretf,

      sinpi,

      sinpif,

      sqrt_finite,

      sqrtf_finite,

      sqrtl_finite,

      dunder_strdup,

      dunder_strndup,

      dunder_strtok_r,

      abs,

      access,

      acos,

      acosf,

      acosh,

      acoshf,

      acoshl,

      acosl,

      asin,

      asinf,

      asinh,

      asinhf,

      asinhl,

      asinl,

      atan,

      atan2,

      atan2f,

      atan2l,

      atanf,

      atanh,

      atanhf,

      atanhl,

      atanl,

      atof,

      atoi,

      atol,

      atoll,

      bcmp,

      bcopy,

      bzero,

      calloc,

      cbrt,

      cbrtf,

      cbrtl,

      ceil,

      ceilf,

      ceill,

      chmod,

      chown,

      clearerr,

      closedir,

      copysign,

      copysignf,

      copysignl,

      cos,

      cosf,

      cosh,

      coshf,

      coshl,

      cosl,

      ctermid,

      exp,

      exp10,

      exp10f,

      exp10l,

      exp2,

      exp2f,

      exp2l,

      expf,

      expl,

      expm1,

      expm1f,

      expm1l,

      fabs,

      fabsf,

      fabsl,

      fclose,

      fdopen,

      feof,

      ferror,

      fflush,

      ffs,

      ffsl,

      ffsll,

      fgetc,

      fgetpos,

      fgets,

      fileno,

      fiprintf,

      flockfile,

      floor,

      floorf,

      floorl,

      fmod,

      fmodf,

      fmodl,

      fopen,

      fopen,

      fprintf,

      fputc,

      fputs,

      fread,

      free,

      frexp,

      frexpf,

      frexpl,

      fscanf,

      fseek,

      fseeko,

      fseeko,

      fsetpos,

      fstat,

      fstat64,

      fstatvfs,

      fstatvfs64,

      ftell,

      ftello,

      ftello,

      ftrylockfile,

      funlockfile,


      fwrite,

      getc,

      getc_unlocked,

      getchar,

      getenv,

      getitimer,

      getlogin_r,

      getpwnam,

      gets,

      gettimeofday,

      htonl,

      htons,

      iprintf,

      isascii,

      isdigit,

      labs,

      lchown,

      llabs,

      log,

      log10,

      log10f,

      log10l,

      log1p,

      log1pf,

      log1pl,

      log2,

      log2f,

      log2l,

      logb,

      logbf,

      logbl,

      logf,

      logl,

      lstat,

      lstat64,

      malloc,

      memalign,

      memccpy,

      memchr,

      memcmp,

      memcpy,

      memmove,

      memrchr,

      memset,

      memset_pattern16,

      mkdir,

      mktime,

      modf,

      modff,

      modfl,

      nearbyint,

      nearbyintf,

      nearbyintl,

      ntohl,

      ntohs,

      open,

      open64,

      opendir,

      pclose,

      perror,

      popen,

      posix_memalign,

      pow,

      powf,

      powl,

      pread,

      printf,

      putc,

      putchar,

      puts,


      pwrite,


      qsort,

      read,

      readlink,

      realloc,

      reallocf,

      realpath,

      remove,

      rename,

      rewind,

      rint,

      rintf,

      rintl,

      rmdir,

      round,

      roundf,

      roundl,

      scanf,

      setbuf,


      setitimer,

      setvbuf,

      sin,

      sinf,

      sinh,

      sinhf,

      sinhl,

      sinl,

      siprintf,

      snprintf,

      sprintf,

      sqrt,

      sqrtf,

      sqrtl,

      sscanf,

      stat,

      stat64,

      statvfs,

      statvfs64,

      stpcpy,

      stpncpy,

      strcasecmp,

      strcat,

      strchr,

      strcmp,

      strcoll,

      strcpy,

      strcspn,

      strdup,

      strlen,

      strncasecmp,

      strncat,

      strncmp,

      strncpy,

      strndup,

      strnlen,

      strpbrk,

      strrchr,

      strspn,

      strstr,

      strtod,

      strtof,

      strtok,

      strtok_r,

      strtol,

      strtold,

      strtoll,

      strtoul,


      strtoull,

      strxfrm,

      system,

      tan,

      tanf,

      tanh,

      tanhf,

      tanhl,

      tanl,

      times,

      tmpfile,

      tmpfile,

      toascii,

      trunc,

      truncf,

      truncl,

      uname,

      ungetc,

      unlink,

      unsetenv,

      utime,

      utimes,

      valloc,

      vfprintf,

      vfscanf,

      vprintf,

      vscanf,

      vsnprintf,

      vsprintf,

      vsscanf,

      write,

      NumLibFuncs
    };
  }




class TargetLibraryInfo : public ImmutablePass {
  virtual void anchor();
  unsigned char AvailableArray[(LibFunc::NumLibFuncs+3)/4];
  llvm::DenseMap<unsigned, std::string> CustomNames;
  static const char* StandardNames[LibFunc::NumLibFuncs];

  enum AvailabilityState {
    StandardName = 3,
    CustomName = 1,
    Unavailable = 0
  };
  void setState(LibFunc::Func F, AvailabilityState State) {
    AvailableArray[F/4] &= ~(3 << 2*(F&3));
    AvailableArray[F/4] |= State << 2*(F&3);
  }
  AvailabilityState getState(LibFunc::Func F) const {
    return static_cast<AvailabilityState>((AvailableArray[F/4] >> 2*(F&3)) & 3);
  }

public:
  static char ID;
  TargetLibraryInfo();
  TargetLibraryInfo(const Triple &T);
  explicit TargetLibraryInfo(const TargetLibraryInfo &TLI);



  bool getLibFunc(StringRef funcName, LibFunc::Func &F) const;



  bool has(LibFunc::Func F) const {
    return getState(F) != Unavailable;
  }



  bool hasOptimizedCodeGen(LibFunc::Func F) const {
    if (getState(F) == Unavailable)
      return false;
    switch (F) {
    default: break;
    case LibFunc::copysign: case LibFunc::copysignf: case LibFunc::copysignl:
    case LibFunc::fabs: case LibFunc::fabsf: case LibFunc::fabsl:
    case LibFunc::sin: case LibFunc::sinf: case LibFunc::sinl:
    case LibFunc::cos: case LibFunc::cosf: case LibFunc::cosl:
    case LibFunc::sqrt: case LibFunc::sqrtf: case LibFunc::sqrtl:
    case LibFunc::sqrt_finite: case LibFunc::sqrtf_finite:
                                                  case LibFunc::sqrtl_finite:
    case LibFunc::floor: case LibFunc::floorf: case LibFunc::floorl:
    case LibFunc::nearbyint: case LibFunc::nearbyintf: case LibFunc::nearbyintl:
    case LibFunc::ceil: case LibFunc::ceilf: case LibFunc::ceill:
    case LibFunc::rint: case LibFunc::rintf: case LibFunc::rintl:
    case LibFunc::round: case LibFunc::roundf: case LibFunc::roundl:
    case LibFunc::trunc: case LibFunc::truncf: case LibFunc::truncl:
    case LibFunc::log2: case LibFunc::log2f: case LibFunc::log2l:
    case LibFunc::exp2: case LibFunc::exp2f: case LibFunc::exp2l:
    case LibFunc::memcmp: case LibFunc::strcmp: case LibFunc::strcpy:
    case LibFunc::stpcpy: case LibFunc::strlen: case LibFunc::strnlen:
    case LibFunc::memchr:
      return true;
    }
    return false;
  }

  StringRef getName(LibFunc::Func F) const {
    AvailabilityState State = getState(F);
    if (State == Unavailable)
      return StringRef();
    if (State == StandardName)
      return StandardNames[F];
    ((void)((State == CustomName) || (__assert_fail("State == CustomName", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Target/TargetLibraryInfo.h", 728, __func__),0)));
    return CustomNames.find(F)->second;
  }



  void setUnavailable(LibFunc::Func F) {
    setState(F, Unavailable);
  }

  void setAvailable(LibFunc::Func F) {
    setState(F, StandardName);
  }

  void setAvailableWithName(LibFunc::Func F, StringRef Name) {
    if (StandardNames[F] != Name) {
      setState(F, CustomName);
      CustomNames[F] = Name;
      ((void)((CustomNames.find(F) != CustomNames.end()) || (__assert_fail("CustomNames.find(F) != CustomNames.end()", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/include/llvm/Target/TargetLibraryInfo.h", 746, __func__),0)));
    } else {
      setState(F, StandardName);
    }
  }



  void disableAllFunctions();
};

}
# 41 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/lib/Analysis/AliasAnalysis.cpp" 2
using namespace llvm;


static void* initializeAliasAnalysisAnalysisGroupOnce(PassRegistry &Registry) { initializeNoAAPass(Registry); PassInfo *AI = new PassInfo("Alias Analysis", & AliasAnalysis :: ID); Registry.registerAnalysisGroup(& AliasAnalysis ::ID, 0, *AI, false, true); return AI; } void llvm::initializeAliasAnalysisAnalysisGroup(PassRegistry &Registry) { static volatile sys::cas_flag initialized = 0; sys::cas_flag old_val = sys::CompareAndSwap(&initialized, 1, 0); if (old_val == 0) { initializeAliasAnalysisAnalysisGroupOnce(Registry); sys::MemoryFence();;; initialized = 2;; } else { sys::cas_flag tmp = initialized; sys::MemoryFence(); while (tmp != 2) { tmp = initialized; sys::MemoryFence(); } }; }
char AliasAnalysis::ID = 0;





AliasAnalysis::AliasResult
AliasAnalysis::alias(const Location &LocA, const Location &LocB) {
  ((void)((AA && "AA didn't call InitializeAliasAnalysis in its run method!") || (__assert_fail("AA && \"AA didn't call InitializeAliasAnalysis in its run method!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/lib/Analysis/AliasAnalysis.cpp", 53, __func__),0)));
  return AA->alias(LocA, LocB);
}

bool AliasAnalysis::pointsToConstantMemory(const Location &Loc,
                                           bool OrLocal) {
  ((void)((AA && "AA didn't call InitializeAliasAnalysis in its run method!") || (__assert_fail("AA && \"AA didn't call InitializeAliasAnalysis in its run method!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/lib/Analysis/AliasAnalysis.cpp", 59, __func__),0)));
  return AA->pointsToConstantMemory(Loc, OrLocal);
}

void AliasAnalysis::deleteValue(Value *V) {
  ((void)((AA && "AA didn't call InitializeAliasAnalysis in its run method!") || (__assert_fail("AA && \"AA didn't call InitializeAliasAnalysis in its run method!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/lib/Analysis/AliasAnalysis.cpp", 64, __func__),0)));
  AA->deleteValue(V);
}

void AliasAnalysis::copyValue(Value *From, Value *To) {
  ((void)((AA && "AA didn't call InitializeAliasAnalysis in its run method!") || (__assert_fail("AA && \"AA didn't call InitializeAliasAnalysis in its run method!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/lib/Analysis/AliasAnalysis.cpp", 69, __func__),0)));
  AA->copyValue(From, To);
}

void AliasAnalysis::addEscapingUse(Use &U) {
  ((void)((AA && "AA didn't call InitializeAliasAnalysis in its run method!") || (__assert_fail("AA && \"AA didn't call InitializeAliasAnalysis in its run method!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/lib/Analysis/AliasAnalysis.cpp", 74, __func__),0)));
  AA->addEscapingUse(U);
}


AliasAnalysis::ModRefResult
AliasAnalysis::getModRefInfo(ImmutableCallSite CS,
                             const Location &Loc) {
  ((void)((AA && "AA didn't call InitializeAliasAnalysis in its run method!") || (__assert_fail("AA && \"AA didn't call InitializeAliasAnalysis in its run method!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/lib/Analysis/AliasAnalysis.cpp", 82, __func__),0)));

  ModRefBehavior MRB = getModRefBehavior(CS);
  if (MRB == DoesNotAccessMemory)
    return NoModRef;

  ModRefResult Mask = ModRef;
  if (onlyReadsMemory(MRB))
    Mask = Ref;

  if (onlyAccessesArgPointees(MRB)) {
    bool doesAlias = false;
    if (doesAccessArgPointees(MRB)) {
      MDNode *CSTag = CS.getInstruction()->getMetadata(LLVMContext::MD_tbaa);
      for (ImmutableCallSite::arg_iterator AI = CS.arg_begin(), AE = CS.arg_end();
           AI != AE; ++AI) {
        const Value *Arg = *AI;
        if (!Arg->getType()->isPointerTy())
          continue;
        Location CSLoc(Arg, UnknownSize, CSTag);
        if (!isNoAlias(CSLoc, Loc)) {
          doesAlias = true;
          break;
        }
      }
    }
    if (!doesAlias)
      return NoModRef;
  }



  if ((Mask & Mod) && pointsToConstantMemory(Loc))
    Mask = ModRefResult(Mask & ~Mod);


  if (!AA) return Mask;



  return ModRefResult(AA->getModRefInfo(CS, Loc) & Mask);
}

AliasAnalysis::ModRefResult
AliasAnalysis::getModRefInfo(ImmutableCallSite CS1, ImmutableCallSite CS2) {
  ((void)((AA && "AA didn't call InitializeAliasAnalysis in its run method!") || (__assert_fail("AA && \"AA didn't call InitializeAliasAnalysis in its run method!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/lib/Analysis/AliasAnalysis.cpp", 127, __func__),0)));


  ModRefBehavior CS1B = getModRefBehavior(CS1);
  if (CS1B == DoesNotAccessMemory) return NoModRef;

  ModRefBehavior CS2B = getModRefBehavior(CS2);
  if (CS2B == DoesNotAccessMemory) return NoModRef;


  if (onlyReadsMemory(CS1B) && onlyReadsMemory(CS2B))
    return NoModRef;

  AliasAnalysis::ModRefResult Mask = ModRef;



  if (onlyReadsMemory(CS1B))
    Mask = ModRefResult(Mask & Ref);




  if (onlyAccessesArgPointees(CS2B)) {
    AliasAnalysis::ModRefResult R = NoModRef;
    if (doesAccessArgPointees(CS2B)) {
      MDNode *CS2Tag = CS2.getInstruction()->getMetadata(LLVMContext::MD_tbaa);
      for (ImmutableCallSite::arg_iterator
           I = CS2.arg_begin(), E = CS2.arg_end(); I != E; ++I) {
        const Value *Arg = *I;
        if (!Arg->getType()->isPointerTy())
          continue;
        Location CS2Loc(Arg, UnknownSize, CS2Tag);
        R = ModRefResult((R | getModRefInfo(CS1, CS2Loc)) & Mask);
        if (R == Mask)
          break;
      }
    }
    return R;
  }



  if (onlyAccessesArgPointees(CS1B)) {
    AliasAnalysis::ModRefResult R = NoModRef;
    if (doesAccessArgPointees(CS1B)) {
      MDNode *CS1Tag = CS1.getInstruction()->getMetadata(LLVMContext::MD_tbaa);
      for (ImmutableCallSite::arg_iterator
           I = CS1.arg_begin(), E = CS1.arg_end(); I != E; ++I) {
        const Value *Arg = *I;
        if (!Arg->getType()->isPointerTy())
          continue;
        Location CS1Loc(Arg, UnknownSize, CS1Tag);
        if (getModRefInfo(CS2, CS1Loc) != NoModRef) {
          R = Mask;
          break;
        }
      }
    }
    if (R == NoModRef)
      return R;
  }


  if (!AA) return Mask;



  return ModRefResult(AA->getModRefInfo(CS1, CS2) & Mask);
}

AliasAnalysis::ModRefBehavior
AliasAnalysis::getModRefBehavior(ImmutableCallSite CS) {
  ((void)((AA && "AA didn't call InitializeAliasAnalysis in its run method!") || (__assert_fail("AA && \"AA didn't call InitializeAliasAnalysis in its run method!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/lib/Analysis/AliasAnalysis.cpp", 200, __func__),0)));

  ModRefBehavior Min = UnknownModRefBehavior;



  if (const Function *F = CS.getCalledFunction())
    Min = getModRefBehavior(F);


  if (!AA) return Min;



  return ModRefBehavior(AA->getModRefBehavior(CS) & Min);
}

AliasAnalysis::ModRefBehavior
AliasAnalysis::getModRefBehavior(const Function *F) {
  ((void)((AA && "AA didn't call InitializeAliasAnalysis in its run method!") || (__assert_fail("AA && \"AA didn't call InitializeAliasAnalysis in its run method!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/lib/Analysis/AliasAnalysis.cpp", 219, __func__),0)));
  return AA->getModRefBehavior(F);
}





AliasAnalysis::Location AliasAnalysis::getLocation(const LoadInst *LI) {
  return Location(LI->getPointerOperand(),
                  getTypeStoreSize(LI->getType()),
                  LI->getMetadata(LLVMContext::MD_tbaa));
}

AliasAnalysis::Location AliasAnalysis::getLocation(const StoreInst *SI) {
  return Location(SI->getPointerOperand(),
                  getTypeStoreSize(SI->getValueOperand()->getType()),
                  SI->getMetadata(LLVMContext::MD_tbaa));
}

AliasAnalysis::Location AliasAnalysis::getLocation(const VAArgInst *VI) {
  return Location(VI->getPointerOperand(),
                  UnknownSize,
                  VI->getMetadata(LLVMContext::MD_tbaa));
}

AliasAnalysis::Location
AliasAnalysis::getLocation(const AtomicCmpXchgInst *CXI) {
  return Location(CXI->getPointerOperand(),
                  getTypeStoreSize(CXI->getCompareOperand()->getType()),
                  CXI->getMetadata(LLVMContext::MD_tbaa));
}

AliasAnalysis::Location
AliasAnalysis::getLocation(const AtomicRMWInst *RMWI) {
  return Location(RMWI->getPointerOperand(),
                  getTypeStoreSize(RMWI->getValOperand()->getType()),
                  RMWI->getMetadata(LLVMContext::MD_tbaa));
}

AliasAnalysis::Location
AliasAnalysis::getLocationForSource(const MemTransferInst *MTI) {
  uint64_t Size = UnknownSize;
  if (ConstantInt *C = dyn_cast<ConstantInt>(MTI->getLength()))
    Size = C->getValue().getZExtValue();



  MDNode *TBAATag = MTI->getMetadata(LLVMContext::MD_tbaa);

  return Location(MTI->getRawSource(), Size, TBAATag);
}

AliasAnalysis::Location
AliasAnalysis::getLocationForDest(const MemIntrinsic *MTI) {
  uint64_t Size = UnknownSize;
  if (ConstantInt *C = dyn_cast<ConstantInt>(MTI->getLength()))
    Size = C->getValue().getZExtValue();



  MDNode *TBAATag = MTI->getMetadata(LLVMContext::MD_tbaa);

  return Location(MTI->getRawDest(), Size, TBAATag);
}



AliasAnalysis::ModRefResult
AliasAnalysis::getModRefInfo(const LoadInst *L, const Location &Loc) {

  if (!L->isUnordered())
    return ModRef;



  if (!alias(getLocation(L), Loc))
    return NoModRef;


  return Ref;
}

AliasAnalysis::ModRefResult
AliasAnalysis::getModRefInfo(const StoreInst *S, const Location &Loc) {

  if (!S->isUnordered())
    return ModRef;



  if (!alias(getLocation(S), Loc))
    return NoModRef;



  if (pointsToConstantMemory(Loc))
    return NoModRef;


  return Mod;
}

AliasAnalysis::ModRefResult
AliasAnalysis::getModRefInfo(const VAArgInst *V, const Location &Loc) {


  if (!alias(getLocation(V), Loc))
    return NoModRef;



  if (pointsToConstantMemory(Loc))
    return NoModRef;


  return ModRef;
}

AliasAnalysis::ModRefResult
AliasAnalysis::getModRefInfo(const AtomicCmpXchgInst *CX, const Location &Loc) {

  if (CX->getOrdering() > Monotonic)
    return ModRef;


  if (!alias(getLocation(CX), Loc))
    return NoModRef;

  return ModRef;
}

AliasAnalysis::ModRefResult
AliasAnalysis::getModRefInfo(const AtomicRMWInst *RMW, const Location &Loc) {

  if (RMW->getOrdering() > Monotonic)
    return ModRef;


  if (!alias(getLocation(RMW), Loc))
    return NoModRef;

  return ModRef;
}

namespace {




  struct CapturesBefore : public CaptureTracker {
    CapturesBefore(const Instruction *I, DominatorTree *DT)
      : BeforeHere(I), DT(DT), Captured(false) {}

    void tooManyUses() { Captured = true; }

    bool shouldExplore(Use *U) {
      Instruction *I = cast<Instruction>(U->getUser());
      BasicBlock *BB = I->getParent();


      if (BeforeHere != I && !DT->isReachableFromEntry(BB))
        return false;



      if (BeforeHere != I && DT->dominates(BeforeHere, I) &&
          !isPotentiallyReachable(I, BeforeHere, DT))
        return false;
      return true;
    }

    bool captured(Use *U) {
      Instruction *I = cast<Instruction>(U->getUser());
      BasicBlock *BB = I->getParent();

      if (BeforeHere != I && !DT->isReachableFromEntry(BB))
        return false;
      if (BeforeHere != I && DT->dominates(BeforeHere, I) &&
          !isPotentiallyReachable(I, BeforeHere, DT))
        return false;
      Captured = true;
      return true;
    }

    const Instruction *BeforeHere;
    DominatorTree *DT;

    bool Captured;
  };
}





AliasAnalysis::ModRefResult
AliasAnalysis::callCapturesBefore(const Instruction *I,
                                  const AliasAnalysis::Location &MemLoc,
                                  DominatorTree *DT) {
  if (!DT || !TD) return AliasAnalysis::ModRef;

  const Value *Object = GetUnderlyingObject(MemLoc.Ptr, TD);
  if (!isIdentifiedObject(Object) || isa<GlobalValue>(Object) ||
      isa<Constant>(Object))
    return AliasAnalysis::ModRef;

  ImmutableCallSite CS(I);
  if (!CS.getInstruction() || CS.getInstruction() == Object)
    return AliasAnalysis::ModRef;

  CapturesBefore CB(I, DT);
  llvm::PointerMayBeCaptured(Object, &CB);
  if (CB.Captured)
    return AliasAnalysis::ModRef;

  unsigned ArgNo = 0;
  AliasAnalysis::ModRefResult R = AliasAnalysis::NoModRef;
  for (ImmutableCallSite::arg_iterator CI = CS.arg_begin(), CE = CS.arg_end();
       CI != CE; ++CI, ++ArgNo) {



    if (!(*CI)->getType()->isPointerTy() ||
        (!CS.doesNotCapture(ArgNo) && !CS.isByValArgument(ArgNo)))
      continue;





    if (isNoAlias(AliasAnalysis::Location(*CI),
    AliasAnalysis::Location(Object)))
      continue;
    if (CS.doesNotAccessMemory(ArgNo))
      continue;
    if (CS.onlyReadsMemory(ArgNo)) {
      R = AliasAnalysis::Ref;
      continue;
    }
    return AliasAnalysis::ModRef;
  }
  return R;
}






AliasAnalysis::~AliasAnalysis() {}




void AliasAnalysis::InitializeAliasAnalysis(Pass *P) {
  TD = P->getAnalysisIfAvailable<DataLayout>();
  TLI = P->getAnalysisIfAvailable<TargetLibraryInfo>();
  AA = &P->getAnalysis<AliasAnalysis>();
}



void AliasAnalysis::getAnalysisUsage(AnalysisUsage &AU) const {
  AU.addRequired<AliasAnalysis>();
}




uint64_t AliasAnalysis::getTypeStoreSize(Type *Ty) {
  return TD ? TD->getTypeStoreSize(Ty) : UnknownSize;
}




bool AliasAnalysis::canBasicBlockModify(const BasicBlock &BB,
                                        const Location &Loc) {
  return canInstructionRangeModify(BB.front(), BB.back(), Loc);
}






bool AliasAnalysis::canInstructionRangeModify(const Instruction &I1,
                                              const Instruction &I2,
                                              const Location &Loc) {
  ((void)((I1.getParent() == I2.getParent() && "Instructions not in same basic block!") || (__assert_fail("I1.getParent() == I2.getParent() && \"Instructions not in same basic block!\"", "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/lib/Analysis/AliasAnalysis.cpp", 510, __func__),0)));

  BasicBlock::const_iterator I = &I1;
  BasicBlock::const_iterator E = &I2;
  ++E;

  for (; I != E; ++I)
    if (getModRefInfo(I, Loc) & Mod)
      return true;
  return false;
}



bool llvm::isNoAliasCall(const Value *V) {
  if (isa<CallInst>(V) || isa<InvokeInst>(V))
    return ImmutableCallSite(cast<Instruction>(V))
      .paramHasAttr(0, Attribute::NoAlias);
  return false;
}



bool llvm::isNoAliasArgument(const Value *V)
{
  if (const Argument *A = dyn_cast<Argument>(V))
    return A->hasNoAliasAttr();
  return false;
}
# 546 "/mnt/home/ec2-user/build/fastcomp_js/emscripten-fastcomp/lib/Analysis/AliasAnalysis.cpp"
bool llvm::isIdentifiedObject(const Value *V) {
  if (isa<AllocaInst>(V))
    return true;
  if (isa<GlobalValue>(V) && !isa<GlobalAlias>(V))
    return true;
  if (isNoAliasCall(V))
    return true;
  if (const Argument *A = dyn_cast<Argument>(V))
    return A->hasNoAliasAttr() || A->hasByValAttr();
  return false;
}
